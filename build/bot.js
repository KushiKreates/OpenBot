import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod2, isNodeMode, target) => {
  target = mod2 != null ? __create(__getProtoOf(mod2)) : {};
  const to = isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target;
  for (let key2 of __getOwnPropNames(mod2))
    if (!__hasOwnProp.call(to, key2))
      __defProp(to, key2, {
        get: () => mod2[key2],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod2) => () => (mod2 || cb((mod2 = { exports: {} }).exports, mod2), mod2.exports);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/whatsapp-web.js/src/util/Constants.js
var require_Constants = __commonJS((exports) => {
  exports.WhatsWebURL = "https://web.whatsapp.com/";
  exports.DefaultOptions = {
    puppeteer: {
      headless: true,
      defaultViewport: null
    },
    webVersion: "2.3000.1017054665",
    webVersionCache: {
      type: "local"
    },
    authTimeoutMs: 0,
    qrMaxRetries: 0,
    takeoverOnConflict: false,
    takeoverTimeoutMs: 0,
    userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36",
    ffmpegPath: "ffmpeg",
    bypassCSP: false,
    proxyAuthentication: undefined
  };
  exports.Status = {
    INITIALIZING: 0,
    AUTHENTICATING: 1,
    READY: 3
  };
  exports.Events = {
    AUTHENTICATED: "authenticated",
    AUTHENTICATION_FAILURE: "auth_failure",
    READY: "ready",
    CHAT_REMOVED: "chat_removed",
    CHAT_ARCHIVED: "chat_archived",
    MESSAGE_RECEIVED: "message",
    MESSAGE_CIPHERTEXT: "message_ciphertext",
    MESSAGE_CREATE: "message_create",
    MESSAGE_REVOKED_EVERYONE: "message_revoke_everyone",
    MESSAGE_REVOKED_ME: "message_revoke_me",
    MESSAGE_ACK: "message_ack",
    MESSAGE_EDIT: "message_edit",
    UNREAD_COUNT: "unread_count",
    MESSAGE_REACTION: "message_reaction",
    MEDIA_UPLOADED: "media_uploaded",
    CONTACT_CHANGED: "contact_changed",
    GROUP_JOIN: "group_join",
    GROUP_LEAVE: "group_leave",
    GROUP_ADMIN_CHANGED: "group_admin_changed",
    GROUP_MEMBERSHIP_REQUEST: "group_membership_request",
    GROUP_UPDATE: "group_update",
    QR_RECEIVED: "qr",
    LOADING_SCREEN: "loading_screen",
    DISCONNECTED: "disconnected",
    STATE_CHANGED: "change_state",
    BATTERY_CHANGED: "change_battery",
    INCOMING_CALL: "call",
    REMOTE_SESSION_SAVED: "remote_session_saved",
    VOTE_UPDATE: "vote_update"
  };
  exports.MessageTypes = {
    TEXT: "chat",
    AUDIO: "audio",
    VOICE: "ptt",
    IMAGE: "image",
    VIDEO: "video",
    DOCUMENT: "document",
    STICKER: "sticker",
    LOCATION: "location",
    CONTACT_CARD: "vcard",
    CONTACT_CARD_MULTI: "multi_vcard",
    ORDER: "order",
    REVOKED: "revoked",
    PRODUCT: "product",
    UNKNOWN: "unknown",
    GROUP_INVITE: "groups_v4_invite",
    LIST: "list",
    LIST_RESPONSE: "list_response",
    BUTTONS_RESPONSE: "buttons_response",
    PAYMENT: "payment",
    BROADCAST_NOTIFICATION: "broadcast_notification",
    CALL_LOG: "call_log",
    CIPHERTEXT: "ciphertext",
    DEBUG: "debug",
    E2E_NOTIFICATION: "e2e_notification",
    GP2: "gp2",
    GROUP_NOTIFICATION: "group_notification",
    HSM: "hsm",
    INTERACTIVE: "interactive",
    NATIVE_FLOW: "native_flow",
    NOTIFICATION: "notification",
    NOTIFICATION_TEMPLATE: "notification_template",
    OVERSIZED: "oversized",
    PROTOCOL: "protocol",
    REACTION: "reaction",
    TEMPLATE_BUTTON_REPLY: "template_button_reply",
    POLL_CREATION: "poll_creation"
  };
  exports.GroupNotificationTypes = {
    ADD: "add",
    INVITE: "invite",
    REMOVE: "remove",
    LEAVE: "leave",
    SUBJECT: "subject",
    DESCRIPTION: "description",
    PICTURE: "picture",
    ANNOUNCE: "announce",
    RESTRICT: "restrict"
  };
  exports.ChatTypes = {
    SOLO: "solo",
    GROUP: "group",
    UNKNOWN: "unknown"
  };
  exports.WAState = {
    CONFLICT: "CONFLICT",
    CONNECTED: "CONNECTED",
    DEPRECATED_VERSION: "DEPRECATED_VERSION",
    OPENING: "OPENING",
    PAIRING: "PAIRING",
    PROXYBLOCK: "PROXYBLOCK",
    SMB_TOS_BLOCK: "SMB_TOS_BLOCK",
    TIMEOUT: "TIMEOUT",
    TOS_BLOCK: "TOS_BLOCK",
    UNLAUNCHED: "UNLAUNCHED",
    UNPAIRED: "UNPAIRED",
    UNPAIRED_IDLE: "UNPAIRED_IDLE"
  };
  exports.MessageAck = {
    ACK_ERROR: -1,
    ACK_PENDING: 0,
    ACK_SERVER: 1,
    ACK_DEVICE: 2,
    ACK_READ: 3,
    ACK_PLAYED: 4
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/DeviceDescriptors.js
var require_DeviceDescriptors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.devices = undefined;
  var deviceArray = [
    {
      name: "Blackberry PlayBook",
      userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
      viewport: {
        width: 600,
        height: 1024,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Blackberry PlayBook landscape",
      userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
      viewport: {
        width: 1024,
        height: 600,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "BlackBerry Z30",
      userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "BlackBerry Z30 landscape",
      userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy Note 3",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy Note 3 landscape",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy Note II",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy Note II landscape",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy S III",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy S III landscape",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy S5",
      userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy S5 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy S8",
      userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
      viewport: {
        width: 360,
        height: 740,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy S8 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
      viewport: {
        width: 740,
        height: 360,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy S9+",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
      viewport: {
        width: 320,
        height: 658,
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy S9+ landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
      viewport: {
        width: 658,
        height: 320,
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Galaxy Tab S4",
      userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
      viewport: {
        width: 712,
        height: 1138,
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Galaxy Tab S4 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
      viewport: {
        width: 1138,
        height: 712,
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 768,
        height: 1024,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 1024,
        height: 768,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad (gen 6)",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 768,
        height: 1024,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad (gen 6) landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 1024,
        height: 768,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad (gen 7)",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 810,
        height: 1080,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad (gen 7) landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 1080,
        height: 810,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad Mini",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 768,
        height: 1024,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad Mini landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 1024,
        height: 768,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad Pro",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 1024,
        height: 1366,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad Pro landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
      viewport: {
        width: 1366,
        height: 1024,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPad Pro 11",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 834,
        height: 1194,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPad Pro 11 landscape",
      userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 1194,
        height: 834,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 4",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
      viewport: {
        width: 320,
        height: 480,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 4 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
      viewport: {
        width: 480,
        height: 320,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 5",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
      viewport: {
        width: 320,
        height: 568,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 5 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
      viewport: {
        width: 568,
        height: 320,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 6",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 375,
        height: 667,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 6 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 667,
        height: 375,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 6 Plus",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 414,
        height: 736,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 6 Plus landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 736,
        height: 414,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 7",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 375,
        height: 667,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 7 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 667,
        height: 375,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 7 Plus",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 414,
        height: 736,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 7 Plus landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 736,
        height: 414,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 8",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 375,
        height: 667,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 8 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 667,
        height: 375,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 8 Plus",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 414,
        height: 736,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 8 Plus landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 736,
        height: 414,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone SE",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
      viewport: {
        width: 320,
        height: 568,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone SE landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
      viewport: {
        width: 568,
        height: 320,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone X",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 375,
        height: 812,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone X landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
      viewport: {
        width: 812,
        height: 375,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone XR",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 414,
        height: 896,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone XR landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 896,
        height: 414,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 11",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 414,
        height: 828,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 11 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 828,
        height: 414,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 11 Pro",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 375,
        height: 812,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 11 Pro landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 812,
        height: 375,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 11 Pro Max",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 414,
        height: 896,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 11 Pro Max landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 896,
        height: 414,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 12",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 390,
        height: 844,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 12 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 844,
        height: 390,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 12 Pro",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 390,
        height: 844,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 12 Pro landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 844,
        height: 390,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 12 Pro Max",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 428,
        height: 926,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 12 Pro Max landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 926,
        height: 428,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 12 Mini",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 375,
        height: 812,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 12 Mini landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 812,
        height: 375,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 13",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 390,
        height: 844,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 13 landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 844,
        height: 390,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 13 Pro",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 390,
        height: 844,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 13 Pro landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 844,
        height: 390,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 13 Pro Max",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 428,
        height: 926,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 13 Pro Max landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 926,
        height: 428,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "iPhone 13 Mini",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 375,
        height: 812,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "iPhone 13 Mini landscape",
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
      viewport: {
        width: 812,
        height: 375,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "JioPhone 2",
      userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
      viewport: {
        width: 240,
        height: 320,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "JioPhone 2 landscape",
      userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
      viewport: {
        width: 320,
        height: 240,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Kindle Fire HDX",
      userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
      viewport: {
        width: 800,
        height: 1280,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Kindle Fire HDX landscape",
      userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
      viewport: {
        width: 1280,
        height: 800,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "LG Optimus L70",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 384,
        height: 640,
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "LG Optimus L70 landscape",
      userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 640,
        height: 384,
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Microsoft Lumia 550",
      userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Microsoft Lumia 950",
      userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Microsoft Lumia 950 landscape",
      userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 10",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
      viewport: {
        width: 800,
        height: 1280,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 10 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
      viewport: {
        width: 1280,
        height: 800,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 4",
      userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 384,
        height: 640,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 4 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 640,
        height: 384,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 5",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 5 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 5X",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 412,
        height: 732,
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 5X landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 732,
        height: 412,
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 6",
      userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 412,
        height: 732,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 6 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 732,
        height: 412,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 6P",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 412,
        height: 732,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 6P landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 732,
        height: 412,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nexus 7",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
      viewport: {
        width: 600,
        height: 960,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nexus 7 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
      viewport: {
        width: 960,
        height: 600,
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nokia Lumia 520",
      userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
      viewport: {
        width: 320,
        height: 533,
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nokia Lumia 520 landscape",
      userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
      viewport: {
        width: 533,
        height: 320,
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Nokia N9",
      userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
      viewport: {
        width: 480,
        height: 854,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Nokia N9 landscape",
      userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
      viewport: {
        width: 854,
        height: 480,
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 2",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 411,
        height: 731,
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 2 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 731,
        height: 411,
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 2 XL",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 411,
        height: 823,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 2 XL landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
      viewport: {
        width: 823,
        height: 411,
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 3",
      userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
      viewport: {
        width: 393,
        height: 786,
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 3 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
      viewport: {
        width: 786,
        height: 393,
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 4",
      userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
      viewport: {
        width: 353,
        height: 745,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 4 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
      viewport: {
        width: 745,
        height: 353,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 4a (5G)",
      userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 353,
        height: 745,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 4a (5G) landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 745,
        height: 353,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Pixel 5",
      userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 393,
        height: 851,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Pixel 5 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 851,
        height: 393,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    },
    {
      name: "Moto G4",
      userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 360,
        height: 640,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: false
      }
    },
    {
      name: "Moto G4 landscape",
      userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
      viewport: {
        width: 640,
        height: 360,
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        isLandscape: true
      }
    }
  ];
  var devices = {};
  exports.devices = devices;
  for (const device of deviceArray) {
    devices[device.name] = device;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Errors.js
var require_Errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.errors = exports.ProtocolError = exports.TimeoutError = exports.CustomError = undefined;

  class CustomError extends Error {
    constructor(message) {
      super(message);
      this.name = this.constructor.name;
      Error.captureStackTrace(this, this.constructor);
    }
  }
  exports.CustomError = CustomError;

  class TimeoutError extends CustomError {
  }
  exports.TimeoutError = TimeoutError;

  class ProtocolError extends CustomError {
    constructor() {
      super(...arguments);
      this.originalMessage = "";
    }
  }
  exports.ProtocolError = ProtocolError;
  exports.errors = Object.freeze({
    TimeoutError,
    ProtocolError
  });
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/NetworkConditions.js
var require_NetworkConditions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.networkConditions = undefined;
  exports.networkConditions = Object.freeze({
    "Slow 3G": {
      download: 500 * 1000 / 8 * 0.8,
      upload: 500 * 1000 / 8 * 0.8,
      latency: 400 * 5
    },
    "Fast 3G": {
      download: 1.6 * 1000 * 1000 / 8 * 0.9,
      upload: 750 * 1000 / 8 * 0.9,
      latency: 150 * 3.75
    }
  });
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/assert.js
var require_assert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assert = undefined;
  var assert = (value, message) => {
    if (!value) {
      throw new Error(message);
    }
  };
  exports.assert = assert;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/environment.js
var require_environment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFERRED_PROMISE_DEBUG_TIMEOUT = exports.isNode = undefined;
  exports.isNode = !!(typeof process !== "undefined" && process.version);
  exports.DEFERRED_PROMISE_DEBUG_TIMEOUT = typeof process !== "undefined" && typeof process.env["PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT"] !== "undefined" ? Number(process.env["PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT"]) : -1;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/ErrorLike.js
var require_ErrorLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isErrnoException = exports.isErrorLike = undefined;
  function isErrorLike(obj2) {
    return typeof obj2 === "object" && obj2 !== null && "name" in obj2 && "message" in obj2;
  }
  exports.isErrorLike = isErrorLike;
  function isErrnoException(obj2) {
    return isErrorLike(obj2) && (("errno" in obj2) || ("code" in obj2) || ("path" in obj2) || ("syscall" in obj2));
  }
  exports.isErrnoException = isErrnoException;
});

// node_modules/puppeteer-core/node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m2 = s * 60;
  var h = m2 * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms / m2) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms, msAbs, m2, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/puppeteer-core/node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key2) => {
      createDebug[key2] = env[key2];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/puppeteer-core/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/puppeteer-core/node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error("Cannot require module "+"supports-color");})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key2) => {
    return /^debug_/i.test(key2);
  }).reduce((obj2, key2) => {
    const prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key2];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj2[prop] = val;
    return obj2;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args) {
    return process.stderr.write(util.format(...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/puppeteer-core/node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Debug.js
var require_Debug = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debug = exports.importDebug = undefined;
  var environment_js_1 = require_environment();
  var debugModule = null;
  async function importDebug() {
    if (!debugModule) {
      debugModule = (await Promise.resolve().then(() => __importStar(require_src()))).default;
    }
    return debugModule;
  }
  exports.importDebug = importDebug;
  var debug = (prefix) => {
    if (environment_js_1.isNode) {
      return async (...logArgs) => {
        (await importDebug())(prefix)(logArgs);
      };
    }
    return (...logArgs) => {
      const debugLevel = globalThis.__PUPPETEER_DEBUG;
      if (!debugLevel) {
        return;
      }
      const everythingShouldBeLogged = debugLevel === "*";
      const prefixMatchesDebugLevel = everythingShouldBeLogged || (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
      if (!prefixMatchesDebugLevel) {
        return;
      }
      console.log(`${prefix}:`, ...logArgs);
    };
  };
  exports.debug = debug;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/util.js
var require_util = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getReadableFromProtocolStream = exports.getReadableAsBuffer = exports.importFS = exports.waitWithTimeout = exports.pageBindingDeliverErrorValueString = exports.pageBindingDeliverErrorString = exports.pageBindingDeliverResultString = exports.pageBindingInitString = exports.evaluationString = exports.createJSHandle = exports.waitForEvent = exports.isNumber = exports.isString = exports.removeEventListeners = exports.addEventListener = exports.releaseObject = exports.valueFromRemoteObject = exports.getExceptionMessage = exports.debugError = undefined;
  var environment_js_1 = require_environment();
  var assert_js_1 = require_assert();
  var ErrorLike_js_1 = require_ErrorLike();
  var Debug_js_1 = require_Debug();
  var ElementHandle_js_1 = require_ElementHandle();
  var Errors_js_1 = require_Errors();
  var JSHandle_js_1 = require_JSHandle();
  exports.debugError = (0, Debug_js_1.debug)("puppeteer:error");
  function getExceptionMessage(exceptionDetails) {
    if (exceptionDetails.exception) {
      return exceptionDetails.exception.description || exceptionDetails.exception.value;
    }
    let message = exceptionDetails.text;
    if (exceptionDetails.stackTrace) {
      for (const callframe of exceptionDetails.stackTrace.callFrames) {
        const location = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
        const functionName = callframe.functionName || "<anonymous>";
        message += `
    at ${functionName} (${location})`;
      }
    }
    return message;
  }
  exports.getExceptionMessage = getExceptionMessage;
  function valueFromRemoteObject(remoteObject) {
    (0, assert_js_1.assert)(!remoteObject.objectId, "Cannot extract value when objectId is given");
    if (remoteObject.unserializableValue) {
      if (remoteObject.type === "bigint" && typeof BigInt !== "undefined") {
        return BigInt(remoteObject.unserializableValue.replace("n", ""));
      }
      switch (remoteObject.unserializableValue) {
        case "-0":
          return -0;
        case "NaN":
          return NaN;
        case "Infinity":
          return Infinity;
        case "-Infinity":
          return -Infinity;
        default:
          throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
      }
    }
    return remoteObject.value;
  }
  exports.valueFromRemoteObject = valueFromRemoteObject;
  async function releaseObject(client, remoteObject) {
    if (!remoteObject.objectId) {
      return;
    }
    await client.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error) => {
      (0, exports.debugError)(error);
    });
  }
  exports.releaseObject = releaseObject;
  function addEventListener(emitter, eventName, handler) {
    emitter.on(eventName, handler);
    return { emitter, eventName, handler };
  }
  exports.addEventListener = addEventListener;
  function removeEventListeners(listeners) {
    for (const listener of listeners) {
      listener.emitter.removeListener(listener.eventName, listener.handler);
    }
    listeners.length = 0;
  }
  exports.removeEventListeners = removeEventListeners;
  var isString = (obj2) => {
    return typeof obj2 === "string" || obj2 instanceof String;
  };
  exports.isString = isString;
  var isNumber = (obj2) => {
    return typeof obj2 === "number" || obj2 instanceof Number;
  };
  exports.isNumber = isNumber;
  async function waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {
    let eventTimeout;
    let resolveCallback;
    let rejectCallback;
    const promise = new Promise((resolve, reject) => {
      resolveCallback = resolve;
      rejectCallback = reject;
    });
    const listener = addEventListener(emitter, eventName, async (event) => {
      if (!await predicate(event)) {
        return;
      }
      resolveCallback(event);
    });
    if (timeout) {
      eventTimeout = setTimeout(() => {
        rejectCallback(new Errors_js_1.TimeoutError("Timeout exceeded while waiting for event"));
      }, timeout);
    }
    function cleanup() {
      removeEventListeners([listener]);
      clearTimeout(eventTimeout);
    }
    const result = await Promise.race([promise, abortPromise]).then((r) => {
      cleanup();
      return r;
    }, (error) => {
      cleanup();
      throw error;
    });
    if ((0, ErrorLike_js_1.isErrorLike)(result)) {
      throw result;
    }
    return result;
  }
  exports.waitForEvent = waitForEvent;
  function createJSHandle(context, remoteObject) {
    if (remoteObject.subtype === "node" && context._world) {
      return new ElementHandle_js_1.ElementHandle(context, remoteObject, context._world.frame());
    }
    return new JSHandle_js_1.JSHandle(context, remoteObject);
  }
  exports.createJSHandle = createJSHandle;
  function evaluationString(fun, ...args) {
    if ((0, exports.isString)(fun)) {
      (0, assert_js_1.assert)(args.length === 0, "Cannot evaluate a string with arguments");
      return fun;
    }
    function serializeArgument(arg) {
      if (Object.is(arg, undefined)) {
        return "undefined";
      }
      return JSON.stringify(arg);
    }
    return `(${fun})(${args.map(serializeArgument).join(",")})`;
  }
  exports.evaluationString = evaluationString;
  function pageBindingInitString(type, name) {
    function addPageBinding(type2, name2) {
      const callCDP = self[name2];
      Object.assign(self, {
        [name2](...args) {
          var _a, _b;
          const callPuppeteer = self[name2];
          (_a = callPuppeteer.callbacks) !== null && _a !== undefined || (callPuppeteer.callbacks = new Map);
          const seq = ((_b = callPuppeteer.lastSeq) !== null && _b !== undefined ? _b : 0) + 1;
          callPuppeteer.lastSeq = seq;
          callCDP(JSON.stringify({ type: type2, name: name2, seq, args }));
          return new Promise((resolve, reject) => {
            callPuppeteer.callbacks.set(seq, { resolve, reject });
          });
        }
      });
    }
    return evaluationString(addPageBinding, type, name);
  }
  exports.pageBindingInitString = pageBindingInitString;
  function pageBindingDeliverResultString(name, seq, result) {
    function deliverResult(name2, seq2, result2) {
      window[name2].callbacks.get(seq2).resolve(result2);
      window[name2].callbacks.delete(seq2);
    }
    return evaluationString(deliverResult, name, seq, result);
  }
  exports.pageBindingDeliverResultString = pageBindingDeliverResultString;
  function pageBindingDeliverErrorString(name, seq, message, stack) {
    function deliverError(name2, seq2, message2, stack2) {
      const error = new Error(message2);
      error.stack = stack2;
      window[name2].callbacks.get(seq2).reject(error);
      window[name2].callbacks.delete(seq2);
    }
    return evaluationString(deliverError, name, seq, message, stack);
  }
  exports.pageBindingDeliverErrorString = pageBindingDeliverErrorString;
  function pageBindingDeliverErrorValueString(name, seq, value) {
    function deliverErrorValue(name2, seq2, value2) {
      window[name2].callbacks.get(seq2).reject(value2);
      window[name2].callbacks.delete(seq2);
    }
    return evaluationString(deliverErrorValue, name, seq, value);
  }
  exports.pageBindingDeliverErrorValueString = pageBindingDeliverErrorValueString;
  async function waitWithTimeout(promise, taskName, timeout) {
    let reject;
    const timeoutError = new Errors_js_1.TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);
    const timeoutPromise = new Promise((_res, rej) => {
      return reject = rej;
    });
    let timeoutTimer = null;
    if (timeout) {
      timeoutTimer = setTimeout(() => {
        return reject(timeoutError);
      }, timeout);
    }
    try {
      return await Promise.race([promise, timeoutPromise]);
    } finally {
      if (timeoutTimer) {
        clearTimeout(timeoutTimer);
      }
    }
  }
  exports.waitWithTimeout = waitWithTimeout;
  var fs = null;
  async function importFS() {
    if (!fs) {
      fs = await Promise.resolve().then(() => __importStar(__require("fs")));
    }
    return fs;
  }
  exports.importFS = importFS;
  async function getReadableAsBuffer(readable, path) {
    const buffers = [];
    if (path) {
      let fs2;
      try {
        fs2 = (await importFS()).promises;
      } catch (error) {
        if (error instanceof TypeError) {
          throw new Error("Cannot write to a path outside of a Node-like environment.");
        }
        throw error;
      }
      const fileHandle = await fs2.open(path, "w+");
      for await (const chunk of readable) {
        buffers.push(chunk);
        await fileHandle.writeFile(chunk);
      }
      await fileHandle.close();
    } else {
      for await (const chunk of readable) {
        buffers.push(chunk);
      }
    }
    try {
      return Buffer.concat(buffers);
    } catch (error) {
      return null;
    }
  }
  exports.getReadableAsBuffer = getReadableAsBuffer;
  async function getReadableFromProtocolStream(client, handle) {
    if (!environment_js_1.isNode) {
      throw new Error("Cannot create a stream outside of Node.js environment.");
    }
    const { Readable } = await Promise.resolve().then(() => __importStar(__require("stream")));
    let eof = false;
    return new Readable({
      async read(size) {
        if (eof) {
          return;
        }
        const response = await client.send("IO.read", { handle, size });
        this.push(response.data, response.base64Encoded ? "base64" : undefined);
        if (response.eof) {
          eof = true;
          await client.send("IO.close", { handle });
          this.push(null);
        }
      }
    });
  }
  exports.getReadableFromProtocolStream = getReadableFromProtocolStream;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/JSHandle.js
var require_JSHandle = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _JSHandle_disposed;
  var _JSHandle_context;
  var _JSHandle_remoteObject;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JSHandle = undefined;
  var assert_js_1 = require_assert();
  var util_js_1 = require_util();

  class JSHandle {
    constructor(context, remoteObject) {
      _JSHandle_disposed.set(this, false);
      _JSHandle_context.set(this, undefined);
      _JSHandle_remoteObject.set(this, undefined);
      __classPrivateFieldSet(this, _JSHandle_context, context, "f");
      __classPrivateFieldSet(this, _JSHandle_remoteObject, remoteObject, "f");
    }
    get client() {
      return __classPrivateFieldGet(this, _JSHandle_context, "f")._client;
    }
    get disposed() {
      return __classPrivateFieldGet(this, _JSHandle_disposed, "f");
    }
    executionContext() {
      return __classPrivateFieldGet(this, _JSHandle_context, "f");
    }
    async evaluate(pageFunction, ...args) {
      return await this.executionContext().evaluate(pageFunction, this, ...args);
    }
    async evaluateHandle(pageFunction, ...args) {
      return await this.executionContext().evaluateHandle(pageFunction, this, ...args);
    }
    async getProperty(propertyName) {
      return this.evaluateHandle((object, propertyName2) => {
        return object[propertyName2];
      }, propertyName);
    }
    async getProperties() {
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _JSHandle_remoteObject, "f").objectId);
      const response = await this.client.send("Runtime.getProperties", {
        objectId: __classPrivateFieldGet(this, _JSHandle_remoteObject, "f").objectId,
        ownProperties: true
      });
      const result = new Map;
      for (const property of response.result) {
        if (!property.enumerable || !property.value) {
          continue;
        }
        result.set(property.name, (0, util_js_1.createJSHandle)(__classPrivateFieldGet(this, _JSHandle_context, "f"), property.value));
      }
      return result;
    }
    async jsonValue() {
      if (!__classPrivateFieldGet(this, _JSHandle_remoteObject, "f").objectId) {
        return (0, util_js_1.valueFromRemoteObject)(__classPrivateFieldGet(this, _JSHandle_remoteObject, "f"));
      }
      const value = await this.evaluate((object) => {
        return object;
      });
      if (value === undefined) {
        throw new Error("Could not serialize referenced object");
      }
      return value;
    }
    asElement() {
      return null;
    }
    async dispose() {
      if (__classPrivateFieldGet(this, _JSHandle_disposed, "f")) {
        return;
      }
      __classPrivateFieldSet(this, _JSHandle_disposed, true, "f");
      await (0, util_js_1.releaseObject)(this.client, __classPrivateFieldGet(this, _JSHandle_remoteObject, "f"));
    }
    toString() {
      if (!__classPrivateFieldGet(this, _JSHandle_remoteObject, "f").objectId) {
        return "JSHandle:" + (0, util_js_1.valueFromRemoteObject)(__classPrivateFieldGet(this, _JSHandle_remoteObject, "f"));
      }
      const type = __classPrivateFieldGet(this, _JSHandle_remoteObject, "f").subtype || __classPrivateFieldGet(this, _JSHandle_remoteObject, "f").type;
      return "JSHandle@" + type;
    }
    remoteObject() {
      return __classPrivateFieldGet(this, _JSHandle_remoteObject, "f");
    }
  }
  exports.JSHandle = JSHandle;
  _JSHandle_disposed = new WeakMap, _JSHandle_context = new WeakMap, _JSHandle_remoteObject = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/ElementHandle.js
var require_ElementHandle = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ElementHandle_instances;
  var _ElementHandle_frame;
  var _ElementHandle_frameManager_get;
  var _ElementHandle_page_get;
  var _ElementHandle_scrollIntoViewIfNeeded;
  var _ElementHandle_getOOPIFOffsets;
  var _ElementHandle_getBoxModel;
  var _ElementHandle_fromProtocolQuad;
  var _ElementHandle_intersectQuadWithViewport;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ElementHandle = undefined;
  var assert_js_1 = require_assert();
  var JSHandle_js_1 = require_JSHandle();
  var QueryHandler_js_1 = require_QueryHandler();
  var util_js_1 = require_util();
  var applyOffsetsToQuad = (quad, offsetX, offsetY) => {
    return quad.map((part) => {
      return { x: part.x + offsetX, y: part.y + offsetY };
    });
  };

  class ElementHandle extends JSHandle_js_1.JSHandle {
    constructor(context, remoteObject, frame) {
      super(context, remoteObject);
      _ElementHandle_instances.add(this);
      _ElementHandle_frame.set(this, undefined);
      __classPrivateFieldSet(this, _ElementHandle_frame, frame, "f");
    }
    get frame() {
      return __classPrivateFieldGet(this, _ElementHandle_frame, "f");
    }
    async $(selector) {
      const { updatedSelector, queryHandler } = (0, QueryHandler_js_1.getQueryHandlerAndSelector)(selector);
      (0, assert_js_1.assert)(queryHandler.queryOne, "Cannot handle queries for a single element with the given selector");
      return await queryHandler.queryOne(this, updatedSelector);
    }
    async $$(selector) {
      const { updatedSelector, queryHandler } = (0, QueryHandler_js_1.getQueryHandlerAndSelector)(selector);
      (0, assert_js_1.assert)(queryHandler.queryAll, "Cannot handle queries for a multiple element with the given selector");
      return await queryHandler.queryAll(this, updatedSelector);
    }
    async $eval(selector, pageFunction, ...args) {
      const elementHandle = await this.$(selector);
      if (!elementHandle) {
        throw new Error(`Error: failed to find element matching selector "${selector}"`);
      }
      const result = await elementHandle.evaluate(pageFunction, ...args);
      await elementHandle.dispose();
      return result;
    }
    async $$eval(selector, pageFunction, ...args) {
      const { updatedSelector, queryHandler } = (0, QueryHandler_js_1.getQueryHandlerAndSelector)(selector);
      (0, assert_js_1.assert)(queryHandler.queryAll, "Cannot handle queries for a multiple element with the given selector");
      const handles = await queryHandler.queryAll(this, updatedSelector);
      const elements = await this.evaluateHandle((_2, ...elements2) => {
        return elements2;
      }, ...handles);
      const [result] = await Promise.all([
        elements.evaluate(pageFunction, ...args),
        ...handles.map((handle) => {
          return handle.dispose();
        })
      ]);
      await elements.dispose();
      return result;
    }
    async $x(expression) {
      if (expression.startsWith("//")) {
        expression = `.${expression}`;
      }
      return this.$$(`xpath/${expression}`);
    }
    async waitForSelector(selector, options = {}) {
      const { updatedSelector, queryHandler } = (0, QueryHandler_js_1.getQueryHandlerAndSelector)(selector);
      (0, assert_js_1.assert)(queryHandler.waitFor, "Query handler does not support waiting");
      return await queryHandler.waitFor(this, updatedSelector, options);
    }
    async waitForXPath(xpath, options = {}) {
      if (xpath.startsWith("//")) {
        xpath = `.${xpath}`;
      }
      return this.waitForSelector(`xpath/${xpath}`, options);
    }
    asElement() {
      return this;
    }
    async contentFrame() {
      const nodeInfo = await this.client.send("DOM.describeNode", {
        objectId: this.remoteObject().objectId
      });
      if (typeof nodeInfo.node.frameId !== "string") {
        return null;
      }
      return __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_frameManager_get).frame(nodeInfo.node.frameId);
    }
    async clickablePoint(offset) {
      const [result, layoutMetrics] = await Promise.all([
        this.client.send("DOM.getContentQuads", {
          objectId: this.remoteObject().objectId
        }).catch(util_js_1.debugError),
        __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get)._client().send("Page.getLayoutMetrics")
      ]);
      if (!result || !result.quads.length) {
        throw new Error("Node is either not clickable or not an HTMLElement");
      }
      const { clientWidth, clientHeight } = layoutMetrics.cssLayoutViewport || layoutMetrics.layoutViewport;
      const { offsetX, offsetY } = await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_getOOPIFOffsets).call(this, __classPrivateFieldGet(this, _ElementHandle_frame, "f"));
      const quads = result.quads.map((quad2) => {
        return __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_fromProtocolQuad).call(this, quad2);
      }).map((quad2) => {
        return applyOffsetsToQuad(quad2, offsetX, offsetY);
      }).map((quad2) => {
        return __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_intersectQuadWithViewport).call(this, quad2, clientWidth, clientHeight);
      }).filter((quad2) => {
        return computeQuadArea(quad2) > 1;
      });
      if (!quads.length) {
        throw new Error("Node is either not clickable or not an HTMLElement");
      }
      const quad = quads[0];
      if (offset) {
        let minX = Number.MAX_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        for (const point of quad) {
          if (point.x < minX) {
            minX = point.x;
          }
          if (point.y < minY) {
            minY = point.y;
          }
        }
        if (minX !== Number.MAX_SAFE_INTEGER && minY !== Number.MAX_SAFE_INTEGER) {
          return {
            x: minX + offset.x,
            y: minY + offset.y
          };
        }
      }
      let x = 0;
      let y = 0;
      for (const point of quad) {
        x += point.x;
        y += point.y;
      }
      return {
        x: x / 4,
        y: y / 4
      };
    }
    async hover() {
      await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_scrollIntoViewIfNeeded).call(this);
      const { x, y } = await this.clickablePoint();
      await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).mouse.move(x, y);
    }
    async click(options = {}) {
      await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_scrollIntoViewIfNeeded).call(this);
      const { x, y } = await this.clickablePoint(options.offset);
      await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).mouse.click(x, y, options);
    }
    async drag(target) {
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).isDragInterceptionEnabled(), "Drag Interception is not enabled!");
      await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_scrollIntoViewIfNeeded).call(this);
      const start = await this.clickablePoint();
      return await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).mouse.drag(start, target);
    }
    async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
      await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_scrollIntoViewIfNeeded).call(this);
      const target = await this.clickablePoint();
      await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).mouse.dragEnter(target, data);
    }
    async dragOver(data = { items: [], dragOperationsMask: 1 }) {
      await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_scrollIntoViewIfNeeded).call(this);
      const target = await this.clickablePoint();
      await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).mouse.dragOver(target, data);
    }
    async drop(data = { items: [], dragOperationsMask: 1 }) {
      await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_scrollIntoViewIfNeeded).call(this);
      const destination = await this.clickablePoint();
      await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).mouse.drop(destination, data);
    }
    async dragAndDrop(target, options) {
      await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_scrollIntoViewIfNeeded).call(this);
      const startPoint = await this.clickablePoint();
      const targetPoint = await target.clickablePoint();
      await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).mouse.dragAndDrop(startPoint, targetPoint, options);
    }
    async select(...values) {
      for (const value of values) {
        (0, assert_js_1.assert)((0, util_js_1.isString)(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
      }
      return this.evaluate((element, vals) => {
        const values2 = new Set(vals);
        if (!(element instanceof HTMLSelectElement)) {
          throw new Error("Element is not a <select> element.");
        }
        const selectedValues = new Set;
        if (!element.multiple) {
          for (const option of element.options) {
            option.selected = false;
          }
          for (const option of element.options) {
            if (values2.has(option.value)) {
              option.selected = true;
              selectedValues.add(option.value);
              break;
            }
          }
        } else {
          for (const option of element.options) {
            option.selected = values2.has(option.value);
            if (option.selected) {
              selectedValues.add(option.value);
            }
          }
        }
        element.dispatchEvent(new Event("input", { bubbles: true }));
        element.dispatchEvent(new Event("change", { bubbles: true }));
        return [...selectedValues.values()];
      }, values);
    }
    async uploadFile(...filePaths) {
      const isMultiple = await this.evaluate((element) => {
        return element.multiple;
      });
      (0, assert_js_1.assert)(filePaths.length <= 1 || isMultiple, "Multiple file uploads only work with <input type=file multiple>");
      let path;
      try {
        path = await Promise.resolve().then(() => __importStar(__require("path")));
      } catch (error) {
        if (error instanceof TypeError) {
          throw new Error(`JSHandle#uploadFile can only be used in Node-like environments.`);
        }
        throw error;
      }
      const files = filePaths.map((filePath) => {
        if (path.win32.isAbsolute(filePath) || path.posix.isAbsolute(filePath)) {
          return filePath;
        } else {
          return path.resolve(filePath);
        }
      });
      const { objectId } = this.remoteObject();
      const { node } = await this.client.send("DOM.describeNode", { objectId });
      const { backendNodeId } = node;
      if (files.length === 0) {
        await this.evaluate((element) => {
          element.files = new DataTransfer().files;
          element.dispatchEvent(new Event("input", { bubbles: true }));
          element.dispatchEvent(new Event("change", { bubbles: true }));
        });
      } else {
        await this.client.send("DOM.setFileInputFiles", {
          objectId,
          files,
          backendNodeId
        });
      }
    }
    async tap() {
      await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_scrollIntoViewIfNeeded).call(this);
      const { x, y } = await this.clickablePoint();
      await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).touchscreen.tap(x, y);
    }
    async focus() {
      await this.evaluate((element) => {
        if (!(element instanceof HTMLElement)) {
          throw new Error("Cannot focus non-HTMLElement");
        }
        return element.focus();
      });
    }
    async type(text, options) {
      await this.focus();
      await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).keyboard.type(text, options);
    }
    async press(key2, options) {
      await this.focus();
      await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).keyboard.press(key2, options);
    }
    async boundingBox() {
      const result = await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_getBoxModel).call(this);
      if (!result) {
        return null;
      }
      const { offsetX, offsetY } = await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_getOOPIFOffsets).call(this, __classPrivateFieldGet(this, _ElementHandle_frame, "f"));
      const quad = result.model.border;
      const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
      const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
      const width2 = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
      const height2 = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
      return { x: x + offsetX, y: y + offsetY, width: width2, height: height2 };
    }
    async boxModel() {
      const result = await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_getBoxModel).call(this);
      if (!result) {
        return null;
      }
      const { offsetX, offsetY } = await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_getOOPIFOffsets).call(this, __classPrivateFieldGet(this, _ElementHandle_frame, "f"));
      const { content, padding, border, margin, width: width2, height: height2 } = result.model;
      return {
        content: applyOffsetsToQuad(__classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_fromProtocolQuad).call(this, content), offsetX, offsetY),
        padding: applyOffsetsToQuad(__classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_fromProtocolQuad).call(this, padding), offsetX, offsetY),
        border: applyOffsetsToQuad(__classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_fromProtocolQuad).call(this, border), offsetX, offsetY),
        margin: applyOffsetsToQuad(__classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_fromProtocolQuad).call(this, margin), offsetX, offsetY),
        width: width2,
        height: height2
      };
    }
    async screenshot(options = {}) {
      let needsViewportReset = false;
      let boundingBox = await this.boundingBox();
      (0, assert_js_1.assert)(boundingBox, "Node is either not visible or not an HTMLElement");
      const viewport = __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).viewport();
      if (viewport && (boundingBox.width > viewport.width || boundingBox.height > viewport.height)) {
        const newViewport = {
          width: Math.max(viewport.width, Math.ceil(boundingBox.width)),
          height: Math.max(viewport.height, Math.ceil(boundingBox.height))
        };
        await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).setViewport(Object.assign({}, viewport, newViewport));
        needsViewportReset = true;
      }
      await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_scrollIntoViewIfNeeded).call(this);
      boundingBox = await this.boundingBox();
      (0, assert_js_1.assert)(boundingBox, "Node is either not visible or not an HTMLElement");
      (0, assert_js_1.assert)(boundingBox.width !== 0, "Node has 0 width.");
      (0, assert_js_1.assert)(boundingBox.height !== 0, "Node has 0 height.");
      const layoutMetrics = await this.client.send("Page.getLayoutMetrics");
      const { pageX, pageY } = layoutMetrics.cssVisualViewport || layoutMetrics.layoutViewport;
      const clip = Object.assign({}, boundingBox);
      clip.x += pageX;
      clip.y += pageY;
      const imageData = await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).screenshot(Object.assign({}, {
        clip
      }, options));
      if (needsViewportReset && viewport) {
        await __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).setViewport(viewport);
      }
      return imageData;
    }
    async isIntersectingViewport(options) {
      const { threshold = 0 } = options !== null && options !== undefined ? options : {};
      return await this.evaluate(async (element, threshold2) => {
        const visibleRatio = await new Promise((resolve) => {
          const observer = new IntersectionObserver((entries) => {
            resolve(entries[0].intersectionRatio);
            observer.disconnect();
          });
          observer.observe(element);
        });
        return threshold2 === 1 ? visibleRatio === 1 : visibleRatio > threshold2;
      }, threshold);
    }
  }
  exports.ElementHandle = ElementHandle;
  _ElementHandle_frame = new WeakMap, _ElementHandle_instances = new WeakSet, _ElementHandle_frameManager_get = function _ElementHandle_frameManager_get() {
    return __classPrivateFieldGet(this, _ElementHandle_frame, "f")._frameManager;
  }, _ElementHandle_page_get = function _ElementHandle_page_get() {
    return __classPrivateFieldGet(this, _ElementHandle_frame, "f").page();
  }, _ElementHandle_scrollIntoViewIfNeeded = async function _ElementHandle_scrollIntoViewIfNeeded() {
    const error = await this.evaluate(async (element) => {
      if (!element.isConnected) {
        return "Node is detached from document";
      }
      if (element.nodeType !== Node.ELEMENT_NODE) {
        return "Node is not of type HTMLElement";
      }
      return;
    });
    if (error) {
      throw new Error(error);
    }
    try {
      await this.client.send("DOM.scrollIntoViewIfNeeded", {
        objectId: this.remoteObject().objectId
      });
    } catch (_err) {
      await this.evaluate(async (element, pageJavascriptEnabled) => {
        const visibleRatio = async () => {
          return await new Promise((resolve) => {
            const observer = new IntersectionObserver((entries) => {
              resolve(entries[0].intersectionRatio);
              observer.disconnect();
            });
            observer.observe(element);
          });
        };
        if (!pageJavascriptEnabled || await visibleRatio() !== 1) {
          element.scrollIntoView({
            block: "center",
            inline: "center",
            behavior: "instant"
          });
        }
      }, __classPrivateFieldGet(this, _ElementHandle_instances, "a", _ElementHandle_page_get).isJavaScriptEnabled());
    }
  }, _ElementHandle_getOOPIFOffsets = async function _ElementHandle_getOOPIFOffsets(frame) {
    let offsetX = 0;
    let offsetY = 0;
    let currentFrame = frame;
    while (currentFrame && currentFrame.parentFrame()) {
      const parent = currentFrame.parentFrame();
      if (!currentFrame.isOOPFrame() || !parent) {
        currentFrame = parent;
        continue;
      }
      const { backendNodeId } = await parent._client().send("DOM.getFrameOwner", {
        frameId: currentFrame._id
      });
      const result = await parent._client().send("DOM.getBoxModel", {
        backendNodeId
      });
      if (!result) {
        break;
      }
      const contentBoxQuad = result.model.content;
      const topLeftCorner = __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_fromProtocolQuad).call(this, contentBoxQuad)[0];
      offsetX += topLeftCorner.x;
      offsetY += topLeftCorner.y;
      currentFrame = parent;
    }
    return { offsetX, offsetY };
  }, _ElementHandle_getBoxModel = function _ElementHandle_getBoxModel() {
    const params = {
      objectId: this.remoteObject().objectId
    };
    return this.client.send("DOM.getBoxModel", params).catch((error) => {
      return (0, util_js_1.debugError)(error);
    });
  }, _ElementHandle_fromProtocolQuad = function _ElementHandle_fromProtocolQuad(quad) {
    return [
      { x: quad[0], y: quad[1] },
      { x: quad[2], y: quad[3] },
      { x: quad[4], y: quad[5] },
      { x: quad[6], y: quad[7] }
    ];
  }, _ElementHandle_intersectQuadWithViewport = function _ElementHandle_intersectQuadWithViewport(quad, width2, height2) {
    return quad.map((point) => {
      return {
        x: Math.min(Math.max(point.x, 0), width2),
        y: Math.min(Math.max(point.y, 0), height2)
      };
    });
  };
  function computeQuadArea(quad) {
    let area = 0;
    for (let i = 0;i < quad.length; ++i) {
      const p1 = quad[i];
      const p2 = quad[(i + 1) % quad.length];
      area += (p1.x * p2.y - p2.x * p1.y) / 2;
    }
    return Math.abs(area);
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/generated/injected.js
var require_injected = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.source = undefined;
  exports.source = `"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/injected/injected.ts
var injected_exports = {};
__export(injected_exports, {
  default: () => injected_default
});
module.exports = __toCommonJS(injected_exports);

// src/common/Errors.ts
var CustomError = class extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
};
var TimeoutError = class extends CustomError {
};
var ProtocolError = class extends CustomError {
  code;
  originalMessage = "";
};
var errors = Object.freeze({
  TimeoutError,
  ProtocolError
});

// src/util/DeferredPromise.ts
function createDeferredPromise(opts) {
  let isResolved = false;
  let isRejected = false;
  let resolver;
  let rejector;
  const taskPromise = new Promise((resolve, reject) => {
    resolver = resolve;
    rejector = reject;
  });
  const timeoutId = opts && opts.timeout > 0 ? setTimeout(() => {
    isRejected = true;
    rejector(new TimeoutError(opts.message));
  }, opts.timeout) : void 0;
  return Object.assign(taskPromise, {
    resolved: () => {
      return isResolved;
    },
    finished: () => {
      return isResolved || isRejected;
    },
    resolve: (value) => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      isResolved = true;
      resolver(value);
    },
    reject: (err) => {
      clearTimeout(timeoutId);
      isRejected = true;
      rejector(err);
    }
  });
}

// src/util/assert.ts
var assert = (value, message) => {
  if (!value) {
    throw new Error(message);
  }
};

// src/injected/Poller.ts
var MutationPoller = class {
  #fn;
  #root;
  #observer;
  #promise;
  constructor(fn, root) {
    this.#fn = fn;
    this.#root = root;
  }
  async start() {
    const promise = this.#promise = createDeferredPromise();
    const result = await this.#fn();
    if (result) {
      promise.resolve(result);
      return;
    }
    this.#observer = new MutationObserver(async () => {
      const result2 = await this.#fn();
      if (!result2) {
        return;
      }
      promise.resolve(result2);
      await this.stop();
    });
    this.#observer.observe(this.#root, {
      childList: true,
      subtree: true,
      attributes: true
    });
  }
  async stop() {
    assert(this.#promise, "Polling never started.");
    if (!this.#promise.finished()) {
      this.#promise.reject(new Error("Polling stopped"));
    }
    if (this.#observer) {
      this.#observer.disconnect();
      this.#observer = void 0;
    }
  }
  result() {
    assert(this.#promise, "Polling never started.");
    return this.#promise;
  }
};
var RAFPoller = class {
  #fn;
  #promise;
  constructor(fn) {
    this.#fn = fn;
  }
  async start() {
    const promise = this.#promise = createDeferredPromise();
    const result = await this.#fn();
    if (result) {
      promise.resolve(result);
      return;
    }
    const poll = async () => {
      if (promise.finished()) {
        return;
      }
      const result2 = await this.#fn();
      if (!result2) {
        window.requestAnimationFrame(poll);
        return;
      }
      promise.resolve(result2);
      await this.stop();
    };
    window.requestAnimationFrame(poll);
  }
  async stop() {
    assert(this.#promise, "Polling never started.");
    if (!this.#promise.finished()) {
      this.#promise.reject(new Error("Polling stopped"));
    }
  }
  result() {
    assert(this.#promise, "Polling never started.");
    return this.#promise;
  }
};
var IntervalPoller = class {
  #fn;
  #ms;
  #interval;
  #promise;
  constructor(fn, ms) {
    this.#fn = fn;
    this.#ms = ms;
  }
  async start() {
    const promise = this.#promise = createDeferredPromise();
    const result = await this.#fn();
    if (result) {
      promise.resolve(result);
      return;
    }
    this.#interval = setInterval(async () => {
      const result2 = await this.#fn();
      if (!result2) {
        return;
      }
      promise.resolve(result2);
      await this.stop();
    }, this.#ms);
  }
  async stop() {
    assert(this.#promise, "Polling never started.");
    if (!this.#promise.finished()) {
      this.#promise.reject(new Error("Polling stopped"));
    }
    if (this.#interval) {
      clearInterval(this.#interval);
      this.#interval = void 0;
    }
  }
  result() {
    assert(this.#promise, "Polling never started.");
    return this.#promise;
  }
};

// src/injected/TextContent.ts
var TRIVIAL_VALUE_INPUT_TYPES = /* @__PURE__ */ new Set(["checkbox", "image", "radio"]);
var isNonTrivialValueNode = (node) => {
  if (node instanceof HTMLSelectElement) {
    return true;
  }
  if (node instanceof HTMLTextAreaElement) {
    return true;
  }
  if (node instanceof HTMLInputElement && !TRIVIAL_VALUE_INPUT_TYPES.has(node.type)) {
    return true;
  }
  return false;
};
var UNSUITABLE_NODE_NAMES = /* @__PURE__ */ new Set(["SCRIPT", "STYLE"]);
var isSuitableNodeForTextMatching = (node) => {
  return !UNSUITABLE_NODE_NAMES.has(node.nodeName) && !document.head?.contains(node);
};
var textContentCache = /* @__PURE__ */ new WeakMap();
var eraseFromCache = (node) => {
  while (node) {
    textContentCache.delete(node);
    if (node instanceof ShadowRoot) {
      node = node.host;
    } else {
      node = node.parentNode;
    }
  }
};
var observedNodes = /* @__PURE__ */ new WeakSet();
var textChangeObserver = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    eraseFromCache(mutation.target);
  }
});
var createTextContent = (root) => {
  let value = textContentCache.get(root);
  if (value) {
    return value;
  }
  value = { full: "", immediate: [] };
  if (!isSuitableNodeForTextMatching(root)) {
    return value;
  }
  let currentImmediate = "";
  if (isNonTrivialValueNode(root)) {
    value.full = root.value;
    value.immediate.push(root.value);
    root.addEventListener(
      "input",
      (event) => {
        eraseFromCache(event.target);
      },
      { once: true, capture: true }
    );
  } else {
    for (let child = root.firstChild; child; child = child.nextSibling) {
      if (child.nodeType === Node.TEXT_NODE) {
        value.full += child.nodeValue ?? "";
        currentImmediate += child.nodeValue ?? "";
        continue;
      }
      if (currentImmediate) {
        value.immediate.push(currentImmediate);
      }
      currentImmediate = "";
      if (child.nodeType === Node.ELEMENT_NODE) {
        value.full += createTextContent(child).full;
      }
    }
    if (currentImmediate) {
      value.immediate.push(currentImmediate);
    }
    if (root instanceof Element && root.shadowRoot) {
      value.full += createTextContent(root.shadowRoot).full;
    }
    if (!observedNodes.has(root)) {
      textChangeObserver.observe(root, {
        childList: true,
        characterData: true
      });
      observedNodes.add(root);
    }
  }
  textContentCache.set(root, value);
  return value;
};

// src/injected/TextQuerySelector.ts
var TextQuerySelector_exports = {};
__export(TextQuerySelector_exports, {
  textQuerySelector: () => textQuerySelector,
  textQuerySelectorAll: () => textQuerySelectorAll
});
var textQuerySelector = (root, selector) => {
  for (const node of root.childNodes) {
    if (node instanceof Element && isSuitableNodeForTextMatching(node)) {
      let matchedNode;
      if (node.shadowRoot) {
        matchedNode = textQuerySelector(node.shadowRoot, selector);
      } else {
        matchedNode = textQuerySelector(node, selector);
      }
      if (matchedNode) {
        return matchedNode;
      }
    }
  }
  if (root instanceof Element) {
    const textContent = createTextContent(root);
    if (textContent.full.includes(selector)) {
      return root;
    }
  }
  return null;
};
var textQuerySelectorAll = (root, selector) => {
  let results = [];
  for (const node of root.childNodes) {
    if (node instanceof Element) {
      let matchedNodes;
      if (node.shadowRoot) {
        matchedNodes = textQuerySelectorAll(node.shadowRoot, selector);
      } else {
        matchedNodes = textQuerySelectorAll(node, selector);
      }
      results = results.concat(matchedNodes);
    }
  }
  if (results.length > 0) {
    return results;
  }
  if (root instanceof Element) {
    const textContent = createTextContent(root);
    if (textContent.full.includes(selector)) {
      return [root];
    }
  }
  return [];
};

// src/injected/XPathQuerySelector.ts
var XPathQuerySelector_exports = {};
__export(XPathQuerySelector_exports, {
  xpathQuerySelector: () => xpathQuerySelector,
  xpathQuerySelectorAll: () => xpathQuerySelectorAll
});
var xpathQuerySelector = (root, selector) => {
  const doc = root.ownerDocument || document;
  const result = doc.evaluate(
    selector,
    root,
    null,
    XPathResult.FIRST_ORDERED_NODE_TYPE
  );
  return result.singleNodeValue;
};
var xpathQuerySelectorAll = (root, selector) => {
  const doc = root.ownerDocument || document;
  const iterator = doc.evaluate(
    selector,
    root,
    null,
    XPathResult.ORDERED_NODE_ITERATOR_TYPE
  );
  const array = [];
  let item;
  while (item = iterator.iterateNext()) {
    array.push(item);
  }
  return array;
};

// src/injected/PierceQuerySelector.ts
var PierceQuerySelector_exports = {};
__export(PierceQuerySelector_exports, {
  pierceQuerySelector: () => pierceQuerySelector,
  pierceQuerySelectorAll: () => pierceQuerySelectorAll
});
var pierceQuerySelector = (root, selector) => {
  let found = null;
  const search = (root2) => {
    const iter = document.createTreeWalker(root2, NodeFilter.SHOW_ELEMENT);
    do {
      const currentNode = iter.currentNode;
      if (currentNode.shadowRoot) {
        search(currentNode.shadowRoot);
      }
      if (currentNode instanceof ShadowRoot) {
        continue;
      }
      if (currentNode !== root2 && !found && currentNode.matches(selector)) {
        found = currentNode;
      }
    } while (!found && iter.nextNode());
  };
  if (root instanceof Document) {
    root = root.documentElement;
  }
  search(root);
  return found;
};
var pierceQuerySelectorAll = (element, selector) => {
  const result = [];
  const collect = (root) => {
    const iter = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
    do {
      const currentNode = iter.currentNode;
      if (currentNode.shadowRoot) {
        collect(currentNode.shadowRoot);
      }
      if (currentNode instanceof ShadowRoot) {
        continue;
      }
      if (currentNode !== root && currentNode.matches(selector)) {
        result.push(currentNode);
      }
    } while (iter.nextNode());
  };
  if (element instanceof Document) {
    element = element.documentElement;
  }
  collect(element);
  return result;
};

// src/injected/util.ts
var util_exports = {};
__export(util_exports, {
  checkVisibility: () => checkVisibility,
  createFunction: () => createFunction
});
var createdFunctions = /* @__PURE__ */ new Map();
var createFunction = (functionValue) => {
  let fn = createdFunctions.get(functionValue);
  if (fn) {
    return fn;
  }
  fn = new Function(\`return \${functionValue}\`)();
  createdFunctions.set(functionValue, fn);
  return fn;
};
var HIDDEN_VISIBILITY_VALUES = ["hidden", "collapse"];
var checkVisibility = (node, visible) => {
  if (!node) {
    return visible === false;
  }
  if (visible === void 0) {
    return node;
  }
  const element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
  const style = window.getComputedStyle(element);
  const isVisible = style && !HIDDEN_VISIBILITY_VALUES.includes(style.visibility) && isBoundingBoxVisible(element);
  return visible === isVisible ? node : false;
};
function isBoundingBoxVisible(element) {
  const rect = element.getBoundingClientRect();
  return rect.width > 0 && rect.height > 0 && rect.right > 0 && rect.bottom > 0 && rect.left < self.innerWidth && rect.top < self.innerHeight;
}

// src/injected/injected.ts
var PuppeteerUtil = Object.freeze({
  ...util_exports,
  ...TextQuerySelector_exports,
  ...XPathQuerySelector_exports,
  ...PierceQuerySelector_exports,
  createDeferredPromise,
  createTextContent,
  IntervalPoller,
  isSuitableNodeForTextMatching,
  MutationPoller,
  RAFPoller
});
var injected_default = PuppeteerUtil;
`;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/DeferredPromise.js
var require_DeferredPromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDeferredPromise = undefined;
  var Errors_js_1 = require_Errors();
  function createDeferredPromise(opts) {
    let isResolved = false;
    let isRejected = false;
    let resolver;
    let rejector;
    const taskPromise = new Promise((resolve, reject) => {
      resolver = resolve;
      rejector = reject;
    });
    const timeoutId = opts && opts.timeout > 0 ? setTimeout(() => {
      isRejected = true;
      rejector(new Errors_js_1.TimeoutError(opts.message));
    }, opts.timeout) : undefined;
    return Object.assign(taskPromise, {
      resolved: () => {
        return isResolved;
      },
      finished: () => {
        return isResolved || isRejected;
      },
      resolve: (value) => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        isResolved = true;
        resolver(value);
      },
      reject: (err) => {
        clearTimeout(timeoutId);
        isRejected = true;
        rejector(err);
      }
    });
  }
  exports.createDeferredPromise = createDeferredPromise;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/LazyArg.js
var require_LazyArg = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _LazyArg_get;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LazyArg = undefined;

  class LazyArg {
    constructor(get2) {
      _LazyArg_get.set(this, undefined);
      __classPrivateFieldSet(this, _LazyArg_get, get2, "f");
    }
    get() {
      return __classPrivateFieldGet(this, _LazyArg_get, "f").call(this);
    }
  }
  exports.LazyArg = LazyArg;
  _LazyArg_get = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/third_party/mitt/index.js
var require_mitt = __commonJS((exports, module) => {
  function mitt_es(n) {
    return { all: n = n || new Map, on: function(t, e) {
      var i = n.get(t);
      i && i.push(e) || n.set(t, [e]);
    }, off: function(t, e) {
      var i = n.get(t);
      i && i.splice(i.indexOf(e) >>> 0, 1);
    }, emit: function(t, e) {
      (n.get(t) || []).slice().map(function(n2) {
        n2(e);
      }), (n.get("*") || []).slice().map(function(n2) {
        n2(t, e);
      });
    } };
  }
  module.exports = mitt_es;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/EventEmitter.js
var require_EventEmitter = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventEmitter = undefined;
  var index_js_1 = __importDefault(require_mitt());

  class EventEmitter {
    constructor() {
      this.eventsMap = new Map;
      this.emitter = (0, index_js_1.default)(this.eventsMap);
    }
    on(event, handler) {
      this.emitter.on(event, handler);
      return this;
    }
    off(event, handler) {
      this.emitter.off(event, handler);
      return this;
    }
    removeListener(event, handler) {
      this.off(event, handler);
      return this;
    }
    addListener(event, handler) {
      this.on(event, handler);
      return this;
    }
    emit(event, eventData) {
      this.emitter.emit(event, eventData);
      return this.eventListenersCount(event) > 0;
    }
    once(event, handler) {
      const onceHandler = (eventData) => {
        handler(eventData);
        this.off(event, onceHandler);
      };
      return this.on(event, onceHandler);
    }
    listenerCount(event) {
      return this.eventListenersCount(event);
    }
    removeAllListeners(event) {
      if (event) {
        this.eventsMap.delete(event);
      } else {
        this.eventsMap.clear();
      }
      return this;
    }
    eventListenersCount(event) {
      var _a;
      return ((_a = this.eventsMap.get(event)) === null || _a === undefined ? undefined : _a.length) || 0;
    }
  }
  exports.EventEmitter = EventEmitter;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Connection.js
var require_Connection = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Connection_instances;
  var _Connection_url;
  var _Connection_transport;
  var _Connection_delay;
  var _Connection_lastId;
  var _Connection_sessions;
  var _Connection_closed;
  var _Connection_callbacks;
  var _Connection_manuallyAttached;
  var _Connection_onClose;
  var _CDPSessionImpl_sessionId;
  var _CDPSessionImpl_targetType;
  var _CDPSessionImpl_callbacks;
  var _CDPSessionImpl_connection;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTargetClosedError = exports.CDPSessionImpl = exports.CDPSession = exports.CDPSessionEmittedEvents = exports.Connection = exports.ConnectionEmittedEvents = undefined;
  var assert_js_1 = require_assert();
  var Debug_js_1 = require_Debug();
  var debugProtocolSend = (0, Debug_js_1.debug)("puppeteer:protocol:SEND ►");
  var debugProtocolReceive = (0, Debug_js_1.debug)("puppeteer:protocol:RECV ◀");
  var EventEmitter_js_1 = require_EventEmitter();
  var Errors_js_1 = require_Errors();
  exports.ConnectionEmittedEvents = {
    Disconnected: Symbol("Connection.Disconnected")
  };

  class Connection extends EventEmitter_js_1.EventEmitter {
    constructor(url, transport, delay = 0) {
      super();
      _Connection_instances.add(this);
      _Connection_url.set(this, undefined);
      _Connection_transport.set(this, undefined);
      _Connection_delay.set(this, undefined);
      _Connection_lastId.set(this, 0);
      _Connection_sessions.set(this, new Map);
      _Connection_closed.set(this, false);
      _Connection_callbacks.set(this, new Map);
      _Connection_manuallyAttached.set(this, new Set);
      __classPrivateFieldSet(this, _Connection_url, url, "f");
      __classPrivateFieldSet(this, _Connection_delay, delay, "f");
      __classPrivateFieldSet(this, _Connection_transport, transport, "f");
      __classPrivateFieldGet(this, _Connection_transport, "f").onmessage = this.onMessage.bind(this);
      __classPrivateFieldGet(this, _Connection_transport, "f").onclose = __classPrivateFieldGet(this, _Connection_instances, "m", _Connection_onClose).bind(this);
    }
    static fromSession(session) {
      return session.connection();
    }
    get _closed() {
      return __classPrivateFieldGet(this, _Connection_closed, "f");
    }
    get _sessions() {
      return __classPrivateFieldGet(this, _Connection_sessions, "f");
    }
    session(sessionId) {
      return __classPrivateFieldGet(this, _Connection_sessions, "f").get(sessionId) || null;
    }
    url() {
      return __classPrivateFieldGet(this, _Connection_url, "f");
    }
    send(method, ...paramArgs) {
      const params = paramArgs.length ? paramArgs[0] : undefined;
      const id = this._rawSend({ method, params });
      return new Promise((resolve, reject) => {
        __classPrivateFieldGet(this, _Connection_callbacks, "f").set(id, {
          resolve,
          reject,
          error: new Errors_js_1.ProtocolError,
          method
        });
      });
    }
    _rawSend(message) {
      var _a;
      const id = __classPrivateFieldSet(this, _Connection_lastId, (_a = __classPrivateFieldGet(this, _Connection_lastId, "f"), ++_a), "f");
      const stringifiedMessage = JSON.stringify(Object.assign({}, message, { id }));
      debugProtocolSend(stringifiedMessage);
      __classPrivateFieldGet(this, _Connection_transport, "f").send(stringifiedMessage);
      return id;
    }
    async onMessage(message) {
      if (__classPrivateFieldGet(this, _Connection_delay, "f")) {
        await new Promise((f) => {
          return setTimeout(f, __classPrivateFieldGet(this, _Connection_delay, "f"));
        });
      }
      debugProtocolReceive(message);
      const object = JSON.parse(message);
      if (object.method === "Target.attachedToTarget") {
        const sessionId = object.params.sessionId;
        const session = new CDPSessionImpl(this, object.params.targetInfo.type, sessionId);
        __classPrivateFieldGet(this, _Connection_sessions, "f").set(sessionId, session);
        this.emit("sessionattached", session);
        const parentSession = __classPrivateFieldGet(this, _Connection_sessions, "f").get(object.sessionId);
        if (parentSession) {
          parentSession.emit("sessionattached", session);
        }
      } else if (object.method === "Target.detachedFromTarget") {
        const session = __classPrivateFieldGet(this, _Connection_sessions, "f").get(object.params.sessionId);
        if (session) {
          session._onClosed();
          __classPrivateFieldGet(this, _Connection_sessions, "f").delete(object.params.sessionId);
          this.emit("sessiondetached", session);
          const parentSession = __classPrivateFieldGet(this, _Connection_sessions, "f").get(object.sessionId);
          if (parentSession) {
            parentSession.emit("sessiondetached", session);
          }
        }
      }
      if (object.sessionId) {
        const session = __classPrivateFieldGet(this, _Connection_sessions, "f").get(object.sessionId);
        if (session) {
          session._onMessage(object);
        }
      } else if (object.id) {
        const callback = __classPrivateFieldGet(this, _Connection_callbacks, "f").get(object.id);
        if (callback) {
          __classPrivateFieldGet(this, _Connection_callbacks, "f").delete(object.id);
          if (object.error) {
            callback.reject(createProtocolError(callback.error, callback.method, object));
          } else {
            callback.resolve(object.result);
          }
        }
      } else {
        this.emit(object.method, object.params);
      }
    }
    dispose() {
      __classPrivateFieldGet(this, _Connection_instances, "m", _Connection_onClose).call(this);
      __classPrivateFieldGet(this, _Connection_transport, "f").close();
    }
    isAutoAttached(targetId) {
      return !__classPrivateFieldGet(this, _Connection_manuallyAttached, "f").has(targetId);
    }
    async _createSession(targetInfo, isAutoAttachEmulated = true) {
      if (!isAutoAttachEmulated) {
        __classPrivateFieldGet(this, _Connection_manuallyAttached, "f").add(targetInfo.targetId);
      }
      const { sessionId } = await this.send("Target.attachToTarget", {
        targetId: targetInfo.targetId,
        flatten: true
      });
      __classPrivateFieldGet(this, _Connection_manuallyAttached, "f").delete(targetInfo.targetId);
      const session = __classPrivateFieldGet(this, _Connection_sessions, "f").get(sessionId);
      if (!session) {
        throw new Error("CDPSession creation failed.");
      }
      return session;
    }
    async createSession(targetInfo) {
      return await this._createSession(targetInfo, false);
    }
  }
  exports.Connection = Connection;
  _Connection_url = new WeakMap, _Connection_transport = new WeakMap, _Connection_delay = new WeakMap, _Connection_lastId = new WeakMap, _Connection_sessions = new WeakMap, _Connection_closed = new WeakMap, _Connection_callbacks = new WeakMap, _Connection_manuallyAttached = new WeakMap, _Connection_instances = new WeakSet, _Connection_onClose = function _Connection_onClose() {
    if (__classPrivateFieldGet(this, _Connection_closed, "f")) {
      return;
    }
    __classPrivateFieldSet(this, _Connection_closed, true, "f");
    __classPrivateFieldGet(this, _Connection_transport, "f").onmessage = undefined;
    __classPrivateFieldGet(this, _Connection_transport, "f").onclose = undefined;
    for (const callback of __classPrivateFieldGet(this, _Connection_callbacks, "f").values()) {
      callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
    }
    __classPrivateFieldGet(this, _Connection_callbacks, "f").clear();
    for (const session of __classPrivateFieldGet(this, _Connection_sessions, "f").values()) {
      session._onClosed();
    }
    __classPrivateFieldGet(this, _Connection_sessions, "f").clear();
    this.emit(exports.ConnectionEmittedEvents.Disconnected);
  };
  exports.CDPSessionEmittedEvents = {
    Disconnected: Symbol("CDPSession.Disconnected")
  };

  class CDPSession extends EventEmitter_js_1.EventEmitter {
    constructor() {
      super();
    }
    connection() {
      throw new Error("Not implemented");
    }
    send() {
      throw new Error("Not implemented");
    }
    async detach() {
      throw new Error("Not implemented");
    }
    id() {
      throw new Error("Not implemented");
    }
  }
  exports.CDPSession = CDPSession;

  class CDPSessionImpl extends CDPSession {
    constructor(connection, targetType, sessionId) {
      super();
      _CDPSessionImpl_sessionId.set(this, undefined);
      _CDPSessionImpl_targetType.set(this, undefined);
      _CDPSessionImpl_callbacks.set(this, new Map);
      _CDPSessionImpl_connection.set(this, undefined);
      __classPrivateFieldSet(this, _CDPSessionImpl_connection, connection, "f");
      __classPrivateFieldSet(this, _CDPSessionImpl_targetType, targetType, "f");
      __classPrivateFieldSet(this, _CDPSessionImpl_sessionId, sessionId, "f");
    }
    connection() {
      return __classPrivateFieldGet(this, _CDPSessionImpl_connection, "f");
    }
    send(method, ...paramArgs) {
      if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, "f")) {
        return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, "f")} has been closed.`));
      }
      const params = paramArgs.length ? paramArgs[0] : undefined;
      const id = __classPrivateFieldGet(this, _CDPSessionImpl_connection, "f")._rawSend({
        sessionId: __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, "f"),
        method,
        params
      });
      return new Promise((resolve, reject) => {
        __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, "f").set(id, {
          resolve,
          reject,
          error: new Errors_js_1.ProtocolError,
          method
        });
      });
    }
    _onMessage(object) {
      const callback = object.id ? __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, "f").get(object.id) : undefined;
      if (object.id && callback) {
        __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, "f").delete(object.id);
        if (object.error) {
          callback.reject(createProtocolError(callback.error, callback.method, object));
        } else {
          callback.resolve(object.result);
        }
      } else {
        (0, assert_js_1.assert)(!object.id);
        this.emit(object.method, object.params);
      }
    }
    async detach() {
      if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, "f")) {
        throw new Error(`Session already detached. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, "f")} has been closed.`);
      }
      await __classPrivateFieldGet(this, _CDPSessionImpl_connection, "f").send("Target.detachFromTarget", {
        sessionId: __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, "f")
      });
    }
    _onClosed() {
      for (const callback of __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, "f").values()) {
        callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
      }
      __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, "f").clear();
      __classPrivateFieldSet(this, _CDPSessionImpl_connection, undefined, "f");
      this.emit(exports.CDPSessionEmittedEvents.Disconnected);
    }
    id() {
      return __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, "f");
    }
  }
  exports.CDPSessionImpl = CDPSessionImpl;
  _CDPSessionImpl_sessionId = new WeakMap, _CDPSessionImpl_targetType = new WeakMap, _CDPSessionImpl_callbacks = new WeakMap, _CDPSessionImpl_connection = new WeakMap;
  function createProtocolError(error, method, object) {
    let message = `Protocol error (${method}): ${object.error.message}`;
    if ("data" in object.error) {
      message += ` ${object.error.data}`;
    }
    return rewriteError(error, message, object.error.message);
  }
  function rewriteError(error, message, originalMessage) {
    error.message = message;
    error.originalMessage = originalMessage !== null && originalMessage !== undefined ? originalMessage : error.originalMessage;
    return error;
  }
  function isTargetClosedError(err) {
    return err.message.includes("Target closed") || err.message.includes("Session closed");
  }
  exports.isTargetClosedError = isTargetClosedError;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/ExecutionContext.js
var require_ExecutionContext = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ExecutionContext_instances;
  var _ExecutionContext_evaluate;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExecutionContext = exports.EVALUATION_SCRIPT_URL = undefined;
  var JSHandle_js_1 = require_JSHandle();
  var LazyArg_js_1 = require_LazyArg();
  var util_js_1 = require_util();
  exports.EVALUATION_SCRIPT_URL = "pptr://__puppeteer_evaluation_script__";
  var SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;

  class ExecutionContext {
    constructor(client, contextPayload, world) {
      _ExecutionContext_instances.add(this);
      this._client = client;
      this._world = world;
      this._contextId = contextPayload.id;
      this._contextName = contextPayload.name;
    }
    async evaluate(pageFunction, ...args) {
      return await __classPrivateFieldGet(this, _ExecutionContext_instances, "m", _ExecutionContext_evaluate).call(this, true, pageFunction, ...args);
    }
    async evaluateHandle(pageFunction, ...args) {
      return __classPrivateFieldGet(this, _ExecutionContext_instances, "m", _ExecutionContext_evaluate).call(this, false, pageFunction, ...args);
    }
  }
  exports.ExecutionContext = ExecutionContext;
  _ExecutionContext_instances = new WeakSet, _ExecutionContext_evaluate = async function _ExecutionContext_evaluate(returnByValue, pageFunction, ...args) {
    const suffix = `//# sourceURL=${exports.EVALUATION_SCRIPT_URL}`;
    if ((0, util_js_1.isString)(pageFunction)) {
      const contextId = this._contextId;
      const expression = pageFunction;
      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + `
` + suffix;
      const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = await this._client.send("Runtime.evaluate", {
        expression: expressionWithSourceUrl,
        contextId,
        returnByValue,
        awaitPromise: true,
        userGesture: true
      }).catch(rewriteError);
      if (exceptionDetails2) {
        throw new Error("Evaluation failed: " + (0, util_js_1.getExceptionMessage)(exceptionDetails2));
      }
      return returnByValue ? (0, util_js_1.valueFromRemoteObject)(remoteObject2) : (0, util_js_1.createJSHandle)(this, remoteObject2);
    }
    let functionText = pageFunction.toString();
    try {
      new Function("(" + functionText + ")");
    } catch (error) {
      if (functionText.startsWith("async ")) {
        functionText = "async function " + functionText.substring("async ".length);
      } else {
        functionText = "function " + functionText;
      }
      try {
        new Function("(" + functionText + ")");
      } catch (error2) {
        throw new Error("Passed function is not well-serializable!");
      }
    }
    let callFunctionOnPromise;
    try {
      callFunctionOnPromise = this._client.send("Runtime.callFunctionOn", {
        functionDeclaration: functionText + `
` + suffix + `
`,
        executionContextId: this._contextId,
        arguments: await Promise.all(args.map(convertArgument.bind(this))),
        returnByValue,
        awaitPromise: true,
        userGesture: true
      });
    } catch (error) {
      if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
        error.message += " Recursive objects are not allowed.";
      }
      throw error;
    }
    const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
    if (exceptionDetails) {
      throw new Error("Evaluation failed: " + (0, util_js_1.getExceptionMessage)(exceptionDetails));
    }
    return returnByValue ? (0, util_js_1.valueFromRemoteObject)(remoteObject) : (0, util_js_1.createJSHandle)(this, remoteObject);
    async function convertArgument(arg) {
      if (arg instanceof LazyArg_js_1.LazyArg) {
        arg = await arg.get();
      }
      if (typeof arg === "bigint") {
        return { unserializableValue: `${arg.toString()}n` };
      }
      if (Object.is(arg, -0)) {
        return { unserializableValue: "-0" };
      }
      if (Object.is(arg, Infinity)) {
        return { unserializableValue: "Infinity" };
      }
      if (Object.is(arg, -Infinity)) {
        return { unserializableValue: "-Infinity" };
      }
      if (Object.is(arg, NaN)) {
        return { unserializableValue: "NaN" };
      }
      const objectHandle = arg && arg instanceof JSHandle_js_1.JSHandle ? arg : null;
      if (objectHandle) {
        if (objectHandle.executionContext() !== this) {
          throw new Error("JSHandles can be evaluated only in the context they were created!");
        }
        if (objectHandle.disposed) {
          throw new Error("JSHandle is disposed!");
        }
        if (objectHandle.remoteObject().unserializableValue) {
          return {
            unserializableValue: objectHandle.remoteObject().unserializableValue
          };
        }
        if (!objectHandle.remoteObject().objectId) {
          return { value: objectHandle.remoteObject().value };
        }
        return { objectId: objectHandle.remoteObject().objectId };
      }
      return { value: arg };
    }
  };
  var rewriteError = (error) => {
    if (error.message.includes("Object reference chain is too long")) {
      return { result: { type: "undefined" } };
    }
    if (error.message.includes("Object couldn't be returned by value")) {
      return { result: { type: "undefined" } };
    }
    if (error.message.endsWith("Cannot find context with specified id") || error.message.endsWith("Inspected target navigated or closed")) {
      throw new Error("Execution context was destroyed, most likely because of a navigation.");
    }
    throw error;
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/FrameTree.js
var require_FrameTree = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _FrameTree_frames;
  var _FrameTree_parentIds;
  var _FrameTree_childIds;
  var _FrameTree_mainFrame;
  var _FrameTree_waitRequests;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FrameTree = undefined;
  var DeferredPromise_js_1 = require_DeferredPromise();

  class FrameTree {
    constructor() {
      _FrameTree_frames.set(this, new Map);
      _FrameTree_parentIds.set(this, new Map);
      _FrameTree_childIds.set(this, new Map);
      _FrameTree_mainFrame.set(this, undefined);
      _FrameTree_waitRequests.set(this, new Map);
    }
    getMainFrame() {
      return __classPrivateFieldGet(this, _FrameTree_mainFrame, "f");
    }
    getById(frameId) {
      return __classPrivateFieldGet(this, _FrameTree_frames, "f").get(frameId);
    }
    waitForFrame(frameId) {
      const frame = this.getById(frameId);
      if (frame) {
        return Promise.resolve(frame);
      }
      const deferred = (0, DeferredPromise_js_1.createDeferredPromise)();
      const callbacks = __classPrivateFieldGet(this, _FrameTree_waitRequests, "f").get(frameId) || new Set;
      callbacks.add(deferred);
      return deferred;
    }
    frames() {
      return Array.from(__classPrivateFieldGet(this, _FrameTree_frames, "f").values());
    }
    addFrame(frame) {
      var _a;
      __classPrivateFieldGet(this, _FrameTree_frames, "f").set(frame._id, frame);
      if (frame._parentId) {
        __classPrivateFieldGet(this, _FrameTree_parentIds, "f").set(frame._id, frame._parentId);
        if (!__classPrivateFieldGet(this, _FrameTree_childIds, "f").has(frame._parentId)) {
          __classPrivateFieldGet(this, _FrameTree_childIds, "f").set(frame._parentId, new Set);
        }
        __classPrivateFieldGet(this, _FrameTree_childIds, "f").get(frame._parentId).add(frame._id);
      } else {
        __classPrivateFieldSet(this, _FrameTree_mainFrame, frame, "f");
      }
      (_a = __classPrivateFieldGet(this, _FrameTree_waitRequests, "f").get(frame._id)) === null || _a === undefined || _a.forEach((request) => {
        return request.resolve(frame);
      });
    }
    removeFrame(frame) {
      var _a;
      __classPrivateFieldGet(this, _FrameTree_frames, "f").delete(frame._id);
      __classPrivateFieldGet(this, _FrameTree_parentIds, "f").delete(frame._id);
      if (frame._parentId) {
        (_a = __classPrivateFieldGet(this, _FrameTree_childIds, "f").get(frame._parentId)) === null || _a === undefined || _a.delete(frame._id);
      } else {
        __classPrivateFieldSet(this, _FrameTree_mainFrame, undefined, "f");
      }
    }
    childFrames(frameId) {
      const childIds = __classPrivateFieldGet(this, _FrameTree_childIds, "f").get(frameId);
      if (!childIds) {
        return [];
      }
      return Array.from(childIds).map((id) => {
        return this.getById(id);
      }).filter((frame) => {
        return frame !== undefined;
      });
    }
    parentFrame(frameId) {
      const parentId = __classPrivateFieldGet(this, _FrameTree_parentIds, "f").get(frameId);
      return parentId ? this.getById(parentId) : undefined;
    }
  }
  exports.FrameTree = FrameTree;
  _FrameTree_frames = new WeakMap, _FrameTree_parentIds = new WeakMap, _FrameTree_childIds = new WeakMap, _FrameTree_mainFrame = new WeakMap, _FrameTree_waitRequests = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/HTTPRequest.js
var require_HTTPRequest = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _HTTPRequest_instances;
  var _HTTPRequest_client;
  var _HTTPRequest_isNavigationRequest;
  var _HTTPRequest_allowInterception;
  var _HTTPRequest_interceptionHandled;
  var _HTTPRequest_url;
  var _HTTPRequest_resourceType;
  var _HTTPRequest_method;
  var _HTTPRequest_postData;
  var _HTTPRequest_headers;
  var _HTTPRequest_frame;
  var _HTTPRequest_continueRequestOverrides;
  var _HTTPRequest_responseForRequest;
  var _HTTPRequest_abortErrorReason;
  var _HTTPRequest_interceptResolutionState;
  var _HTTPRequest_interceptHandlers;
  var _HTTPRequest_initiator;
  var _HTTPRequest_continue;
  var _HTTPRequest_respond;
  var _HTTPRequest_abort;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InterceptResolutionAction = exports.HTTPRequest = exports.DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = undefined;
  var assert_js_1 = require_assert();
  var util_js_1 = require_util();
  exports.DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = 0;

  class HTTPRequest {
    constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {
      _HTTPRequest_instances.add(this);
      this._failureText = null;
      this._response = null;
      this._fromMemoryCache = false;
      _HTTPRequest_client.set(this, undefined);
      _HTTPRequest_isNavigationRequest.set(this, undefined);
      _HTTPRequest_allowInterception.set(this, undefined);
      _HTTPRequest_interceptionHandled.set(this, false);
      _HTTPRequest_url.set(this, undefined);
      _HTTPRequest_resourceType.set(this, undefined);
      _HTTPRequest_method.set(this, undefined);
      _HTTPRequest_postData.set(this, undefined);
      _HTTPRequest_headers.set(this, {});
      _HTTPRequest_frame.set(this, undefined);
      _HTTPRequest_continueRequestOverrides.set(this, undefined);
      _HTTPRequest_responseForRequest.set(this, null);
      _HTTPRequest_abortErrorReason.set(this, null);
      _HTTPRequest_interceptResolutionState.set(this, {
        action: InterceptResolutionAction.None
      });
      _HTTPRequest_interceptHandlers.set(this, undefined);
      _HTTPRequest_initiator.set(this, undefined);
      __classPrivateFieldSet(this, _HTTPRequest_client, client, "f");
      this._requestId = event.requestId;
      __classPrivateFieldSet(this, _HTTPRequest_isNavigationRequest, event.requestId === event.loaderId && event.type === "Document", "f");
      this._interceptionId = interceptionId;
      __classPrivateFieldSet(this, _HTTPRequest_allowInterception, allowInterception, "f");
      __classPrivateFieldSet(this, _HTTPRequest_url, event.request.url, "f");
      __classPrivateFieldSet(this, _HTTPRequest_resourceType, (event.type || "other").toLowerCase(), "f");
      __classPrivateFieldSet(this, _HTTPRequest_method, event.request.method, "f");
      __classPrivateFieldSet(this, _HTTPRequest_postData, event.request.postData, "f");
      __classPrivateFieldSet(this, _HTTPRequest_frame, frame, "f");
      this._redirectChain = redirectChain;
      __classPrivateFieldSet(this, _HTTPRequest_continueRequestOverrides, {}, "f");
      __classPrivateFieldSet(this, _HTTPRequest_interceptHandlers, [], "f");
      __classPrivateFieldSet(this, _HTTPRequest_initiator, event.initiator, "f");
      for (const [key2, value] of Object.entries(event.request.headers)) {
        __classPrivateFieldGet(this, _HTTPRequest_headers, "f")[key2.toLowerCase()] = value;
      }
    }
    get client() {
      return __classPrivateFieldGet(this, _HTTPRequest_client, "f");
    }
    url() {
      return __classPrivateFieldGet(this, _HTTPRequest_url, "f");
    }
    continueRequestOverrides() {
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
      return __classPrivateFieldGet(this, _HTTPRequest_continueRequestOverrides, "f");
    }
    responseForRequest() {
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
      return __classPrivateFieldGet(this, _HTTPRequest_responseForRequest, "f");
    }
    abortErrorReason() {
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
      return __classPrivateFieldGet(this, _HTTPRequest_abortErrorReason, "f");
    }
    interceptResolutionState() {
      if (!__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f")) {
        return { action: InterceptResolutionAction.Disabled };
      }
      if (__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, "f")) {
        return { action: InterceptResolutionAction.AlreadyHandled };
      }
      return { ...__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f") };
    }
    isInterceptResolutionHandled() {
      return __classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, "f");
    }
    enqueueInterceptAction(pendingHandler) {
      __classPrivateFieldGet(this, _HTTPRequest_interceptHandlers, "f").push(pendingHandler);
    }
    async finalizeInterceptions() {
      await __classPrivateFieldGet(this, _HTTPRequest_interceptHandlers, "f").reduce((promiseChain, interceptAction) => {
        return promiseChain.then(interceptAction);
      }, Promise.resolve());
      const { action } = this.interceptResolutionState();
      switch (action) {
        case "abort":
          return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_abort).call(this, __classPrivateFieldGet(this, _HTTPRequest_abortErrorReason, "f"));
        case "respond":
          if (__classPrivateFieldGet(this, _HTTPRequest_responseForRequest, "f") === null) {
            throw new Error("Response is missing for the interception");
          }
          return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_respond).call(this, __classPrivateFieldGet(this, _HTTPRequest_responseForRequest, "f"));
        case "continue":
          return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_continue).call(this, __classPrivateFieldGet(this, _HTTPRequest_continueRequestOverrides, "f"));
      }
    }
    resourceType() {
      return __classPrivateFieldGet(this, _HTTPRequest_resourceType, "f");
    }
    method() {
      return __classPrivateFieldGet(this, _HTTPRequest_method, "f");
    }
    postData() {
      return __classPrivateFieldGet(this, _HTTPRequest_postData, "f");
    }
    headers() {
      return __classPrivateFieldGet(this, _HTTPRequest_headers, "f");
    }
    response() {
      return this._response;
    }
    frame() {
      return __classPrivateFieldGet(this, _HTTPRequest_frame, "f");
    }
    isNavigationRequest() {
      return __classPrivateFieldGet(this, _HTTPRequest_isNavigationRequest, "f");
    }
    initiator() {
      return __classPrivateFieldGet(this, _HTTPRequest_initiator, "f");
    }
    redirectChain() {
      return this._redirectChain.slice();
    }
    failure() {
      if (!this._failureText) {
        return null;
      }
      return {
        errorText: this._failureText
      };
    }
    async continue(overrides = {}, priority) {
      if (__classPrivateFieldGet(this, _HTTPRequest_url, "f").startsWith("data:")) {
        return;
      }
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, "f"), "Request is already handled!");
      if (priority === undefined) {
        return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_continue).call(this, overrides);
      }
      __classPrivateFieldSet(this, _HTTPRequest_continueRequestOverrides, overrides, "f");
      if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority === undefined || priority > __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority) {
        __classPrivateFieldSet(this, _HTTPRequest_interceptResolutionState, {
          action: InterceptResolutionAction.Continue,
          priority
        }, "f");
        return;
      }
      if (priority === __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority) {
        if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").action === "abort" || __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").action === "respond") {
          return;
        }
        __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").action = InterceptResolutionAction.Continue;
      }
      return;
    }
    async respond(response, priority) {
      if (__classPrivateFieldGet(this, _HTTPRequest_url, "f").startsWith("data:")) {
        return;
      }
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, "f"), "Request is already handled!");
      if (priority === undefined) {
        return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_respond).call(this, response);
      }
      __classPrivateFieldSet(this, _HTTPRequest_responseForRequest, response, "f");
      if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority === undefined || priority > __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority) {
        __classPrivateFieldSet(this, _HTTPRequest_interceptResolutionState, {
          action: InterceptResolutionAction.Respond,
          priority
        }, "f");
        return;
      }
      if (priority === __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority) {
        if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").action === "abort") {
          return;
        }
        __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").action = InterceptResolutionAction.Respond;
      }
    }
    async abort(errorCode = "failed", priority) {
      if (__classPrivateFieldGet(this, _HTTPRequest_url, "f").startsWith("data:")) {
        return;
      }
      const errorReason = errorReasons[errorCode];
      (0, assert_js_1.assert)(errorReason, "Unknown error code: " + errorCode);
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, "f"), "Request is already handled!");
      if (priority === undefined) {
        return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_abort).call(this, errorReason);
      }
      __classPrivateFieldSet(this, _HTTPRequest_abortErrorReason, errorReason, "f");
      if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority === undefined || priority >= __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority) {
        __classPrivateFieldSet(this, _HTTPRequest_interceptResolutionState, {
          action: InterceptResolutionAction.Abort,
          priority
        }, "f");
        return;
      }
    }
  }
  exports.HTTPRequest = HTTPRequest;
  _HTTPRequest_client = new WeakMap, _HTTPRequest_isNavigationRequest = new WeakMap, _HTTPRequest_allowInterception = new WeakMap, _HTTPRequest_interceptionHandled = new WeakMap, _HTTPRequest_url = new WeakMap, _HTTPRequest_resourceType = new WeakMap, _HTTPRequest_method = new WeakMap, _HTTPRequest_postData = new WeakMap, _HTTPRequest_headers = new WeakMap, _HTTPRequest_frame = new WeakMap, _HTTPRequest_continueRequestOverrides = new WeakMap, _HTTPRequest_responseForRequest = new WeakMap, _HTTPRequest_abortErrorReason = new WeakMap, _HTTPRequest_interceptResolutionState = new WeakMap, _HTTPRequest_interceptHandlers = new WeakMap, _HTTPRequest_initiator = new WeakMap, _HTTPRequest_instances = new WeakSet, _HTTPRequest_continue = async function _HTTPRequest_continue(overrides = {}) {
    const { url, method, postData, headers } = overrides;
    __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, true, "f");
    const postDataBinaryBase64 = postData ? Buffer.from(postData).toString("base64") : undefined;
    if (this._interceptionId === undefined) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
    }
    await __classPrivateFieldGet(this, _HTTPRequest_client, "f").send("Fetch.continueRequest", {
      requestId: this._interceptionId,
      url,
      method,
      postData: postDataBinaryBase64,
      headers: headers ? headersArray(headers) : undefined
    }).catch((error) => {
      __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, false, "f");
      return handleError(error);
    });
  }, _HTTPRequest_respond = async function _HTTPRequest_respond(response) {
    __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, true, "f");
    const responseBody = response.body && (0, util_js_1.isString)(response.body) ? Buffer.from(response.body) : response.body || null;
    const responseHeaders = {};
    if (response.headers) {
      for (const header of Object.keys(response.headers)) {
        const value = response.headers[header];
        responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map((item) => {
          return String(item);
        }) : String(value);
      }
    }
    if (response.contentType) {
      responseHeaders["content-type"] = response.contentType;
    }
    if (responseBody && !("content-length" in responseHeaders)) {
      responseHeaders["content-length"] = String(Buffer.byteLength(responseBody));
    }
    const status = response.status || 200;
    if (this._interceptionId === undefined) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
    }
    await __classPrivateFieldGet(this, _HTTPRequest_client, "f").send("Fetch.fulfillRequest", {
      requestId: this._interceptionId,
      responseCode: status,
      responsePhrase: STATUS_TEXTS[status],
      responseHeaders: headersArray(responseHeaders),
      body: responseBody ? responseBody.toString("base64") : undefined
    }).catch((error) => {
      __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, false, "f");
      return handleError(error);
    });
  }, _HTTPRequest_abort = async function _HTTPRequest_abort(errorReason) {
    __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, true, "f");
    if (this._interceptionId === undefined) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
    }
    await __classPrivateFieldGet(this, _HTTPRequest_client, "f").send("Fetch.failRequest", {
      requestId: this._interceptionId,
      errorReason: errorReason || "Failed"
    }).catch(handleError);
  };
  var InterceptResolutionAction;
  (function(InterceptResolutionAction2) {
    InterceptResolutionAction2["Abort"] = "abort";
    InterceptResolutionAction2["Respond"] = "respond";
    InterceptResolutionAction2["Continue"] = "continue";
    InterceptResolutionAction2["Disabled"] = "disabled";
    InterceptResolutionAction2["None"] = "none";
    InterceptResolutionAction2["AlreadyHandled"] = "already-handled";
  })(InterceptResolutionAction = exports.InterceptResolutionAction || (exports.InterceptResolutionAction = {}));
  var errorReasons = {
    aborted: "Aborted",
    accessdenied: "AccessDenied",
    addressunreachable: "AddressUnreachable",
    blockedbyclient: "BlockedByClient",
    blockedbyresponse: "BlockedByResponse",
    connectionaborted: "ConnectionAborted",
    connectionclosed: "ConnectionClosed",
    connectionfailed: "ConnectionFailed",
    connectionrefused: "ConnectionRefused",
    connectionreset: "ConnectionReset",
    internetdisconnected: "InternetDisconnected",
    namenotresolved: "NameNotResolved",
    timedout: "TimedOut",
    failed: "Failed"
  };
  function headersArray(headers) {
    const result = [];
    for (const name in headers) {
      const value = headers[name];
      if (!Object.is(value, undefined)) {
        const values = Array.isArray(value) ? value : [value];
        result.push(...values.map((value2) => {
          return { name, value: value2 + "" };
        }));
      }
    }
    return result;
  }
  async function handleError(error) {
    if (["Invalid header"].includes(error.originalMessage)) {
      throw error;
    }
    (0, util_js_1.debugError)(error);
  }
  var STATUS_TEXTS = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "103": "Early Hints",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "306": "Switch Proxy",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Too Early",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/SecurityDetails.js
var require_SecurityDetails = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _SecurityDetails_subjectName;
  var _SecurityDetails_issuer;
  var _SecurityDetails_validFrom;
  var _SecurityDetails_validTo;
  var _SecurityDetails_protocol;
  var _SecurityDetails_sanList;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SecurityDetails = undefined;

  class SecurityDetails {
    constructor(securityPayload) {
      _SecurityDetails_subjectName.set(this, undefined);
      _SecurityDetails_issuer.set(this, undefined);
      _SecurityDetails_validFrom.set(this, undefined);
      _SecurityDetails_validTo.set(this, undefined);
      _SecurityDetails_protocol.set(this, undefined);
      _SecurityDetails_sanList.set(this, undefined);
      __classPrivateFieldSet(this, _SecurityDetails_subjectName, securityPayload.subjectName, "f");
      __classPrivateFieldSet(this, _SecurityDetails_issuer, securityPayload.issuer, "f");
      __classPrivateFieldSet(this, _SecurityDetails_validFrom, securityPayload.validFrom, "f");
      __classPrivateFieldSet(this, _SecurityDetails_validTo, securityPayload.validTo, "f");
      __classPrivateFieldSet(this, _SecurityDetails_protocol, securityPayload.protocol, "f");
      __classPrivateFieldSet(this, _SecurityDetails_sanList, securityPayload.sanList, "f");
    }
    issuer() {
      return __classPrivateFieldGet(this, _SecurityDetails_issuer, "f");
    }
    validFrom() {
      return __classPrivateFieldGet(this, _SecurityDetails_validFrom, "f");
    }
    validTo() {
      return __classPrivateFieldGet(this, _SecurityDetails_validTo, "f");
    }
    protocol() {
      return __classPrivateFieldGet(this, _SecurityDetails_protocol, "f");
    }
    subjectName() {
      return __classPrivateFieldGet(this, _SecurityDetails_subjectName, "f");
    }
    subjectAlternativeNames() {
      return __classPrivateFieldGet(this, _SecurityDetails_sanList, "f");
    }
  }
  exports.SecurityDetails = SecurityDetails;
  _SecurityDetails_subjectName = new WeakMap, _SecurityDetails_issuer = new WeakMap, _SecurityDetails_validFrom = new WeakMap, _SecurityDetails_validTo = new WeakMap, _SecurityDetails_protocol = new WeakMap, _SecurityDetails_sanList = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/HTTPResponse.js
var require_HTTPResponse = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _HTTPResponse_instances;
  var _HTTPResponse_client;
  var _HTTPResponse_request;
  var _HTTPResponse_contentPromise;
  var _HTTPResponse_bodyLoadedPromise;
  var _HTTPResponse_bodyLoadedPromiseFulfill;
  var _HTTPResponse_remoteAddress;
  var _HTTPResponse_status;
  var _HTTPResponse_statusText;
  var _HTTPResponse_url;
  var _HTTPResponse_fromDiskCache;
  var _HTTPResponse_fromServiceWorker;
  var _HTTPResponse_headers;
  var _HTTPResponse_securityDetails;
  var _HTTPResponse_timing;
  var _HTTPResponse_parseStatusTextFromExtrInfo;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTTPResponse = undefined;
  var SecurityDetails_js_1 = require_SecurityDetails();
  var Errors_js_1 = require_Errors();

  class HTTPResponse {
    constructor(client, request, responsePayload, extraInfo) {
      _HTTPResponse_instances.add(this);
      _HTTPResponse_client.set(this, undefined);
      _HTTPResponse_request.set(this, undefined);
      _HTTPResponse_contentPromise.set(this, null);
      _HTTPResponse_bodyLoadedPromise.set(this, undefined);
      _HTTPResponse_bodyLoadedPromiseFulfill.set(this, () => {});
      _HTTPResponse_remoteAddress.set(this, undefined);
      _HTTPResponse_status.set(this, undefined);
      _HTTPResponse_statusText.set(this, undefined);
      _HTTPResponse_url.set(this, undefined);
      _HTTPResponse_fromDiskCache.set(this, undefined);
      _HTTPResponse_fromServiceWorker.set(this, undefined);
      _HTTPResponse_headers.set(this, {});
      _HTTPResponse_securityDetails.set(this, undefined);
      _HTTPResponse_timing.set(this, undefined);
      __classPrivateFieldSet(this, _HTTPResponse_client, client, "f");
      __classPrivateFieldSet(this, _HTTPResponse_request, request, "f");
      __classPrivateFieldSet(this, _HTTPResponse_bodyLoadedPromise, new Promise((fulfill) => {
        __classPrivateFieldSet(this, _HTTPResponse_bodyLoadedPromiseFulfill, fulfill, "f");
      }), "f");
      __classPrivateFieldSet(this, _HTTPResponse_remoteAddress, {
        ip: responsePayload.remoteIPAddress,
        port: responsePayload.remotePort
      }, "f");
      __classPrivateFieldSet(this, _HTTPResponse_statusText, __classPrivateFieldGet(this, _HTTPResponse_instances, "m", _HTTPResponse_parseStatusTextFromExtrInfo).call(this, extraInfo) || responsePayload.statusText, "f");
      __classPrivateFieldSet(this, _HTTPResponse_url, request.url(), "f");
      __classPrivateFieldSet(this, _HTTPResponse_fromDiskCache, !!responsePayload.fromDiskCache, "f");
      __classPrivateFieldSet(this, _HTTPResponse_fromServiceWorker, !!responsePayload.fromServiceWorker, "f");
      __classPrivateFieldSet(this, _HTTPResponse_status, extraInfo ? extraInfo.statusCode : responsePayload.status, "f");
      const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
      for (const [key2, value] of Object.entries(headers)) {
        __classPrivateFieldGet(this, _HTTPResponse_headers, "f")[key2.toLowerCase()] = value;
      }
      __classPrivateFieldSet(this, _HTTPResponse_securityDetails, responsePayload.securityDetails ? new SecurityDetails_js_1.SecurityDetails(responsePayload.securityDetails) : null, "f");
      __classPrivateFieldSet(this, _HTTPResponse_timing, responsePayload.timing || null, "f");
    }
    _resolveBody(err) {
      if (err) {
        return __classPrivateFieldGet(this, _HTTPResponse_bodyLoadedPromiseFulfill, "f").call(this, err);
      }
      return __classPrivateFieldGet(this, _HTTPResponse_bodyLoadedPromiseFulfill, "f").call(this);
    }
    remoteAddress() {
      return __classPrivateFieldGet(this, _HTTPResponse_remoteAddress, "f");
    }
    url() {
      return __classPrivateFieldGet(this, _HTTPResponse_url, "f");
    }
    ok() {
      return __classPrivateFieldGet(this, _HTTPResponse_status, "f") === 0 || __classPrivateFieldGet(this, _HTTPResponse_status, "f") >= 200 && __classPrivateFieldGet(this, _HTTPResponse_status, "f") <= 299;
    }
    status() {
      return __classPrivateFieldGet(this, _HTTPResponse_status, "f");
    }
    statusText() {
      return __classPrivateFieldGet(this, _HTTPResponse_statusText, "f");
    }
    headers() {
      return __classPrivateFieldGet(this, _HTTPResponse_headers, "f");
    }
    securityDetails() {
      return __classPrivateFieldGet(this, _HTTPResponse_securityDetails, "f");
    }
    timing() {
      return __classPrivateFieldGet(this, _HTTPResponse_timing, "f");
    }
    buffer() {
      if (!__classPrivateFieldGet(this, _HTTPResponse_contentPromise, "f")) {
        __classPrivateFieldSet(this, _HTTPResponse_contentPromise, __classPrivateFieldGet(this, _HTTPResponse_bodyLoadedPromise, "f").then(async (error) => {
          if (error) {
            throw error;
          }
          try {
            const response = await __classPrivateFieldGet(this, _HTTPResponse_client, "f").send("Network.getResponseBody", {
              requestId: __classPrivateFieldGet(this, _HTTPResponse_request, "f")._requestId
            });
            return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
          } catch (error2) {
            if (error2 instanceof Errors_js_1.ProtocolError && error2.originalMessage === "No resource with given identifier found") {
              throw new Errors_js_1.ProtocolError("Could not load body for this request. This might happen if the request is a preflight request.");
            }
            throw error2;
          }
        }), "f");
      }
      return __classPrivateFieldGet(this, _HTTPResponse_contentPromise, "f");
    }
    async text() {
      const content = await this.buffer();
      return content.toString("utf8");
    }
    async json() {
      const content = await this.text();
      return JSON.parse(content);
    }
    request() {
      return __classPrivateFieldGet(this, _HTTPResponse_request, "f");
    }
    fromCache() {
      return __classPrivateFieldGet(this, _HTTPResponse_fromDiskCache, "f") || __classPrivateFieldGet(this, _HTTPResponse_request, "f")._fromMemoryCache;
    }
    fromServiceWorker() {
      return __classPrivateFieldGet(this, _HTTPResponse_fromServiceWorker, "f");
    }
    frame() {
      return __classPrivateFieldGet(this, _HTTPResponse_request, "f").frame();
    }
  }
  exports.HTTPResponse = HTTPResponse;
  _HTTPResponse_client = new WeakMap, _HTTPResponse_request = new WeakMap, _HTTPResponse_contentPromise = new WeakMap, _HTTPResponse_bodyLoadedPromise = new WeakMap, _HTTPResponse_bodyLoadedPromiseFulfill = new WeakMap, _HTTPResponse_remoteAddress = new WeakMap, _HTTPResponse_status = new WeakMap, _HTTPResponse_statusText = new WeakMap, _HTTPResponse_url = new WeakMap, _HTTPResponse_fromDiskCache = new WeakMap, _HTTPResponse_fromServiceWorker = new WeakMap, _HTTPResponse_headers = new WeakMap, _HTTPResponse_securityDetails = new WeakMap, _HTTPResponse_timing = new WeakMap, _HTTPResponse_instances = new WeakSet, _HTTPResponse_parseStatusTextFromExtrInfo = function _HTTPResponse_parseStatusTextFromExtrInfo(extraInfo) {
    if (!extraInfo || !extraInfo.headersText) {
      return;
    }
    const firstLine = extraInfo.headersText.split("\r", 1)[0];
    if (!firstLine) {
      return;
    }
    const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
    if (!match) {
      return;
    }
    const statusText = match[1];
    if (!statusText) {
      return;
    }
    return statusText;
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/NetworkEventManager.js
var require_NetworkEventManager = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _NetworkEventManager_requestWillBeSentMap;
  var _NetworkEventManager_requestPausedMap;
  var _NetworkEventManager_httpRequestsMap;
  var _NetworkEventManager_responseReceivedExtraInfoMap;
  var _NetworkEventManager_queuedRedirectInfoMap;
  var _NetworkEventManager_queuedEventGroupMap;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NetworkEventManager = undefined;

  class NetworkEventManager {
    constructor() {
      _NetworkEventManager_requestWillBeSentMap.set(this, new Map);
      _NetworkEventManager_requestPausedMap.set(this, new Map);
      _NetworkEventManager_httpRequestsMap.set(this, new Map);
      _NetworkEventManager_responseReceivedExtraInfoMap.set(this, new Map);
      _NetworkEventManager_queuedRedirectInfoMap.set(this, new Map);
      _NetworkEventManager_queuedEventGroupMap.set(this, new Map);
    }
    forget(networkRequestId) {
      __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, "f").delete(networkRequestId);
      __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, "f").delete(networkRequestId);
      __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, "f").delete(networkRequestId);
      __classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, "f").delete(networkRequestId);
      __classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").delete(networkRequestId);
    }
    responseExtraInfo(networkRequestId) {
      if (!__classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").has(networkRequestId)) {
        __classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").set(networkRequestId, []);
      }
      return __classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").get(networkRequestId);
    }
    queuedRedirectInfo(fetchRequestId) {
      if (!__classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, "f").has(fetchRequestId)) {
        __classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, "f").set(fetchRequestId, []);
      }
      return __classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, "f").get(fetchRequestId);
    }
    queueRedirectInfo(fetchRequestId, redirectInfo) {
      this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
    }
    takeQueuedRedirectInfo(fetchRequestId) {
      return this.queuedRedirectInfo(fetchRequestId).shift();
    }
    numRequestsInProgress() {
      return [...__classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, "f")].filter(([, request]) => {
        return !request.response();
      }).length;
    }
    storeRequestWillBeSent(networkRequestId, event) {
      __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, "f").set(networkRequestId, event);
    }
    getRequestWillBeSent(networkRequestId) {
      return __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, "f").get(networkRequestId);
    }
    forgetRequestWillBeSent(networkRequestId) {
      __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, "f").delete(networkRequestId);
    }
    getRequestPaused(networkRequestId) {
      return __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, "f").get(networkRequestId);
    }
    forgetRequestPaused(networkRequestId) {
      __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, "f").delete(networkRequestId);
    }
    storeRequestPaused(networkRequestId, event) {
      __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, "f").set(networkRequestId, event);
    }
    getRequest(networkRequestId) {
      return __classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, "f").get(networkRequestId);
    }
    storeRequest(networkRequestId, request) {
      __classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, "f").set(networkRequestId, request);
    }
    forgetRequest(networkRequestId) {
      __classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, "f").delete(networkRequestId);
    }
    getQueuedEventGroup(networkRequestId) {
      return __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, "f").get(networkRequestId);
    }
    queueEventGroup(networkRequestId, event) {
      __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, "f").set(networkRequestId, event);
    }
    forgetQueuedEventGroup(networkRequestId) {
      __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, "f").delete(networkRequestId);
    }
  }
  exports.NetworkEventManager = NetworkEventManager;
  _NetworkEventManager_requestWillBeSentMap = new WeakMap, _NetworkEventManager_requestPausedMap = new WeakMap, _NetworkEventManager_httpRequestsMap = new WeakMap, _NetworkEventManager_responseReceivedExtraInfoMap = new WeakMap, _NetworkEventManager_queuedRedirectInfoMap = new WeakMap, _NetworkEventManager_queuedEventGroupMap = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/DebuggableDeferredPromise.js
var require_DebuggableDeferredPromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDebuggableDeferredPromise = undefined;
  var environment_js_1 = require_environment();
  var DeferredPromise_js_1 = require_DeferredPromise();
  function createDebuggableDeferredPromise(message) {
    if (environment_js_1.DEFERRED_PROMISE_DEBUG_TIMEOUT > 0) {
      return (0, DeferredPromise_js_1.createDeferredPromise)({
        message,
        timeout: environment_js_1.DEFERRED_PROMISE_DEBUG_TIMEOUT
      });
    }
    return (0, DeferredPromise_js_1.createDeferredPromise)();
  }
  exports.createDebuggableDeferredPromise = createDebuggableDeferredPromise;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/NetworkManager.js
var require_NetworkManager = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _NetworkManager_instances;
  var _NetworkManager_client;
  var _NetworkManager_ignoreHTTPSErrors;
  var _NetworkManager_frameManager;
  var _NetworkManager_networkEventManager;
  var _NetworkManager_extraHTTPHeaders;
  var _NetworkManager_credentials;
  var _NetworkManager_attemptedAuthentications;
  var _NetworkManager_userRequestInterceptionEnabled;
  var _NetworkManager_protocolRequestInterceptionEnabled;
  var _NetworkManager_userCacheDisabled;
  var _NetworkManager_emulatedNetworkConditions;
  var _NetworkManager_deferredInitPromise;
  var _NetworkManager_updateNetworkConditions;
  var _NetworkManager_updateProtocolRequestInterception;
  var _NetworkManager_cacheDisabled;
  var _NetworkManager_updateProtocolCacheDisabled;
  var _NetworkManager_onRequestWillBeSent;
  var _NetworkManager_onAuthRequired;
  var _NetworkManager_onRequestPaused;
  var _NetworkManager_patchRequestEventHeaders;
  var _NetworkManager_onRequest;
  var _NetworkManager_onRequestServedFromCache;
  var _NetworkManager_handleRequestRedirect;
  var _NetworkManager_emitResponseEvent;
  var _NetworkManager_onResponseReceived;
  var _NetworkManager_onResponseReceivedExtraInfo;
  var _NetworkManager_forgetRequest;
  var _NetworkManager_onLoadingFinished;
  var _NetworkManager_emitLoadingFinished;
  var _NetworkManager_onLoadingFailed;
  var _NetworkManager_emitLoadingFailed;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NetworkManager = exports.NetworkManagerEmittedEvents = undefined;
  var assert_js_1 = require_assert();
  var EventEmitter_js_1 = require_EventEmitter();
  var HTTPRequest_js_1 = require_HTTPRequest();
  var HTTPResponse_js_1 = require_HTTPResponse();
  var NetworkEventManager_js_1 = require_NetworkEventManager();
  var util_js_1 = require_util();
  var DebuggableDeferredPromise_js_1 = require_DebuggableDeferredPromise();
  exports.NetworkManagerEmittedEvents = {
    Request: Symbol("NetworkManager.Request"),
    RequestServedFromCache: Symbol("NetworkManager.RequestServedFromCache"),
    Response: Symbol("NetworkManager.Response"),
    RequestFailed: Symbol("NetworkManager.RequestFailed"),
    RequestFinished: Symbol("NetworkManager.RequestFinished")
  };

  class NetworkManager extends EventEmitter_js_1.EventEmitter {
    constructor(client, ignoreHTTPSErrors, frameManager) {
      super();
      _NetworkManager_instances.add(this);
      _NetworkManager_client.set(this, undefined);
      _NetworkManager_ignoreHTTPSErrors.set(this, undefined);
      _NetworkManager_frameManager.set(this, undefined);
      _NetworkManager_networkEventManager.set(this, new NetworkEventManager_js_1.NetworkEventManager);
      _NetworkManager_extraHTTPHeaders.set(this, {});
      _NetworkManager_credentials.set(this, undefined);
      _NetworkManager_attemptedAuthentications.set(this, new Set);
      _NetworkManager_userRequestInterceptionEnabled.set(this, false);
      _NetworkManager_protocolRequestInterceptionEnabled.set(this, false);
      _NetworkManager_userCacheDisabled.set(this, false);
      _NetworkManager_emulatedNetworkConditions.set(this, {
        offline: false,
        upload: -1,
        download: -1,
        latency: 0
      });
      _NetworkManager_deferredInitPromise.set(this, undefined);
      __classPrivateFieldSet(this, _NetworkManager_client, client, "f");
      __classPrivateFieldSet(this, _NetworkManager_ignoreHTTPSErrors, ignoreHTTPSErrors, "f");
      __classPrivateFieldSet(this, _NetworkManager_frameManager, frameManager, "f");
      __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Fetch.requestPaused", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequestPaused).bind(this));
      __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Fetch.authRequired", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onAuthRequired).bind(this));
      __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.requestWillBeSent", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequestWillBeSent).bind(this));
      __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.requestServedFromCache", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequestServedFromCache).bind(this));
      __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.responseReceived", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onResponseReceived).bind(this));
      __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.loadingFinished", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onLoadingFinished).bind(this));
      __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.loadingFailed", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onLoadingFailed).bind(this));
      __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.responseReceivedExtraInfo", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onResponseReceivedExtraInfo).bind(this));
    }
    initialize() {
      if (__classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, "f")) {
        return __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, "f");
      }
      __classPrivateFieldSet(this, _NetworkManager_deferredInitPromise, (0, DebuggableDeferredPromise_js_1.createDebuggableDeferredPromise)("NetworkManager initialization timed out"), "f");
      const init = Promise.all([
        __classPrivateFieldGet(this, _NetworkManager_ignoreHTTPSErrors, "f") ? __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Security.setIgnoreCertificateErrors", {
          ignore: true
        }) : null,
        __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Network.enable")
      ]);
      const deferredInitPromise = __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, "f");
      init.then(() => {
        deferredInitPromise.resolve();
      }).catch((err) => {
        deferredInitPromise.reject(err);
      });
      return __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, "f");
    }
    async authenticate(credentials) {
      __classPrivateFieldSet(this, _NetworkManager_credentials, credentials, "f");
      await __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolRequestInterception).call(this);
    }
    async setExtraHTTPHeaders(extraHTTPHeaders) {
      __classPrivateFieldSet(this, _NetworkManager_extraHTTPHeaders, {}, "f");
      for (const key2 of Object.keys(extraHTTPHeaders)) {
        const value = extraHTTPHeaders[key2];
        (0, assert_js_1.assert)((0, util_js_1.isString)(value), `Expected value of header "${key2}" to be String, but "${typeof value}" is found.`);
        __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, "f")[key2.toLowerCase()] = value;
      }
      await __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Network.setExtraHTTPHeaders", {
        headers: __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, "f")
      });
    }
    extraHTTPHeaders() {
      return Object.assign({}, __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, "f"));
    }
    numRequestsInProgress() {
      return __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").numRequestsInProgress();
    }
    async setOfflineMode(value) {
      __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").offline = value;
      await __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateNetworkConditions).call(this);
    }
    async emulateNetworkConditions(networkConditions) {
      __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").upload = networkConditions ? networkConditions.upload : -1;
      __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").download = networkConditions ? networkConditions.download : -1;
      __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").latency = networkConditions ? networkConditions.latency : 0;
      await __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateNetworkConditions).call(this);
    }
    async setUserAgent(userAgent, userAgentMetadata) {
      await __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Network.setUserAgentOverride", {
        userAgent,
        userAgentMetadata
      });
    }
    async setCacheEnabled(enabled) {
      __classPrivateFieldSet(this, _NetworkManager_userCacheDisabled, !enabled, "f");
      await __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolCacheDisabled).call(this);
    }
    async setRequestInterception(value) {
      __classPrivateFieldSet(this, _NetworkManager_userRequestInterceptionEnabled, value, "f");
      await __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolRequestInterception).call(this);
    }
  }
  exports.NetworkManager = NetworkManager;
  _NetworkManager_client = new WeakMap, _NetworkManager_ignoreHTTPSErrors = new WeakMap, _NetworkManager_frameManager = new WeakMap, _NetworkManager_networkEventManager = new WeakMap, _NetworkManager_extraHTTPHeaders = new WeakMap, _NetworkManager_credentials = new WeakMap, _NetworkManager_attemptedAuthentications = new WeakMap, _NetworkManager_userRequestInterceptionEnabled = new WeakMap, _NetworkManager_protocolRequestInterceptionEnabled = new WeakMap, _NetworkManager_userCacheDisabled = new WeakMap, _NetworkManager_emulatedNetworkConditions = new WeakMap, _NetworkManager_deferredInitPromise = new WeakMap, _NetworkManager_instances = new WeakSet, _NetworkManager_updateNetworkConditions = async function _NetworkManager_updateNetworkConditions() {
    await __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Network.emulateNetworkConditions", {
      offline: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").offline,
      latency: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").latency,
      uploadThroughput: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").upload,
      downloadThroughput: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").download
    });
  }, _NetworkManager_updateProtocolRequestInterception = async function _NetworkManager_updateProtocolRequestInterception() {
    const enabled = __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, "f") || !!__classPrivateFieldGet(this, _NetworkManager_credentials, "f");
    if (enabled === __classPrivateFieldGet(this, _NetworkManager_protocolRequestInterceptionEnabled, "f")) {
      return;
    }
    __classPrivateFieldSet(this, _NetworkManager_protocolRequestInterceptionEnabled, enabled, "f");
    if (enabled) {
      await Promise.all([
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolCacheDisabled).call(this),
        __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Fetch.enable", {
          handleAuthRequests: true,
          patterns: [{ urlPattern: "*" }]
        })
      ]);
    } else {
      await Promise.all([
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolCacheDisabled).call(this),
        __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Fetch.disable")
      ]);
    }
  }, _NetworkManager_cacheDisabled = function _NetworkManager_cacheDisabled() {
    return __classPrivateFieldGet(this, _NetworkManager_userCacheDisabled, "f");
  }, _NetworkManager_updateProtocolCacheDisabled = async function _NetworkManager_updateProtocolCacheDisabled() {
    await __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Network.setCacheDisabled", {
      cacheDisabled: __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_cacheDisabled).call(this)
    });
  }, _NetworkManager_onRequestWillBeSent = function _NetworkManager_onRequestWillBeSent(event) {
    if (__classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, "f") && !event.request.url.startsWith("data:")) {
      const { requestId: networkRequestId } = event;
      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").storeRequestWillBeSent(networkRequestId, event);
      const requestPausedEvent = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequestPaused(networkRequestId);
      if (requestPausedEvent) {
        const { requestId: fetchRequestId } = requestPausedEvent;
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_patchRequestEventHeaders).call(this, event, requestPausedEvent);
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, event, fetchRequestId);
        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").forgetRequestPaused(networkRequestId);
      }
      return;
    }
    __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, event, undefined);
  }, _NetworkManager_onAuthRequired = function _NetworkManager_onAuthRequired(event) {
    let response = "Default";
    if (__classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, "f").has(event.requestId)) {
      response = "CancelAuth";
    } else if (__classPrivateFieldGet(this, _NetworkManager_credentials, "f")) {
      response = "ProvideCredentials";
      __classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, "f").add(event.requestId);
    }
    const { username, password } = __classPrivateFieldGet(this, _NetworkManager_credentials, "f") || {
      username: undefined,
      password: undefined
    };
    __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Fetch.continueWithAuth", {
      requestId: event.requestId,
      authChallengeResponse: { response, username, password }
    }).catch(util_js_1.debugError);
  }, _NetworkManager_onRequestPaused = function _NetworkManager_onRequestPaused(event) {
    if (!__classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, "f") && __classPrivateFieldGet(this, _NetworkManager_protocolRequestInterceptionEnabled, "f")) {
      __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Fetch.continueRequest", {
        requestId: event.requestId
      }).catch(util_js_1.debugError);
    }
    const { networkId: networkRequestId, requestId: fetchRequestId } = event;
    if (!networkRequestId) {
      return;
    }
    const requestWillBeSentEvent = (() => {
      const requestWillBeSentEvent2 = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequestWillBeSent(networkRequestId);
      if (requestWillBeSentEvent2 && (requestWillBeSentEvent2.request.url !== event.request.url || requestWillBeSentEvent2.request.method !== event.request.method)) {
        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").forgetRequestWillBeSent(networkRequestId);
        return;
      }
      return requestWillBeSentEvent2;
    })();
    if (requestWillBeSentEvent) {
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_patchRequestEventHeaders).call(this, requestWillBeSentEvent, event);
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, requestWillBeSentEvent, fetchRequestId);
    } else {
      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").storeRequestPaused(networkRequestId, event);
    }
  }, _NetworkManager_patchRequestEventHeaders = function _NetworkManager_patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {
    requestWillBeSentEvent.request.headers = {
      ...requestWillBeSentEvent.request.headers,
      ...requestPausedEvent.request.headers
    };
  }, _NetworkManager_onRequest = function _NetworkManager_onRequest(event, fetchRequestId) {
    let redirectChain = [];
    if (event.redirectResponse) {
      let redirectResponseExtraInfo = null;
      if (event.redirectHasExtraInfo) {
        redirectResponseExtraInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).shift();
        if (!redirectResponseExtraInfo) {
          __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").queueRedirectInfo(event.requestId, {
            event,
            fetchRequestId
          });
          return;
        }
      }
      const request2 = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
      if (request2) {
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_handleRequestRedirect).call(this, request2, event.redirectResponse, redirectResponseExtraInfo);
        redirectChain = request2._redirectChain;
      }
    }
    const frame = event.frameId ? __classPrivateFieldGet(this, _NetworkManager_frameManager, "f").frame(event.frameId) : null;
    const request = new HTTPRequest_js_1.HTTPRequest(__classPrivateFieldGet(this, _NetworkManager_client, "f"), frame, fetchRequestId, __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, "f"), event, redirectChain);
    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").storeRequest(event.requestId, request);
    this.emit(exports.NetworkManagerEmittedEvents.Request, request);
    request.finalizeInterceptions();
  }, _NetworkManager_onRequestServedFromCache = function _NetworkManager_onRequestServedFromCache(event) {
    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
    if (request) {
      request._fromMemoryCache = true;
    }
    this.emit(exports.NetworkManagerEmittedEvents.RequestServedFromCache, request);
  }, _NetworkManager_handleRequestRedirect = function _NetworkManager_handleRequestRedirect(request, responsePayload, extraInfo) {
    const response = new HTTPResponse_js_1.HTTPResponse(__classPrivateFieldGet(this, _NetworkManager_client, "f"), request, responsePayload, extraInfo);
    request._response = response;
    request._redirectChain.push(request);
    response._resolveBody(new Error("Response body is unavailable for redirect responses"));
    __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_forgetRequest).call(this, request, false);
    this.emit(exports.NetworkManagerEmittedEvents.Response, response);
    this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);
  }, _NetworkManager_emitResponseEvent = function _NetworkManager_emitResponseEvent(responseReceived, extraInfo) {
    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(responseReceived.requestId);
    if (!request) {
      return;
    }
    const extraInfos = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(responseReceived.requestId);
    if (extraInfos.length) {
      (0, util_js_1.debugError)(new Error("Unexpected extraInfo events for request " + responseReceived.requestId));
    }
    const response = new HTTPResponse_js_1.HTTPResponse(__classPrivateFieldGet(this, _NetworkManager_client, "f"), request, responseReceived.response, extraInfo);
    request._response = response;
    this.emit(exports.NetworkManagerEmittedEvents.Response, response);
  }, _NetworkManager_onResponseReceived = function _NetworkManager_onResponseReceived(event) {
    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
    let extraInfo = null;
    if (request && !request._fromMemoryCache && event.hasExtraInfo) {
      extraInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).shift();
      if (!extraInfo) {
        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").queueEventGroup(event.requestId, {
          responseReceivedEvent: event
        });
        return;
      }
    }
    __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitResponseEvent).call(this, event, extraInfo);
  }, _NetworkManager_onResponseReceivedExtraInfo = function _NetworkManager_onResponseReceivedExtraInfo(event) {
    const redirectInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").takeQueuedRedirectInfo(event.requestId);
    if (redirectInfo) {
      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).push(event);
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, redirectInfo.event, redirectInfo.fetchRequestId);
      return;
    }
    const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").forgetQueuedEventGroup(event.requestId);
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitResponseEvent).call(this, queuedEvents.responseReceivedEvent, event);
      if (queuedEvents.loadingFinishedEvent) {
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFinished).call(this, queuedEvents.loadingFinishedEvent);
      }
      if (queuedEvents.loadingFailedEvent) {
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFailed).call(this, queuedEvents.loadingFailedEvent);
      }
      return;
    }
    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).push(event);
  }, _NetworkManager_forgetRequest = function _NetworkManager_forgetRequest(request, events) {
    const requestId = request._requestId;
    const interceptionId = request._interceptionId;
    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").forgetRequest(requestId);
    interceptionId !== undefined && __classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, "f").delete(interceptionId);
    if (events) {
      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").forget(requestId);
    }
  }, _NetworkManager_onLoadingFinished = function _NetworkManager_onLoadingFinished(event) {
    const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      queuedEvents.loadingFinishedEvent = event;
    } else {
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFinished).call(this, event);
    }
  }, _NetworkManager_emitLoadingFinished = function _NetworkManager_emitLoadingFinished(event) {
    var _a;
    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
    if (!request) {
      return;
    }
    if (request.response()) {
      (_a = request.response()) === null || _a === undefined || _a._resolveBody(null);
    }
    __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_forgetRequest).call(this, request, true);
    this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);
  }, _NetworkManager_onLoadingFailed = function _NetworkManager_onLoadingFailed(event) {
    const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      queuedEvents.loadingFailedEvent = event;
    } else {
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFailed).call(this, event);
    }
  }, _NetworkManager_emitLoadingFailed = function _NetworkManager_emitLoadingFailed(event) {
    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
    if (!request) {
      return;
    }
    request._failureText = event.errorText;
    const response = request.response();
    if (response) {
      response._resolveBody(null);
    }
    __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_forgetRequest).call(this, request, true);
    this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/FrameManager.js
var require_FrameManager = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _FrameManager_instances;
  var _FrameManager_page;
  var _FrameManager_networkManager;
  var _FrameManager_timeoutSettings;
  var _FrameManager_contextIdToContext;
  var _FrameManager_isolatedWorlds;
  var _FrameManager_client;
  var _FrameManager_onLifecycleEvent;
  var _FrameManager_onFrameStartedLoading;
  var _FrameManager_onFrameStoppedLoading;
  var _FrameManager_handleFrameTree;
  var _FrameManager_onFrameAttached;
  var _FrameManager_onFrameNavigated;
  var _FrameManager_createIsolatedWorld;
  var _FrameManager_onFrameNavigatedWithinDocument;
  var _FrameManager_onFrameDetached;
  var _FrameManager_onExecutionContextCreated;
  var _FrameManager_onExecutionContextDestroyed;
  var _FrameManager_onExecutionContextsCleared;
  var _FrameManager_removeFramesRecursively;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FrameManager = exports.FrameManagerEmittedEvents = undefined;
  var assert_js_1 = require_assert();
  var ErrorLike_js_1 = require_ErrorLike();
  var Connection_js_1 = require_Connection();
  var EventEmitter_js_1 = require_EventEmitter();
  var ExecutionContext_js_1 = require_ExecutionContext();
  var Frame_js_1 = require_Frame();
  var FrameTree_js_1 = require_FrameTree();
  var IsolatedWorld_js_1 = require_IsolatedWorld();
  var NetworkManager_js_1 = require_NetworkManager();
  var util_js_1 = require_util();
  var UTILITY_WORLD_NAME = "__puppeteer_utility_world__";
  exports.FrameManagerEmittedEvents = {
    FrameAttached: Symbol("FrameManager.FrameAttached"),
    FrameNavigated: Symbol("FrameManager.FrameNavigated"),
    FrameDetached: Symbol("FrameManager.FrameDetached"),
    FrameSwapped: Symbol("FrameManager.FrameSwapped"),
    LifecycleEvent: Symbol("FrameManager.LifecycleEvent"),
    FrameNavigatedWithinDocument: Symbol("FrameManager.FrameNavigatedWithinDocument"),
    ExecutionContextCreated: Symbol("FrameManager.ExecutionContextCreated"),
    ExecutionContextDestroyed: Symbol("FrameManager.ExecutionContextDestroyed")
  };

  class FrameManager extends EventEmitter_js_1.EventEmitter {
    constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {
      super();
      _FrameManager_instances.add(this);
      _FrameManager_page.set(this, undefined);
      _FrameManager_networkManager.set(this, undefined);
      _FrameManager_timeoutSettings.set(this, undefined);
      _FrameManager_contextIdToContext.set(this, new Map);
      _FrameManager_isolatedWorlds.set(this, new Set);
      _FrameManager_client.set(this, undefined);
      this._frameTree = new FrameTree_js_1.FrameTree;
      __classPrivateFieldSet(this, _FrameManager_client, client, "f");
      __classPrivateFieldSet(this, _FrameManager_page, page, "f");
      __classPrivateFieldSet(this, _FrameManager_networkManager, new NetworkManager_js_1.NetworkManager(client, ignoreHTTPSErrors, this), "f");
      __classPrivateFieldSet(this, _FrameManager_timeoutSettings, timeoutSettings, "f");
      this.setupEventListeners(__classPrivateFieldGet(this, _FrameManager_client, "f"));
    }
    get timeoutSettings() {
      return __classPrivateFieldGet(this, _FrameManager_timeoutSettings, "f");
    }
    get networkManager() {
      return __classPrivateFieldGet(this, _FrameManager_networkManager, "f");
    }
    get client() {
      return __classPrivateFieldGet(this, _FrameManager_client, "f");
    }
    setupEventListeners(session) {
      session.on("Page.frameAttached", (event) => {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameAttached).call(this, session, event.frameId, event.parentFrameId);
      });
      session.on("Page.frameNavigated", (event) => {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameNavigated).call(this, event.frame);
      });
      session.on("Page.navigatedWithinDocument", (event) => {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameNavigatedWithinDocument).call(this, event.frameId, event.url);
      });
      session.on("Page.frameDetached", (event) => {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameDetached).call(this, event.frameId, event.reason);
      });
      session.on("Page.frameStartedLoading", (event) => {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameStartedLoading).call(this, event.frameId);
      });
      session.on("Page.frameStoppedLoading", (event) => {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameStoppedLoading).call(this, event.frameId);
      });
      session.on("Runtime.executionContextCreated", (event) => {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onExecutionContextCreated).call(this, event.context, session);
      });
      session.on("Runtime.executionContextDestroyed", (event) => {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onExecutionContextDestroyed).call(this, event.executionContextId, session);
      });
      session.on("Runtime.executionContextsCleared", () => {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onExecutionContextsCleared).call(this, session);
      });
      session.on("Page.lifecycleEvent", (event) => {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onLifecycleEvent).call(this, event);
      });
    }
    async initialize(client = __classPrivateFieldGet(this, _FrameManager_client, "f")) {
      try {
        const result = await Promise.all([
          client.send("Page.enable"),
          client.send("Page.getFrameTree")
        ]);
        const { frameTree } = result[1];
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_handleFrameTree).call(this, client, frameTree);
        await Promise.all([
          client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
          client.send("Runtime.enable").then(() => {
            return __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_createIsolatedWorld).call(this, client, UTILITY_WORLD_NAME);
          }),
          client === __classPrivateFieldGet(this, _FrameManager_client, "f") ? __classPrivateFieldGet(this, _FrameManager_networkManager, "f").initialize() : Promise.resolve()
        ]);
      } catch (error) {
        if ((0, ErrorLike_js_1.isErrorLike)(error) && (0, Connection_js_1.isTargetClosedError)(error)) {
          return;
        }
        throw error;
      }
    }
    executionContextById(contextId, session = __classPrivateFieldGet(this, _FrameManager_client, "f")) {
      const key2 = `${session.id()}:${contextId}`;
      const context = __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").get(key2);
      (0, assert_js_1.assert)(context, "INTERNAL ERROR: missing context with id = " + contextId);
      return context;
    }
    page() {
      return __classPrivateFieldGet(this, _FrameManager_page, "f");
    }
    mainFrame() {
      const mainFrame = this._frameTree.getMainFrame();
      (0, assert_js_1.assert)(mainFrame, "Requesting main frame too early!");
      return mainFrame;
    }
    frames() {
      return Array.from(this._frameTree.frames());
    }
    frame(frameId) {
      return this._frameTree.getById(frameId) || null;
    }
    onAttachedToTarget(target) {
      if (target._getTargetInfo().type !== "iframe") {
        return;
      }
      const frame = this.frame(target._getTargetInfo().targetId);
      if (frame) {
        frame.updateClient(target._session());
      }
      this.setupEventListeners(target._session());
      this.initialize(target._session());
    }
    onDetachedFromTarget(target) {
      const frame = this.frame(target._targetId);
      if (frame && frame.isOOPFrame()) {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_removeFramesRecursively).call(this, frame);
      }
    }
  }
  exports.FrameManager = FrameManager;
  _FrameManager_page = new WeakMap, _FrameManager_networkManager = new WeakMap, _FrameManager_timeoutSettings = new WeakMap, _FrameManager_contextIdToContext = new WeakMap, _FrameManager_isolatedWorlds = new WeakMap, _FrameManager_client = new WeakMap, _FrameManager_instances = new WeakSet, _FrameManager_onLifecycleEvent = function _FrameManager_onLifecycleEvent(event) {
    const frame = this.frame(event.frameId);
    if (!frame) {
      return;
    }
    frame._onLifecycleEvent(event.loaderId, event.name);
    this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);
  }, _FrameManager_onFrameStartedLoading = function _FrameManager_onFrameStartedLoading(frameId) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._onLoadingStarted();
  }, _FrameManager_onFrameStoppedLoading = function _FrameManager_onFrameStoppedLoading(frameId) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._onLoadingStopped();
    this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);
  }, _FrameManager_handleFrameTree = function _FrameManager_handleFrameTree(session, frameTree) {
    if (frameTree.frame.parentId) {
      __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameAttached).call(this, session, frameTree.frame.id, frameTree.frame.parentId);
    }
    __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameNavigated).call(this, frameTree.frame);
    if (!frameTree.childFrames) {
      return;
    }
    for (const child of frameTree.childFrames) {
      __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_handleFrameTree).call(this, session, child);
    }
  }, _FrameManager_onFrameAttached = function _FrameManager_onFrameAttached(session, frameId, parentFrameId) {
    let frame = this.frame(frameId);
    if (frame) {
      if (session && frame.isOOPFrame()) {
        frame.updateClient(session);
      }
      return;
    }
    frame = new Frame_js_1.Frame(this, frameId, parentFrameId, session);
    this._frameTree.addFrame(frame);
    this.emit(exports.FrameManagerEmittedEvents.FrameAttached, frame);
  }, _FrameManager_onFrameNavigated = async function _FrameManager_onFrameNavigated(framePayload) {
    const frameId = framePayload.id;
    const isMainFrame = !framePayload.parentId;
    let frame = this._frameTree.getById(frameId);
    if (frame) {
      for (const child of frame.childFrames()) {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_removeFramesRecursively).call(this, child);
      }
    }
    if (isMainFrame) {
      if (frame) {
        this._frameTree.removeFrame(frame);
        frame._id = frameId;
      } else {
        frame = new Frame_js_1.Frame(this, frameId, undefined, __classPrivateFieldGet(this, _FrameManager_client, "f"));
      }
      this._frameTree.addFrame(frame);
    }
    frame = await this._frameTree.waitForFrame(frameId);
    frame._navigated(framePayload);
    this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);
  }, _FrameManager_createIsolatedWorld = async function _FrameManager_createIsolatedWorld(session, name) {
    const key2 = `${session.id()}:${name}`;
    if (__classPrivateFieldGet(this, _FrameManager_isolatedWorlds, "f").has(key2)) {
      return;
    }
    await session.send("Page.addScriptToEvaluateOnNewDocument", {
      source: `//# sourceURL=${ExecutionContext_js_1.EVALUATION_SCRIPT_URL}`,
      worldName: name
    });
    await Promise.all(this.frames().filter((frame) => {
      return frame._client() === session;
    }).map((frame) => {
      return session.send("Page.createIsolatedWorld", {
        frameId: frame._id,
        worldName: name,
        grantUniveralAccess: true
      }).catch(util_js_1.debugError);
    }));
    __classPrivateFieldGet(this, _FrameManager_isolatedWorlds, "f").add(key2);
  }, _FrameManager_onFrameNavigatedWithinDocument = function _FrameManager_onFrameNavigatedWithinDocument(frameId, url) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._navigatedWithinDocument(url);
    this.emit(exports.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);
    this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);
  }, _FrameManager_onFrameDetached = function _FrameManager_onFrameDetached(frameId, reason) {
    const frame = this.frame(frameId);
    if (reason === "remove") {
      if (frame) {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_removeFramesRecursively).call(this, frame);
      }
    } else if (reason === "swap") {
      this.emit(exports.FrameManagerEmittedEvents.FrameSwapped, frame);
    }
  }, _FrameManager_onExecutionContextCreated = function _FrameManager_onExecutionContextCreated(contextPayload, session) {
    const auxData = contextPayload.auxData;
    const frameId = auxData && auxData.frameId;
    const frame = typeof frameId === "string" ? this.frame(frameId) : undefined;
    let world;
    if (frame) {
      if (frame._client() !== session) {
        return;
      }
      if (contextPayload.auxData && !!contextPayload.auxData["isDefault"]) {
        world = frame.worlds[IsolatedWorld_js_1.MAIN_WORLD];
      } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].hasContext()) {
        world = frame.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD];
      }
    }
    const context = new ExecutionContext_js_1.ExecutionContext((frame === null || frame === undefined ? undefined : frame._client()) || __classPrivateFieldGet(this, _FrameManager_client, "f"), contextPayload, world);
    if (world) {
      world.setContext(context);
    }
    const key2 = `${session.id()}:${contextPayload.id}`;
    __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").set(key2, context);
  }, _FrameManager_onExecutionContextDestroyed = function _FrameManager_onExecutionContextDestroyed(executionContextId, session) {
    const key2 = `${session.id()}:${executionContextId}`;
    const context = __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").get(key2);
    if (!context) {
      return;
    }
    __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").delete(key2);
    if (context._world) {
      context._world.clearContext();
    }
  }, _FrameManager_onExecutionContextsCleared = function _FrameManager_onExecutionContextsCleared(session) {
    for (const [key2, context] of __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").entries()) {
      if (context._client !== session) {
        continue;
      }
      if (context._world) {
        context._world.clearContext();
      }
      __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").delete(key2);
    }
  }, _FrameManager_removeFramesRecursively = function _FrameManager_removeFramesRecursively(frame) {
    for (const child of frame.childFrames()) {
      __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_removeFramesRecursively).call(this, child);
    }
    frame._detach();
    this._frameTree.removeFrame(frame);
    this.emit(exports.FrameManagerEmittedEvents.FrameDetached, frame);
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/LifecycleWatcher.js
var require_LifecycleWatcher = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _LifecycleWatcher_instances;
  var _LifecycleWatcher_expectedLifecycle;
  var _LifecycleWatcher_frameManager;
  var _LifecycleWatcher_frame;
  var _LifecycleWatcher_timeout;
  var _LifecycleWatcher_navigationRequest;
  var _LifecycleWatcher_eventListeners;
  var _LifecycleWatcher_initialLoaderId;
  var _LifecycleWatcher_sameDocumentNavigationCompleteCallback;
  var _LifecycleWatcher_sameDocumentNavigationPromise;
  var _LifecycleWatcher_lifecycleCallback;
  var _LifecycleWatcher_lifecyclePromise;
  var _LifecycleWatcher_newDocumentNavigationCompleteCallback;
  var _LifecycleWatcher_newDocumentNavigationPromise;
  var _LifecycleWatcher_terminationCallback;
  var _LifecycleWatcher_terminationPromise;
  var _LifecycleWatcher_timeoutPromise;
  var _LifecycleWatcher_maximumTimer;
  var _LifecycleWatcher_hasSameDocumentNavigation;
  var _LifecycleWatcher_swapped;
  var _LifecycleWatcher_navigationResponseReceived;
  var _LifecycleWatcher_onRequest;
  var _LifecycleWatcher_onResponse;
  var _LifecycleWatcher_onFrameDetached;
  var _LifecycleWatcher_terminate;
  var _LifecycleWatcher_createTimeoutPromise;
  var _LifecycleWatcher_navigatedWithinDocument;
  var _LifecycleWatcher_navigated;
  var _LifecycleWatcher_frameSwapped;
  var _LifecycleWatcher_checkLifecycleComplete;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LifecycleWatcher = undefined;
  var assert_js_1 = require_assert();
  var util_js_1 = require_util();
  var DeferredPromise_js_1 = require_DeferredPromise();
  var Errors_js_1 = require_Errors();
  var FrameManager_js_1 = require_FrameManager();
  var NetworkManager_js_1 = require_NetworkManager();
  var Connection_js_1 = require_Connection();
  var puppeteerToProtocolLifecycle = new Map([
    ["load", "load"],
    ["domcontentloaded", "DOMContentLoaded"],
    ["networkidle0", "networkIdle"],
    ["networkidle2", "networkAlmostIdle"]
  ]);
  var noop = () => {};

  class LifecycleWatcher {
    constructor(frameManager, frame, waitUntil, timeout) {
      _LifecycleWatcher_instances.add(this);
      _LifecycleWatcher_expectedLifecycle.set(this, undefined);
      _LifecycleWatcher_frameManager.set(this, undefined);
      _LifecycleWatcher_frame.set(this, undefined);
      _LifecycleWatcher_timeout.set(this, undefined);
      _LifecycleWatcher_navigationRequest.set(this, null);
      _LifecycleWatcher_eventListeners.set(this, undefined);
      _LifecycleWatcher_initialLoaderId.set(this, undefined);
      _LifecycleWatcher_sameDocumentNavigationCompleteCallback.set(this, noop);
      _LifecycleWatcher_sameDocumentNavigationPromise.set(this, new Promise((fulfill) => {
        __classPrivateFieldSet(this, _LifecycleWatcher_sameDocumentNavigationCompleteCallback, fulfill, "f");
      }));
      _LifecycleWatcher_lifecycleCallback.set(this, noop);
      _LifecycleWatcher_lifecyclePromise.set(this, new Promise((fulfill) => {
        __classPrivateFieldSet(this, _LifecycleWatcher_lifecycleCallback, fulfill, "f");
      }));
      _LifecycleWatcher_newDocumentNavigationCompleteCallback.set(this, noop);
      _LifecycleWatcher_newDocumentNavigationPromise.set(this, new Promise((fulfill) => {
        __classPrivateFieldSet(this, _LifecycleWatcher_newDocumentNavigationCompleteCallback, fulfill, "f");
      }));
      _LifecycleWatcher_terminationCallback.set(this, noop);
      _LifecycleWatcher_terminationPromise.set(this, new Promise((fulfill) => {
        __classPrivateFieldSet(this, _LifecycleWatcher_terminationCallback, fulfill, "f");
      }));
      _LifecycleWatcher_timeoutPromise.set(this, undefined);
      _LifecycleWatcher_maximumTimer.set(this, undefined);
      _LifecycleWatcher_hasSameDocumentNavigation.set(this, undefined);
      _LifecycleWatcher_swapped.set(this, undefined);
      _LifecycleWatcher_navigationResponseReceived.set(this, undefined);
      if (Array.isArray(waitUntil)) {
        waitUntil = waitUntil.slice();
      } else if (typeof waitUntil === "string") {
        waitUntil = [waitUntil];
      }
      __classPrivateFieldSet(this, _LifecycleWatcher_initialLoaderId, frame._loaderId, "f");
      __classPrivateFieldSet(this, _LifecycleWatcher_expectedLifecycle, waitUntil.map((value) => {
        const protocolEvent = puppeteerToProtocolLifecycle.get(value);
        (0, assert_js_1.assert)(protocolEvent, "Unknown value for options.waitUntil: " + value);
        return protocolEvent;
      }), "f");
      __classPrivateFieldSet(this, _LifecycleWatcher_frameManager, frameManager, "f");
      __classPrivateFieldSet(this, _LifecycleWatcher_frame, frame, "f");
      __classPrivateFieldSet(this, _LifecycleWatcher_timeout, timeout, "f");
      __classPrivateFieldSet(this, _LifecycleWatcher_eventListeners, [
        (0, util_js_1.addEventListener)(frameManager.client, Connection_js_1.CDPSessionEmittedEvents.Disconnected, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_terminate).bind(this, new Error("Navigation failed because browser has disconnected!"))),
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.LifecycleEvent, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).bind(this)),
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_navigatedWithinDocument).bind(this)),
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigated, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_navigated).bind(this)),
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameSwapped, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_frameSwapped).bind(this)),
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameDetached, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onFrameDetached).bind(this)),
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f").networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Request, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onRequest).bind(this)),
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f").networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Response, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onResponse).bind(this))
      ], "f");
      __classPrivateFieldSet(this, _LifecycleWatcher_timeoutPromise, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_createTimeoutPromise).call(this), "f");
      __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
    }
    async navigationResponse() {
      var _a;
      await ((_a = __classPrivateFieldGet(this, _LifecycleWatcher_navigationResponseReceived, "f")) === null || _a === undefined ? undefined : _a.catch(() => {}));
      return __classPrivateFieldGet(this, _LifecycleWatcher_navigationRequest, "f") ? __classPrivateFieldGet(this, _LifecycleWatcher_navigationRequest, "f").response() : null;
    }
    sameDocumentNavigationPromise() {
      return __classPrivateFieldGet(this, _LifecycleWatcher_sameDocumentNavigationPromise, "f");
    }
    newDocumentNavigationPromise() {
      return __classPrivateFieldGet(this, _LifecycleWatcher_newDocumentNavigationPromise, "f");
    }
    lifecyclePromise() {
      return __classPrivateFieldGet(this, _LifecycleWatcher_lifecyclePromise, "f");
    }
    timeoutOrTerminationPromise() {
      return Promise.race([__classPrivateFieldGet(this, _LifecycleWatcher_timeoutPromise, "f"), __classPrivateFieldGet(this, _LifecycleWatcher_terminationPromise, "f")]);
    }
    dispose() {
      (0, util_js_1.removeEventListeners)(__classPrivateFieldGet(this, _LifecycleWatcher_eventListeners, "f"));
      __classPrivateFieldGet(this, _LifecycleWatcher_maximumTimer, "f") !== undefined && clearTimeout(__classPrivateFieldGet(this, _LifecycleWatcher_maximumTimer, "f"));
    }
  }
  exports.LifecycleWatcher = LifecycleWatcher;
  _LifecycleWatcher_expectedLifecycle = new WeakMap, _LifecycleWatcher_frameManager = new WeakMap, _LifecycleWatcher_frame = new WeakMap, _LifecycleWatcher_timeout = new WeakMap, _LifecycleWatcher_navigationRequest = new WeakMap, _LifecycleWatcher_eventListeners = new WeakMap, _LifecycleWatcher_initialLoaderId = new WeakMap, _LifecycleWatcher_sameDocumentNavigationCompleteCallback = new WeakMap, _LifecycleWatcher_sameDocumentNavigationPromise = new WeakMap, _LifecycleWatcher_lifecycleCallback = new WeakMap, _LifecycleWatcher_lifecyclePromise = new WeakMap, _LifecycleWatcher_newDocumentNavigationCompleteCallback = new WeakMap, _LifecycleWatcher_newDocumentNavigationPromise = new WeakMap, _LifecycleWatcher_terminationCallback = new WeakMap, _LifecycleWatcher_terminationPromise = new WeakMap, _LifecycleWatcher_timeoutPromise = new WeakMap, _LifecycleWatcher_maximumTimer = new WeakMap, _LifecycleWatcher_hasSameDocumentNavigation = new WeakMap, _LifecycleWatcher_swapped = new WeakMap, _LifecycleWatcher_navigationResponseReceived = new WeakMap, _LifecycleWatcher_instances = new WeakSet, _LifecycleWatcher_onRequest = function _LifecycleWatcher_onRequest(request) {
    var _a, _b;
    if (request.frame() !== __classPrivateFieldGet(this, _LifecycleWatcher_frame, "f") || !request.isNavigationRequest()) {
      return;
    }
    __classPrivateFieldSet(this, _LifecycleWatcher_navigationRequest, request, "f");
    (_a = __classPrivateFieldGet(this, _LifecycleWatcher_navigationResponseReceived, "f")) === null || _a === undefined || _a.resolve();
    __classPrivateFieldSet(this, _LifecycleWatcher_navigationResponseReceived, (0, DeferredPromise_js_1.createDeferredPromise)(), "f");
    if (request.response() !== null) {
      (_b = __classPrivateFieldGet(this, _LifecycleWatcher_navigationResponseReceived, "f")) === null || _b === undefined || _b.resolve();
    }
  }, _LifecycleWatcher_onResponse = function _LifecycleWatcher_onResponse(response) {
    var _a, _b;
    if (((_a = __classPrivateFieldGet(this, _LifecycleWatcher_navigationRequest, "f")) === null || _a === undefined ? undefined : _a._requestId) !== response.request()._requestId) {
      return;
    }
    (_b = __classPrivateFieldGet(this, _LifecycleWatcher_navigationResponseReceived, "f")) === null || _b === undefined || _b.resolve();
  }, _LifecycleWatcher_onFrameDetached = function _LifecycleWatcher_onFrameDetached(frame) {
    if (__classPrivateFieldGet(this, _LifecycleWatcher_frame, "f") === frame) {
      __classPrivateFieldGet(this, _LifecycleWatcher_terminationCallback, "f").call(null, new Error("Navigating frame was detached"));
      return;
    }
    __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
  }, _LifecycleWatcher_terminate = function _LifecycleWatcher_terminate(error) {
    __classPrivateFieldGet(this, _LifecycleWatcher_terminationCallback, "f").call(null, error);
  }, _LifecycleWatcher_createTimeoutPromise = async function _LifecycleWatcher_createTimeoutPromise() {
    if (!__classPrivateFieldGet(this, _LifecycleWatcher_timeout, "f")) {
      return new Promise(noop);
    }
    const errorMessage = "Navigation timeout of " + __classPrivateFieldGet(this, _LifecycleWatcher_timeout, "f") + " ms exceeded";
    await new Promise((fulfill) => {
      return __classPrivateFieldSet(this, _LifecycleWatcher_maximumTimer, setTimeout(fulfill, __classPrivateFieldGet(this, _LifecycleWatcher_timeout, "f")), "f");
    });
    return new Errors_js_1.TimeoutError(errorMessage);
  }, _LifecycleWatcher_navigatedWithinDocument = function _LifecycleWatcher_navigatedWithinDocument(frame) {
    if (frame !== __classPrivateFieldGet(this, _LifecycleWatcher_frame, "f")) {
      return;
    }
    __classPrivateFieldSet(this, _LifecycleWatcher_hasSameDocumentNavigation, true, "f");
    __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
  }, _LifecycleWatcher_navigated = function _LifecycleWatcher_navigated(frame) {
    if (frame !== __classPrivateFieldGet(this, _LifecycleWatcher_frame, "f")) {
      return;
    }
    __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
  }, _LifecycleWatcher_frameSwapped = function _LifecycleWatcher_frameSwapped(frame) {
    if (frame !== __classPrivateFieldGet(this, _LifecycleWatcher_frame, "f")) {
      return;
    }
    __classPrivateFieldSet(this, _LifecycleWatcher_swapped, true, "f");
    __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
  }, _LifecycleWatcher_checkLifecycleComplete = function _LifecycleWatcher_checkLifecycleComplete() {
    if (!checkLifecycle(__classPrivateFieldGet(this, _LifecycleWatcher_frame, "f"), __classPrivateFieldGet(this, _LifecycleWatcher_expectedLifecycle, "f"))) {
      return;
    }
    __classPrivateFieldGet(this, _LifecycleWatcher_lifecycleCallback, "f").call(this);
    if (__classPrivateFieldGet(this, _LifecycleWatcher_hasSameDocumentNavigation, "f")) {
      __classPrivateFieldGet(this, _LifecycleWatcher_sameDocumentNavigationCompleteCallback, "f").call(this);
    }
    if (__classPrivateFieldGet(this, _LifecycleWatcher_swapped, "f") || __classPrivateFieldGet(this, _LifecycleWatcher_frame, "f")._loaderId !== __classPrivateFieldGet(this, _LifecycleWatcher_initialLoaderId, "f")) {
      __classPrivateFieldGet(this, _LifecycleWatcher_newDocumentNavigationCompleteCallback, "f").call(this);
    }
    function checkLifecycle(frame, expectedLifecycle) {
      for (const event of expectedLifecycle) {
        if (!frame._lifecycleEvents.has(event)) {
          return false;
        }
      }
      for (const child of frame.childFrames()) {
        if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {
          return false;
        }
      }
      return true;
    }
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/WaitTask.js
var require_WaitTask = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _WaitTask_world;
  var _WaitTask_bindings;
  var _WaitTask_polling;
  var _WaitTask_root;
  var _WaitTask_fn;
  var _WaitTask_args;
  var _WaitTask_timeout;
  var _WaitTask_result;
  var _WaitTask_poller;
  var _TaskManager_tasks;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TaskManager = exports.WaitTask = undefined;
  var DeferredPromise_js_1 = require_DeferredPromise();
  var Errors_js_1 = require_Errors();

  class WaitTask {
    constructor(world, options, fn, ...args) {
      var _a;
      _WaitTask_world.set(this, undefined);
      _WaitTask_bindings.set(this, undefined);
      _WaitTask_polling.set(this, undefined);
      _WaitTask_root.set(this, undefined);
      _WaitTask_fn.set(this, undefined);
      _WaitTask_args.set(this, undefined);
      _WaitTask_timeout.set(this, undefined);
      _WaitTask_result.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
      _WaitTask_poller.set(this, undefined);
      __classPrivateFieldSet(this, _WaitTask_world, world, "f");
      __classPrivateFieldSet(this, _WaitTask_bindings, (_a = options.bindings) !== null && _a !== undefined ? _a : new Map, "f");
      __classPrivateFieldSet(this, _WaitTask_polling, options.polling, "f");
      __classPrivateFieldSet(this, _WaitTask_root, options.root, "f");
      switch (typeof fn) {
        case "string":
          __classPrivateFieldSet(this, _WaitTask_fn, `() => {return (${fn});}`, "f");
          break;
        default:
          __classPrivateFieldSet(this, _WaitTask_fn, fn.toString(), "f");
          break;
      }
      __classPrivateFieldSet(this, _WaitTask_args, args, "f");
      __classPrivateFieldGet(this, _WaitTask_world, "f").taskManager.add(this);
      if (options.timeout) {
        __classPrivateFieldSet(this, _WaitTask_timeout, setTimeout(() => {
          this.terminate(new Errors_js_1.TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`));
        }, options.timeout), "f");
      }
      if (__classPrivateFieldGet(this, _WaitTask_bindings, "f").size !== 0) {
        for (const [name, fn2] of __classPrivateFieldGet(this, _WaitTask_bindings, "f")) {
          __classPrivateFieldGet(this, _WaitTask_world, "f")._boundFunctions.set(name, fn2);
        }
      }
      this.rerun();
    }
    get result() {
      return __classPrivateFieldGet(this, _WaitTask_result, "f");
    }
    async rerun() {
      try {
        if (__classPrivateFieldGet(this, _WaitTask_bindings, "f").size !== 0) {
          const context = await __classPrivateFieldGet(this, _WaitTask_world, "f").executionContext();
          await Promise.all([...__classPrivateFieldGet(this, _WaitTask_bindings, "f")].map(async ([name]) => {
            return await __classPrivateFieldGet(this, _WaitTask_world, "f")._addBindingToContext(context, name);
          }));
        }
        switch (__classPrivateFieldGet(this, _WaitTask_polling, "f")) {
          case "raf":
            __classPrivateFieldSet(this, _WaitTask_poller, await __classPrivateFieldGet(this, _WaitTask_world, "f").evaluateHandle(({ RAFPoller, createFunction }, fn, ...args) => {
              const fun = createFunction(fn);
              return new RAFPoller(() => {
                return fun(...args);
              });
            }, await __classPrivateFieldGet(this, _WaitTask_world, "f").puppeteerUtil, __classPrivateFieldGet(this, _WaitTask_fn, "f"), ...__classPrivateFieldGet(this, _WaitTask_args, "f")), "f");
            break;
          case "mutation":
            __classPrivateFieldSet(this, _WaitTask_poller, await __classPrivateFieldGet(this, _WaitTask_world, "f").evaluateHandle(({ MutationPoller, createFunction }, root, fn, ...args) => {
              const fun = createFunction(fn);
              return new MutationPoller(() => {
                return fun(...args);
              }, root || document);
            }, await __classPrivateFieldGet(this, _WaitTask_world, "f").puppeteerUtil, __classPrivateFieldGet(this, _WaitTask_root, "f"), __classPrivateFieldGet(this, _WaitTask_fn, "f"), ...__classPrivateFieldGet(this, _WaitTask_args, "f")), "f");
            break;
          default:
            __classPrivateFieldSet(this, _WaitTask_poller, await __classPrivateFieldGet(this, _WaitTask_world, "f").evaluateHandle(({ IntervalPoller, createFunction }, ms, fn, ...args) => {
              const fun = createFunction(fn);
              return new IntervalPoller(() => {
                return fun(...args);
              }, ms);
            }, await __classPrivateFieldGet(this, _WaitTask_world, "f").puppeteerUtil, __classPrivateFieldGet(this, _WaitTask_polling, "f"), __classPrivateFieldGet(this, _WaitTask_fn, "f"), ...__classPrivateFieldGet(this, _WaitTask_args, "f")), "f");
            break;
        }
        await __classPrivateFieldGet(this, _WaitTask_poller, "f").evaluate((poller) => {
          poller.start();
        });
        const result = await __classPrivateFieldGet(this, _WaitTask_poller, "f").evaluateHandle((poller) => {
          return poller.result();
        });
        __classPrivateFieldGet(this, _WaitTask_result, "f").resolve(result);
        await this.terminate();
      } catch (error) {
        const badError = this.getBadError(error);
        if (badError) {
          await this.terminate(badError);
        }
      }
    }
    async terminate(error) {
      __classPrivateFieldGet(this, _WaitTask_world, "f").taskManager.delete(this);
      if (__classPrivateFieldGet(this, _WaitTask_timeout, "f")) {
        clearTimeout(__classPrivateFieldGet(this, _WaitTask_timeout, "f"));
      }
      if (error && !__classPrivateFieldGet(this, _WaitTask_result, "f").finished()) {
        __classPrivateFieldGet(this, _WaitTask_result, "f").reject(error);
      }
      if (__classPrivateFieldGet(this, _WaitTask_poller, "f")) {
        try {
          await __classPrivateFieldGet(this, _WaitTask_poller, "f").evaluateHandle(async (poller) => {
            await poller.stop();
          });
          if (__classPrivateFieldGet(this, _WaitTask_poller, "f")) {
            await __classPrivateFieldGet(this, _WaitTask_poller, "f").dispose();
            __classPrivateFieldSet(this, _WaitTask_poller, undefined, "f");
          }
        } catch {}
      }
    }
    getBadError(error) {
      if (error instanceof Error) {
        if (error.message.includes("Execution context is not available in detached frame")) {
          return new Error("Waiting failed: Frame detached");
        }
        if (error.message.includes("Execution context was destroyed")) {
          return;
        }
        if (error.message.includes("Cannot find context with specified id")) {
          return;
        }
      }
      return error;
    }
  }
  exports.WaitTask = WaitTask;
  _WaitTask_world = new WeakMap, _WaitTask_bindings = new WeakMap, _WaitTask_polling = new WeakMap, _WaitTask_root = new WeakMap, _WaitTask_fn = new WeakMap, _WaitTask_args = new WeakMap, _WaitTask_timeout = new WeakMap, _WaitTask_result = new WeakMap, _WaitTask_poller = new WeakMap;

  class TaskManager {
    constructor() {
      _TaskManager_tasks.set(this, new Set);
    }
    add(task) {
      __classPrivateFieldGet(this, _TaskManager_tasks, "f").add(task);
    }
    delete(task) {
      __classPrivateFieldGet(this, _TaskManager_tasks, "f").delete(task);
    }
    terminateAll(error) {
      for (const task of __classPrivateFieldGet(this, _TaskManager_tasks, "f")) {
        task.terminate(error);
      }
      __classPrivateFieldGet(this, _TaskManager_tasks, "f").clear();
    }
    async rerunAll() {
      await Promise.all([...__classPrivateFieldGet(this, _TaskManager_tasks, "f")].map((task) => {
        return task.rerun();
      }));
    }
  }
  exports.TaskManager = TaskManager;
  _TaskManager_tasks = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/IsolatedWorld.js
var require_IsolatedWorld = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _IsolatedWorld_instances;
  var _a;
  var _IsolatedWorld_frame;
  var _IsolatedWorld_document;
  var _IsolatedWorld_context;
  var _IsolatedWorld_detached;
  var _IsolatedWorld_ctxBindings;
  var _IsolatedWorld_boundFunctions;
  var _IsolatedWorld_taskManager;
  var _IsolatedWorld_puppeteerUtil;
  var _IsolatedWorld_bindingIdentifier;
  var _IsolatedWorld_client_get;
  var _IsolatedWorld_frameManager_get;
  var _IsolatedWorld_timeoutSettings_get;
  var _IsolatedWorld_injectPuppeteerUtil;
  var _IsolatedWorld_settingUpBinding;
  var _IsolatedWorld_onBindingCalled;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsolatedWorld = exports.PUPPETEER_WORLD = exports.MAIN_WORLD = undefined;
  var injected_js_1 = require_injected();
  var assert_js_1 = require_assert();
  var DeferredPromise_js_1 = require_DeferredPromise();
  var ErrorLike_js_1 = require_ErrorLike();
  var LazyArg_js_1 = require_LazyArg();
  var LifecycleWatcher_js_1 = require_LifecycleWatcher();
  var util_js_1 = require_util();
  var WaitTask_js_1 = require_WaitTask();
  exports.MAIN_WORLD = Symbol("mainWorld");
  exports.PUPPETEER_WORLD = Symbol("puppeteerWorld");

  class IsolatedWorld {
    constructor(frame) {
      _IsolatedWorld_instances.add(this);
      _IsolatedWorld_frame.set(this, undefined);
      _IsolatedWorld_document.set(this, undefined);
      _IsolatedWorld_context.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
      _IsolatedWorld_detached.set(this, false);
      _IsolatedWorld_ctxBindings.set(this, new Set);
      _IsolatedWorld_boundFunctions.set(this, new Map);
      _IsolatedWorld_taskManager.set(this, new WaitTask_js_1.TaskManager);
      _IsolatedWorld_puppeteerUtil.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
      _IsolatedWorld_settingUpBinding.set(this, null);
      _IsolatedWorld_onBindingCalled.set(this, async (event) => {
        let payload;
        if (!this.hasContext()) {
          return;
        }
        const context = await this.executionContext();
        try {
          payload = JSON.parse(event.payload);
        } catch {
          return;
        }
        const { type, name, seq, args } = payload;
        if (type !== "internal" || !__classPrivateFieldGet(this, _IsolatedWorld_ctxBindings, "f").has(__classPrivateFieldGet(IsolatedWorld, _a, "f", _IsolatedWorld_bindingIdentifier).call(IsolatedWorld, name, context._contextId))) {
          return;
        }
        if (context._contextId !== event.executionContextId) {
          return;
        }
        try {
          const fn = this._boundFunctions.get(name);
          if (!fn) {
            throw new Error(`Bound function $name is not found`);
          }
          const result = await fn(...args);
          await context.evaluate((name2, seq2, result2) => {
            const callbacks = self[name2].callbacks;
            callbacks.get(seq2).resolve(result2);
            callbacks.delete(seq2);
          }, name, seq, result);
        } catch (error) {
          if (error.message.includes("Protocol error")) {
            return;
          }
          (0, util_js_1.debugError)(error);
        }
      });
      __classPrivateFieldSet(this, _IsolatedWorld_frame, frame, "f");
      __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).on("Runtime.bindingCalled", __classPrivateFieldGet(this, _IsolatedWorld_onBindingCalled, "f"));
    }
    get puppeteerUtil() {
      return __classPrivateFieldGet(this, _IsolatedWorld_puppeteerUtil, "f");
    }
    get taskManager() {
      return __classPrivateFieldGet(this, _IsolatedWorld_taskManager, "f");
    }
    get _boundFunctions() {
      return __classPrivateFieldGet(this, _IsolatedWorld_boundFunctions, "f");
    }
    frame() {
      return __classPrivateFieldGet(this, _IsolatedWorld_frame, "f");
    }
    clearContext() {
      __classPrivateFieldSet(this, _IsolatedWorld_document, undefined, "f");
      __classPrivateFieldSet(this, _IsolatedWorld_puppeteerUtil, (0, DeferredPromise_js_1.createDeferredPromise)(), "f");
      __classPrivateFieldSet(this, _IsolatedWorld_context, (0, DeferredPromise_js_1.createDeferredPromise)(), "f");
    }
    setContext(context) {
      __classPrivateFieldGet(this, _IsolatedWorld_instances, "m", _IsolatedWorld_injectPuppeteerUtil).call(this, context);
      __classPrivateFieldGet(this, _IsolatedWorld_ctxBindings, "f").clear();
      __classPrivateFieldGet(this, _IsolatedWorld_context, "f").resolve(context);
    }
    hasContext() {
      return __classPrivateFieldGet(this, _IsolatedWorld_context, "f").resolved();
    }
    _detach() {
      __classPrivateFieldSet(this, _IsolatedWorld_detached, true, "f");
      __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).off("Runtime.bindingCalled", __classPrivateFieldGet(this, _IsolatedWorld_onBindingCalled, "f"));
      __classPrivateFieldGet(this, _IsolatedWorld_taskManager, "f").terminateAll(new Error("waitForFunction failed: frame got detached."));
    }
    executionContext() {
      if (__classPrivateFieldGet(this, _IsolatedWorld_detached, "f")) {
        throw new Error(`Execution context is not available in detached frame "${__classPrivateFieldGet(this, _IsolatedWorld_frame, "f").url()}" (are you trying to evaluate?)`);
      }
      if (__classPrivateFieldGet(this, _IsolatedWorld_context, "f") === null) {
        throw new Error(`Execution content promise is missing`);
      }
      return __classPrivateFieldGet(this, _IsolatedWorld_context, "f");
    }
    async evaluateHandle(pageFunction, ...args) {
      const context = await this.executionContext();
      return context.evaluateHandle(pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
      const context = await this.executionContext();
      return context.evaluate(pageFunction, ...args);
    }
    async $(selector) {
      const document2 = await this.document();
      return document2.$(selector);
    }
    async $$(selector) {
      const document2 = await this.document();
      return document2.$$(selector);
    }
    async document() {
      if (__classPrivateFieldGet(this, _IsolatedWorld_document, "f")) {
        return __classPrivateFieldGet(this, _IsolatedWorld_document, "f");
      }
      const context = await this.executionContext();
      __classPrivateFieldSet(this, _IsolatedWorld_document, await context.evaluateHandle(() => {
        return document;
      }), "f");
      return __classPrivateFieldGet(this, _IsolatedWorld_document, "f");
    }
    async $x(expression) {
      const document2 = await this.document();
      return document2.$x(expression);
    }
    async $eval(selector, pageFunction, ...args) {
      const document2 = await this.document();
      return document2.$eval(selector, pageFunction, ...args);
    }
    async $$eval(selector, pageFunction, ...args) {
      const document2 = await this.document();
      return document2.$$eval(selector, pageFunction, ...args);
    }
    async content() {
      return await this.evaluate(() => {
        let retVal = "";
        if (document.doctype) {
          retVal = new XMLSerializer().serializeToString(document.doctype);
        }
        if (document.documentElement) {
          retVal += document.documentElement.outerHTML;
        }
        return retVal;
      });
    }
    async setContent(html, options = {}) {
      const { waitUntil = ["load"], timeout = __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_timeoutSettings_get).navigationTimeout() } = options;
      await this.evaluate((html2) => {
        document.open();
        document.write(html2);
        document.close();
      }, html);
      const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(__classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_frameManager_get), __classPrivateFieldGet(this, _IsolatedWorld_frame, "f"), waitUntil, timeout);
      const error = await Promise.race([
        watcher.timeoutOrTerminationPromise(),
        watcher.lifecyclePromise()
      ]);
      watcher.dispose();
      if (error) {
        throw error;
      }
    }
    async click(selector, options) {
      const handle = await this.$(selector);
      (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
      await handle.click(options);
      await handle.dispose();
    }
    async focus(selector) {
      const handle = await this.$(selector);
      (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
      await handle.focus();
      await handle.dispose();
    }
    async hover(selector) {
      const handle = await this.$(selector);
      (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
      await handle.hover();
      await handle.dispose();
    }
    async select(selector, ...values) {
      const handle = await this.$(selector);
      (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
      const result = await handle.select(...values);
      await handle.dispose();
      return result;
    }
    async tap(selector) {
      const handle = await this.$(selector);
      (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
      await handle.tap();
      await handle.dispose();
    }
    async type(selector, text, options) {
      const handle = await this.$(selector);
      (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
      await handle.type(text, options);
      await handle.dispose();
    }
    async _addBindingToContext(context, name) {
      if (__classPrivateFieldGet(this, _IsolatedWorld_ctxBindings, "f").has(__classPrivateFieldGet(IsolatedWorld, _a, "f", _IsolatedWorld_bindingIdentifier).call(IsolatedWorld, name, context._contextId))) {
        return;
      }
      if (__classPrivateFieldGet(this, _IsolatedWorld_settingUpBinding, "f")) {
        await __classPrivateFieldGet(this, _IsolatedWorld_settingUpBinding, "f");
        return this._addBindingToContext(context, name);
      }
      const bind = async (name2) => {
        const expression = (0, util_js_1.pageBindingInitString)("internal", name2);
        try {
          await context._client.send("Runtime.addBinding", {
            name: name2,
            executionContextName: context._contextName
          });
          await context.evaluate(expression);
        } catch (error) {
          if (error instanceof Error) {
            if (error.message.includes("Execution context was destroyed")) {
              return;
            }
            if (error.message.includes("Cannot find context with specified id")) {
              return;
            }
          }
          (0, util_js_1.debugError)(error);
          return;
        }
        __classPrivateFieldGet(this, _IsolatedWorld_ctxBindings, "f").add(__classPrivateFieldGet(IsolatedWorld, _a, "f", _IsolatedWorld_bindingIdentifier).call(IsolatedWorld, name2, context._contextId));
      };
      __classPrivateFieldSet(this, _IsolatedWorld_settingUpBinding, bind(name), "f");
      await __classPrivateFieldGet(this, _IsolatedWorld_settingUpBinding, "f");
      __classPrivateFieldSet(this, _IsolatedWorld_settingUpBinding, null, "f");
    }
    async _waitForSelectorInPage(queryOne, root, selector, options, bindings = new Map) {
      const { visible: waitForVisible = false, hidden: waitForHidden = false, timeout = __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_timeoutSettings_get).timeout() } = options;
      try {
        const handle = await this.waitForFunction(async (PuppeteerUtil, query, selector2, root2, visible) => {
          if (!PuppeteerUtil) {
            return;
          }
          const node = await PuppeteerUtil.createFunction(query)(root2 || document, selector2, PuppeteerUtil);
          return PuppeteerUtil.checkVisibility(node, visible);
        }, {
          bindings,
          polling: waitForVisible || waitForHidden ? "raf" : "mutation",
          root,
          timeout
        }, new LazyArg_js_1.LazyArg(async () => {
          try {
            return await this.puppeteerUtil;
          } catch {
            return;
          }
        }), queryOne.toString(), selector, root, waitForVisible ? true : waitForHidden ? false : undefined);
        const elementHandle = handle.asElement();
        if (!elementHandle) {
          await handle.dispose();
          return null;
        }
        return elementHandle;
      } catch (error) {
        if (!(0, ErrorLike_js_1.isErrorLike)(error)) {
          throw error;
        }
        error.message = `Waiting for selector \`${selector}\` failed: ${error.message}`;
        throw error;
      }
    }
    waitForFunction(pageFunction, options = {}, ...args) {
      const { polling = "raf", timeout = __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_timeoutSettings_get).timeout(), bindings, root } = options;
      if (typeof polling === "number" && polling < 0) {
        throw new Error("Cannot poll with non-positive interval");
      }
      const waitTask = new WaitTask_js_1.WaitTask(this, {
        bindings,
        polling,
        root,
        timeout
      }, pageFunction, ...args);
      return waitTask.result;
    }
    async title() {
      return this.evaluate(() => {
        return document.title;
      });
    }
    async adoptBackendNode(backendNodeId) {
      const executionContext = await this.executionContext();
      const { object } = await __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).send("DOM.resolveNode", {
        backendNodeId,
        executionContextId: executionContext._contextId
      });
      return (0, util_js_1.createJSHandle)(executionContext, object);
    }
    async adoptHandle(handle) {
      const executionContext = await this.executionContext();
      (0, assert_js_1.assert)(handle.executionContext() !== executionContext, "Cannot adopt handle that already belongs to this execution context");
      const nodeInfo = await __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).send("DOM.describeNode", {
        objectId: handle.remoteObject().objectId
      });
      return await this.adoptBackendNode(nodeInfo.node.backendNodeId);
    }
    async transferHandle(handle) {
      const result = await this.adoptHandle(handle);
      await handle.dispose();
      return result;
    }
  }
  exports.IsolatedWorld = IsolatedWorld;
  _a = IsolatedWorld, _IsolatedWorld_frame = new WeakMap, _IsolatedWorld_document = new WeakMap, _IsolatedWorld_context = new WeakMap, _IsolatedWorld_detached = new WeakMap, _IsolatedWorld_ctxBindings = new WeakMap, _IsolatedWorld_boundFunctions = new WeakMap, _IsolatedWorld_taskManager = new WeakMap, _IsolatedWorld_puppeteerUtil = new WeakMap, _IsolatedWorld_settingUpBinding = new WeakMap, _IsolatedWorld_onBindingCalled = new WeakMap, _IsolatedWorld_instances = new WeakSet, _IsolatedWorld_client_get = function _IsolatedWorld_client_get() {
    return __classPrivateFieldGet(this, _IsolatedWorld_frame, "f")._client();
  }, _IsolatedWorld_frameManager_get = function _IsolatedWorld_frameManager_get() {
    return __classPrivateFieldGet(this, _IsolatedWorld_frame, "f")._frameManager;
  }, _IsolatedWorld_timeoutSettings_get = function _IsolatedWorld_timeoutSettings_get() {
    return __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_frameManager_get).timeoutSettings;
  }, _IsolatedWorld_injectPuppeteerUtil = async function _IsolatedWorld_injectPuppeteerUtil(context) {
    try {
      __classPrivateFieldGet(this, _IsolatedWorld_puppeteerUtil, "f").resolve(await context.evaluateHandle(`(() => {
              const module = {};
              ${injected_js_1.source}
              return module.exports.default;
            })()`));
      __classPrivateFieldGet(this, _IsolatedWorld_taskManager, "f").rerunAll();
    } catch (error) {
      (0, util_js_1.debugError)(error);
    }
  };
  _IsolatedWorld_bindingIdentifier = { value: (name, contextId) => {
    return `${name}_${contextId}`;
  } };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Frame.js
var require_Frame = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Frame_url;
  var _Frame_detached;
  var _Frame_client;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Frame = undefined;
  var assert_js_1 = require_assert();
  var ErrorLike_js_1 = require_ErrorLike();
  var IsolatedWorld_js_1 = require_IsolatedWorld();
  var LifecycleWatcher_js_1 = require_LifecycleWatcher();
  var QueryHandler_js_1 = require_QueryHandler();
  var util_js_1 = require_util();

  class Frame {
    constructor(frameManager, frameId, parentFrameId, client) {
      _Frame_url.set(this, "");
      _Frame_detached.set(this, false);
      _Frame_client.set(this, undefined);
      this._loaderId = "";
      this._hasStartedLoading = false;
      this._lifecycleEvents = new Set;
      this._frameManager = frameManager;
      __classPrivateFieldSet(this, _Frame_url, "", "f");
      this._id = frameId;
      this._parentId = parentFrameId;
      __classPrivateFieldSet(this, _Frame_detached, false, "f");
      this._loaderId = "";
      this.updateClient(client);
    }
    updateClient(client) {
      __classPrivateFieldSet(this, _Frame_client, client, "f");
      this.worlds = {
        [IsolatedWorld_js_1.MAIN_WORLD]: new IsolatedWorld_js_1.IsolatedWorld(this),
        [IsolatedWorld_js_1.PUPPETEER_WORLD]: new IsolatedWorld_js_1.IsolatedWorld(this)
      };
    }
    page() {
      return this._frameManager.page();
    }
    isOOPFrame() {
      return __classPrivateFieldGet(this, _Frame_client, "f") !== this._frameManager.client;
    }
    async goto(url, options = {}) {
      const { referer = this._frameManager.networkManager.extraHTTPHeaders()["referer"], waitUntil = ["load"], timeout = this._frameManager.timeoutSettings.navigationTimeout() } = options;
      let ensureNewDocumentNavigation = false;
      const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this._frameManager, this, waitUntil, timeout);
      let error = await Promise.race([
        navigate(__classPrivateFieldGet(this, _Frame_client, "f"), url, referer, this._id),
        watcher.timeoutOrTerminationPromise()
      ]);
      if (!error) {
        error = await Promise.race([
          watcher.timeoutOrTerminationPromise(),
          ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
        ]);
      }
      try {
        if (error) {
          throw error;
        }
        return await watcher.navigationResponse();
      } finally {
        watcher.dispose();
      }
      async function navigate(client, url2, referrer, frameId) {
        try {
          const response = await client.send("Page.navigate", {
            url: url2,
            referrer,
            frameId
          });
          ensureNewDocumentNavigation = !!response.loaderId;
          return response.errorText ? new Error(`${response.errorText} at ${url2}`) : null;
        } catch (error2) {
          if ((0, ErrorLike_js_1.isErrorLike)(error2)) {
            return error2;
          }
          throw error2;
        }
      }
    }
    async waitForNavigation(options = {}) {
      const { waitUntil = ["load"], timeout = this._frameManager.timeoutSettings.navigationTimeout() } = options;
      const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this._frameManager, this, waitUntil, timeout);
      const error = await Promise.race([
        watcher.timeoutOrTerminationPromise(),
        watcher.sameDocumentNavigationPromise(),
        watcher.newDocumentNavigationPromise()
      ]);
      try {
        if (error) {
          throw error;
        }
        return await watcher.navigationResponse();
      } finally {
        watcher.dispose();
      }
    }
    _client() {
      return __classPrivateFieldGet(this, _Frame_client, "f");
    }
    executionContext() {
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].executionContext();
    }
    async evaluateHandle(pageFunction, ...args) {
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].evaluateHandle(pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].evaluate(pageFunction, ...args);
    }
    async $(selector) {
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].$(selector);
    }
    async $$(selector) {
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].$$(selector);
    }
    async $eval(selector, pageFunction, ...args) {
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].$eval(selector, pageFunction, ...args);
    }
    async $$eval(selector, pageFunction, ...args) {
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].$$eval(selector, pageFunction, ...args);
    }
    async $x(expression) {
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].$x(expression);
    }
    async waitForSelector(selector, options = {}) {
      const { updatedSelector, queryHandler } = (0, QueryHandler_js_1.getQueryHandlerAndSelector)(selector);
      (0, assert_js_1.assert)(queryHandler.waitFor, "Query handler does not support waiting");
      return await queryHandler.waitFor(this, updatedSelector, options);
    }
    async waitForXPath(xpath, options = {}) {
      if (xpath.startsWith("//")) {
        xpath = `.${xpath}`;
      }
      return this.waitForSelector(`xpath/${xpath}`, options);
    }
    waitForFunction(pageFunction, options = {}, ...args) {
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].waitForFunction(pageFunction, options, ...args);
    }
    async content() {
      return this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].content();
    }
    async setContent(html, options = {}) {
      return this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].setContent(html, options);
    }
    name() {
      return this._name || "";
    }
    url() {
      return __classPrivateFieldGet(this, _Frame_url, "f");
    }
    parentFrame() {
      return this._frameManager._frameTree.parentFrame(this._id) || null;
    }
    childFrames() {
      return this._frameManager._frameTree.childFrames(this._id);
    }
    isDetached() {
      return __classPrivateFieldGet(this, _Frame_detached, "f");
    }
    async addScriptTag(options) {
      let { content = "", type } = options;
      const { path } = options;
      if (+!!options.url + +!!path + +!!content !== 1) {
        throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
      }
      if (path) {
        let fs;
        try {
          fs = (await Promise.resolve().then(() => __importStar(__require("fs")))).promises;
        } catch (error) {
          if (error instanceof TypeError) {
            throw new Error("Can only pass a file path in a Node-like environment.");
          }
          throw error;
        }
        content = await fs.readFile(path, "utf8");
        content += `//# sourceURL=${path.replace(/\n/g, "")}`;
      }
      type = type !== null && type !== undefined ? type : "text/javascript";
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].transferHandle(await this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].evaluateHandle(async ({ createDeferredPromise }, { url, id, type: type2, content: content2 }) => {
        const promise = createDeferredPromise();
        const script = document.createElement("script");
        script.type = type2;
        script.text = content2;
        if (url) {
          script.src = url;
          script.addEventListener("load", () => {
            return promise.resolve();
          }, { once: true });
          script.addEventListener("error", (event) => {
            var _a;
            promise.reject(new Error((_a = event.message) !== null && _a !== undefined ? _a : "Could not load script"));
          }, { once: true });
        } else {
          promise.resolve();
        }
        if (id) {
          script.id = id;
        }
        document.head.appendChild(script);
        await promise;
        return script;
      }, await this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].puppeteerUtil, { ...options, type, content }));
    }
    async addStyleTag(options) {
      let { content = "" } = options;
      const { path } = options;
      if (+!!options.url + +!!path + +!!content !== 1) {
        throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
      }
      if (path) {
        let fs;
        try {
          fs = (await (0, util_js_1.importFS)()).promises;
        } catch (error) {
          if (error instanceof TypeError) {
            throw new Error("Can only pass a file path in a Node-like environment.");
          }
          throw error;
        }
        content = await fs.readFile(path, "utf8");
        content += "/*# sourceURL=" + path.replace(/\n/g, "") + "*/";
        options.content = content;
      }
      return this.worlds[IsolatedWorld_js_1.MAIN_WORLD].transferHandle(await this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].evaluateHandle(async ({ createDeferredPromise }, { url, content: content2 }) => {
        const promise = createDeferredPromise();
        let element;
        if (!url) {
          element = document.createElement("style");
          element.appendChild(document.createTextNode(content2));
        } else {
          const link = document.createElement("link");
          link.rel = "stylesheet";
          link.href = url;
          element = link;
        }
        element.addEventListener("load", () => {
          promise.resolve();
        }, { once: true });
        element.addEventListener("error", (event) => {
          var _a;
          promise.reject(new Error((_a = event.message) !== null && _a !== undefined ? _a : "Could not load style"));
        }, { once: true });
        document.head.appendChild(element);
        await promise;
        return element;
      }, await this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].puppeteerUtil, options));
    }
    async click(selector, options = {}) {
      return this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].click(selector, options);
    }
    async focus(selector) {
      return this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].focus(selector);
    }
    async hover(selector) {
      return this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].hover(selector);
    }
    select(selector, ...values) {
      return this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].select(selector, ...values);
    }
    async tap(selector) {
      return this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].tap(selector);
    }
    async type(selector, text, options) {
      return this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].type(selector, text, options);
    }
    waitForTimeout(milliseconds) {
      return new Promise((resolve) => {
        setTimeout(resolve, milliseconds);
      });
    }
    async title() {
      return this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].title();
    }
    _navigated(framePayload) {
      this._name = framePayload.name;
      __classPrivateFieldSet(this, _Frame_url, `${framePayload.url}${framePayload.urlFragment || ""}`, "f");
    }
    _navigatedWithinDocument(url) {
      __classPrivateFieldSet(this, _Frame_url, url, "f");
    }
    _onLifecycleEvent(loaderId, name) {
      if (name === "init") {
        this._loaderId = loaderId;
        this._lifecycleEvents.clear();
      }
      this._lifecycleEvents.add(name);
    }
    _onLoadingStopped() {
      this._lifecycleEvents.add("DOMContentLoaded");
      this._lifecycleEvents.add("load");
    }
    _onLoadingStarted() {
      this._hasStartedLoading = true;
    }
    _detach() {
      __classPrivateFieldSet(this, _Frame_detached, true, "f");
      this.worlds[IsolatedWorld_js_1.MAIN_WORLD]._detach();
      this.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD]._detach();
    }
  }
  exports.Frame = Frame;
  _Frame_url = new WeakMap, _Frame_detached = new WeakMap, _Frame_client = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/AriaQueryHandler.js
var require_AriaQueryHandler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ariaHandler = undefined;
  var assert_js_1 = require_assert();
  var ElementHandle_js_1 = require_ElementHandle();
  var Frame_js_1 = require_Frame();
  var IsolatedWorld_js_1 = require_IsolatedWorld();
  async function queryAXTree(client, element, accessibleName, role) {
    const { nodes } = await client.send("Accessibility.queryAXTree", {
      objectId: element.remoteObject().objectId,
      accessibleName,
      role
    });
    const filteredNodes = nodes.filter((node) => {
      return !node.role || node.role.value !== "StaticText";
    });
    return filteredNodes;
  }
  var normalizeValue = (value) => {
    return value.replace(/ +/g, " ").trim();
  };
  var knownAttributes = new Set(["name", "role"]);
  var attributeRegexp = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
  function isKnownAttribute(attribute) {
    return knownAttributes.has(attribute);
  }
  function parseAriaSelector(selector) {
    const queryOptions = {};
    const defaultName = selector.replace(attributeRegexp, (_2, attribute, _quote, value) => {
      attribute = attribute.trim();
      (0, assert_js_1.assert)(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
      queryOptions[attribute] = normalizeValue(value);
      return "";
    });
    if (defaultName && !queryOptions.name) {
      queryOptions.name = normalizeValue(defaultName);
    }
    return queryOptions;
  }
  var queryOneId = async (element, selector) => {
    const { name, role } = parseAriaSelector(selector);
    const res = await queryAXTree(element.client, element, name, role);
    if (!res[0] || !res[0].backendDOMNodeId) {
      return null;
    }
    return res[0].backendDOMNodeId;
  };
  var queryOne = async (element, selector) => {
    const id = await queryOneId(element, selector);
    if (!id) {
      return null;
    }
    return await element.frame.worlds[IsolatedWorld_js_1.MAIN_WORLD].adoptBackendNode(id);
  };
  var waitFor = async (elementOrFrame, selector, options) => {
    let frame;
    let element;
    if (elementOrFrame instanceof Frame_js_1.Frame) {
      frame = elementOrFrame;
    } else {
      frame = elementOrFrame.frame;
      element = await frame.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].adoptHandle(elementOrFrame);
    }
    const ariaQuerySelector = async (selector2) => {
      const id = await queryOneId(element || await frame.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].document(), selector2);
      if (!id) {
        return null;
      }
      return await frame.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].adoptBackendNode(id);
    };
    const result = await frame.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD]._waitForSelectorInPage((_2, selector2) => {
      return globalThis.ariaQuerySelector(selector2);
    }, element, selector, options, new Map([["ariaQuerySelector", ariaQuerySelector]]));
    if (element) {
      await element.dispose();
    }
    if (!(result instanceof ElementHandle_js_1.ElementHandle)) {
      await (result === null || result === undefined ? undefined : result.dispose());
      return null;
    }
    return result.frame.worlds[IsolatedWorld_js_1.MAIN_WORLD].transferHandle(result);
  };
  var queryAll = async (element, selector) => {
    const exeCtx = element.executionContext();
    const { name, role } = parseAriaSelector(selector);
    const res = await queryAXTree(exeCtx._client, element, name, role);
    const world = exeCtx._world;
    return Promise.all(res.map((axNode) => {
      return world.adoptBackendNode(axNode.backendDOMNodeId);
    }));
  };
  exports.ariaHandler = {
    queryOne,
    waitFor,
    queryAll
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/QueryHandler.js
var require_QueryHandler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getQueryHandlerAndSelector = exports.clearCustomQueryHandlers = exports.customQueryHandlerNames = exports.unregisterCustomQueryHandler = exports.registerCustomQueryHandler = undefined;
  var AriaQueryHandler_js_1 = require_AriaQueryHandler();
  var ElementHandle_js_1 = require_ElementHandle();
  var Frame_js_1 = require_Frame();
  var IsolatedWorld_js_1 = require_IsolatedWorld();
  function createPuppeteerQueryHandler(handler) {
    const internalHandler = {};
    if (handler.queryOne) {
      const queryOne = handler.queryOne;
      internalHandler.queryOne = async (element, selector) => {
        const jsHandle = await element.evaluateHandle(queryOne, selector, await element.executionContext()._world.puppeteerUtil);
        const elementHandle = jsHandle.asElement();
        if (elementHandle) {
          return elementHandle;
        }
        await jsHandle.dispose();
        return null;
      };
      internalHandler.waitFor = async (elementOrFrame, selector, options) => {
        let frame;
        let element;
        if (elementOrFrame instanceof Frame_js_1.Frame) {
          frame = elementOrFrame;
        } else {
          frame = elementOrFrame.frame;
          element = await frame.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD].adoptHandle(elementOrFrame);
        }
        const result = await frame.worlds[IsolatedWorld_js_1.PUPPETEER_WORLD]._waitForSelectorInPage(queryOne, element, selector, options);
        if (element) {
          await element.dispose();
        }
        if (!result) {
          return null;
        }
        if (!(result instanceof ElementHandle_js_1.ElementHandle)) {
          await result.dispose();
          return null;
        }
        return frame.worlds[IsolatedWorld_js_1.MAIN_WORLD].transferHandle(result);
      };
    }
    if (handler.queryAll) {
      const queryAll = handler.queryAll;
      internalHandler.queryAll = async (element, selector) => {
        const jsHandle = await element.evaluateHandle(queryAll, selector, await element.executionContext()._world.puppeteerUtil);
        const properties = await jsHandle.getProperties();
        await jsHandle.dispose();
        const result = [];
        for (const property of properties.values()) {
          const elementHandle = property.asElement();
          if (elementHandle) {
            result.push(elementHandle);
          }
        }
        return result;
      };
    }
    return internalHandler;
  }
  var defaultHandler = createPuppeteerQueryHandler({
    queryOne: (element, selector) => {
      if (!("querySelector" in element)) {
        throw new Error(`Could not invoke \`querySelector\` on node of type ${element.nodeName}.`);
      }
      return element.querySelector(selector);
    },
    queryAll: (element, selector) => {
      if (!("querySelectorAll" in element)) {
        throw new Error(`Could not invoke \`querySelectorAll\` on node of type ${element.nodeName}.`);
      }
      return [
        ...element.querySelectorAll(selector)
      ];
    }
  });
  var pierceHandler = createPuppeteerQueryHandler({
    queryOne: (element, selector, { pierceQuerySelector }) => {
      return pierceQuerySelector(element, selector);
    },
    queryAll: (element, selector, { pierceQuerySelectorAll }) => {
      return pierceQuerySelectorAll(element, selector);
    }
  });
  var xpathHandler = createPuppeteerQueryHandler({
    queryOne: (element, selector, { xpathQuerySelector }) => {
      return xpathQuerySelector(element, selector);
    },
    queryAll: (element, selector, { xpathQuerySelectorAll }) => {
      return xpathQuerySelectorAll(element, selector);
    }
  });
  var textQueryHandler = createPuppeteerQueryHandler({
    queryOne: (element, selector, { textQuerySelector }) => {
      return textQuerySelector(element, selector);
    },
    queryAll: (element, selector, { textQuerySelectorAll }) => {
      return textQuerySelectorAll(element, selector);
    }
  });
  var INTERNAL_QUERY_HANDLERS = new Map([
    ["aria", { handler: AriaQueryHandler_js_1.ariaHandler }],
    ["pierce", { handler: pierceHandler }],
    ["xpath", { handler: xpathHandler }],
    ["text", { handler: textQueryHandler }]
  ]);
  var QUERY_HANDLERS = new Map;
  function registerCustomQueryHandler(name, handler) {
    if (INTERNAL_QUERY_HANDLERS.has(name)) {
      throw new Error(`A query handler named "${name}" already exists`);
    }
    if (QUERY_HANDLERS.has(name)) {
      throw new Error(`A custom query handler named "${name}" already exists`);
    }
    const isValidName = /^[a-zA-Z]+$/.test(name);
    if (!isValidName) {
      throw new Error(`Custom query handler names may only contain [a-zA-Z]`);
    }
    QUERY_HANDLERS.set(name, { handler: createPuppeteerQueryHandler(handler) });
  }
  exports.registerCustomQueryHandler = registerCustomQueryHandler;
  function unregisterCustomQueryHandler(name) {
    QUERY_HANDLERS.delete(name);
  }
  exports.unregisterCustomQueryHandler = unregisterCustomQueryHandler;
  function customQueryHandlerNames() {
    return [...QUERY_HANDLERS.keys()];
  }
  exports.customQueryHandlerNames = customQueryHandlerNames;
  function clearCustomQueryHandlers() {
    QUERY_HANDLERS.clear();
  }
  exports.clearCustomQueryHandlers = clearCustomQueryHandlers;
  var CUSTOM_QUERY_SEPARATORS = ["=", "/"];
  function getQueryHandlerAndSelector(selector) {
    for (const handlerMap of [QUERY_HANDLERS, INTERNAL_QUERY_HANDLERS]) {
      for (const [name, { handler: queryHandler, transformSelector }] of handlerMap) {
        for (const separator of CUSTOM_QUERY_SEPARATORS) {
          const prefix = `${name}${separator}`;
          if (selector.startsWith(prefix)) {
            selector = selector.slice(prefix.length);
            if (transformSelector) {
              selector = transformSelector(selector);
            }
            return { updatedSelector: selector, queryHandler };
          }
        }
      }
    }
    return { updatedSelector: selector, queryHandler: defaultHandler };
  }
  exports.getQueryHandlerAndSelector = getQueryHandlerAndSelector;
});

// node_modules/ms/index.js
var require_ms2 = __commonJS((exports, module) => {
  var s = 1000;
  var m2 = s * 60;
  var h = m2 * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms / m2) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms, msAbs, m2, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms2();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key2) => {
      createDebug[key2] = env[key2];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m2;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common2()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error("Cannot require module "+"supports-color");})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key2) => {
    return /^debug_/i.test(key2);
  }).reduce((obj2, key2) => {
    const prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key2];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj2[prop] = val;
    return obj2;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common2()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser2();
  } else {
    module.exports = require_node2();
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports, module) => {
  module.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS((exports, module) => {
  var wrappy = require_wrappy();
  module.exports = wrappy(once);
  module.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS((exports, module) => {
  var once = require_once();
  var noop = function() {};
  var qnt = global.Bare ? queueMicrotask : process.nextTick.bind(process);
  var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  };
  var isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
  };
  var eos = function(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
      if (!stream.writable)
        onfinish();
    };
    var onfinish = function() {
      writable = false;
      if (!readable)
        callback.call(stream);
    };
    var onend = function() {
      readable = false;
      if (!writable)
        callback.call(stream);
    };
    var onexit = function(exitCode) {
      callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
    };
    var onerror = function(err) {
      callback.call(stream, err);
    };
    var onclose = function() {
      qnt(onclosenexttick);
    };
    var onclosenexttick = function() {
      if (cancelled)
        return;
      if (readable && !(rs && (rs.ended && !rs.destroyed)))
        return callback.call(stream, new Error("premature close"));
      if (writable && !(ws && (ws.ended && !ws.destroyed)))
        return callback.call(stream, new Error("premature close"));
    };
    var onrequest = function() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !ws) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream))
      stream.on("exit", onexit);
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      cancelled = true;
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("exit", onexit);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  };
  module.exports = eos;
});

// node_modules/pump/index.js
var require_pump = __commonJS((exports, module) => {
  var once = require_once();
  var eos = require_end_of_stream();
  var fs;
  try {
    fs = __require("fs");
  } catch (e) {}
  var noop = function() {};
  var ancient = typeof process === "undefined" ? false : /^v?\.0/.test(process.version);
  var isFn = function(fn) {
    return typeof fn === "function";
  };
  var isFS = function(stream) {
    if (!ancient)
      return false;
    if (!fs)
      return false;
    return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
  };
  var isRequest = function(stream) {
    return stream.setHeader && isFn(stream.abort);
  };
  var destroyer = function(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    eos(stream, { readable: reading, writable: writing }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isFS(stream))
        return stream.close(noop);
      if (isRequest(stream))
        return stream.abort();
      if (isFn(stream.destroy))
        return stream.destroy();
      callback(err || new Error("stream was destroyed"));
    };
  };
  var call = function(fn) {
    fn();
  };
  var pipe = function(from, to) {
    return from.pipe(to);
  };
  var pump = function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2)
      throw new Error("pump requires two streams per minimum");
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  };
  module.exports = pump;
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS((exports, module) => {
  var { PassThrough: PassThroughStream } = __require("stream");
  module.exports = (options) => {
    options = { ...options };
    const { array } = options;
    let { encoding } = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || isBuffer);
    } else {
      encoding = encoding || "utf8";
    }
    if (isBuffer) {
      encoding = null;
    }
    const stream = new PassThroughStream({ objectMode });
    if (encoding) {
      stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(chunk);
      if (objectMode) {
        length = chunks.length;
      } else {
        length += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return chunks;
      }
      return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = () => length;
    return stream;
  };
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS((exports, module) => {
  var { constants: BufferConstants } = __require("buffer");
  var pump = require_pump();
  var bufferStream = require_buffer_stream();

  class MaxBufferError extends Error {
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  }
  async function getStream(inputStream, options) {
    if (!inputStream) {
      return Promise.reject(new Error("Expected a stream"));
    }
    options = {
      maxBuffer: Infinity,
      ...options
    };
    const { maxBuffer } = options;
    let stream;
    await new Promise((resolve, reject) => {
      const rejectPromise = (error) => {
        if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
          error.bufferedData = stream.getBufferedValue();
        }
        reject(error);
      };
      stream = pump(inputStream, bufferStream(options), (error) => {
        if (error) {
          rejectPromise(error);
          return;
        }
        resolve();
      });
      stream.on("data", () => {
        if (stream.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError);
        }
      });
    });
    return stream.getBufferedValue();
  }
  module.exports = getStream;
  module.exports.default = getStream;
  module.exports.buffer = (stream, options) => getStream(stream, { ...options, encoding: "buffer" });
  module.exports.array = (stream, options) => getStream(stream, { ...options, array: true });
  module.exports.MaxBufferError = MaxBufferError;
});

// node_modules/pend/index.js
var require_pend = __commonJS((exports, module) => {
  module.exports = Pend;
  function Pend() {
    this.pending = 0;
    this.max = Infinity;
    this.listeners = [];
    this.waiting = [];
    this.error = null;
  }
  Pend.prototype.go = function(fn) {
    if (this.pending < this.max) {
      pendGo(this, fn);
    } else {
      this.waiting.push(fn);
    }
  };
  Pend.prototype.wait = function(cb) {
    if (this.pending === 0) {
      cb(this.error);
    } else {
      this.listeners.push(cb);
    }
  };
  Pend.prototype.hold = function() {
    return pendHold(this);
  };
  function pendHold(self2) {
    self2.pending += 1;
    var called = false;
    return onCb;
    function onCb(err) {
      if (called)
        throw new Error("callback called twice");
      called = true;
      self2.error = self2.error || err;
      self2.pending -= 1;
      if (self2.waiting.length > 0 && self2.pending < self2.max) {
        pendGo(self2, self2.waiting.shift());
      } else if (self2.pending === 0) {
        var listeners = self2.listeners;
        self2.listeners = [];
        listeners.forEach(cbListener);
      }
    }
    function cbListener(listener) {
      listener(self2.error);
    }
  }
  function pendGo(self2, fn) {
    fn(pendHold(self2));
  }
});

// node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS((exports) => {
  var fs = __require("fs");
  var util = __require("util");
  var stream = __require("stream");
  var Readable = stream.Readable;
  var Writable = stream.Writable;
  var PassThrough = stream.PassThrough;
  var Pend = require_pend();
  var EventEmitter = __require("events").EventEmitter;
  exports.createFromBuffer = createFromBuffer;
  exports.createFromFd = createFromFd;
  exports.BufferSlicer = BufferSlicer;
  exports.FdSlicer = FdSlicer;
  util.inherits(FdSlicer, EventEmitter);
  function FdSlicer(fd, options) {
    options = options || {};
    EventEmitter.call(this);
    this.fd = fd;
    this.pend = new Pend;
    this.pend.max = 1;
    this.refCount = 0;
    this.autoClose = !!options.autoClose;
  }
  FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
    var self2 = this;
    self2.pend.go(function(cb) {
      fs.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
        cb();
        callback(err, bytesRead, buffer2);
      });
    });
  };
  FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
    var self2 = this;
    self2.pend.go(function(cb) {
      fs.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
        cb();
        callback(err, written, buffer2);
      });
    });
  };
  FdSlicer.prototype.createReadStream = function(options) {
    return new ReadStream(this, options);
  };
  FdSlicer.prototype.createWriteStream = function(options) {
    return new WriteStream(this, options);
  };
  FdSlicer.prototype.ref = function() {
    this.refCount += 1;
  };
  FdSlicer.prototype.unref = function() {
    var self2 = this;
    self2.refCount -= 1;
    if (self2.refCount > 0)
      return;
    if (self2.refCount < 0)
      throw new Error("invalid unref");
    if (self2.autoClose) {
      fs.close(self2.fd, onCloseDone);
    }
    function onCloseDone(err) {
      if (err) {
        self2.emit("error", err);
      } else {
        self2.emit("close");
      }
    }
  };
  util.inherits(ReadStream, Readable);
  function ReadStream(context, options) {
    options = options || {};
    Readable.call(this, options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end;
    this.pos = this.start;
    this.destroyed = false;
  }
  ReadStream.prototype._read = function(n) {
    var self2 = this;
    if (self2.destroyed)
      return;
    var toRead = Math.min(self2._readableState.highWaterMark, n);
    if (self2.endOffset != null) {
      toRead = Math.min(toRead, self2.endOffset - self2.pos);
    }
    if (toRead <= 0) {
      self2.destroyed = true;
      self2.push(null);
      self2.context.unref();
      return;
    }
    self2.context.pend.go(function(cb) {
      if (self2.destroyed)
        return cb();
      var buffer = new Buffer(toRead);
      fs.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
        if (err) {
          self2.destroy(err);
        } else if (bytesRead === 0) {
          self2.destroyed = true;
          self2.push(null);
          self2.context.unref();
        } else {
          self2.pos += bytesRead;
          self2.push(buffer.slice(0, bytesRead));
        }
        cb();
      });
    });
  };
  ReadStream.prototype.destroy = function(err) {
    if (this.destroyed)
      return;
    err = err || new Error("stream destroyed");
    this.destroyed = true;
    this.emit("error", err);
    this.context.unref();
  };
  util.inherits(WriteStream, Writable);
  function WriteStream(context, options) {
    options = options || {};
    Writable.call(this, options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end == null ? Infinity : +options.end;
    this.bytesWritten = 0;
    this.pos = this.start;
    this.destroyed = false;
    this.on("finish", this.destroy.bind(this));
  }
  WriteStream.prototype._write = function(buffer, encoding, callback) {
    var self2 = this;
    if (self2.destroyed)
      return;
    if (self2.pos + buffer.length > self2.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = "ETOOBIG";
      self2.destroy();
      callback(err);
      return;
    }
    self2.context.pend.go(function(cb) {
      if (self2.destroyed)
        return cb();
      fs.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
        if (err2) {
          self2.destroy();
          cb();
          callback(err2);
        } else {
          self2.bytesWritten += bytes;
          self2.pos += bytes;
          self2.emit("progress");
          cb();
          callback();
        }
      });
    });
  };
  WriteStream.prototype.destroy = function() {
    if (this.destroyed)
      return;
    this.destroyed = true;
    this.context.unref();
  };
  util.inherits(BufferSlicer, EventEmitter);
  function BufferSlicer(buffer, options) {
    EventEmitter.call(this);
    options = options || {};
    this.refCount = 0;
    this.buffer = buffer;
    this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
  }
  BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
    var end = position + length;
    var delta = end - this.buffer.length;
    var written = delta > 0 ? delta : length;
    this.buffer.copy(buffer, offset, position, end);
    setImmediate(function() {
      callback(null, written);
    });
  };
  BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
    buffer.copy(this.buffer, position, offset, offset + length);
    setImmediate(function() {
      callback(null, length, buffer);
    });
  };
  BufferSlicer.prototype.createReadStream = function(options) {
    options = options || {};
    var readStream = new PassThrough(options);
    readStream.destroyed = false;
    readStream.start = options.start || 0;
    readStream.endOffset = options.end;
    readStream.pos = readStream.endOffset || this.buffer.length;
    var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
    var offset = 0;
    while (true) {
      var nextOffset = offset + this.maxChunkSize;
      if (nextOffset >= entireSlice.length) {
        if (offset < entireSlice.length) {
          readStream.write(entireSlice.slice(offset, entireSlice.length));
        }
        break;
      }
      readStream.write(entireSlice.slice(offset, nextOffset));
      offset = nextOffset;
    }
    readStream.end();
    readStream.destroy = function() {
      readStream.destroyed = true;
    };
    return readStream;
  };
  BufferSlicer.prototype.createWriteStream = function(options) {
    var bufferSlicer = this;
    options = options || {};
    var writeStream = new Writable(options);
    writeStream.start = options.start || 0;
    writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
    writeStream.bytesWritten = 0;
    writeStream.pos = writeStream.start;
    writeStream.destroyed = false;
    writeStream._write = function(buffer, encoding, callback) {
      if (writeStream.destroyed)
        return;
      var end = writeStream.pos + buffer.length;
      if (end > writeStream.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        writeStream.destroyed = true;
        callback(err);
        return;
      }
      buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
      writeStream.bytesWritten += buffer.length;
      writeStream.pos = end;
      writeStream.emit("progress");
      callback();
    };
    writeStream.destroy = function() {
      writeStream.destroyed = true;
    };
    return writeStream;
  };
  BufferSlicer.prototype.ref = function() {
    this.refCount += 1;
  };
  BufferSlicer.prototype.unref = function() {
    this.refCount -= 1;
    if (this.refCount < 0) {
      throw new Error("invalid unref");
    }
  };
  function createFromBuffer(buffer, options) {
    return new BufferSlicer(buffer, options);
  }
  function createFromFd(fd, options) {
    return new FdSlicer(fd, options);
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  var CRC_TABLE = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  if (typeof Int32Array !== "undefined") {
    CRC_TABLE = new Int32Array(CRC_TABLE);
  }
  function ensureBuffer(input) {
    if (Buffer2.isBuffer(input)) {
      return input;
    }
    var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
    if (typeof input === "number") {
      return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
    } else if (typeof input === "string") {
      return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
    } else {
      throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
  }
  function bufferizeInt(num) {
    var tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
  }
  function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer2.isBuffer(previous)) {
      previous = previous.readUInt32BE(0);
    }
    var crc = ~~previous ^ -1;
    for (var n = 0;n < buf.length; n++) {
      crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  }
  function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  crc32.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  module.exports = crc32;
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS((exports) => {
  var fs = __require("fs");
  var zlib = __require("zlib");
  var fd_slicer = require_fd_slicer();
  var crc32 = require_buffer_crc32();
  var util = __require("util");
  var EventEmitter = __require("events").EventEmitter;
  var Transform = __require("stream").Transform;
  var PassThrough = __require("stream").PassThrough;
  var Writable = __require("stream").Writable;
  exports.open = open;
  exports.fromFd = fromFd;
  exports.fromBuffer = fromBuffer;
  exports.fromRandomAccessReader = fromRandomAccessReader;
  exports.dosDateTimeToDate = dosDateTimeToDate;
  exports.validateFileName = validateFileName;
  exports.ZipFile = ZipFile;
  exports.Entry = Entry;
  exports.RandomAccessReader = RandomAccessReader;
  function open(path, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (options == null)
      options = {};
    if (options.autoClose == null)
      options.autoClose = true;
    if (options.lazyEntries == null)
      options.lazyEntries = false;
    if (options.decodeStrings == null)
      options.decodeStrings = true;
    if (options.validateEntrySizes == null)
      options.validateEntrySizes = true;
    if (options.strictFileNames == null)
      options.strictFileNames = false;
    if (callback == null)
      callback = defaultCallback;
    fs.open(path, "r", function(err, fd) {
      if (err)
        return callback(err);
      fromFd(fd, options, function(err2, zipfile) {
        if (err2)
          fs.close(fd, defaultCallback);
        callback(err2, zipfile);
      });
    });
  }
  function fromFd(fd, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (options == null)
      options = {};
    if (options.autoClose == null)
      options.autoClose = false;
    if (options.lazyEntries == null)
      options.lazyEntries = false;
    if (options.decodeStrings == null)
      options.decodeStrings = true;
    if (options.validateEntrySizes == null)
      options.validateEntrySizes = true;
    if (options.strictFileNames == null)
      options.strictFileNames = false;
    if (callback == null)
      callback = defaultCallback;
    fs.fstat(fd, function(err, stats) {
      if (err)
        return callback(err);
      var reader = fd_slicer.createFromFd(fd, { autoClose: true });
      fromRandomAccessReader(reader, stats.size, options, callback);
    });
  }
  function fromBuffer(buffer, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (options == null)
      options = {};
    options.autoClose = false;
    if (options.lazyEntries == null)
      options.lazyEntries = false;
    if (options.decodeStrings == null)
      options.decodeStrings = true;
    if (options.validateEntrySizes == null)
      options.validateEntrySizes = true;
    if (options.strictFileNames == null)
      options.strictFileNames = false;
    var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
    fromRandomAccessReader(reader, buffer.length, options, callback);
  }
  function fromRandomAccessReader(reader, totalSize, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (options == null)
      options = {};
    if (options.autoClose == null)
      options.autoClose = true;
    if (options.lazyEntries == null)
      options.lazyEntries = false;
    if (options.decodeStrings == null)
      options.decodeStrings = true;
    var decodeStrings = !!options.decodeStrings;
    if (options.validateEntrySizes == null)
      options.validateEntrySizes = true;
    if (options.strictFileNames == null)
      options.strictFileNames = false;
    if (callback == null)
      callback = defaultCallback;
    if (typeof totalSize !== "number")
      throw new Error("expected totalSize parameter to be a number");
    if (totalSize > Number.MAX_SAFE_INTEGER) {
      throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
    }
    reader.ref();
    var eocdrWithoutCommentSize = 22;
    var maxCommentSize = 65535;
    var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
    var buffer = newBuffer(bufferSize);
    var bufferReadStart = totalSize - buffer.length;
    readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
      if (err)
        return callback(err);
      for (var i = bufferSize - eocdrWithoutCommentSize;i >= 0; i -= 1) {
        if (buffer.readUInt32LE(i) !== 101010256)
          continue;
        var eocdrBuffer = buffer.slice(i);
        var diskNumber = eocdrBuffer.readUInt16LE(4);
        if (diskNumber !== 0) {
          return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
        }
        var entryCount = eocdrBuffer.readUInt16LE(10);
        var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
        var commentLength = eocdrBuffer.readUInt16LE(20);
        var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
        if (commentLength !== expectedCommentLength) {
          return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
        }
        var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
        if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
        }
        var zip64EocdlBuffer = newBuffer(20);
        var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
        readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
          if (err2)
            return callback(err2);
          if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
            return callback(new Error("invalid zip64 end of central directory locator signature"));
          }
          var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
          var zip64EocdrBuffer = newBuffer(56);
          readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
            if (err3)
              return callback(err3);
            if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
              return callback(new Error("invalid zip64 end of central directory record signature"));
            }
            entryCount = readUInt64LE(zip64EocdrBuffer, 32);
            centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          });
        });
        return;
      }
      callback(new Error("end of central directory record signature not found"));
    });
  }
  util.inherits(ZipFile, EventEmitter);
  function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
    var self2 = this;
    EventEmitter.call(self2);
    self2.reader = reader;
    self2.reader.on("error", function(err) {
      emitError(self2, err);
    });
    self2.reader.once("close", function() {
      self2.emit("close");
    });
    self2.readEntryCursor = centralDirectoryOffset;
    self2.fileSize = fileSize;
    self2.entryCount = entryCount;
    self2.comment = comment;
    self2.entriesRead = 0;
    self2.autoClose = !!autoClose;
    self2.lazyEntries = !!lazyEntries;
    self2.decodeStrings = !!decodeStrings;
    self2.validateEntrySizes = !!validateEntrySizes;
    self2.strictFileNames = !!strictFileNames;
    self2.isOpen = true;
    self2.emittedError = false;
    if (!self2.lazyEntries)
      self2._readEntry();
  }
  ZipFile.prototype.close = function() {
    if (!this.isOpen)
      return;
    this.isOpen = false;
    this.reader.unref();
  };
  function emitErrorAndAutoClose(self2, err) {
    if (self2.autoClose)
      self2.close();
    emitError(self2, err);
  }
  function emitError(self2, err) {
    if (self2.emittedError)
      return;
    self2.emittedError = true;
    self2.emit("error", err);
  }
  ZipFile.prototype.readEntry = function() {
    if (!this.lazyEntries)
      throw new Error("readEntry() called without lazyEntries:true");
    this._readEntry();
  };
  ZipFile.prototype._readEntry = function() {
    var self2 = this;
    if (self2.entryCount === self2.entriesRead) {
      setImmediate(function() {
        if (self2.autoClose)
          self2.close();
        if (self2.emittedError)
          return;
        self2.emit("end");
      });
      return;
    }
    if (self2.emittedError)
      return;
    var buffer = newBuffer(46);
    readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
      if (err)
        return emitErrorAndAutoClose(self2, err);
      if (self2.emittedError)
        return;
      var entry = new Entry;
      var signature = buffer.readUInt32LE(0);
      if (signature !== 33639248)
        return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
      entry.versionMadeBy = buffer.readUInt16LE(4);
      entry.versionNeededToExtract = buffer.readUInt16LE(6);
      entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
      entry.compressionMethod = buffer.readUInt16LE(10);
      entry.lastModFileTime = buffer.readUInt16LE(12);
      entry.lastModFileDate = buffer.readUInt16LE(14);
      entry.crc32 = buffer.readUInt32LE(16);
      entry.compressedSize = buffer.readUInt32LE(20);
      entry.uncompressedSize = buffer.readUInt32LE(24);
      entry.fileNameLength = buffer.readUInt16LE(28);
      entry.extraFieldLength = buffer.readUInt16LE(30);
      entry.fileCommentLength = buffer.readUInt16LE(32);
      entry.internalFileAttributes = buffer.readUInt16LE(36);
      entry.externalFileAttributes = buffer.readUInt32LE(38);
      entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
      if (entry.generalPurposeBitFlag & 64)
        return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
      self2.readEntryCursor += 46;
      buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
        if (err2)
          return emitErrorAndAutoClose(self2, err2);
        if (self2.emittedError)
          return;
        var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
        entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
        var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
        var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
        entry.extraFields = [];
        var i = 0;
        while (i < extraFieldBuffer.length - 3) {
          var headerId = extraFieldBuffer.readUInt16LE(i + 0);
          var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
          var dataStart = i + 4;
          var dataEnd = dataStart + dataSize;
          if (dataEnd > extraFieldBuffer.length)
            return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
          var dataBuffer = newBuffer(dataSize);
          extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
          entry.extraFields.push({
            id: headerId,
            data: dataBuffer
          });
          i = dataEnd;
        }
        entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
        entry.comment = entry.fileComment;
        self2.readEntryCursor += buffer.length;
        self2.entriesRead += 1;
        if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
          var zip64EiefBuffer = null;
          for (var i = 0;i < entry.extraFields.length; i++) {
            var extraField = entry.extraFields[i];
            if (extraField.id === 1) {
              zip64EiefBuffer = extraField.data;
              break;
            }
          }
          if (zip64EiefBuffer == null) {
            return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
          }
          var index = 0;
          if (entry.uncompressedSize === 4294967295) {
            if (index + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
            }
            entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
            index += 8;
          }
          if (entry.compressedSize === 4294967295) {
            if (index + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
            }
            entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
            index += 8;
          }
          if (entry.relativeOffsetOfLocalHeader === 4294967295) {
            if (index + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
            }
            entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
            index += 8;
          }
        }
        if (self2.decodeStrings) {
          for (var i = 0;i < entry.extraFields.length; i++) {
            var extraField = entry.extraFields[i];
            if (extraField.id === 28789) {
              if (extraField.data.length < 6) {
                continue;
              }
              if (extraField.data.readUInt8(0) !== 1) {
                continue;
              }
              var oldNameCrc32 = extraField.data.readUInt32LE(1);
              if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                continue;
              }
              entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
              break;
            }
          }
        }
        if (self2.validateEntrySizes && entry.compressionMethod === 0) {
          var expectedCompressedSize = entry.uncompressedSize;
          if (entry.isEncrypted()) {
            expectedCompressedSize += 12;
          }
          if (entry.compressedSize !== expectedCompressedSize) {
            var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
            return emitErrorAndAutoClose(self2, new Error(msg));
          }
        }
        if (self2.decodeStrings) {
          if (!self2.strictFileNames) {
            entry.fileName = entry.fileName.replace(/\\/g, "/");
          }
          var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
          if (errorMessage != null)
            return emitErrorAndAutoClose(self2, new Error(errorMessage));
        }
        self2.emit("entry", entry);
        if (!self2.lazyEntries)
          self2._readEntry();
      });
    });
  };
  ZipFile.prototype.openReadStream = function(entry, options, callback) {
    var self2 = this;
    var relativeStart = 0;
    var relativeEnd = entry.compressedSize;
    if (callback == null) {
      callback = options;
      options = {};
    } else {
      if (options.decrypt != null) {
        if (!entry.isEncrypted()) {
          throw new Error("options.decrypt can only be specified for encrypted entries");
        }
        if (options.decrypt !== false)
          throw new Error("invalid options.decrypt value: " + options.decrypt);
        if (entry.isCompressed()) {
          if (options.decompress !== false)
            throw new Error("entry is encrypted and compressed, and options.decompress !== false");
        }
      }
      if (options.decompress != null) {
        if (!entry.isCompressed()) {
          throw new Error("options.decompress can only be specified for compressed entries");
        }
        if (!(options.decompress === false || options.decompress === true)) {
          throw new Error("invalid options.decompress value: " + options.decompress);
        }
      }
      if (options.start != null || options.end != null) {
        if (entry.isCompressed() && options.decompress !== false) {
          throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
        }
        if (entry.isEncrypted() && options.decrypt !== false) {
          throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
        }
      }
      if (options.start != null) {
        relativeStart = options.start;
        if (relativeStart < 0)
          throw new Error("options.start < 0");
        if (relativeStart > entry.compressedSize)
          throw new Error("options.start > entry.compressedSize");
      }
      if (options.end != null) {
        relativeEnd = options.end;
        if (relativeEnd < 0)
          throw new Error("options.end < 0");
        if (relativeEnd > entry.compressedSize)
          throw new Error("options.end > entry.compressedSize");
        if (relativeEnd < relativeStart)
          throw new Error("options.end < options.start");
      }
    }
    if (!self2.isOpen)
      return callback(new Error("closed"));
    if (entry.isEncrypted()) {
      if (options.decrypt !== false)
        return callback(new Error("entry is encrypted, and options.decrypt !== false"));
    }
    self2.reader.ref();
    var buffer = newBuffer(30);
    readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
      try {
        if (err)
          return callback(err);
        var signature = buffer.readUInt32LE(0);
        if (signature !== 67324752) {
          return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
        }
        var fileNameLength = buffer.readUInt16LE(26);
        var extraFieldLength = buffer.readUInt16LE(28);
        var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
        var decompress;
        if (entry.compressionMethod === 0) {
          decompress = false;
        } else if (entry.compressionMethod === 8) {
          decompress = options.decompress != null ? options.decompress : true;
        } else {
          return callback(new Error("unsupported compression method: " + entry.compressionMethod));
        }
        var fileDataStart = localFileHeaderEnd;
        var fileDataEnd = fileDataStart + entry.compressedSize;
        if (entry.compressedSize !== 0) {
          if (fileDataEnd > self2.fileSize) {
            return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
          }
        }
        var readStream = self2.reader.createReadStream({
          start: fileDataStart + relativeStart,
          end: fileDataStart + relativeEnd
        });
        var endpointStream = readStream;
        if (decompress) {
          var destroyed = false;
          var inflateFilter = zlib.createInflateRaw();
          readStream.on("error", function(err2) {
            setImmediate(function() {
              if (!destroyed)
                inflateFilter.emit("error", err2);
            });
          });
          readStream.pipe(inflateFilter);
          if (self2.validateEntrySizes) {
            endpointStream = new AssertByteCountStream(entry.uncompressedSize);
            inflateFilter.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  endpointStream.emit("error", err2);
              });
            });
            inflateFilter.pipe(endpointStream);
          } else {
            endpointStream = inflateFilter;
          }
          endpointStream.destroy = function() {
            destroyed = true;
            if (inflateFilter !== endpointStream)
              inflateFilter.unpipe(endpointStream);
            readStream.unpipe(inflateFilter);
            readStream.destroy();
          };
        }
        callback(null, endpointStream);
      } finally {
        self2.reader.unref();
      }
    });
  };
  function Entry() {}
  Entry.prototype.getLastModDate = function() {
    return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
  };
  Entry.prototype.isEncrypted = function() {
    return (this.generalPurposeBitFlag & 1) !== 0;
  };
  Entry.prototype.isCompressed = function() {
    return this.compressionMethod === 8;
  };
  function dosDateTimeToDate(date, time) {
    var day = date & 31;
    var month = (date >> 5 & 15) - 1;
    var year = (date >> 9 & 127) + 1980;
    var millisecond = 0;
    var second = (time & 31) * 2;
    var minute = time >> 5 & 63;
    var hour = time >> 11 & 31;
    return new Date(year, month, day, hour, minute, second, millisecond);
  }
  function validateFileName(fileName) {
    if (fileName.indexOf("\\") !== -1) {
      return "invalid characters in fileName: " + fileName;
    }
    if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
      return "absolute path: " + fileName;
    }
    if (fileName.split("/").indexOf("..") !== -1) {
      return "invalid relative path: " + fileName;
    }
    return null;
  }
  function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
    if (length === 0) {
      return setImmediate(function() {
        callback(null, newBuffer(0));
      });
    }
    reader.read(buffer, offset, length, position, function(err, bytesRead) {
      if (err)
        return callback(err);
      if (bytesRead < length) {
        return callback(new Error("unexpected EOF"));
      }
      callback();
    });
  }
  util.inherits(AssertByteCountStream, Transform);
  function AssertByteCountStream(byteCount) {
    Transform.call(this);
    this.actualByteCount = 0;
    this.expectedByteCount = byteCount;
  }
  AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
    this.actualByteCount += chunk.length;
    if (this.actualByteCount > this.expectedByteCount) {
      var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
      return cb(new Error(msg));
    }
    cb(null, chunk);
  };
  AssertByteCountStream.prototype._flush = function(cb) {
    if (this.actualByteCount < this.expectedByteCount) {
      var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
      return cb(new Error(msg));
    }
    cb();
  };
  util.inherits(RandomAccessReader, EventEmitter);
  function RandomAccessReader() {
    EventEmitter.call(this);
    this.refCount = 0;
  }
  RandomAccessReader.prototype.ref = function() {
    this.refCount += 1;
  };
  RandomAccessReader.prototype.unref = function() {
    var self2 = this;
    self2.refCount -= 1;
    if (self2.refCount > 0)
      return;
    if (self2.refCount < 0)
      throw new Error("invalid unref");
    self2.close(onCloseDone);
    function onCloseDone(err) {
      if (err)
        return self2.emit("error", err);
      self2.emit("close");
    }
  };
  RandomAccessReader.prototype.createReadStream = function(options) {
    var start = options.start;
    var end = options.end;
    if (start === end) {
      var emptyStream = new PassThrough;
      setImmediate(function() {
        emptyStream.end();
      });
      return emptyStream;
    }
    var stream = this._readStreamForRange(start, end);
    var destroyed = false;
    var refUnrefFilter = new RefUnrefFilter(this);
    stream.on("error", function(err) {
      setImmediate(function() {
        if (!destroyed)
          refUnrefFilter.emit("error", err);
      });
    });
    refUnrefFilter.destroy = function() {
      stream.unpipe(refUnrefFilter);
      refUnrefFilter.unref();
      stream.destroy();
    };
    var byteCounter = new AssertByteCountStream(end - start);
    refUnrefFilter.on("error", function(err) {
      setImmediate(function() {
        if (!destroyed)
          byteCounter.emit("error", err);
      });
    });
    byteCounter.destroy = function() {
      destroyed = true;
      refUnrefFilter.unpipe(byteCounter);
      refUnrefFilter.destroy();
    };
    return stream.pipe(refUnrefFilter).pipe(byteCounter);
  };
  RandomAccessReader.prototype._readStreamForRange = function(start, end) {
    throw new Error("not implemented");
  };
  RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
    var readStream = this.createReadStream({ start: position, end: position + length });
    var writeStream = new Writable;
    var written = 0;
    writeStream._write = function(chunk, encoding, cb) {
      chunk.copy(buffer, offset + written, 0, chunk.length);
      written += chunk.length;
      cb();
    };
    writeStream.on("finish", callback);
    readStream.on("error", function(error) {
      callback(error);
    });
    readStream.pipe(writeStream);
  };
  RandomAccessReader.prototype.close = function(callback) {
    setImmediate(callback);
  };
  util.inherits(RefUnrefFilter, PassThrough);
  function RefUnrefFilter(context) {
    PassThrough.call(this);
    this.context = context;
    this.context.ref();
    this.unreffedYet = false;
  }
  RefUnrefFilter.prototype._flush = function(cb) {
    this.unref();
    cb();
  };
  RefUnrefFilter.prototype.unref = function(cb) {
    if (this.unreffedYet)
      return;
    this.unreffedYet = true;
    this.context.unref();
  };
  var cp437 = "\x00☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ";
  function decodeBuffer(buffer, start, end, isUtf8) {
    if (isUtf8) {
      return buffer.toString("utf8", start, end);
    } else {
      var result = "";
      for (var i = start;i < end; i++) {
        result += cp437[buffer[i]];
      }
      return result;
    }
  }
  function readUInt64LE(buffer, offset) {
    var lower32 = buffer.readUInt32LE(offset);
    var upper32 = buffer.readUInt32LE(offset + 4);
    return upper32 * 4294967296 + lower32;
  }
  var newBuffer;
  if (typeof Buffer.allocUnsafe === "function") {
    newBuffer = function(len) {
      return Buffer.allocUnsafe(len);
    };
  } else {
    newBuffer = function(len) {
      return new Buffer(len);
    };
  }
  function defaultCallback(err) {
    if (err)
      throw err;
  }
});

// node_modules/extract-zip/index.js
var require_extract_zip = __commonJS((exports, module) => {
  var debug = require_src2()("extract-zip");
  var { createWriteStream, promises: fs } = __require("fs");
  var getStream = require_get_stream();
  var path = __require("path");
  var { promisify } = __require("util");
  var stream = __require("stream");
  var yauzl = require_yauzl();
  var openZip = promisify(yauzl.open);
  var pipeline = promisify(stream.pipeline);

  class Extractor {
    constructor(zipPath, opts) {
      this.zipPath = zipPath;
      this.opts = opts;
    }
    async extract() {
      debug("opening", this.zipPath, "with opts", this.opts);
      this.zipfile = await openZip(this.zipPath, { lazyEntries: true });
      this.canceled = false;
      return new Promise((resolve, reject) => {
        this.zipfile.on("error", (err) => {
          this.canceled = true;
          reject(err);
        });
        this.zipfile.readEntry();
        this.zipfile.on("close", () => {
          if (!this.canceled) {
            debug("zip extraction complete");
            resolve();
          }
        });
        this.zipfile.on("entry", async (entry) => {
          if (this.canceled) {
            debug("skipping entry", entry.fileName, { cancelled: this.canceled });
            return;
          }
          debug("zipfile entry", entry.fileName);
          if (entry.fileName.startsWith("__MACOSX/")) {
            this.zipfile.readEntry();
            return;
          }
          const destDir = path.dirname(path.join(this.opts.dir, entry.fileName));
          try {
            await fs.mkdir(destDir, { recursive: true });
            const canonicalDestDir = await fs.realpath(destDir);
            const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir);
            if (relativeDestDir.split(path.sep).includes("..")) {
              throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
            }
            await this.extractEntry(entry);
            debug("finished processing", entry.fileName);
            this.zipfile.readEntry();
          } catch (err) {
            this.canceled = true;
            this.zipfile.close();
            reject(err);
          }
        });
      });
    }
    async extractEntry(entry) {
      if (this.canceled) {
        debug("skipping entry extraction", entry.fileName, { cancelled: this.canceled });
        return;
      }
      if (this.opts.onEntry) {
        this.opts.onEntry(entry, this.zipfile);
      }
      const dest = path.join(this.opts.dir, entry.fileName);
      const mode = entry.externalFileAttributes >> 16 & 65535;
      const IFMT = 61440;
      const IFDIR = 16384;
      const IFLNK = 40960;
      const symlink = (mode & IFMT) === IFLNK;
      let isDir = (mode & IFMT) === IFDIR;
      if (!isDir && entry.fileName.endsWith("/")) {
        isDir = true;
      }
      const madeBy = entry.versionMadeBy >> 8;
      if (!isDir)
        isDir = madeBy === 0 && entry.externalFileAttributes === 16;
      debug("extracting entry", { filename: entry.fileName, isDir, isSymlink: symlink });
      const procMode = this.getExtractedMode(mode, isDir) & 511;
      const destDir = isDir ? dest : path.dirname(dest);
      const mkdirOptions = { recursive: true };
      if (isDir) {
        mkdirOptions.mode = procMode;
      }
      debug("mkdir", { dir: destDir, ...mkdirOptions });
      await fs.mkdir(destDir, mkdirOptions);
      if (isDir)
        return;
      debug("opening read stream", dest);
      const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);
      if (symlink) {
        const link = await getStream(readStream);
        debug("creating symlink", link, dest);
        await fs.symlink(link, dest);
      } else {
        await pipeline(readStream, createWriteStream(dest, { mode: procMode }));
      }
    }
    getExtractedMode(entryMode, isDir) {
      let mode = entryMode;
      if (mode === 0) {
        if (isDir) {
          if (this.opts.defaultDirMode) {
            mode = parseInt(this.opts.defaultDirMode, 10);
          }
          if (!mode) {
            mode = 493;
          }
        } else {
          if (this.opts.defaultFileMode) {
            mode = parseInt(this.opts.defaultFileMode, 10);
          }
          if (!mode) {
            mode = 420;
          }
        }
      }
      return mode;
    }
  }
  module.exports = async function(zipPath, opts) {
    debug("creating target directory", opts.dir);
    if (!path.isAbsolute(opts.dir)) {
      throw new Error("Target directory is expected to be absolute");
    }
    await fs.mkdir(opts.dir, { recursive: true });
    opts.dir = await fs.realpath(opts.dir);
    return new Extractor(zipPath, opts).extract();
  };
});

// node_modules/https-proxy-agent/node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function promisify(fn) {
    return function(req, opts) {
      return new Promise((resolve, reject) => {
        fn.call(this, req, opts, (err, rtn) => {
          if (err) {
            reject(err);
          } else {
            resolve(rtn);
          }
        });
      });
    };
  }
  exports.default = promisify;
});

// node_modules/https-proxy-agent/node_modules/agent-base/dist/src/index.js
var require_src3 = __commonJS((exports, module) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  var events_1 = __require("events");
  var debug_1 = __importDefault(require_src2());
  var promisify_1 = __importDefault(require_promisify());
  var debug = debug_1.default("agent-base");
  function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === "function";
  }
  function isSecureEndpoint() {
    const { stack } = new Error;
    if (typeof stack !== "string")
      return false;
    return stack.split(`
`).some((l2) => l2.indexOf("(https.js:") !== -1 || l2.indexOf("node:https:") !== -1);
  }
  function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
  }
  (function(createAgent2) {

    class Agent extends events_1.EventEmitter {
      constructor(callback, _opts) {
        super();
        let opts = _opts;
        if (typeof callback === "function") {
          this.callback = callback;
        } else if (callback) {
          opts = callback;
        }
        this.timeout = null;
        if (opts && typeof opts.timeout === "number") {
          this.timeout = opts.timeout;
        }
        this.maxFreeSockets = 1;
        this.maxSockets = 1;
        this.maxTotalSockets = Infinity;
        this.sockets = {};
        this.freeSockets = {};
        this.requests = {};
        this.options = {};
      }
      get defaultPort() {
        if (typeof this.explicitDefaultPort === "number") {
          return this.explicitDefaultPort;
        }
        return isSecureEndpoint() ? 443 : 80;
      }
      set defaultPort(v) {
        this.explicitDefaultPort = v;
      }
      get protocol() {
        if (typeof this.explicitProtocol === "string") {
          return this.explicitProtocol;
        }
        return isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        this.explicitProtocol = v;
      }
      callback(req, opts, fn) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
      }
      addRequest(req, _opts) {
        const opts = Object.assign({}, _opts);
        if (typeof opts.secureEndpoint !== "boolean") {
          opts.secureEndpoint = isSecureEndpoint();
        }
        if (opts.host == null) {
          opts.host = "localhost";
        }
        if (opts.port == null) {
          opts.port = opts.secureEndpoint ? 443 : 80;
        }
        if (opts.protocol == null) {
          opts.protocol = opts.secureEndpoint ? "https:" : "http:";
        }
        if (opts.host && opts.path) {
          delete opts.path;
        }
        delete opts.agent;
        delete opts.hostname;
        delete opts._defaultAgent;
        delete opts.defaultPort;
        delete opts.createConnection;
        req._last = true;
        req.shouldKeepAlive = false;
        let timedOut = false;
        let timeoutId = null;
        const timeoutMs = opts.timeout || this.timeout;
        const onerror = (err) => {
          if (req._hadError)
            return;
          req.emit("error", err);
          req._hadError = true;
        };
        const ontimeout = () => {
          timeoutId = null;
          timedOut = true;
          const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
          err.code = "ETIMEOUT";
          onerror(err);
        };
        const callbackError = (err) => {
          if (timedOut)
            return;
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          onerror(err);
        };
        const onsocket = (socket) => {
          if (timedOut)
            return;
          if (timeoutId != null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          if (isAgent(socket)) {
            debug("Callback returned another Agent instance %o", socket.constructor.name);
            socket.addRequest(req, opts);
            return;
          }
          if (socket) {
            socket.once("free", () => {
              this.freeSocket(socket, opts);
            });
            req.onSocket(socket);
            return;
          }
          const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
          onerror(err);
        };
        if (typeof this.callback !== "function") {
          onerror(new Error("`callback` is not defined"));
          return;
        }
        if (!this.promisifiedCallback) {
          if (this.callback.length >= 3) {
            debug("Converting legacy callback function to promise");
            this.promisifiedCallback = promisify_1.default(this.callback);
          } else {
            this.promisifiedCallback = this.callback;
          }
        }
        if (typeof timeoutMs === "number" && timeoutMs > 0) {
          timeoutId = setTimeout(ontimeout, timeoutMs);
        }
        if ("port" in opts && typeof opts.port !== "number") {
          opts.port = Number(opts.port);
        }
        try {
          debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
          Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
        } catch (err) {
          Promise.reject(err).catch(callbackError);
        }
      }
      freeSocket(socket, opts) {
        debug("Freeing socket %o %o", socket.constructor.name, opts);
        socket.destroy();
      }
      destroy() {
        debug("Destroying agent %o", this.constructor.name);
      }
    }
    createAgent2.Agent = Agent;
    createAgent2.prototype = createAgent2.Agent.prototype;
  })(createAgent || (createAgent = {}));
  module.exports = createAgent;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debug_1 = __importDefault(require_src2());
  var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("close", onclose);
        socket.removeListener("readable", read);
      }
      function onclose(err) {
        debug("onclose had error %o", err);
      }
      function onend() {
        debug("onend");
      }
      function onerror(err) {
        cleanup();
        debug("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf(`\r
\r
`);
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const firstLine = buffered.toString("ascii", 0, buffered.indexOf(`\r
`));
        const statusCode = +firstLine.split(" ")[1];
        debug("got proxy server response: %o", firstLine);
        resolve({
          statusCode,
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("close", onclose);
      socket.on("end", onend);
      read();
    });
  }
  exports.default = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var net_1 = __importDefault(__require("net"));
  var tls_1 = __importDefault(__require("tls"));
  var url_1 = __importDefault(__require("url"));
  var assert_1 = __importDefault(__require("assert"));
  var debug_1 = __importDefault(require_src2());
  var agent_base_1 = require_src3();
  var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
  var debug = debug_1.default("https-proxy-agent:agent");

  class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug("creating new HttpsProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (this.secureProxy && !("ALPNProtocols" in proxy)) {
        proxy.ALPNProtocols = ["http 1.1"];
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    callback(req, opts) {
      return __awaiter(this, undefined, undefined, function* () {
        const { proxy, secureProxy } = this;
        let socket;
        if (secureProxy) {
          debug("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        const headers = Object.assign({}, proxy.headers);
        const hostname = `${opts.host}:${opts.port}`;
        let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
        if (proxy.auth) {
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
        }
        let { host, port, secureEndpoint } = opts;
        if (!isDefaultPort(port, secureEndpoint)) {
          host += `:${port}`;
        }
        headers.Host = host;
        headers.Connection = "close";
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = parse_proxy_response_1.default(socket);
        socket.write(`${payload}\r
`);
        const { statusCode, buffered } = yield proxyResponsePromise;
        if (statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }));
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net_1.default.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug("replaying proxy buffer for failed request");
          assert_1.default(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      });
    }
  }
  exports.default = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function isDefaultPort(port, secure) {
    return Boolean(!secure && port === 80 || secure && port === 443);
  }
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  function omit(obj2, ...keys) {
    const ret = {};
    let key2;
    for (key2 in obj2) {
      if (!keys.includes(key2)) {
        ret[key2] = obj2[key2];
      }
    }
    return ret;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  var agent_1 = __importDefault(require_agent());
  function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  (function(createHttpsProxyAgent2) {
    createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent2.prototype = agent_1.default.prototype;
  })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
  module.exports = createHttpsProxyAgent;
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS((exports) => {
  var parseUrl = __require("url").parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl(url) {
    var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  function getEnv(key2) {
    return process.env[key2.toLowerCase()] || process.env[key2.toUpperCase()] || "";
  }
  exports.getProxyForUrl = getProxyForUrl;
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS((exports) => {
  var pathModule = __require("path");
  var isWindows = process.platform === "win32";
  var fs = __require("fs");
  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error;
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb === "function" ? cb : rethrow();
  }
  var normalize = pathModule.normalize;
  if (isWindows) {
    nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  var nextPartRe;
  if (isWindows) {
    splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    splitRootRe = /^[\/]*/;
  }
  var splitRootRe;
  exports.realpathSync = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m2 = splitRootRe.exec(p);
      pos = m2[0].length;
      current = m2[0];
      base = m2[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat = fs.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs.statSync(base);
          linkTarget = fs.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache)
          cache[base] = resolvedLink;
        if (!isWindows)
          seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache)
      cache[original] = p;
    return p;
  };
  exports.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m2 = splitRootRe.exec(p);
      pos = m2[0].length;
      current = m2[0];
      base = m2[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs.lstat(base, function(err) {
          if (err)
            return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache)
          cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
      if (err)
        return cb(err);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache)
          cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows) {
        var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs.stat(base, function(err2) {
        if (err2)
          return cb(err2);
        fs.readlink(base, function(err3, target) {
          if (!isWindows)
            seenLinks[id] = target;
          gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base2) {
      if (err)
        return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache)
        cache[base2] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS((exports, module) => {
  module.exports = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs = __require("fs");
  var origRealpath = fs.realpath;
  var origRealpathSync = fs.realpathSync;
  var version = process.version;
  var ok = /^v[0-5]\./.test(version);
  var old = require_old();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }
  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }
  function monkeypatch() {
    fs.realpath = realpath;
    fs.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs.realpath = origRealpath;
    fs.realpathSync = origRealpathSync;
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports, module) => {
  module.exports = function(xs, fn) {
    var res = [];
    for (var i = 0;i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports, module) => {
  module.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m2 = str.match(reg);
    return m2 ? m2[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports, module) => {
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module.exports = expandTop;
  var escSlash = "\x00SLASH" + Math.random() + "\x00";
  var escOpen = "\x00OPEN" + Math.random() + "\x00";
  var escClose = "\x00CLOSE" + Math.random() + "\x00";
  var escComma = "\x00COMMA" + Math.random() + "\x00";
  var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m2 = balanced("{", "}", str);
    if (!m2)
      return str.split(",");
    var pre = m2.pre;
    var body = m2.body;
    var post = m2.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m2 = balanced("{", "}", str);
    if (!m2 || /\$$/.test(m2.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m2.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m2.post.match(/,(?!,).*\}/)) {
        str = m2.pre + "{" + m2.body + escClose + m2.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m2.body.split(/\.\./);
    } else {
      n = parseCommaParts(m2.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m2.post.length ? expand(m2.post, false) : [""];
          return post.map(function(p) {
            return m2.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m2.pre;
    var post = m2.post.length ? expand(m2.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width2 = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x;test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width2 - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0;j < N.length; j++) {
      for (var k = 0;k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
});

// node_modules/glob/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports, module) => {
  module.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path = function() {
    try {
      return __require("path");
    } catch (e) {}
  }() || {
    sep: "/"
  };
  minimatch.sep = path.sep;
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  function ext(a, b) {
    b = b || {};
    var t = {};
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    var orig = minimatch;
    var m2 = function minimatch(p, pattern, options) {
      return orig(p, pattern, ext(def, options));
    };
    m2.Minimatch = function Minimatch(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    m2.Minimatch.defaults = function defaults(options) {
      return orig.defaults(ext(def, options)).Minimatch;
    };
    m2.filter = function filter(pattern, options) {
      return orig.filter(pattern, ext(def, options));
    };
    m2.defaults = function defaults(options) {
      return orig.defaults(ext(def, options));
    };
    m2.makeRe = function makeRe(pattern, options) {
      return orig.makeRe(pattern, ext(def, options));
    };
    m2.braceExpand = function braceExpand(pattern, options) {
      return orig.braceExpand(pattern, ext(def, options));
    };
    m2.match = function(list, pattern, options) {
      return orig.match(list, pattern, ext(def, options));
    };
    return m2;
  };
  Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    assertValidPattern(pattern);
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    assertValidPattern(pattern);
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (!options.allowWindowsEscape && path.sep !== "/") {
      pattern = pattern.split(path.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.make();
  }
  Minimatch.prototype.debug = function() {};
  Minimatch.prototype.make = make;
  function make() {
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = function debug() {
        console.error.apply(console, arguments);
      };
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l2 = pattern.length;i < l2 && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  }
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = function(pattern) {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  function parse(pattern, isSub) {
    assertValidPattern(pattern);
    var options = this.options;
    if (pattern === "**") {
      if (!options.noglobstar)
        return GLOBSTAR;
      else
        pattern = "*";
    }
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c;i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop();pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug(`tail=%j
   %s`, tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1;n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0;i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = function match(f, partial) {
    if (typeof partial === "undefined")
      partial = this.partial;
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path.sep !== "/") {
      f = f.split(path.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1;i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0;i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  };
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", { this: this, file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (;fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug(`
globstar while`, file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug(`
>>> no match, partial?`, file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util = __require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module.exports = util.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS((exports, module) => {
  function posix(path) {
    return path.charAt(0) === "/";
  }
  function win32(path) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  }
  module.exports = process.platform === "win32" ? win32 : posix;
  module.exports.posix = posix;
  module.exports.win32 = win32;
});

// node_modules/glob/common.js
var require_common3 = __commonJS((exports) => {
  exports.setopts = setopts;
  exports.ownProp = ownProp;
  exports.makeAbs = makeAbs;
  exports.finish = finish;
  exports.mark = mark;
  exports.isIgnored = isIgnored;
  exports.childrenIgnored = childrenIgnored;
  function ownProp(obj2, field) {
    return Object.prototype.hasOwnProperty.call(obj2, field);
  }
  var fs = __require("fs");
  var path = __require("path");
  var minimatch = require_minimatch();
  var isAbsolute = require_path_is_absolute();
  var Minimatch = minimatch.Minimatch;
  function alphasort(a, b) {
    return a.localeCompare(b, "en");
  }
  function setupIgnores(self2, options) {
    self2.ignore = options.ignore || [];
    if (!Array.isArray(self2.ignore))
      self2.ignore = [self2.ignore];
    if (self2.ignore.length) {
      self2.ignore = self2.ignore.map(ignoreMap);
    }
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch(gpattern, { dot: true });
    }
    return {
      matcher: new Minimatch(pattern, { dot: true }),
      gmatcher
    };
  }
  function setopts(self2, pattern, options) {
    if (!options)
      options = {};
    if (options.matchBase && pattern.indexOf("/") === -1) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self2.silent = !!options.silent;
    self2.pattern = pattern;
    self2.strict = options.strict !== false;
    self2.realpath = !!options.realpath;
    self2.realpathCache = options.realpathCache || Object.create(null);
    self2.follow = !!options.follow;
    self2.dot = !!options.dot;
    self2.mark = !!options.mark;
    self2.nodir = !!options.nodir;
    if (self2.nodir)
      self2.mark = true;
    self2.sync = !!options.sync;
    self2.nounique = !!options.nounique;
    self2.nonull = !!options.nonull;
    self2.nosort = !!options.nosort;
    self2.nocase = !!options.nocase;
    self2.stat = !!options.stat;
    self2.noprocess = !!options.noprocess;
    self2.absolute = !!options.absolute;
    self2.fs = options.fs || fs;
    self2.maxLength = options.maxLength || Infinity;
    self2.cache = options.cache || Object.create(null);
    self2.statCache = options.statCache || Object.create(null);
    self2.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self2, options);
    self2.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options, "cwd"))
      self2.cwd = cwd;
    else {
      self2.cwd = path.resolve(options.cwd);
      self2.changedCwd = self2.cwd !== cwd;
    }
    self2.root = options.root || path.resolve(self2.cwd, "/");
    self2.root = path.resolve(self2.root);
    if (process.platform === "win32")
      self2.root = self2.root.replace(/\\/g, "/");
    self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
    if (process.platform === "win32")
      self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
    self2.nomount = !!options.nomount;
    options.nonegate = true;
    options.nocomment = true;
    options.allowWindowsEscape = false;
    self2.minimatch = new Minimatch(pattern, options);
    self2.options = self2.minimatch.options;
  }
  function finish(self2) {
    var nou = self2.nounique;
    var all = nou ? [] : Object.create(null);
    for (var i = 0, l2 = self2.matches.length;i < l2; i++) {
      var matches = self2.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal = self2.minimatch.globSet[i];
          if (nou)
            all.push(literal);
          else
            all[literal] = true;
        }
      } else {
        var m2 = Object.keys(matches);
        if (nou)
          all.push.apply(all, m2);
        else
          m2.forEach(function(m3) {
            all[m3] = true;
          });
      }
    }
    if (!nou)
      all = Object.keys(all);
    if (!self2.nosort)
      all = all.sort(alphasort);
    if (self2.mark) {
      for (var i = 0;i < all.length; i++) {
        all[i] = self2._mark(all[i]);
      }
      if (self2.nodir) {
        all = all.filter(function(e) {
          var notDir = !/\/$/.test(e);
          var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
          if (notDir && c)
            notDir = c !== "DIR" && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self2.ignore.length)
      all = all.filter(function(m3) {
        return !isIgnored(self2, m3);
      });
    self2.found = all;
  }
  function mark(self2, p) {
    var abs = makeAbs(self2, p);
    var c = self2.cache[abs];
    var m2 = p;
    if (c) {
      var isDir = c === "DIR" || Array.isArray(c);
      var slash = p.slice(-1) === "/";
      if (isDir && !slash)
        m2 += "/";
      else if (!isDir && slash)
        m2 = m2.slice(0, -1);
      if (m2 !== p) {
        var mabs = makeAbs(self2, m2);
        self2.statCache[mabs] = self2.statCache[abs];
        self2.cache[mabs] = self2.cache[abs];
      }
    }
    return m2;
  }
  function makeAbs(self2, f) {
    var abs = f;
    if (f.charAt(0) === "/") {
      abs = path.join(self2.root, f);
    } else if (isAbsolute(f) || f === "") {
      abs = f;
    } else if (self2.changedCwd) {
      abs = path.resolve(self2.cwd, f);
    } else {
      abs = path.resolve(f);
    }
    if (process.platform === "win32")
      abs = abs.replace(/\\/g, "/");
    return abs;
  }
  function isIgnored(self2, path2) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
    });
  }
  function childrenIgnored(self2, path2) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path2));
    });
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS((exports, module) => {
  module.exports = globSync;
  globSync.GlobSync = GlobSync;
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var Glob = require_glob().Glob;
  var util = __require("util");
  var path = __require("path");
  var assert = __require("assert");
  var isAbsolute = require_path_is_absolute();
  var common = require_common3();
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  function globSync(pattern, options) {
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
` + "See: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
  }
  function GlobSync(pattern, options) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
` + "See: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0;i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert.ok(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set = self2.matches[index] = Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert.ok(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0;i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m2;
        if (negate && !prefix) {
          m2 = !e.match(pn);
        } else {
          m2 = e.match(pn);
        }
        if (m2)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0;i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0;i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat;
    var stat;
    try {
      lstat = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0;i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          throw error;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0;i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index) {
    var exists = this._stat(prefix);
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path.join(this.root, prefix);
      } else {
        prefix = path.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var exists;
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = this.fs.statSync(abs);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS((exports, module) => {
  var wrappy = require_wrappy();
  var reqs = Object.create(null);
  var once = require_once();
  module.exports = wrappy(inflight);
  function inflight(key2, cb) {
    if (reqs[key2]) {
      reqs[key2].push(cb);
      return null;
    } else {
      reqs[key2] = [cb];
      return makeres(key2);
    }
  }
  function makeres(key2) {
    return once(function RES() {
      var cbs = reqs[key2];
      var len = cbs.length;
      var args = slice(arguments);
      try {
        for (var i = 0;i < len; i++) {
          cbs[i].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key2];
        }
      }
    });
  }
  function slice(args) {
    var length = args.length;
    var array = [];
    for (var i = 0;i < length; i++)
      array[i] = args[i];
    return array;
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS((exports, module) => {
  module.exports = glob;
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var inherits = require_inherits();
  var EE = __require("events").EventEmitter;
  var path = __require("path");
  var assert = __require("assert");
  var isAbsolute = require_path_is_absolute();
  var globSync = require_sync();
  var common = require_common3();
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var inflight = require_inflight();
  var util = __require("util");
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  var once = require_once();
  function glob(pattern, options, cb) {
    if (typeof options === "function")
      cb = options, options = {};
    if (!options)
      options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  glob.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern)
      return false;
    if (set.length > 1)
      return true;
    for (var j = 0;j < set[0].length; j++) {
      if (typeof set[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits(Glob, EE);
  function Glob(pattern, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync = true;
    for (var i = 0;i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0;i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self2 = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set[real] = true;
        else if (er.syscall === "stat")
          set[p] = true;
        else
          self2.emit("error", er);
        if (--n === 0) {
          self2.matches[index] = set;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0;i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0;i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0;i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m2;
        if (negate && !prefix) {
          m2 = !e.match(pn);
        } else {
          m2 = e.match(pn);
        }
        if (m2)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0;i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0;i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index, e]);
      return;
    }
    var abs = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\x00" + abs;
    var self2 = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight("readdir\x00" + abs + "\x00" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self2 = this;
    self2.fs.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0;i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          this.emit("error", error);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0;i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path.join(this.root, prefix);
      } else {
        prefix = path.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var exists;
    var stat = this.statCache[abs];
    if (stat !== undefined) {
      if (stat === false)
        return cb(null, stat);
      else {
        var type = stat.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat);
      }
    }
    var self2 = this;
    var statcb = inflight("stat\x00" + abs, lstatcb_);
    if (statcb)
      self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return self2.fs.stat(abs, function(er2, stat2) {
          if (er2)
            self2._stat2(f, abs, null, lstat, cb);
          else
            self2._stat2(f, abs, er2, stat2, cb);
        });
      } else {
        self2._stat2(f, abs, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat;
    if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, false, stat);
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat);
  };
});

// node_modules/puppeteer-core/node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS((exports, module) => {
  var assert = __require("assert");
  var path = __require("path");
  var fs = __require("fs");
  var glob = undefined;
  try {
    glob = require_glob();
  } catch (_err) {}
  var defaultGlobOpts = {
    nosort: true,
    silent: true
  };
  var timeout = 0;
  var isWindows = process.platform === "win32";
  var defaults = (options) => {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m2) => {
      options[m2] = options[m2] || fs[m2];
      m2 = m2 + "Sync";
      options[m2] = options[m2] || fs[m2];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1000;
    if (options.glob === false) {
      options.disableGlob = true;
    }
    if (options.disableGlob !== true && glob === undefined) {
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    }
    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
  };
  var rimraf = (p, options, cb) => {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert.equal(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    let busyTries = 0;
    let errState = null;
    let n = 0;
    const next = (er) => {
      errState = errState || er;
      if (--n === 0)
        cb(errState);
    };
    const afterGlob = (er, results2) => {
      if (er)
        return cb(er);
      n = results2.length;
      if (n === 0)
        return cb();
      results2.forEach((p2) => {
        const CB = (er2) => {
          if (er2) {
            if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
              busyTries++;
              return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
            }
            if (er2.code === "EMFILE" && timeout < options.emfileWait) {
              return setTimeout(() => rimraf_(p2, options, CB), timeout++);
            }
            if (er2.code === "ENOENT")
              er2 = null;
          }
          timeout = 0;
          next(er2);
        };
        rimraf_(p2, options, CB);
      });
    };
    if (options.disableGlob || !glob.hasMagic(p))
      return afterGlob(null, [p]);
    options.lstat(p, (er, stat) => {
      if (!er)
        return afterGlob(null, [p]);
      glob(p, options.glob, afterGlob);
    });
  };
  var rimraf_ = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT")
        return cb(null);
      if (er && er.code === "EPERM" && isWindows)
        fixWinEPERM(p, options, er, cb);
      if (st && st.isDirectory())
        return rmdir(p, options, er, cb);
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb(null);
          if (er2.code === "EPERM")
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          if (er2.code === "EISDIR")
            return rmdir(p, options, er2, cb);
        }
        return cb(er2);
      });
    });
  };
  var fixWinEPERM = (p, options, er, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2)
        cb(er2.code === "ENOENT" ? null : er);
      else
        options.stat(p, (er3, stats) => {
          if (er3)
            cb(er3.code === "ENOENT" ? null : er);
          else if (stats.isDirectory())
            rmdir(p, options, er, cb);
          else
            options.unlink(p, cb);
        });
    });
  };
  var fixWinEPERMSync = (p, options, er) => {
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT")
        return;
      else
        throw er;
    }
    let stats;
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT")
        return;
      else
        throw er;
    }
    if (stats.isDirectory())
      rmdirSync(p, options, er);
    else
      options.unlinkSync(p);
  };
  var rmdir = (p, options, originalEr, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
        rmkids(p, options, cb);
      else if (er && er.code === "ENOTDIR")
        cb(originalEr);
      else
        cb(er);
    });
  };
  var rmkids = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      if (n === 0)
        return options.rmdir(p, cb);
      let errState;
      files.forEach((f) => {
        rimraf(path.join(p, f), options, (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--n === 0)
            options.rmdir(p, cb);
        });
      });
    });
  };
  var rimrafSync = (p, options) => {
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    let results2;
    if (options.disableGlob || !glob.hasMagic(p)) {
      results2 = [p];
    } else {
      try {
        options.lstatSync(p);
        results2 = [p];
      } catch (er) {
        results2 = glob.sync(p, options.glob);
      }
    }
    if (!results2.length)
      return;
    for (let i = 0;i < results2.length; i++) {
      const p2 = results2[i];
      let st;
      try {
        st = options.lstatSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM" && isWindows)
          fixWinEPERMSync(p2, options, er);
      }
      try {
        if (st && st.isDirectory())
          rmdirSync(p2, options, null);
        else
          options.unlinkSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p2, options, er);
      }
    }
  };
  var rmdirSync = (p, options, originalEr) => {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR")
        throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
        rmkidsSync(p, options);
    }
  };
  var rmkidsSync = (p, options) => {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
    const retries = isWindows ? 100 : 1;
    let i = 0;
    do {
      let threw = true;
      try {
        const ret = options.rmdirSync(p, options);
        threw = false;
        return ret;
      } finally {
        if (++i < retries && threw)
          continue;
      }
    } while (true);
  };
  module.exports = rimraf;
  rimraf.sync = rimrafSync;
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var LCHOWN = fs.lchown ? "lchown" : "chown";
  var LCHOWNSYNC = fs.lchownSync ? "lchownSync" : "chownSync";
  var needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
  var lchownSync = (path2, uid, gid) => {
    try {
      return fs[LCHOWNSYNC](path2, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  };
  var chownSync = (path2, uid, gid) => {
    try {
      return fs.chownSync(path2, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  };
  var handleEISDIR = needEISDIRHandled ? (path2, uid, gid, cb) => (er) => {
    if (!er || er.code !== "EISDIR")
      cb(er);
    else
      fs.chown(path2, uid, gid, cb);
  } : (_2, __, ___, cb) => cb;
  var handleEISDirSync = needEISDIRHandled ? (path2, uid, gid) => {
    try {
      return lchownSync(path2, uid, gid);
    } catch (er) {
      if (er.code !== "EISDIR")
        throw er;
      chownSync(path2, uid, gid);
    }
  } : (path2, uid, gid) => lchownSync(path2, uid, gid);
  var nodeVersion = process.version;
  var readdir = (path2, options, cb) => fs.readdir(path2, options, cb);
  var readdirSync = (path2, options) => fs.readdirSync(path2, options);
  if (/^v4\./.test(nodeVersion))
    readdir = (path2, options, cb) => fs.readdir(path2, cb);
  var chown = (cpath, uid, gid, cb) => {
    fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
      cb(er && er.code !== "ENOENT" ? er : null);
    }));
  };
  var chownrKid = (p, child, uid, gid, cb) => {
    if (typeof child === "string")
      return fs.lstat(path.resolve(p, child), (er, stats) => {
        if (er)
          return cb(er.code !== "ENOENT" ? er : null);
        stats.name = child;
        chownrKid(p, stats, uid, gid, cb);
      });
    if (child.isDirectory()) {
      chownr(path.resolve(p, child.name), uid, gid, (er) => {
        if (er)
          return cb(er);
        const cpath = path.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      });
    } else {
      const cpath = path.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    }
  };
  var chownr = (p, uid, gid, cb) => {
    readdir(p, { withFileTypes: true }, (er, children) => {
      if (er) {
        if (er.code === "ENOENT")
          return cb();
        else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
          return cb(er);
      }
      if (er || !children.length)
        return chown(p, uid, gid, cb);
      let len = children.length;
      let errState = null;
      const then = (er2) => {
        if (errState)
          return;
        if (er2)
          return cb(errState = er2);
        if (--len === 0)
          return chown(p, uid, gid, cb);
      };
      children.forEach((child) => chownrKid(p, child, uid, gid, then));
    });
  };
  var chownrKidSync = (p, child, uid, gid) => {
    if (typeof child === "string") {
      try {
        const stats = fs.lstatSync(path.resolve(p, child));
        stats.name = child;
        child = stats;
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else
          throw er;
      }
    }
    if (child.isDirectory())
      chownrSync(path.resolve(p, child.name), uid, gid);
    handleEISDirSync(path.resolve(p, child.name), uid, gid);
  };
  var chownrSync = (p, uid, gid) => {
    let children;
    try {
      children = readdirSync(p, { withFileTypes: true });
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
        return handleEISDirSync(p, uid, gid);
      else
        throw er;
    }
    if (children && children.length)
      children.forEach((child) => chownrKidSync(p, child, uid, gid));
    return handleEISDirSync(p, uid, gid);
  };
  module.exports = chownr;
  chownr.sync = chownrSync;
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj2, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var _require = __require("buffer");
  var Buffer2 = _require.Buffer;
  var _require2 = __require("util");
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  module.exports = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next)
          ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/errors.js
var require_errors = __commonJS((exports, module) => {
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }

    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports.codes = codes;
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports, module) => {
  var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  module.exports = {
    getHighWaterMark
  };
});

// node_modules/util-deprecate/node.js
var require_node3 = __commonJS((exports, module) => {
  module.exports = __require("util").deprecate;
});

// node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_node3()
  };
  var Stream = __require("stream");
  var Buffer2 = __require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits()(Writable, Stream);
  function nop() {}
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_2) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END;
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES;
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l2 = state.bufferedRequestCount;
      var buffer = new Array(l2);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var objectKeys = Object.keys || function(obj2) {
    var keys2 = [];
    for (var key2 in obj2)
      keys2.push(key2);
    return keys2;
  };
  module.exports = Duplex;
  var Readable = require__stream_readable();
  var Writable = require__stream_writable();
  require_inherits()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key2 in src) {
      dst[key2] = src[key2];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS((exports, module) => {
  var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {}
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  module.exports = eos;
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports, module) => {
  var _Object$setPrototypeO;
  function _defineProperty(obj2, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = require_end_of_stream2();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  module.exports = createReadableStreamAsyncIterator;
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key2, arg) {
    try {
      var info = gen[key2](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj2, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj2) {
      Object.defineProperty(obj2, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key2] = value;
    }
    return obj2;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
  function from(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator])
      iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator])
      iterator = iterable[Symbol.iterator]();
    else
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable = new Readable(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
          if (done) {
            readable.push(null);
          } else if (readable.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable;
  }
  module.exports = from;
});

// node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  module.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = __require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var debugUtil = __require("util");
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug() {};
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === undefined) {
        from = require_from();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l2 = xs.length;i < l2; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  module.exports = Transform;
  var _require$codes = require_errors().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require__stream_duplex();
  require_inherits()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK);
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0;
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
    return stream.push(null);
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform();
  require_inherits()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(undefined, arguments);
    };
  }
  var _require$codes = require_errors().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === undefined)
      eos = require_end_of_stream2();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0;_key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  module.exports = pipeline;
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable();
    exports.Duplex = require__stream_duplex();
    exports.Transform = require__stream_transform();
    exports.PassThrough = require__stream_passthrough();
    exports.finished = require_end_of_stream2();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("buffer");
  var symbol = Symbol.for("BufferList");
  function BufferList(buf) {
    if (!(this instanceof BufferList)) {
      return new BufferList(buf);
    }
    BufferList._init.call(this, buf);
  }
  BufferList._init = function _init(buf) {
    Object.defineProperty(this, symbol, { value: true });
    this._bufs = [];
    this.length = 0;
    if (buf) {
      this.append(buf);
    }
  };
  BufferList.prototype._new = function _new(buf) {
    return new BufferList(buf);
  };
  BufferList.prototype._offset = function _offset(offset) {
    if (offset === 0) {
      return [0, 0];
    }
    let tot = 0;
    for (let i = 0;i < this._bufs.length; i++) {
      const _t = tot + this._bufs[i].length;
      if (offset < _t || i === this._bufs.length - 1) {
        return [i, offset - tot];
      }
      tot = _t;
    }
  };
  BufferList.prototype._reverseOffset = function(blOffset) {
    const bufferId = blOffset[0];
    let offset = blOffset[1];
    for (let i = 0;i < bufferId; i++) {
      offset += this._bufs[i].length;
    }
    return offset;
  };
  BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) {
      return;
    }
    const offset = this._offset(index);
    return this._bufs[offset[0]][offset[1]];
  };
  BufferList.prototype.slice = function slice(start, end) {
    if (typeof start === "number" && start < 0) {
      start += this.length;
    }
    if (typeof end === "number" && end < 0) {
      end += this.length;
    }
    return this.copy(null, 0, start, end);
  };
  BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart !== "number" || srcStart < 0) {
      srcStart = 0;
    }
    if (typeof srcEnd !== "number" || srcEnd > this.length) {
      srcEnd = this.length;
    }
    if (srcStart >= this.length) {
      return dst || Buffer2.alloc(0);
    }
    if (srcEnd <= 0) {
      return dst || Buffer2.alloc(0);
    }
    const copy = !!dst;
    const off = this._offset(srcStart);
    const len = srcEnd - srcStart;
    let bytes = len;
    let bufoff = copy && dstStart || 0;
    let start = off[1];
    if (srcStart === 0 && srcEnd === this.length) {
      if (!copy) {
        return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
      }
      for (let i = 0;i < this._bufs.length; i++) {
        this._bufs[i].copy(dst, bufoff);
        bufoff += this._bufs[i].length;
      }
      return dst;
    }
    if (bytes <= this._bufs[off[0]].length - start) {
      return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    }
    if (!copy) {
      dst = Buffer2.allocUnsafe(len);
    }
    for (let i = off[0];i < this._bufs.length; i++) {
      const l2 = this._bufs[i].length - start;
      if (bytes > l2) {
        this._bufs[i].copy(dst, bufoff, start);
        bufoff += l2;
      } else {
        this._bufs[i].copy(dst, bufoff, start, start + bytes);
        bufoff += l2;
        break;
      }
      bytes -= l2;
      if (start) {
        start = 0;
      }
    }
    if (dst.length > bufoff)
      return dst.slice(0, bufoff);
    return dst;
  };
  BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = typeof end !== "number" ? this.length : end;
    if (start < 0) {
      start += this.length;
    }
    if (end < 0) {
      end += this.length;
    }
    if (start === end) {
      return this._new();
    }
    const startOffset = this._offset(start);
    const endOffset = this._offset(end);
    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] === 0) {
      buffers.pop();
    } else {
      buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    }
    if (startOffset[1] !== 0) {
      buffers[0] = buffers[0].slice(startOffset[1]);
    }
    return this._new(buffers);
  };
  BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
  BufferList.prototype.consume = function consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0)
      return this;
    while (this._bufs.length) {
      if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes);
        this.length -= bytes;
        break;
      }
    }
    return this;
  };
  BufferList.prototype.duplicate = function duplicate() {
    const copy = this._new();
    for (let i = 0;i < this._bufs.length; i++) {
      copy.append(this._bufs[i]);
    }
    return copy;
  };
  BufferList.prototype.append = function append(buf) {
    if (buf == null) {
      return this;
    }
    if (buf.buffer) {
      this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
    } else if (Array.isArray(buf)) {
      for (let i = 0;i < buf.length; i++) {
        this.append(buf[i]);
      }
    } else if (this._isBufferList(buf)) {
      for (let i = 0;i < buf._bufs.length; i++) {
        this.append(buf._bufs[i]);
      }
    } else {
      if (typeof buf === "number") {
        buf = buf.toString();
      }
      this._appendBuffer(Buffer2.from(buf));
    }
    return this;
  };
  BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
  };
  BufferList.prototype.indexOf = function(search, offset, encoding) {
    if (encoding === undefined && typeof offset === "string") {
      encoding = offset;
      offset = undefined;
    }
    if (typeof search === "function" || Array.isArray(search)) {
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    } else if (typeof search === "number") {
      search = Buffer2.from([search]);
    } else if (typeof search === "string") {
      search = Buffer2.from(search, encoding);
    } else if (this._isBufferList(search)) {
      search = search.slice();
    } else if (Array.isArray(search.buffer)) {
      search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
    } else if (!Buffer2.isBuffer(search)) {
      search = Buffer2.from(search);
    }
    offset = Number(offset || 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const blOffset = this._offset(offset);
    let blIndex = blOffset[0];
    let buffOffset = blOffset[1];
    for (;blIndex < this._bufs.length; blIndex++) {
      const buff = this._bufs[blIndex];
      while (buffOffset < buff.length) {
        const availableWindow = buff.length - buffOffset;
        if (availableWindow >= search.length) {
          const nativeSearchResult = buff.indexOf(search, buffOffset);
          if (nativeSearchResult !== -1) {
            return this._reverseOffset([blIndex, nativeSearchResult]);
          }
          buffOffset = buff.length - search.length + 1;
        } else {
          const revOffset = this._reverseOffset([blIndex, buffOffset]);
          if (this._match(revOffset, search)) {
            return revOffset;
          }
          buffOffset++;
        }
      }
      buffOffset = 0;
    }
    return -1;
  };
  BufferList.prototype._match = function(offset, search) {
    if (this.length - offset < search.length) {
      return false;
    }
    for (let searchOffset = 0;searchOffset < search.length; searchOffset++) {
      if (this.get(offset + searchOffset) !== search[searchOffset]) {
        return false;
      }
    }
    return true;
  };
  (function() {
    const methods = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (const m2 in methods) {
      (function(m3) {
        if (methods[m3] === null) {
          BufferList.prototype[m3] = function(offset, byteLength) {
            return this.slice(offset, offset + byteLength)[m3](0, byteLength);
          };
        } else {
          BufferList.prototype[m3] = function(offset = 0) {
            return this.slice(offset, offset + methods[m3])[m3](0);
          };
        }
      })(m2);
    }
  })();
  BufferList.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferList || BufferList.isBufferList(b);
  };
  BufferList.isBufferList = function isBufferList(b) {
    return b != null && b[symbol];
  };
  module.exports = BufferList;
});

// node_modules/bl/bl.js
var require_bl = __commonJS((exports, module) => {
  var DuplexStream = require_readable().Duplex;
  var inherits = require_inherits();
  var BufferList = require_BufferList();
  function BufferListStream(callback) {
    if (!(this instanceof BufferListStream)) {
      return new BufferListStream(callback);
    }
    if (typeof callback === "function") {
      this._callback = callback;
      const piper = function piper(err) {
        if (this._callback) {
          this._callback(err);
          this._callback = null;
        }
      }.bind(this);
      this.on("pipe", function onPipe(src) {
        src.on("error", piper);
      });
      this.on("unpipe", function onUnpipe(src) {
        src.removeListener("error", piper);
      });
      callback = null;
    }
    BufferList._init.call(this, callback);
    DuplexStream.call(this);
  }
  inherits(BufferListStream, DuplexStream);
  Object.assign(BufferListStream.prototype, BufferList.prototype);
  BufferListStream.prototype._new = function _new(callback) {
    return new BufferListStream(callback);
  };
  BufferListStream.prototype._write = function _write(buf, encoding, callback) {
    this._appendBuffer(buf);
    if (typeof callback === "function") {
      callback();
    }
  };
  BufferListStream.prototype._read = function _read(size) {
    if (!this.length) {
      return this.push(null);
    }
    size = Math.min(size, this.length);
    this.push(this.slice(0, size));
    this.consume(size);
  };
  BufferListStream.prototype.end = function end(chunk) {
    DuplexStream.prototype.end.call(this, chunk);
    if (this._callback) {
      this._callback(null, this.slice());
      this._callback = null;
    }
  };
  BufferListStream.prototype._destroy = function _destroy(err, cb) {
    this._bufs.length = 0;
    this.length = 0;
    cb(err);
  };
  BufferListStream.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
  };
  BufferListStream.isBufferList = BufferList.isBufferList;
  module.exports = BufferListStream;
  module.exports.BufferListStream = BufferListStream;
  module.exports.BufferList = BufferList;
});

// node_modules/tar-stream/headers.js
var require_headers = __commonJS((exports) => {
  var alloc = Buffer.alloc;
  var ZEROS = "0000000000000000000";
  var SEVENS = "7777777777777777777";
  var ZERO_OFFSET = 48;
  var USTAR_MAGIC = Buffer.from("ustar\x00", "binary");
  var USTAR_VER = Buffer.from("00", "binary");
  var GNU_MAGIC = Buffer.from("ustar ", "binary");
  var GNU_VER = Buffer.from(" \x00", "binary");
  var MASK = parseInt("7777", 8);
  var MAGIC_OFFSET = 257;
  var VERSION_OFFSET = 263;
  var clamp = function(index, len, defaultValue) {
    if (typeof index !== "number")
      return defaultValue;
    index = ~~index;
    if (index >= len)
      return len;
    if (index >= 0)
      return index;
    index += len;
    if (index >= 0)
      return index;
    return 0;
  };
  var toType = function(flag) {
    switch (flag) {
      case 0:
        return "file";
      case 1:
        return "link";
      case 2:
        return "symlink";
      case 3:
        return "character-device";
      case 4:
        return "block-device";
      case 5:
        return "directory";
      case 6:
        return "fifo";
      case 7:
        return "contiguous-file";
      case 72:
        return "pax-header";
      case 55:
        return "pax-global-header";
      case 27:
        return "gnu-long-link-path";
      case 28:
      case 30:
        return "gnu-long-path";
    }
    return null;
  };
  var toTypeflag = function(flag) {
    switch (flag) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
    }
    return 0;
  };
  var indexOf = function(block, num, offset, end) {
    for (;offset < end; offset++) {
      if (block[offset] === num)
        return offset;
    }
    return end;
  };
  var cksum = function(block) {
    var sum = 8 * 32;
    for (var i = 0;i < 148; i++)
      sum += block[i];
    for (var j = 156;j < 512; j++)
      sum += block[j];
    return sum;
  };
  var encodeOct = function(val, n) {
    val = val.toString(8);
    if (val.length > n)
      return SEVENS.slice(0, n) + " ";
    else
      return ZEROS.slice(0, n - val.length) + val + " ";
  };
  function parse256(buf) {
    var positive;
    if (buf[0] === 128)
      positive = true;
    else if (buf[0] === 255)
      positive = false;
    else
      return null;
    var tuple = [];
    for (var i = buf.length - 1;i > 0; i--) {
      var byte = buf[i];
      if (positive)
        tuple.push(byte);
      else
        tuple.push(255 - byte);
    }
    var sum = 0;
    var l2 = tuple.length;
    for (i = 0;i < l2; i++) {
      sum += tuple[i] * Math.pow(256, i);
    }
    return positive ? sum : -1 * sum;
  }
  var decodeOct = function(val, offset, length) {
    val = val.slice(offset, offset + length);
    offset = 0;
    if (val[offset] & 128) {
      return parse256(val);
    } else {
      while (offset < val.length && val[offset] === 32)
        offset++;
      var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
      while (offset < end && val[offset] === 0)
        offset++;
      if (end === offset)
        return 0;
      return parseInt(val.slice(offset, end).toString(), 8);
    }
  };
  var decodeStr = function(val, offset, length, encoding) {
    return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
  };
  var addLength = function(str) {
    var len = Buffer.byteLength(str);
    var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits))
      digits++;
    return len + digits + str;
  };
  exports.decodeLongPath = function(buf, encoding) {
    return decodeStr(buf, 0, buf.length, encoding);
  };
  exports.encodePax = function(opts) {
    var result = "";
    if (opts.name)
      result += addLength(" path=" + opts.name + `
`);
    if (opts.linkname)
      result += addLength(" linkpath=" + opts.linkname + `
`);
    var pax = opts.pax;
    if (pax) {
      for (var key2 in pax) {
        result += addLength(" " + key2 + "=" + pax[key2] + `
`);
      }
    }
    return Buffer.from(result);
  };
  exports.decodePax = function(buf) {
    var result = {};
    while (buf.length) {
      var i = 0;
      while (i < buf.length && buf[i] !== 32)
        i++;
      var len = parseInt(buf.slice(0, i).toString(), 10);
      if (!len)
        return result;
      var b = buf.slice(i + 1, len - 1).toString();
      var keyIndex = b.indexOf("=");
      if (keyIndex === -1)
        return result;
      result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
      buf = buf.slice(len);
    }
    return result;
  };
  exports.encode = function(opts) {
    var buf = alloc(512);
    var name = opts.name;
    var prefix = "";
    if (opts.typeflag === 5 && name[name.length - 1] !== "/")
      name += "/";
    if (Buffer.byteLength(name) !== name.length)
      return null;
    while (Buffer.byteLength(name) > 100) {
      var i = name.indexOf("/");
      if (i === -1)
        return null;
      prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
      name = name.slice(i + 1);
    }
    if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155)
      return null;
    if (opts.linkname && Buffer.byteLength(opts.linkname) > 100)
      return null;
    buf.write(name);
    buf.write(encodeOct(opts.mode & MASK, 6), 100);
    buf.write(encodeOct(opts.uid, 6), 108);
    buf.write(encodeOct(opts.gid, 6), 116);
    buf.write(encodeOct(opts.size, 11), 124);
    buf.write(encodeOct(opts.mtime.getTime() / 1000 | 0, 11), 136);
    buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
    if (opts.linkname)
      buf.write(opts.linkname, 157);
    USTAR_MAGIC.copy(buf, MAGIC_OFFSET);
    USTAR_VER.copy(buf, VERSION_OFFSET);
    if (opts.uname)
      buf.write(opts.uname, 265);
    if (opts.gname)
      buf.write(opts.gname, 297);
    buf.write(encodeOct(opts.devmajor || 0, 6), 329);
    buf.write(encodeOct(opts.devminor || 0, 6), 337);
    if (prefix)
      buf.write(prefix, 345);
    buf.write(encodeOct(cksum(buf), 6), 148);
    return buf;
  };
  exports.decode = function(buf, filenameEncoding, allowUnknownFormat) {
    var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
    var name = decodeStr(buf, 0, 100, filenameEncoding);
    var mode = decodeOct(buf, 100, 8);
    var uid = decodeOct(buf, 108, 8);
    var gid = decodeOct(buf, 116, 8);
    var size = decodeOct(buf, 124, 12);
    var mtime = decodeOct(buf, 136, 12);
    var type = toType(typeflag);
    var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
    var uname = decodeStr(buf, 265, 32);
    var gname = decodeStr(buf, 297, 32);
    var devmajor = decodeOct(buf, 329, 8);
    var devminor = decodeOct(buf, 337, 8);
    var c = cksum(buf);
    if (c === 8 * 32)
      return null;
    if (c !== decodeOct(buf, 148, 8))
      throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
      if (buf[345])
        name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
    } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 && GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {} else {
      if (!allowUnknownFormat) {
        throw new Error("Invalid tar header: unknown format.");
      }
    }
    if (typeflag === 0 && name && name[name.length - 1] === "/")
      typeflag = 5;
    return {
      name,
      mode,
      uid,
      gid,
      size,
      mtime: new Date(1000 * mtime),
      type,
      linkname,
      uname,
      gname,
      devmajor,
      devminor
    };
  };
});

// node_modules/tar-stream/extract.js
var require_extract = __commonJS((exports, module) => {
  var util = __require("util");
  var bl = require_bl();
  var headers = require_headers();
  var Writable = require_readable().Writable;
  var PassThrough = require_readable().PassThrough;
  var noop = function() {};
  var overflow = function(size) {
    size &= 511;
    return size && 512 - size;
  };
  var emptyStream = function(self2, offset) {
    var s = new Source(self2, offset);
    s.end();
    return s;
  };
  var mixinPax = function(header, pax) {
    if (pax.path)
      header.name = pax.path;
    if (pax.linkpath)
      header.linkname = pax.linkpath;
    if (pax.size)
      header.size = parseInt(pax.size, 10);
    header.pax = pax;
    return header;
  };
  var Source = function(self2, offset) {
    this._parent = self2;
    this.offset = offset;
    PassThrough.call(this, { autoDestroy: false });
  };
  util.inherits(Source, PassThrough);
  Source.prototype.destroy = function(err) {
    this._parent.destroy(err);
  };
  var Extract = function(opts) {
    if (!(this instanceof Extract))
      return new Extract(opts);
    Writable.call(this, opts);
    opts = opts || {};
    this._offset = 0;
    this._buffer = bl();
    this._missing = 0;
    this._partial = false;
    this._onparse = noop;
    this._header = null;
    this._stream = null;
    this._overflow = null;
    this._cb = null;
    this._locked = false;
    this._destroyed = false;
    this._pax = null;
    this._paxGlobal = null;
    this._gnuLongPath = null;
    this._gnuLongLinkPath = null;
    var self2 = this;
    var b = self2._buffer;
    var oncontinue = function() {
      self2._continue();
    };
    var onunlock = function(err) {
      self2._locked = false;
      if (err)
        return self2.destroy(err);
      if (!self2._stream)
        oncontinue();
    };
    var onstreamend = function() {
      self2._stream = null;
      var drain = overflow(self2._header.size);
      if (drain)
        self2._parse(drain, ondrain);
      else
        self2._parse(512, onheader);
      if (!self2._locked)
        oncontinue();
    };
    var ondrain = function() {
      self2._buffer.consume(overflow(self2._header.size));
      self2._parse(512, onheader);
      oncontinue();
    };
    var onpaxglobalheader = function() {
      var size = self2._header.size;
      self2._paxGlobal = headers.decodePax(b.slice(0, size));
      b.consume(size);
      onstreamend();
    };
    var onpaxheader = function() {
      var size = self2._header.size;
      self2._pax = headers.decodePax(b.slice(0, size));
      if (self2._paxGlobal)
        self2._pax = Object.assign({}, self2._paxGlobal, self2._pax);
      b.consume(size);
      onstreamend();
    };
    var ongnulongpath = function() {
      var size = self2._header.size;
      this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
      b.consume(size);
      onstreamend();
    };
    var ongnulonglinkpath = function() {
      var size = self2._header.size;
      this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
      b.consume(size);
      onstreamend();
    };
    var onheader = function() {
      var offset = self2._offset;
      var header;
      try {
        header = self2._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat);
      } catch (err) {
        self2.emit("error", err);
      }
      b.consume(512);
      if (!header) {
        self2._parse(512, onheader);
        oncontinue();
        return;
      }
      if (header.type === "gnu-long-path") {
        self2._parse(header.size, ongnulongpath);
        oncontinue();
        return;
      }
      if (header.type === "gnu-long-link-path") {
        self2._parse(header.size, ongnulonglinkpath);
        oncontinue();
        return;
      }
      if (header.type === "pax-global-header") {
        self2._parse(header.size, onpaxglobalheader);
        oncontinue();
        return;
      }
      if (header.type === "pax-header") {
        self2._parse(header.size, onpaxheader);
        oncontinue();
        return;
      }
      if (self2._gnuLongPath) {
        header.name = self2._gnuLongPath;
        self2._gnuLongPath = null;
      }
      if (self2._gnuLongLinkPath) {
        header.linkname = self2._gnuLongLinkPath;
        self2._gnuLongLinkPath = null;
      }
      if (self2._pax) {
        self2._header = header = mixinPax(header, self2._pax);
        self2._pax = null;
      }
      self2._locked = true;
      if (!header.size || header.type === "directory") {
        self2._parse(512, onheader);
        self2.emit("entry", header, emptyStream(self2, offset), onunlock);
        return;
      }
      self2._stream = new Source(self2, offset);
      self2.emit("entry", header, self2._stream, onunlock);
      self2._parse(header.size, onstreamend);
      oncontinue();
    };
    this._onheader = onheader;
    this._parse(512, onheader);
  };
  util.inherits(Extract, Writable);
  Extract.prototype.destroy = function(err) {
    if (this._destroyed)
      return;
    this._destroyed = true;
    if (err)
      this.emit("error", err);
    this.emit("close");
    if (this._stream)
      this._stream.emit("close");
  };
  Extract.prototype._parse = function(size, onparse) {
    if (this._destroyed)
      return;
    this._offset += size;
    this._missing = size;
    if (onparse === this._onheader)
      this._partial = false;
    this._onparse = onparse;
  };
  Extract.prototype._continue = function() {
    if (this._destroyed)
      return;
    var cb = this._cb;
    this._cb = noop;
    if (this._overflow)
      this._write(this._overflow, undefined, cb);
    else
      cb();
  };
  Extract.prototype._write = function(data, enc, cb) {
    if (this._destroyed)
      return;
    var s = this._stream;
    var b = this._buffer;
    var missing = this._missing;
    if (data.length)
      this._partial = true;
    if (data.length < missing) {
      this._missing -= data.length;
      this._overflow = null;
      if (s)
        return s.write(data, cb);
      b.append(data);
      return cb();
    }
    this._cb = cb;
    this._missing = 0;
    var overflow2 = null;
    if (data.length > missing) {
      overflow2 = data.slice(missing);
      data = data.slice(0, missing);
    }
    if (s)
      s.end(data);
    else
      b.append(data);
    this._overflow = overflow2;
    this._onparse();
  };
  Extract.prototype._final = function(cb) {
    if (this._partial)
      return this.destroy(new Error("Unexpected end of data"));
    cb();
  };
  module.exports = Extract;
});

// node_modules/fs-constants/index.js
var require_fs_constants = __commonJS((exports, module) => {
  module.exports = __require("fs").constants || __require("constants");
});

// node_modules/tar-stream/pack.js
var require_pack = __commonJS((exports, module) => {
  var constants = require_fs_constants();
  var eos = require_end_of_stream();
  var inherits = require_inherits();
  var alloc = Buffer.alloc;
  var Readable = require_readable().Readable;
  var Writable = require_readable().Writable;
  var StringDecoder = __require("string_decoder").StringDecoder;
  var headers = require_headers();
  var DMODE = parseInt("755", 8);
  var FMODE = parseInt("644", 8);
  var END_OF_TAR = alloc(1024);
  var noop = function() {};
  var overflow = function(self2, size) {
    size &= 511;
    if (size)
      self2.push(END_OF_TAR.slice(0, 512 - size));
  };
  function modeToType(mode) {
    switch (mode & constants.S_IFMT) {
      case constants.S_IFBLK:
        return "block-device";
      case constants.S_IFCHR:
        return "character-device";
      case constants.S_IFDIR:
        return "directory";
      case constants.S_IFIFO:
        return "fifo";
      case constants.S_IFLNK:
        return "symlink";
    }
    return "file";
  }
  var Sink = function(to) {
    Writable.call(this);
    this.written = 0;
    this._to = to;
    this._destroyed = false;
  };
  inherits(Sink, Writable);
  Sink.prototype._write = function(data, enc, cb) {
    this.written += data.length;
    if (this._to.push(data))
      return cb();
    this._to._drain = cb;
  };
  Sink.prototype.destroy = function() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    this.emit("close");
  };
  var LinkSink = function() {
    Writable.call(this);
    this.linkname = "";
    this._decoder = new StringDecoder("utf-8");
    this._destroyed = false;
  };
  inherits(LinkSink, Writable);
  LinkSink.prototype._write = function(data, enc, cb) {
    this.linkname += this._decoder.write(data);
    cb();
  };
  LinkSink.prototype.destroy = function() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    this.emit("close");
  };
  var Void = function() {
    Writable.call(this);
    this._destroyed = false;
  };
  inherits(Void, Writable);
  Void.prototype._write = function(data, enc, cb) {
    cb(new Error("No body allowed for this entry"));
  };
  Void.prototype.destroy = function() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    this.emit("close");
  };
  var Pack = function(opts) {
    if (!(this instanceof Pack))
      return new Pack(opts);
    Readable.call(this, opts);
    this._drain = noop;
    this._finalized = false;
    this._finalizing = false;
    this._destroyed = false;
    this._stream = null;
  };
  inherits(Pack, Readable);
  Pack.prototype.entry = function(header, buffer, callback) {
    if (this._stream)
      throw new Error("already piping an entry");
    if (this._finalized || this._destroyed)
      return;
    if (typeof buffer === "function") {
      callback = buffer;
      buffer = null;
    }
    if (!callback)
      callback = noop;
    var self2 = this;
    if (!header.size || header.type === "symlink")
      header.size = 0;
    if (!header.type)
      header.type = modeToType(header.mode);
    if (!header.mode)
      header.mode = header.type === "directory" ? DMODE : FMODE;
    if (!header.uid)
      header.uid = 0;
    if (!header.gid)
      header.gid = 0;
    if (!header.mtime)
      header.mtime = new Date;
    if (typeof buffer === "string")
      buffer = Buffer.from(buffer);
    if (Buffer.isBuffer(buffer)) {
      header.size = buffer.length;
      this._encode(header);
      var ok = this.push(buffer);
      overflow(self2, header.size);
      if (ok)
        process.nextTick(callback);
      else
        this._drain = callback;
      return new Void;
    }
    if (header.type === "symlink" && !header.linkname) {
      var linkSink = new LinkSink;
      eos(linkSink, function(err) {
        if (err) {
          self2.destroy();
          return callback(err);
        }
        header.linkname = linkSink.linkname;
        self2._encode(header);
        callback();
      });
      return linkSink;
    }
    this._encode(header);
    if (header.type !== "file" && header.type !== "contiguous-file") {
      process.nextTick(callback);
      return new Void;
    }
    var sink = new Sink(this);
    this._stream = sink;
    eos(sink, function(err) {
      self2._stream = null;
      if (err) {
        self2.destroy();
        return callback(err);
      }
      if (sink.written !== header.size) {
        self2.destroy();
        return callback(new Error("size mismatch"));
      }
      overflow(self2, header.size);
      if (self2._finalizing)
        self2.finalize();
      callback();
    });
    return sink;
  };
  Pack.prototype.finalize = function() {
    if (this._stream) {
      this._finalizing = true;
      return;
    }
    if (this._finalized)
      return;
    this._finalized = true;
    this.push(END_OF_TAR);
    this.push(null);
  };
  Pack.prototype.destroy = function(err) {
    if (this._destroyed)
      return;
    this._destroyed = true;
    if (err)
      this.emit("error", err);
    this.emit("close");
    if (this._stream && this._stream.destroy)
      this._stream.destroy();
  };
  Pack.prototype._encode = function(header) {
    if (!header.pax) {
      var buf = headers.encode(header);
      if (buf) {
        this.push(buf);
        return;
      }
    }
    this._encodePax(header);
  };
  Pack.prototype._encodePax = function(header) {
    var paxHeader = headers.encodePax({
      name: header.name,
      linkname: header.linkname,
      pax: header.pax
    });
    var newHeader = {
      name: "PaxHeader",
      mode: header.mode,
      uid: header.uid,
      gid: header.gid,
      size: paxHeader.length,
      mtime: header.mtime,
      type: "pax-header",
      linkname: header.linkname && "PaxHeader",
      uname: header.uname,
      gname: header.gname,
      devmajor: header.devmajor,
      devminor: header.devminor
    };
    this.push(headers.encode(newHeader));
    this.push(paxHeader);
    overflow(this, paxHeader.length);
    newHeader.size = header.size;
    newHeader.type = header.type;
    this.push(headers.encode(newHeader));
  };
  Pack.prototype._read = function(n) {
    var drain = this._drain;
    this._drain = noop;
    drain();
  };
  module.exports = Pack;
});

// node_modules/tar-stream/index.js
var require_tar_stream = __commonJS((exports) => {
  exports.extract = require_extract();
  exports.pack = require_pack();
});

// node_modules/mkdirp-classic/index.js
var require_mkdirp_classic = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var _0777 = parseInt("0777", 8);
  module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
  function mkdirP(p, opts, f, made) {
    if (typeof opts === "function") {
      f = opts;
      opts = {};
    } else if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    if (mode === undefined) {
      mode = _0777 & ~process.umask();
    }
    if (!made)
      made = null;
    var cb = f || function() {};
    p = path.resolve(p);
    xfs.mkdir(p, mode, function(er) {
      if (!er) {
        made = made || p;
        return cb(null, made);
      }
      switch (er.code) {
        case "ENOENT":
          mkdirP(path.dirname(p), opts, function(er2, made2) {
            if (er2)
              cb(er2, made2);
            else
              mkdirP(p, opts, cb, made2);
          });
          break;
        default:
          xfs.stat(p, function(er2, stat) {
            if (er2 || !stat.isDirectory())
              cb(er, made);
            else
              cb(null, made);
          });
          break;
      }
    });
  }
  mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    if (mode === undefined) {
      mode = _0777 & ~process.umask();
    }
    if (!made)
      made = null;
    p = path.resolve(p);
    try {
      xfs.mkdirSync(p, mode);
      made = made || p;
    } catch (err0) {
      switch (err0.code) {
        case "ENOENT":
          made = sync(path.dirname(p), opts, made);
          sync(p, opts, made);
          break;
        default:
          var stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
          break;
      }
    }
    return made;
  };
});

// node_modules/tar-fs/index.js
var require_tar_fs = __commonJS((exports) => {
  var chownr = require_chownr();
  var tar = require_tar_stream();
  var pump = require_pump();
  var mkdirp = require_mkdirp_classic();
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var win32 = os.platform() === "win32";
  var noop = function() {};
  var echo = function(name) {
    return name;
  };
  var normalize = !win32 ? echo : function(name) {
    return name.replace(/\\/g, "/").replace(/[:?<>|]/g, "_");
  };
  var statAll = function(fs2, stat, cwd, ignore, entries, sort) {
    var queue = entries || ["."];
    return function loop(callback) {
      if (!queue.length)
        return callback();
      var next = queue.shift();
      var nextAbs = path.join(cwd, next);
      stat.call(fs2, nextAbs, function(err, stat2) {
        if (err)
          return callback(err);
        if (!stat2.isDirectory())
          return callback(null, next, stat2);
        fs2.readdir(nextAbs, function(err2, files) {
          if (err2)
            return callback(err2);
          if (sort)
            files.sort();
          for (var i = 0;i < files.length; i++) {
            if (!ignore(path.join(cwd, next, files[i])))
              queue.push(path.join(next, files[i]));
          }
          callback(null, next, stat2);
        });
      });
    };
  };
  var strip = function(map, level) {
    return function(header) {
      header.name = header.name.split("/").slice(level).join("/");
      var linkname = header.linkname;
      if (linkname && (header.type === "link" || path.isAbsolute(linkname))) {
        header.linkname = linkname.split("/").slice(level).join("/");
      }
      return map(header);
    };
  };
  exports.pack = function(cwd, opts) {
    if (!cwd)
      cwd = ".";
    if (!opts)
      opts = {};
    var xfs = opts.fs || fs;
    var ignore = opts.ignore || opts.filter || noop;
    var map = opts.map || noop;
    var mapStream = opts.mapStream || echo;
    var statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort);
    var strict = opts.strict !== false;
    var umask = typeof opts.umask === "number" ? ~opts.umask : ~processUmask();
    var dmode = typeof opts.dmode === "number" ? opts.dmode : 0;
    var fmode = typeof opts.fmode === "number" ? opts.fmode : 0;
    var pack = opts.pack || tar.pack();
    var finish = opts.finish || noop;
    if (opts.strip)
      map = strip(map, opts.strip);
    if (opts.readable) {
      dmode |= parseInt(555, 8);
      fmode |= parseInt(444, 8);
    }
    if (opts.writable) {
      dmode |= parseInt(333, 8);
      fmode |= parseInt(222, 8);
    }
    var onsymlink = function(filename, header) {
      xfs.readlink(path.join(cwd, filename), function(err, linkname) {
        if (err)
          return pack.destroy(err);
        header.linkname = normalize(linkname);
        pack.entry(header, onnextentry);
      });
    };
    var onstat = function(err, filename, stat) {
      if (err)
        return pack.destroy(err);
      if (!filename) {
        if (opts.finalize !== false)
          pack.finalize();
        return finish(pack);
      }
      if (stat.isSocket())
        return onnextentry();
      var header = {
        name: normalize(filename),
        mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,
        mtime: stat.mtime,
        size: stat.size,
        type: "file",
        uid: stat.uid,
        gid: stat.gid
      };
      if (stat.isDirectory()) {
        header.size = 0;
        header.type = "directory";
        header = map(header) || header;
        return pack.entry(header, onnextentry);
      }
      if (stat.isSymbolicLink()) {
        header.size = 0;
        header.type = "symlink";
        header = map(header) || header;
        return onsymlink(filename, header);
      }
      header = map(header) || header;
      if (!stat.isFile()) {
        if (strict)
          return pack.destroy(new Error("unsupported type for " + filename));
        return onnextentry();
      }
      var entry = pack.entry(header, onnextentry);
      if (!entry)
        return;
      var rs = mapStream(xfs.createReadStream(path.join(cwd, filename), { start: 0, end: header.size > 0 ? header.size - 1 : header.size }), header);
      rs.on("error", function(err2) {
        entry.destroy(err2);
      });
      pump(rs, entry);
    };
    var onnextentry = function(err) {
      if (err)
        return pack.destroy(err);
      statNext(onstat);
    };
    onnextentry();
    return pack;
  };
  var head = function(list) {
    return list.length ? list[list.length - 1] : null;
  };
  var processGetuid = function() {
    return process.getuid ? process.getuid() : -1;
  };
  var processUmask = function() {
    return process.umask ? process.umask() : 0;
  };
  exports.extract = function(cwd, opts) {
    if (!cwd)
      cwd = ".";
    if (!opts)
      opts = {};
    var xfs = opts.fs || fs;
    var ignore = opts.ignore || opts.filter || noop;
    var map = opts.map || noop;
    var mapStream = opts.mapStream || echo;
    var own = opts.chown !== false && !win32 && processGetuid() === 0;
    var extract = opts.extract || tar.extract();
    var stack = [];
    var now = new Date;
    var umask = typeof opts.umask === "number" ? ~opts.umask : ~processUmask();
    var dmode = typeof opts.dmode === "number" ? opts.dmode : 0;
    var fmode = typeof opts.fmode === "number" ? opts.fmode : 0;
    var strict = opts.strict !== false;
    if (opts.strip)
      map = strip(map, opts.strip);
    if (opts.readable) {
      dmode |= parseInt(555, 8);
      fmode |= parseInt(444, 8);
    }
    if (opts.writable) {
      dmode |= parseInt(333, 8);
      fmode |= parseInt(222, 8);
    }
    var utimesParent = function(name, cb) {
      var top;
      while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0])
        stack.pop();
      if (!top)
        return cb();
      xfs.utimes(top[0], now, top[1], cb);
    };
    var utimes = function(name, header, cb) {
      if (opts.utimes === false)
        return cb();
      if (header.type === "directory")
        return xfs.utimes(name, now, header.mtime, cb);
      if (header.type === "symlink")
        return utimesParent(name, cb);
      xfs.utimes(name, now, header.mtime, function(err) {
        if (err)
          return cb(err);
        utimesParent(name, cb);
      });
    };
    var chperm = function(name, header, cb) {
      var link = header.type === "symlink";
      var chmod = link ? xfs.lchmod : xfs.chmod;
      var chown = link ? xfs.lchown : xfs.chown;
      if (!chmod)
        return cb();
      var mode = (header.mode | (header.type === "directory" ? dmode : fmode)) & umask;
      if (chown && own)
        chown.call(xfs, name, header.uid, header.gid, onchown);
      else
        onchown(null);
      function onchown(err) {
        if (err)
          return cb(err);
        if (!chmod)
          return cb();
        chmod.call(xfs, name, mode, cb);
      }
    };
    extract.on("entry", function(header, stream, next) {
      header = map(header) || header;
      header.name = normalize(header.name);
      var name = path.join(cwd, path.join("/", header.name));
      if (ignore(name, header)) {
        stream.resume();
        return next();
      }
      var stat = function(err) {
        if (err)
          return next(err);
        utimes(name, header, function(err2) {
          if (err2)
            return next(err2);
          if (win32)
            return next();
          chperm(name, header, next);
        });
      };
      var onsymlink = function() {
        if (win32)
          return next();
        xfs.unlink(name, function() {
          xfs.symlink(header.linkname, name, stat);
        });
      };
      var onlink = function() {
        if (win32)
          return next();
        xfs.unlink(name, function() {
          var srcpath = path.join(cwd, path.join("/", header.linkname));
          xfs.link(srcpath, name, function(err) {
            if (err && err.code === "EPERM" && opts.hardlinkAsFilesFallback) {
              stream = xfs.createReadStream(srcpath);
              return onfile();
            }
            stat(err);
          });
        });
      };
      var onfile = function() {
        var ws = xfs.createWriteStream(name);
        var rs = mapStream(stream, header);
        ws.on("error", function(err) {
          rs.destroy(err);
        });
        pump(rs, ws, function(err) {
          if (err)
            return next(err);
          ws.on("close", stat);
        });
      };
      if (header.type === "directory") {
        stack.push([name, header.mtime]);
        return mkdirfix(name, {
          fs: xfs,
          own,
          uid: header.uid,
          gid: header.gid
        }, stat);
      }
      var dir = path.dirname(name);
      validate(xfs, dir, path.join(cwd, "."), function(err, valid) {
        if (err)
          return next(err);
        if (!valid)
          return next(new Error(dir + " is not a valid path"));
        mkdirfix(dir, {
          fs: xfs,
          own,
          uid: header.uid,
          gid: header.gid
        }, function(err2) {
          if (err2)
            return next(err2);
          switch (header.type) {
            case "file":
              return onfile();
            case "link":
              return onlink();
            case "symlink":
              return onsymlink();
          }
          if (strict)
            return next(new Error("unsupported type for " + name + " (" + header.type + ")"));
          stream.resume();
          next();
        });
      });
    });
    if (opts.finish)
      extract.on("finish", opts.finish);
    return extract;
  };
  function validate(fs2, name, root, cb) {
    if (name === root)
      return cb(null, true);
    fs2.lstat(name, function(err, st) {
      if (err && err.code !== "ENOENT")
        return cb(err);
      if (err || st.isDirectory())
        return validate(fs2, path.join(name, ".."), root, cb);
      cb(null, false);
    });
  }
  function mkdirfix(name, opts, cb) {
    mkdirp(name, { fs: opts.fs }, function(err, made) {
      if (!err && made && opts.own) {
        chownr(made, opts.uid, opts.gid, cb);
      } else {
        cb(err);
      }
    });
  }
});

// node_modules/through/index.js
var require_through = __commonJS((exports, module) => {
  var Stream = __require("stream");
  exports = module.exports = through;
  through.through = through;
  function through(write, end, opts) {
    write = write || function(data) {
      this.queue(data);
    };
    end = end || function() {
      this.queue(null);
    };
    var ended = false, destroyed = false, buffer = [], _ended = false;
    var stream = new Stream;
    stream.readable = stream.writable = true;
    stream.paused = false;
    stream.autoDestroy = !(opts && opts.autoDestroy === false);
    stream.write = function(data) {
      write.call(this, data);
      return !stream.paused;
    };
    function drain() {
      while (buffer.length && !stream.paused) {
        var data = buffer.shift();
        if (data === null)
          return stream.emit("end");
        else
          stream.emit("data", data);
      }
    }
    stream.queue = stream.push = function(data) {
      if (_ended)
        return stream;
      if (data === null)
        _ended = true;
      buffer.push(data);
      drain();
      return stream;
    };
    stream.on("end", function() {
      stream.readable = false;
      if (!stream.writable && stream.autoDestroy)
        process.nextTick(function() {
          stream.destroy();
        });
    });
    function _end() {
      stream.writable = false;
      end.call(stream);
      if (!stream.readable && stream.autoDestroy)
        stream.destroy();
    }
    stream.end = function(data) {
      if (ended)
        return;
      ended = true;
      if (arguments.length)
        stream.write(data);
      _end();
      return stream;
    };
    stream.destroy = function() {
      if (destroyed)
        return;
      destroyed = true;
      ended = true;
      buffer.length = 0;
      stream.writable = stream.readable = false;
      stream.emit("close");
      return stream;
    };
    stream.pause = function() {
      if (stream.paused)
        return;
      stream.paused = true;
      return stream;
    };
    stream.resume = function() {
      if (stream.paused) {
        stream.paused = false;
        stream.emit("resume");
      }
      drain();
      if (!stream.paused)
        stream.emit("drain");
      return stream;
    };
    return stream;
  }
});

// node_modules/unbzip2-stream/lib/bzip2.js
var require_bzip2 = __commonJS((exports, module) => {
  function Bzip2Error(message2) {
    this.name = "Bzip2Error";
    this.message = message2;
    this.stack = new Error().stack;
  }
  Bzip2Error.prototype = new Error;
  var message = {
    Error: function(message2) {
      throw new Bzip2Error(message2);
    }
  };
  var bzip2 = {};
  bzip2.Bzip2Error = Bzip2Error;
  bzip2.crcTable = [
    0,
    79764919,
    159529838,
    222504665,
    319059676,
    398814059,
    445009330,
    507990021,
    638119352,
    583659535,
    797628118,
    726387553,
    890018660,
    835552979,
    1015980042,
    944750013,
    1276238704,
    1221641927,
    1167319070,
    1095957929,
    1595256236,
    1540665371,
    1452775106,
    1381403509,
    1780037320,
    1859660671,
    1671105958,
    1733955601,
    2031960084,
    2111593891,
    1889500026,
    1952343757,
    2552477408,
    2632100695,
    2443283854,
    2506133561,
    2334638140,
    2414271883,
    2191915858,
    2254759653,
    3190512472,
    3135915759,
    3081330742,
    3009969537,
    2905550212,
    2850959411,
    2762807018,
    2691435357,
    3560074640,
    3505614887,
    3719321342,
    3648080713,
    3342211916,
    3287746299,
    3467911202,
    3396681109,
    4063920168,
    4143685023,
    4223187782,
    4286162673,
    3779000052,
    3858754371,
    3904687514,
    3967668269,
    881225847,
    809987520,
    1023691545,
    969234094,
    662832811,
    591600412,
    771767749,
    717299826,
    311336399,
    374308984,
    453813921,
    533576470,
    25881363,
    88864420,
    134795389,
    214552010,
    2023205639,
    2086057648,
    1897238633,
    1976864222,
    1804852699,
    1867694188,
    1645340341,
    1724971778,
    1587496639,
    1516133128,
    1461550545,
    1406951526,
    1302016099,
    1230646740,
    1142491917,
    1087903418,
    2896545431,
    2825181984,
    2770861561,
    2716262478,
    3215044683,
    3143675388,
    3055782693,
    3001194130,
    2326604591,
    2389456536,
    2200899649,
    2280525302,
    2578013683,
    2640855108,
    2418763421,
    2498394922,
    3769900519,
    3832873040,
    3912640137,
    3992402750,
    4088425275,
    4151408268,
    4197601365,
    4277358050,
    3334271071,
    3263032808,
    3476998961,
    3422541446,
    3585640067,
    3514407732,
    3694837229,
    3640369242,
    1762451694,
    1842216281,
    1619975040,
    1682949687,
    2047383090,
    2127137669,
    1938468188,
    2001449195,
    1325665622,
    1271206113,
    1183200824,
    1111960463,
    1543535498,
    1489069629,
    1434599652,
    1363369299,
    622672798,
    568075817,
    748617968,
    677256519,
    907627842,
    853037301,
    1067152940,
    995781531,
    51762726,
    131386257,
    177728840,
    240578815,
    269590778,
    349224269,
    429104020,
    491947555,
    4046411278,
    4126034873,
    4172115296,
    4234965207,
    3794477266,
    3874110821,
    3953728444,
    4016571915,
    3609705398,
    3555108353,
    3735388376,
    3664026991,
    3290680682,
    3236090077,
    3449943556,
    3378572211,
    3174993278,
    3120533705,
    3032266256,
    2961025959,
    2923101090,
    2868635157,
    2813903052,
    2742672763,
    2604032198,
    2683796849,
    2461293480,
    2524268063,
    2284983834,
    2364738477,
    2175806836,
    2238787779,
    1569362073,
    1498123566,
    1409854455,
    1355396672,
    1317987909,
    1246755826,
    1192025387,
    1137557660,
    2072149281,
    2135122070,
    1912620623,
    1992383480,
    1753615357,
    1816598090,
    1627664531,
    1707420964,
    295390185,
    358241886,
    404320391,
    483945776,
    43990325,
    106832002,
    186451547,
    266083308,
    932423249,
    861060070,
    1041341759,
    986742920,
    613929101,
    542559546,
    756411363,
    701822548,
    3316196985,
    3244833742,
    3425377559,
    3370778784,
    3601682597,
    3530312978,
    3744426955,
    3689838204,
    3819031489,
    3881883254,
    3928223919,
    4007849240,
    4037393693,
    4100235434,
    4180117107,
    4259748804,
    2310601993,
    2373574846,
    2151335527,
    2231098320,
    2596047829,
    2659030626,
    2470359227,
    2550115596,
    2947551409,
    2876312838,
    2788305887,
    2733848168,
    3165939309,
    3094707162,
    3040238851,
    2985771188
  ];
  bzip2.array = function(bytes) {
    var bit = 0, byte = 0;
    var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
    return function(n) {
      var result = 0;
      while (n > 0) {
        var left = 8 - bit;
        if (n >= left) {
          result <<= left;
          result |= BITMASK[left] & bytes[byte++];
          bit = 0;
          n -= left;
        } else {
          result <<= n;
          result |= (bytes[byte] & BITMASK[n] << 8 - n - bit) >> 8 - n - bit;
          bit += n;
          n = 0;
        }
      }
      return result;
    };
  };
  bzip2.simple = function(srcbuffer, stream) {
    var bits = bzip2.array(srcbuffer);
    var size = bzip2.header(bits);
    var ret = false;
    var bufsize = 1e5 * size;
    var buf = new Int32Array(bufsize);
    do {
      ret = bzip2.decompress(bits, stream, buf, bufsize);
    } while (!ret);
  };
  bzip2.header = function(bits) {
    this.byteCount = new Int32Array(256);
    this.symToByte = new Uint8Array(256);
    this.mtfSymbol = new Int32Array(256);
    this.selectors = new Uint8Array(32768);
    if (bits(8 * 3) != 4348520)
      message.Error("No magic number found");
    var i = bits(8) - 48;
    if (i < 1 || i > 9)
      message.Error("Not a BZIP archive");
    return i;
  };
  bzip2.decompress = function(bits, stream, buf, bufsize, streamCRC) {
    var MAX_HUFCODE_BITS = 20;
    var MAX_SYMBOLS = 258;
    var SYMBOL_RUNA = 0;
    var SYMBOL_RUNB = 1;
    var GROUP_SIZE = 50;
    var crc = 0 ^ -1;
    for (var h = "", i = 0;i < 6; i++)
      h += bits(8).toString(16);
    if (h == "177245385090") {
      var finalCRC = bits(32) | 0;
      if (finalCRC !== streamCRC)
        message.Error("Error in bzip2: crc32 do not match");
      bits(null);
      return null;
    }
    if (h != "314159265359")
      message.Error("eek not valid bzip data");
    var crcblock = bits(32) | 0;
    if (bits(1))
      message.Error("unsupported obsolete version");
    var origPtr = bits(24);
    if (origPtr > bufsize)
      message.Error("Initial position larger than buffer size");
    var t = bits(16);
    var symTotal = 0;
    for (i = 0;i < 16; i++) {
      if (t & 1 << 15 - i) {
        var k = bits(16);
        for (j = 0;j < 16; j++) {
          if (k & 1 << 15 - j) {
            this.symToByte[symTotal++] = 16 * i + j;
          }
        }
      }
    }
    var groupCount = bits(3);
    if (groupCount < 2 || groupCount > 6)
      message.Error("another error");
    var nSelectors = bits(15);
    if (nSelectors == 0)
      message.Error("meh");
    for (var i = 0;i < groupCount; i++)
      this.mtfSymbol[i] = i;
    for (var i = 0;i < nSelectors; i++) {
      for (var j = 0;bits(1); j++)
        if (j >= groupCount)
          message.Error("whoops another error");
      var uc = this.mtfSymbol[j];
      for (var k = j - 1;k >= 0; k--) {
        this.mtfSymbol[k + 1] = this.mtfSymbol[k];
      }
      this.mtfSymbol[0] = uc;
      this.selectors[i] = uc;
    }
    var symCount = symTotal + 2;
    var groups = [];
    var length = new Uint8Array(MAX_SYMBOLS), temp = new Uint16Array(MAX_HUFCODE_BITS + 1);
    var hufGroup;
    for (var j = 0;j < groupCount; j++) {
      t = bits(5);
      for (var i = 0;i < symCount; i++) {
        while (true) {
          if (t < 1 || t > MAX_HUFCODE_BITS)
            message.Error("I gave up a while ago on writing error messages");
          if (!bits(1))
            break;
          if (!bits(1))
            t++;
          else
            t--;
        }
        length[i] = t;
      }
      var minLen, maxLen;
      minLen = maxLen = length[0];
      for (var i = 1;i < symCount; i++) {
        if (length[i] > maxLen)
          maxLen = length[i];
        else if (length[i] < minLen)
          minLen = length[i];
      }
      hufGroup = groups[j] = {};
      hufGroup.permute = new Int32Array(MAX_SYMBOLS);
      hufGroup.limit = new Int32Array(MAX_HUFCODE_BITS + 1);
      hufGroup.base = new Int32Array(MAX_HUFCODE_BITS + 1);
      hufGroup.minLen = minLen;
      hufGroup.maxLen = maxLen;
      var base = hufGroup.base;
      var limit = hufGroup.limit;
      var pp = 0;
      for (var i = minLen;i <= maxLen; i++)
        for (var t = 0;t < symCount; t++)
          if (length[t] == i)
            hufGroup.permute[pp++] = t;
      for (i = minLen;i <= maxLen; i++)
        temp[i] = limit[i] = 0;
      for (i = 0;i < symCount; i++)
        temp[length[i]]++;
      pp = t = 0;
      for (i = minLen;i < maxLen; i++) {
        pp += temp[i];
        limit[i] = pp - 1;
        pp <<= 1;
        base[i + 1] = pp - (t += temp[i]);
      }
      limit[maxLen] = pp + temp[maxLen] - 1;
      base[minLen] = 0;
    }
    for (var i = 0;i < 256; i++) {
      this.mtfSymbol[i] = i;
      this.byteCount[i] = 0;
    }
    var runPos, count, symCount, selector;
    runPos = count = symCount = selector = 0;
    while (true) {
      if (!symCount--) {
        symCount = GROUP_SIZE - 1;
        if (selector >= nSelectors)
          message.Error("meow i'm a kitty, that's an error");
        hufGroup = groups[this.selectors[selector++]];
        base = hufGroup.base;
        limit = hufGroup.limit;
      }
      i = hufGroup.minLen;
      j = bits(i);
      while (true) {
        if (i > hufGroup.maxLen)
          message.Error("rawr i'm a dinosaur");
        if (j <= limit[i])
          break;
        i++;
        j = j << 1 | bits(1);
      }
      j -= base[i];
      if (j < 0 || j >= MAX_SYMBOLS)
        message.Error("moo i'm a cow");
      var nextSym = hufGroup.permute[j];
      if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {
        if (!runPos) {
          runPos = 1;
          t = 0;
        }
        if (nextSym == SYMBOL_RUNA)
          t += runPos;
        else
          t += 2 * runPos;
        runPos <<= 1;
        continue;
      }
      if (runPos) {
        runPos = 0;
        if (count + t > bufsize)
          message.Error("Boom.");
        uc = this.symToByte[this.mtfSymbol[0]];
        this.byteCount[uc] += t;
        while (t--)
          buf[count++] = uc;
      }
      if (nextSym > symTotal)
        break;
      if (count >= bufsize)
        message.Error("I can't think of anything. Error");
      i = nextSym - 1;
      uc = this.mtfSymbol[i];
      for (var k = i - 1;k >= 0; k--) {
        this.mtfSymbol[k + 1] = this.mtfSymbol[k];
      }
      this.mtfSymbol[0] = uc;
      uc = this.symToByte[uc];
      this.byteCount[uc]++;
      buf[count++] = uc;
    }
    if (origPtr < 0 || origPtr >= count)
      message.Error("I'm a monkey and I'm throwing something at someone, namely you");
    var j = 0;
    for (var i = 0;i < 256; i++) {
      k = j + this.byteCount[i];
      this.byteCount[i] = j;
      j = k;
    }
    for (var i = 0;i < count; i++) {
      uc = buf[i] & 255;
      buf[this.byteCount[uc]] |= i << 8;
      this.byteCount[uc]++;
    }
    var pos = 0, current = 0, run = 0;
    if (count) {
      pos = buf[origPtr];
      current = pos & 255;
      pos >>= 8;
      run = -1;
    }
    count = count;
    var copies, previous, outbyte;
    while (count) {
      count--;
      previous = current;
      pos = buf[pos];
      current = pos & 255;
      pos >>= 8;
      if (run++ == 3) {
        copies = current;
        outbyte = previous;
        current = -1;
      } else {
        copies = 1;
        outbyte = current;
      }
      while (copies--) {
        crc = (crc << 8 ^ this.crcTable[(crc >> 24 ^ outbyte) & 255]) & 4294967295;
        stream(outbyte);
      }
      if (current != previous)
        run = 0;
    }
    crc = (crc ^ -1) >>> 0;
    if ((crc | 0) != (crcblock | 0))
      message.Error("Error in bzip2: crc32 do not match");
    streamCRC = (crc ^ (streamCRC << 1 | streamCRC >>> 31)) & 4294967295;
    return streamCRC;
  };
  module.exports = bzip2;
});

// node_modules/unbzip2-stream/lib/bit_iterator.js
var require_bit_iterator = __commonJS((exports, module) => {
  var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
  module.exports = function bitIterator(nextBuffer) {
    var bit = 0, byte = 0;
    var bytes = nextBuffer();
    var f = function(n) {
      if (n === null && bit != 0) {
        bit = 0;
        byte++;
        return;
      }
      var result = 0;
      while (n > 0) {
        if (byte >= bytes.length) {
          byte = 0;
          bytes = nextBuffer();
        }
        var left = 8 - bit;
        if (bit === 0 && n > 0)
          f.bytesRead++;
        if (n >= left) {
          result <<= left;
          result |= BITMASK[left] & bytes[byte++];
          bit = 0;
          n -= left;
        } else {
          result <<= n;
          result |= (bytes[byte] & BITMASK[n] << 8 - n - bit) >> 8 - n - bit;
          bit += n;
          n = 0;
        }
      }
      return result;
    };
    f.bytesRead = 0;
    return f;
  };
});

// node_modules/unbzip2-stream/index.js
var require_unbzip2_stream = __commonJS((exports, module) => {
  var through = require_through();
  var bz2 = require_bzip2();
  var bitIterator = require_bit_iterator();
  module.exports = unbzip2Stream;
  function unbzip2Stream() {
    var bufferQueue = [];
    var hasBytes = 0;
    var blockSize = 0;
    var broken = false;
    var done = false;
    var bitReader = null;
    var streamCRC = null;
    function decompressBlock(push) {
      if (!blockSize) {
        blockSize = bz2.header(bitReader);
        streamCRC = 0;
        return true;
      } else {
        var bufsize = 1e5 * blockSize;
        var buf = new Int32Array(bufsize);
        var chunk = [];
        var f = function(b) {
          chunk.push(b);
        };
        streamCRC = bz2.decompress(bitReader, f, buf, bufsize, streamCRC);
        if (streamCRC === null) {
          blockSize = 0;
          return false;
        } else {
          push(Buffer.from(chunk));
          return true;
        }
      }
    }
    var outlength = 0;
    function decompressAndQueue(stream) {
      if (broken)
        return;
      try {
        return decompressBlock(function(d) {
          stream.queue(d);
          if (d !== null) {
            outlength += d.length;
          } else {}
        });
      } catch (e) {
        stream.emit("error", e);
        broken = true;
        return false;
      }
    }
    return through(function write(data) {
      bufferQueue.push(data);
      hasBytes += data.length;
      if (bitReader === null) {
        bitReader = bitIterator(function() {
          return bufferQueue.shift();
        });
      }
      while (!broken && hasBytes - bitReader.bytesRead + 1 >= (25000 + 1e5 * blockSize || 4)) {
        decompressAndQueue(this);
      }
    }, function end(x) {
      while (!broken && bitReader && hasBytes > bitReader.bytesRead) {
        decompressAndQueue(this);
      }
      if (!broken) {
        if (streamCRC !== null)
          this.emit("error", new Error("input stream ended prematurely"));
        this.queue(null);
      }
    });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/BrowserFetcher.js
var require_BrowserFetcher = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  var _BrowserFetcher_instances;
  var _BrowserFetcher_product;
  var _BrowserFetcher_downloadsFolder;
  var _BrowserFetcher_downloadHost;
  var _BrowserFetcher_platform;
  var _BrowserFetcher_getFolderPath;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BrowserFetcher = undefined;
  var childProcess = __importStar(__require("child_process"));
  var extract_zip_1 = __importDefault(require_extract_zip());
  var fs = __importStar(__require("fs"));
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  var https_proxy_agent_1 = __importDefault(require_dist());
  var os = __importStar(__require("os"));
  var path = __importStar(__require("path"));
  var proxy_from_env_1 = require_proxy_from_env();
  var rimraf_1 = __importDefault(require_rimraf());
  var tar_fs_1 = __importDefault(require_tar_fs());
  var unbzip2_stream_1 = __importDefault(require_unbzip2_stream());
  var URL2 = __importStar(__require("url"));
  var util = __importStar(__require("util"));
  var util_1 = __require("util");
  var Debug_js_1 = require_Debug();
  var assert_js_1 = require_assert();
  var experimentalChromiumMacArm = process.env["PUPPETEER_EXPERIMENTAL_CHROMIUM_MAC_ARM"] || process.env["npm_config_puppeteer_experimental_chromium_mac_arm"];
  var debugFetcher = (0, Debug_js_1.debug)("puppeteer:fetcher");
  var downloadURLs = {
    chrome: {
      linux: "%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip",
      mac: "%s/chromium-browser-snapshots/Mac/%d/%s.zip",
      mac_arm: "%s/chromium-browser-snapshots/Mac_Arm/%d/%s.zip",
      win32: "%s/chromium-browser-snapshots/Win/%d/%s.zip",
      win64: "%s/chromium-browser-snapshots/Win_x64/%d/%s.zip"
    },
    firefox: {
      linux: "%s/firefox-%s.en-US.%s-x86_64.tar.bz2",
      mac: "%s/firefox-%s.en-US.%s.dmg",
      win32: "%s/firefox-%s.en-US.%s.zip",
      win64: "%s/firefox-%s.en-US.%s.zip"
    }
  };
  var browserConfig = {
    chrome: {
      host: "https://storage.googleapis.com",
      destination: ".local-chromium"
    },
    firefox: {
      host: "https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central",
      destination: ".local-firefox"
    }
  };
  function archiveName(product, platform, revision) {
    switch (product) {
      case "chrome":
        switch (platform) {
          case "linux":
            return "chrome-linux";
          case "mac_arm":
          case "mac":
            return "chrome-mac";
          case "win32":
          case "win64":
            return parseInt(revision, 10) > 591479 ? "chrome-win" : "chrome-win32";
        }
      case "firefox":
        return platform;
    }
  }
  function downloadURL(product, platform, host, revision) {
    const url = util.format(downloadURLs[product][platform], host, revision, archiveName(product, platform, revision));
    return url;
  }
  function handleArm64() {
    let exists = fs.existsSync("/usr/bin/chromium-browser");
    if (exists) {
      return;
    }
    exists = fs.existsSync("/usr/bin/chromium");
    if (exists) {
      return;
    }
    console.error("The chromium binary is not available for arm64." + `
If you are on Ubuntu, you can install with: ` + `

 sudo apt install chromium
` + `

 sudo apt install chromium-browser
`);
    throw new Error;
  }
  var readdirAsync = (0, util_1.promisify)(fs.readdir.bind(fs));
  var mkdirAsync = (0, util_1.promisify)(fs.mkdir.bind(fs));
  var unlinkAsync = (0, util_1.promisify)(fs.unlink.bind(fs));
  var chmodAsync = (0, util_1.promisify)(fs.chmod.bind(fs));
  function existsAsync(filePath) {
    return new Promise((resolve) => {
      fs.access(filePath, (err) => {
        return resolve(!err);
      });
    });
  }

  class BrowserFetcher {
    constructor(projectRoot, options = {}) {
      _BrowserFetcher_instances.add(this);
      _BrowserFetcher_product.set(this, undefined);
      _BrowserFetcher_downloadsFolder.set(this, undefined);
      _BrowserFetcher_downloadHost.set(this, undefined);
      _BrowserFetcher_platform.set(this, undefined);
      __classPrivateFieldSet(this, _BrowserFetcher_product, (options.product || "chrome").toLowerCase(), "f");
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _BrowserFetcher_product, "f") === "chrome" || __classPrivateFieldGet(this, _BrowserFetcher_product, "f") === "firefox", `Unknown product: "${options.product}"`);
      __classPrivateFieldSet(this, _BrowserFetcher_downloadsFolder, options.path || path.join(projectRoot, browserConfig[__classPrivateFieldGet(this, _BrowserFetcher_product, "f")].destination), "f");
      __classPrivateFieldSet(this, _BrowserFetcher_downloadHost, options.host || browserConfig[__classPrivateFieldGet(this, _BrowserFetcher_product, "f")].host, "f");
      if (options.platform) {
        __classPrivateFieldSet(this, _BrowserFetcher_platform, options.platform, "f");
      } else {
        const platform = os.platform();
        switch (platform) {
          case "darwin":
            switch (__classPrivateFieldGet(this, _BrowserFetcher_product, "f")) {
              case "chrome":
                __classPrivateFieldSet(this, _BrowserFetcher_platform, os.arch() === "arm64" && experimentalChromiumMacArm ? "mac_arm" : "mac", "f");
                break;
              case "firefox":
                __classPrivateFieldSet(this, _BrowserFetcher_platform, "mac", "f");
                break;
            }
            break;
          case "linux":
            __classPrivateFieldSet(this, _BrowserFetcher_platform, "linux", "f");
            break;
          case "win32":
            __classPrivateFieldSet(this, _BrowserFetcher_platform, os.arch() === "x64" || os.arch() === "arm64" && _isWindows11(os.release()) ? "win64" : "win32", "f");
            return;
          default:
            (0, assert_js_1.assert)(false, "Unsupported platform: " + platform);
        }
      }
      (0, assert_js_1.assert)(downloadURLs[__classPrivateFieldGet(this, _BrowserFetcher_product, "f")][__classPrivateFieldGet(this, _BrowserFetcher_platform, "f")], "Unsupported platform: " + __classPrivateFieldGet(this, _BrowserFetcher_platform, "f"));
    }
    platform() {
      return __classPrivateFieldGet(this, _BrowserFetcher_platform, "f");
    }
    product() {
      return __classPrivateFieldGet(this, _BrowserFetcher_product, "f");
    }
    host() {
      return __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, "f");
    }
    canDownload(revision) {
      const url = downloadURL(__classPrivateFieldGet(this, _BrowserFetcher_product, "f"), __classPrivateFieldGet(this, _BrowserFetcher_platform, "f"), __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, "f"), revision);
      return new Promise((resolve) => {
        const request = httpRequest(url, "HEAD", (response) => {
          resolve(response.statusCode === 200);
        }, false);
        request.on("error", (error) => {
          console.error(error);
          resolve(false);
        });
      });
    }
    async download(revision, progressCallback = () => {}) {
      const url = downloadURL(__classPrivateFieldGet(this, _BrowserFetcher_product, "f"), __classPrivateFieldGet(this, _BrowserFetcher_platform, "f"), __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, "f"), revision);
      const fileName = url.split("/").pop();
      (0, assert_js_1.assert)(fileName, `A malformed download URL was found: ${url}.`);
      const archivePath = path.join(__classPrivateFieldGet(this, _BrowserFetcher_downloadsFolder, "f"), fileName);
      const outputPath = __classPrivateFieldGet(this, _BrowserFetcher_instances, "m", _BrowserFetcher_getFolderPath).call(this, revision);
      if (await existsAsync(outputPath)) {
        return this.revisionInfo(revision);
      }
      if (!await existsAsync(__classPrivateFieldGet(this, _BrowserFetcher_downloadsFolder, "f"))) {
        await mkdirAsync(__classPrivateFieldGet(this, _BrowserFetcher_downloadsFolder, "f"));
      }
      if (os.platform() === "linux" && os.arch() === "arm64") {
        handleArm64();
        return;
      }
      try {
        await _downloadFile(url, archivePath, progressCallback);
        await install(archivePath, outputPath);
      } finally {
        if (await existsAsync(archivePath)) {
          await unlinkAsync(archivePath);
        }
      }
      const revisionInfo = this.revisionInfo(revision);
      if (revisionInfo) {
        await chmodAsync(revisionInfo.executablePath, 493);
      }
      return revisionInfo;
    }
    async localRevisions() {
      if (!await existsAsync(__classPrivateFieldGet(this, _BrowserFetcher_downloadsFolder, "f"))) {
        return [];
      }
      const fileNames = await readdirAsync(__classPrivateFieldGet(this, _BrowserFetcher_downloadsFolder, "f"));
      return fileNames.map((fileName) => {
        return parseFolderPath(__classPrivateFieldGet(this, _BrowserFetcher_product, "f"), fileName);
      }).filter((entry) => {
        var _a;
        return (_a = entry && entry.platform === __classPrivateFieldGet(this, _BrowserFetcher_platform, "f")) !== null && _a !== undefined ? _a : false;
      }).map((entry) => {
        return entry.revision;
      });
    }
    async remove(revision) {
      const folderPath = __classPrivateFieldGet(this, _BrowserFetcher_instances, "m", _BrowserFetcher_getFolderPath).call(this, revision);
      (0, assert_js_1.assert)(await existsAsync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);
      await new Promise((fulfill) => {
        return (0, rimraf_1.default)(folderPath, fulfill);
      });
    }
    revisionInfo(revision) {
      const folderPath = __classPrivateFieldGet(this, _BrowserFetcher_instances, "m", _BrowserFetcher_getFolderPath).call(this, revision);
      let executablePath = "";
      if (__classPrivateFieldGet(this, _BrowserFetcher_product, "f") === "chrome") {
        if (__classPrivateFieldGet(this, _BrowserFetcher_platform, "f") === "mac" || __classPrivateFieldGet(this, _BrowserFetcher_platform, "f") === "mac_arm") {
          executablePath = path.join(folderPath, archiveName(__classPrivateFieldGet(this, _BrowserFetcher_product, "f"), __classPrivateFieldGet(this, _BrowserFetcher_platform, "f"), revision), "Chromium.app", "Contents", "MacOS", "Chromium");
        } else if (__classPrivateFieldGet(this, _BrowserFetcher_platform, "f") === "linux") {
          executablePath = path.join(folderPath, archiveName(__classPrivateFieldGet(this, _BrowserFetcher_product, "f"), __classPrivateFieldGet(this, _BrowserFetcher_platform, "f"), revision), "chrome");
        } else if (__classPrivateFieldGet(this, _BrowserFetcher_platform, "f") === "win32" || __classPrivateFieldGet(this, _BrowserFetcher_platform, "f") === "win64") {
          executablePath = path.join(folderPath, archiveName(__classPrivateFieldGet(this, _BrowserFetcher_product, "f"), __classPrivateFieldGet(this, _BrowserFetcher_platform, "f"), revision), "chrome.exe");
        } else {
          throw new Error("Unsupported platform: " + __classPrivateFieldGet(this, _BrowserFetcher_platform, "f"));
        }
      } else if (__classPrivateFieldGet(this, _BrowserFetcher_product, "f") === "firefox") {
        if (__classPrivateFieldGet(this, _BrowserFetcher_platform, "f") === "mac" || __classPrivateFieldGet(this, _BrowserFetcher_platform, "f") === "mac_arm") {
          executablePath = path.join(folderPath, "Firefox Nightly.app", "Contents", "MacOS", "firefox");
        } else if (__classPrivateFieldGet(this, _BrowserFetcher_platform, "f") === "linux") {
          executablePath = path.join(folderPath, "firefox", "firefox");
        } else if (__classPrivateFieldGet(this, _BrowserFetcher_platform, "f") === "win32" || __classPrivateFieldGet(this, _BrowserFetcher_platform, "f") === "win64") {
          executablePath = path.join(folderPath, "firefox", "firefox.exe");
        } else {
          throw new Error("Unsupported platform: " + __classPrivateFieldGet(this, _BrowserFetcher_platform, "f"));
        }
      } else {
        throw new Error("Unsupported product: " + __classPrivateFieldGet(this, _BrowserFetcher_product, "f"));
      }
      const url = downloadURL(__classPrivateFieldGet(this, _BrowserFetcher_product, "f"), __classPrivateFieldGet(this, _BrowserFetcher_platform, "f"), __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, "f"), revision);
      const local = fs.existsSync(folderPath);
      debugFetcher({
        revision,
        executablePath,
        folderPath,
        local,
        url,
        product: __classPrivateFieldGet(this, _BrowserFetcher_product, "f")
      });
      return {
        revision,
        executablePath,
        folderPath,
        local,
        url,
        product: __classPrivateFieldGet(this, _BrowserFetcher_product, "f")
      };
    }
  }
  exports.BrowserFetcher = BrowserFetcher;
  _BrowserFetcher_product = new WeakMap, _BrowserFetcher_downloadsFolder = new WeakMap, _BrowserFetcher_downloadHost = new WeakMap, _BrowserFetcher_platform = new WeakMap, _BrowserFetcher_instances = new WeakSet, _BrowserFetcher_getFolderPath = function _BrowserFetcher_getFolderPath(revision) {
    return path.resolve(__classPrivateFieldGet(this, _BrowserFetcher_downloadsFolder, "f"), `${__classPrivateFieldGet(this, _BrowserFetcher_platform, "f")}-${revision}`);
  };
  function parseFolderPath(product, folderPath) {
    const name = path.basename(folderPath);
    const splits = name.split("-");
    if (splits.length !== 2) {
      return;
    }
    const [platform, revision] = splits;
    if (!revision || !platform || !(platform in downloadURLs[product])) {
      return;
    }
    return { product, platform, revision };
  }
  function _isWindows11(version) {
    const parts = version.split(".");
    if (parts.length > 2) {
      const major = parseInt(parts[0], 10);
      const minor = parseInt(parts[1], 10);
      const patch = parseInt(parts[2], 10);
      return major > 10 || major === 10 && minor > 0 || major === 10 && minor === 0 && patch >= 22000;
    }
    return false;
  }
  function _downloadFile(url, destinationPath, progressCallback) {
    debugFetcher(`Downloading binary from ${url}`);
    let fulfill;
    let reject;
    const promise = new Promise((x, y) => {
      fulfill = x;
      reject = y;
    });
    let downloadedBytes = 0;
    let totalBytes = 0;
    const request = httpRequest(url, "GET", (response) => {
      if (response.statusCode !== 200) {
        const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);
        response.resume();
        reject(error);
        return;
      }
      const file = fs.createWriteStream(destinationPath);
      file.on("finish", () => {
        return fulfill();
      });
      file.on("error", (error) => {
        return reject(error);
      });
      response.pipe(file);
      totalBytes = parseInt(response.headers["content-length"], 10);
      if (progressCallback) {
        response.on("data", onData);
      }
    });
    request.on("error", (error) => {
      return reject(error);
    });
    return promise;
    function onData(chunk) {
      downloadedBytes += chunk.length;
      progressCallback(downloadedBytes, totalBytes);
    }
  }
  function install(archivePath, folderPath) {
    debugFetcher(`Installing ${archivePath} to ${folderPath}`);
    if (archivePath.endsWith(".zip")) {
      return (0, extract_zip_1.default)(archivePath, { dir: folderPath });
    } else if (archivePath.endsWith(".tar.bz2")) {
      return _extractTar(archivePath, folderPath);
    } else if (archivePath.endsWith(".dmg")) {
      return mkdirAsync(folderPath).then(() => {
        return _installDMG(archivePath, folderPath);
      });
    } else {
      throw new Error(`Unsupported archive format: ${archivePath}`);
    }
  }
  function _extractTar(tarPath, folderPath) {
    return new Promise((fulfill, reject) => {
      const tarStream = tar_fs_1.default.extract(folderPath);
      tarStream.on("error", reject);
      tarStream.on("finish", fulfill);
      const readStream = fs.createReadStream(tarPath);
      readStream.pipe((0, unbzip2_stream_1.default)()).pipe(tarStream);
    });
  }
  function _installDMG(dmgPath, folderPath) {
    let mountPath;
    return new Promise((fulfill, reject) => {
      const mountCommand = `hdiutil attach -nobrowse -noautoopen "${dmgPath}"`;
      childProcess.exec(mountCommand, (err, stdout) => {
        if (err) {
          return reject(err);
        }
        const volumes = stdout.match(/\/Volumes\/(.*)/m);
        if (!volumes) {
          return reject(new Error(`Could not find volume path in ${stdout}`));
        }
        mountPath = volumes[0];
        readdirAsync(mountPath).then((fileNames) => {
          const appName = fileNames.find((item) => {
            return typeof item === "string" && item.endsWith(".app");
          });
          if (!appName) {
            return reject(new Error(`Cannot find app in ${mountPath}`));
          }
          const copyPath = path.join(mountPath, appName);
          debugFetcher(`Copying ${copyPath} to ${folderPath}`);
          childProcess.exec(`cp -R "${copyPath}" "${folderPath}"`, (err2) => {
            if (err2) {
              reject(err2);
            } else {
              fulfill();
            }
          });
        }).catch(reject);
      });
    }).catch((error) => {
      console.error(error);
    }).finally(() => {
      if (!mountPath) {
        return;
      }
      const unmountCommand = `hdiutil detach "${mountPath}" -quiet`;
      debugFetcher(`Unmounting ${mountPath}`);
      childProcess.exec(unmountCommand, (err) => {
        if (err) {
          console.error(`Error unmounting dmg: ${err}`);
        }
      });
    });
  }
  function httpRequest(url, method, response, keepAlive = true) {
    const urlParsed = URL2.parse(url);
    let options = {
      ...urlParsed,
      method,
      headers: keepAlive ? {
        Connection: "keep-alive"
      } : undefined
    };
    const proxyURL = (0, proxy_from_env_1.getProxyForUrl)(url);
    if (proxyURL) {
      if (url.startsWith("http:")) {
        const proxy = URL2.parse(proxyURL);
        options = {
          path: options.href,
          host: proxy.hostname,
          port: proxy.port
        };
      } else {
        const parsedProxyURL = URL2.parse(proxyURL);
        const proxyOptions = {
          ...parsedProxyURL,
          secureProxy: parsedProxyURL.protocol === "https:"
        };
        options.agent = (0, https_proxy_agent_1.default)(proxyOptions);
        options.rejectUnauthorized = false;
      }
    }
    const requestCallback = (res) => {
      if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
        httpRequest(res.headers.location, method, response);
      } else {
        response(res);
      }
    };
    const request = options.protocol === "https:" ? https.request(options, requestCallback) : http.request(options, requestCallback);
    request.end();
    return request;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/compat.js
var require_compat = __commonJS((exports) => {
  var __dirname = "/Users/nadhi/Documents/GitHub/Whatsapp-Bot/node_modules/puppeteer-core/lib/cjs/puppeteer";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.puppeteerDirname = undefined;
  var path_1 = __require("path");
  var puppeteerDirname;
  exports.puppeteerDirname = puppeteerDirname;
  try {
    exports.puppeteerDirname = puppeteerDirname = (0, path_1.dirname)(__require.resolve("./compat"));
  } catch (error) {
    exports.puppeteerDirname = puppeteerDirname = __dirname;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rootDirname = undefined;
  var path_1 = __require("path");
  var compat_js_1 = require_compat();
  exports.rootDirname = (0, path_1.dirname)((0, path_1.dirname)((0, path_1.dirname)(compat_js_1.puppeteerDirname)));
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/WebWorker.js
var require_WebWorker = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _WebWorker_executionContext;
  var _WebWorker_client;
  var _WebWorker_url;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebWorker = undefined;
  var EventEmitter_js_1 = require_EventEmitter();
  var ExecutionContext_js_1 = require_ExecutionContext();
  var JSHandle_js_1 = require_JSHandle();
  var util_js_1 = require_util();
  var DeferredPromise_js_1 = require_DeferredPromise();

  class WebWorker extends EventEmitter_js_1.EventEmitter {
    constructor(client, url, consoleAPICalled, exceptionThrown) {
      super();
      _WebWorker_executionContext.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
      _WebWorker_client.set(this, undefined);
      _WebWorker_url.set(this, undefined);
      __classPrivateFieldSet(this, _WebWorker_client, client, "f");
      __classPrivateFieldSet(this, _WebWorker_url, url, "f");
      __classPrivateFieldGet(this, _WebWorker_client, "f").once("Runtime.executionContextCreated", async (event) => {
        const context = new ExecutionContext_js_1.ExecutionContext(client, event.context);
        __classPrivateFieldGet(this, _WebWorker_executionContext, "f").resolve(context);
      });
      __classPrivateFieldGet(this, _WebWorker_client, "f").on("Runtime.consoleAPICalled", async (event) => {
        const context = await __classPrivateFieldGet(this, _WebWorker_executionContext, "f");
        return consoleAPICalled(event.type, event.args.map((object) => {
          return new JSHandle_js_1.JSHandle(context, object);
        }), event.stackTrace);
      });
      __classPrivateFieldGet(this, _WebWorker_client, "f").on("Runtime.exceptionThrown", (exception) => {
        return exceptionThrown(exception.exceptionDetails);
      });
      __classPrivateFieldGet(this, _WebWorker_client, "f").send("Runtime.enable").catch(util_js_1.debugError);
    }
    async executionContext() {
      return __classPrivateFieldGet(this, _WebWorker_executionContext, "f");
    }
    url() {
      return __classPrivateFieldGet(this, _WebWorker_url, "f");
    }
    async evaluate(pageFunction, ...args) {
      const context = await __classPrivateFieldGet(this, _WebWorker_executionContext, "f");
      return context.evaluate(pageFunction, ...args);
    }
    async evaluateHandle(pageFunction, ...args) {
      const context = await __classPrivateFieldGet(this, _WebWorker_executionContext, "f");
      return context.evaluateHandle(pageFunction, ...args);
    }
  }
  exports.WebWorker = WebWorker;
  _WebWorker_executionContext = new WeakMap, _WebWorker_client = new WeakMap, _WebWorker_url = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Accessibility.js
var require_Accessibility = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Accessibility_client;
  var _AXNode_instances;
  var _AXNode_richlyEditable;
  var _AXNode_editable;
  var _AXNode_focusable;
  var _AXNode_hidden;
  var _AXNode_name;
  var _AXNode_role;
  var _AXNode_ignored;
  var _AXNode_cachedHasFocusableChild;
  var _AXNode_isPlainTextField;
  var _AXNode_isTextOnlyObject;
  var _AXNode_hasFocusableChild;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Accessibility = undefined;

  class Accessibility {
    constructor(client) {
      _Accessibility_client.set(this, undefined);
      __classPrivateFieldSet(this, _Accessibility_client, client, "f");
    }
    async snapshot(options = {}) {
      var _a, _b;
      const { interestingOnly = true, root = null } = options;
      const { nodes } = await __classPrivateFieldGet(this, _Accessibility_client, "f").send("Accessibility.getFullAXTree");
      let backendNodeId;
      if (root) {
        const { node } = await __classPrivateFieldGet(this, _Accessibility_client, "f").send("DOM.describeNode", {
          objectId: root.remoteObject().objectId
        });
        backendNodeId = node.backendNodeId;
      }
      const defaultRoot = AXNode.createTree(nodes);
      let needle = defaultRoot;
      if (backendNodeId) {
        needle = defaultRoot.find((node) => {
          return node.payload.backendDOMNodeId === backendNodeId;
        });
        if (!needle) {
          return null;
        }
      }
      if (!interestingOnly) {
        return (_a = this.serializeTree(needle)[0]) !== null && _a !== undefined ? _a : null;
      }
      const interestingNodes = new Set;
      this.collectInterestingNodes(interestingNodes, defaultRoot, false);
      if (!interestingNodes.has(needle)) {
        return null;
      }
      return (_b = this.serializeTree(needle, interestingNodes)[0]) !== null && _b !== undefined ? _b : null;
    }
    serializeTree(node, interestingNodes) {
      const children = [];
      for (const child of node.children) {
        children.push(...this.serializeTree(child, interestingNodes));
      }
      if (interestingNodes && !interestingNodes.has(node)) {
        return children;
      }
      const serializedNode = node.serialize();
      if (children.length) {
        serializedNode.children = children;
      }
      return [serializedNode];
    }
    collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl)) {
        collection.add(node);
      }
      if (node.isLeafNode()) {
        return;
      }
      insideControl = insideControl || node.isControl();
      for (const child of node.children) {
        this.collectInterestingNodes(collection, child, insideControl);
      }
    }
  }
  exports.Accessibility = Accessibility;
  _Accessibility_client = new WeakMap;

  class AXNode {
    constructor(payload) {
      _AXNode_instances.add(this);
      this.children = [];
      _AXNode_richlyEditable.set(this, false);
      _AXNode_editable.set(this, false);
      _AXNode_focusable.set(this, false);
      _AXNode_hidden.set(this, false);
      _AXNode_name.set(this, undefined);
      _AXNode_role.set(this, undefined);
      _AXNode_ignored.set(this, undefined);
      _AXNode_cachedHasFocusableChild.set(this, undefined);
      this.payload = payload;
      __classPrivateFieldSet(this, _AXNode_name, this.payload.name ? this.payload.name.value : "", "f");
      __classPrivateFieldSet(this, _AXNode_role, this.payload.role ? this.payload.role.value : "Unknown", "f");
      __classPrivateFieldSet(this, _AXNode_ignored, this.payload.ignored, "f");
      for (const property of this.payload.properties || []) {
        if (property.name === "editable") {
          __classPrivateFieldSet(this, _AXNode_richlyEditable, property.value.value === "richtext", "f");
          __classPrivateFieldSet(this, _AXNode_editable, true, "f");
        }
        if (property.name === "focusable") {
          __classPrivateFieldSet(this, _AXNode_focusable, property.value.value, "f");
        }
        if (property.name === "hidden") {
          __classPrivateFieldSet(this, _AXNode_hidden, property.value.value, "f");
        }
      }
    }
    find(predicate) {
      if (predicate(this)) {
        return this;
      }
      for (const child of this.children) {
        const result = child.find(predicate);
        if (result) {
          return result;
        }
      }
      return null;
    }
    isLeafNode() {
      if (!this.children.length) {
        return true;
      }
      if (__classPrivateFieldGet(this, _AXNode_instances, "m", _AXNode_isPlainTextField).call(this) || __classPrivateFieldGet(this, _AXNode_instances, "m", _AXNode_isTextOnlyObject).call(this)) {
        return true;
      }
      switch (__classPrivateFieldGet(this, _AXNode_role, "f")) {
        case "doc-cover":
        case "graphics-symbol":
        case "img":
        case "Meter":
        case "scrollbar":
        case "slider":
        case "separator":
        case "progressbar":
          return true;
        default:
          break;
      }
      if (__classPrivateFieldGet(this, _AXNode_instances, "m", _AXNode_hasFocusableChild).call(this)) {
        return false;
      }
      if (__classPrivateFieldGet(this, _AXNode_focusable, "f") && __classPrivateFieldGet(this, _AXNode_name, "f")) {
        return true;
      }
      if (__classPrivateFieldGet(this, _AXNode_role, "f") === "heading" && __classPrivateFieldGet(this, _AXNode_name, "f")) {
        return true;
      }
      return false;
    }
    isControl() {
      switch (__classPrivateFieldGet(this, _AXNode_role, "f")) {
        case "button":
        case "checkbox":
        case "ColorWell":
        case "combobox":
        case "DisclosureTriangle":
        case "listbox":
        case "menu":
        case "menubar":
        case "menuitem":
        case "menuitemcheckbox":
        case "menuitemradio":
        case "radio":
        case "scrollbar":
        case "searchbox":
        case "slider":
        case "spinbutton":
        case "switch":
        case "tab":
        case "textbox":
        case "tree":
        case "treeitem":
          return true;
        default:
          return false;
      }
    }
    isInteresting(insideControl) {
      const role = __classPrivateFieldGet(this, _AXNode_role, "f");
      if (role === "Ignored" || __classPrivateFieldGet(this, _AXNode_hidden, "f") || __classPrivateFieldGet(this, _AXNode_ignored, "f")) {
        return false;
      }
      if (__classPrivateFieldGet(this, _AXNode_focusable, "f") || __classPrivateFieldGet(this, _AXNode_richlyEditable, "f")) {
        return true;
      }
      if (this.isControl()) {
        return true;
      }
      if (insideControl) {
        return false;
      }
      return this.isLeafNode() && !!__classPrivateFieldGet(this, _AXNode_name, "f");
    }
    serialize() {
      const properties = new Map;
      for (const property of this.payload.properties || []) {
        properties.set(property.name.toLowerCase(), property.value.value);
      }
      if (this.payload.name) {
        properties.set("name", this.payload.name.value);
      }
      if (this.payload.value) {
        properties.set("value", this.payload.value.value);
      }
      if (this.payload.description) {
        properties.set("description", this.payload.description.value);
      }
      const node = {
        role: __classPrivateFieldGet(this, _AXNode_role, "f")
      };
      const userStringProperties = [
        "name",
        "value",
        "description",
        "keyshortcuts",
        "roledescription",
        "valuetext"
      ];
      const getUserStringPropertyValue = (key2) => {
        return properties.get(key2);
      };
      for (const userStringProperty of userStringProperties) {
        if (!properties.has(userStringProperty)) {
          continue;
        }
        node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
      }
      const booleanProperties = [
        "disabled",
        "expanded",
        "focused",
        "modal",
        "multiline",
        "multiselectable",
        "readonly",
        "required",
        "selected"
      ];
      const getBooleanPropertyValue = (key2) => {
        return properties.get(key2);
      };
      for (const booleanProperty of booleanProperties) {
        if (booleanProperty === "focused" && __classPrivateFieldGet(this, _AXNode_role, "f") === "RootWebArea") {
          continue;
        }
        const value = getBooleanPropertyValue(booleanProperty);
        if (!value) {
          continue;
        }
        node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
      }
      const tristateProperties = ["checked", "pressed"];
      for (const tristateProperty of tristateProperties) {
        if (!properties.has(tristateProperty)) {
          continue;
        }
        const value = properties.get(tristateProperty);
        node[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
      }
      const numericalProperties = [
        "level",
        "valuemax",
        "valuemin"
      ];
      const getNumericalPropertyValue = (key2) => {
        return properties.get(key2);
      };
      for (const numericalProperty of numericalProperties) {
        if (!properties.has(numericalProperty)) {
          continue;
        }
        node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
      }
      const tokenProperties = [
        "autocomplete",
        "haspopup",
        "invalid",
        "orientation"
      ];
      const getTokenPropertyValue = (key2) => {
        return properties.get(key2);
      };
      for (const tokenProperty of tokenProperties) {
        const value = getTokenPropertyValue(tokenProperty);
        if (!value || value === "false") {
          continue;
        }
        node[tokenProperty] = getTokenPropertyValue(tokenProperty);
      }
      return node;
    }
    static createTree(payloads) {
      const nodeById = new Map;
      for (const payload of payloads) {
        nodeById.set(payload.nodeId, new AXNode(payload));
      }
      for (const node of nodeById.values()) {
        for (const childId of node.payload.childIds || []) {
          node.children.push(nodeById.get(childId));
        }
      }
      return nodeById.values().next().value;
    }
  }
  _AXNode_richlyEditable = new WeakMap, _AXNode_editable = new WeakMap, _AXNode_focusable = new WeakMap, _AXNode_hidden = new WeakMap, _AXNode_name = new WeakMap, _AXNode_role = new WeakMap, _AXNode_ignored = new WeakMap, _AXNode_cachedHasFocusableChild = new WeakMap, _AXNode_instances = new WeakSet, _AXNode_isPlainTextField = function _AXNode_isPlainTextField() {
    if (__classPrivateFieldGet(this, _AXNode_richlyEditable, "f")) {
      return false;
    }
    if (__classPrivateFieldGet(this, _AXNode_editable, "f")) {
      return true;
    }
    return __classPrivateFieldGet(this, _AXNode_role, "f") === "textbox" || __classPrivateFieldGet(this, _AXNode_role, "f") === "searchbox";
  }, _AXNode_isTextOnlyObject = function _AXNode_isTextOnlyObject() {
    const role = __classPrivateFieldGet(this, _AXNode_role, "f");
    return role === "LineBreak" || role === "text" || role === "InlineTextBox";
  }, _AXNode_hasFocusableChild = function _AXNode_hasFocusableChild() {
    if (__classPrivateFieldGet(this, _AXNode_cachedHasFocusableChild, "f") === undefined) {
      __classPrivateFieldSet(this, _AXNode_cachedHasFocusableChild, false, "f");
      for (const child of this.children) {
        if (__classPrivateFieldGet(child, _AXNode_focusable, "f") || __classPrivateFieldGet(child, _AXNode_instances, "m", _AXNode_hasFocusableChild).call(child)) {
          __classPrivateFieldSet(this, _AXNode_cachedHasFocusableChild, true, "f");
          break;
        }
      }
    }
    return __classPrivateFieldGet(this, _AXNode_cachedHasFocusableChild, "f");
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/ConsoleMessage.js
var require_ConsoleMessage = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ConsoleMessage_type;
  var _ConsoleMessage_text;
  var _ConsoleMessage_args;
  var _ConsoleMessage_stackTraceLocations;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConsoleMessage = undefined;

  class ConsoleMessage {
    constructor(type, text, args, stackTraceLocations) {
      _ConsoleMessage_type.set(this, undefined);
      _ConsoleMessage_text.set(this, undefined);
      _ConsoleMessage_args.set(this, undefined);
      _ConsoleMessage_stackTraceLocations.set(this, undefined);
      __classPrivateFieldSet(this, _ConsoleMessage_type, type, "f");
      __classPrivateFieldSet(this, _ConsoleMessage_text, text, "f");
      __classPrivateFieldSet(this, _ConsoleMessage_args, args, "f");
      __classPrivateFieldSet(this, _ConsoleMessage_stackTraceLocations, stackTraceLocations, "f");
    }
    type() {
      return __classPrivateFieldGet(this, _ConsoleMessage_type, "f");
    }
    text() {
      return __classPrivateFieldGet(this, _ConsoleMessage_text, "f");
    }
    args() {
      return __classPrivateFieldGet(this, _ConsoleMessage_args, "f");
    }
    location() {
      var _a;
      return (_a = __classPrivateFieldGet(this, _ConsoleMessage_stackTraceLocations, "f")[0]) !== null && _a !== undefined ? _a : {};
    }
    stackTrace() {
      return __classPrivateFieldGet(this, _ConsoleMessage_stackTraceLocations, "f");
    }
  }
  exports.ConsoleMessage = ConsoleMessage;
  _ConsoleMessage_type = new WeakMap, _ConsoleMessage_text = new WeakMap, _ConsoleMessage_args = new WeakMap, _ConsoleMessage_stackTraceLocations = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Coverage.js
var require_Coverage = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Coverage_jsCoverage;
  var _Coverage_cssCoverage;
  var _JSCoverage_instances;
  var _JSCoverage_client;
  var _JSCoverage_enabled;
  var _JSCoverage_scriptURLs;
  var _JSCoverage_scriptSources;
  var _JSCoverage_eventListeners;
  var _JSCoverage_resetOnNavigation;
  var _JSCoverage_reportAnonymousScripts;
  var _JSCoverage_includeRawScriptCoverage;
  var _JSCoverage_onExecutionContextsCleared;
  var _JSCoverage_onScriptParsed;
  var _CSSCoverage_instances;
  var _CSSCoverage_client;
  var _CSSCoverage_enabled;
  var _CSSCoverage_stylesheetURLs;
  var _CSSCoverage_stylesheetSources;
  var _CSSCoverage_eventListeners;
  var _CSSCoverage_resetOnNavigation;
  var _CSSCoverage_onExecutionContextsCleared;
  var _CSSCoverage_onStyleSheet;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CSSCoverage = exports.JSCoverage = exports.Coverage = undefined;
  var assert_js_1 = require_assert();
  var util_js_1 = require_util();
  var ExecutionContext_js_1 = require_ExecutionContext();
  var util_js_2 = require_util();

  class Coverage {
    constructor(client) {
      _Coverage_jsCoverage.set(this, undefined);
      _Coverage_cssCoverage.set(this, undefined);
      __classPrivateFieldSet(this, _Coverage_jsCoverage, new JSCoverage(client), "f");
      __classPrivateFieldSet(this, _Coverage_cssCoverage, new CSSCoverage(client), "f");
    }
    async startJSCoverage(options = {}) {
      return await __classPrivateFieldGet(this, _Coverage_jsCoverage, "f").start(options);
    }
    async stopJSCoverage() {
      return await __classPrivateFieldGet(this, _Coverage_jsCoverage, "f").stop();
    }
    async startCSSCoverage(options = {}) {
      return await __classPrivateFieldGet(this, _Coverage_cssCoverage, "f").start(options);
    }
    async stopCSSCoverage() {
      return await __classPrivateFieldGet(this, _Coverage_cssCoverage, "f").stop();
    }
  }
  exports.Coverage = Coverage;
  _Coverage_jsCoverage = new WeakMap, _Coverage_cssCoverage = new WeakMap;

  class JSCoverage {
    constructor(client) {
      _JSCoverage_instances.add(this);
      _JSCoverage_client.set(this, undefined);
      _JSCoverage_enabled.set(this, false);
      _JSCoverage_scriptURLs.set(this, new Map);
      _JSCoverage_scriptSources.set(this, new Map);
      _JSCoverage_eventListeners.set(this, []);
      _JSCoverage_resetOnNavigation.set(this, false);
      _JSCoverage_reportAnonymousScripts.set(this, false);
      _JSCoverage_includeRawScriptCoverage.set(this, false);
      __classPrivateFieldSet(this, _JSCoverage_client, client, "f");
    }
    async start(options = {}) {
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _JSCoverage_enabled, "f"), "JSCoverage is already enabled");
      const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false } = options;
      __classPrivateFieldSet(this, _JSCoverage_resetOnNavigation, resetOnNavigation, "f");
      __classPrivateFieldSet(this, _JSCoverage_reportAnonymousScripts, reportAnonymousScripts, "f");
      __classPrivateFieldSet(this, _JSCoverage_includeRawScriptCoverage, includeRawScriptCoverage, "f");
      __classPrivateFieldSet(this, _JSCoverage_enabled, true, "f");
      __classPrivateFieldGet(this, _JSCoverage_scriptURLs, "f").clear();
      __classPrivateFieldGet(this, _JSCoverage_scriptSources, "f").clear();
      __classPrivateFieldSet(this, _JSCoverage_eventListeners, [
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _JSCoverage_client, "f"), "Debugger.scriptParsed", __classPrivateFieldGet(this, _JSCoverage_instances, "m", _JSCoverage_onScriptParsed).bind(this)),
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _JSCoverage_client, "f"), "Runtime.executionContextsCleared", __classPrivateFieldGet(this, _JSCoverage_instances, "m", _JSCoverage_onExecutionContextsCleared).bind(this))
      ], "f");
      await Promise.all([
        __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Profiler.enable"),
        __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Profiler.startPreciseCoverage", {
          callCount: __classPrivateFieldGet(this, _JSCoverage_includeRawScriptCoverage, "f"),
          detailed: true
        }),
        __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Debugger.enable"),
        __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Debugger.setSkipAllPauses", { skip: true })
      ]);
    }
    async stop() {
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _JSCoverage_enabled, "f"), "JSCoverage is not enabled");
      __classPrivateFieldSet(this, _JSCoverage_enabled, false, "f");
      const result = await Promise.all([
        __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Profiler.takePreciseCoverage"),
        __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Profiler.stopPreciseCoverage"),
        __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Profiler.disable"),
        __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Debugger.disable")
      ]);
      (0, util_js_2.removeEventListeners)(__classPrivateFieldGet(this, _JSCoverage_eventListeners, "f"));
      const coverage = [];
      const profileResponse = result[0];
      for (const entry of profileResponse.result) {
        let url = __classPrivateFieldGet(this, _JSCoverage_scriptURLs, "f").get(entry.scriptId);
        if (!url && __classPrivateFieldGet(this, _JSCoverage_reportAnonymousScripts, "f")) {
          url = "debugger://VM" + entry.scriptId;
        }
        const text = __classPrivateFieldGet(this, _JSCoverage_scriptSources, "f").get(entry.scriptId);
        if (text === undefined || url === undefined) {
          continue;
        }
        const flattenRanges = [];
        for (const func of entry.functions) {
          flattenRanges.push(...func.ranges);
        }
        const ranges = convertToDisjointRanges(flattenRanges);
        if (!__classPrivateFieldGet(this, _JSCoverage_includeRawScriptCoverage, "f")) {
          coverage.push({ url, ranges, text });
        } else {
          coverage.push({ url, ranges, text, rawScriptCoverage: entry });
        }
      }
      return coverage;
    }
  }
  exports.JSCoverage = JSCoverage;
  _JSCoverage_client = new WeakMap, _JSCoverage_enabled = new WeakMap, _JSCoverage_scriptURLs = new WeakMap, _JSCoverage_scriptSources = new WeakMap, _JSCoverage_eventListeners = new WeakMap, _JSCoverage_resetOnNavigation = new WeakMap, _JSCoverage_reportAnonymousScripts = new WeakMap, _JSCoverage_includeRawScriptCoverage = new WeakMap, _JSCoverage_instances = new WeakSet, _JSCoverage_onExecutionContextsCleared = function _JSCoverage_onExecutionContextsCleared() {
    if (!__classPrivateFieldGet(this, _JSCoverage_resetOnNavigation, "f")) {
      return;
    }
    __classPrivateFieldGet(this, _JSCoverage_scriptURLs, "f").clear();
    __classPrivateFieldGet(this, _JSCoverage_scriptSources, "f").clear();
  }, _JSCoverage_onScriptParsed = async function _JSCoverage_onScriptParsed(event) {
    if (event.url === ExecutionContext_js_1.EVALUATION_SCRIPT_URL) {
      return;
    }
    if (!event.url && !__classPrivateFieldGet(this, _JSCoverage_reportAnonymousScripts, "f")) {
      return;
    }
    try {
      const response = await __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Debugger.getScriptSource", {
        scriptId: event.scriptId
      });
      __classPrivateFieldGet(this, _JSCoverage_scriptURLs, "f").set(event.scriptId, event.url);
      __classPrivateFieldGet(this, _JSCoverage_scriptSources, "f").set(event.scriptId, response.scriptSource);
    } catch (error) {
      (0, util_js_1.debugError)(error);
    }
  };

  class CSSCoverage {
    constructor(client) {
      _CSSCoverage_instances.add(this);
      _CSSCoverage_client.set(this, undefined);
      _CSSCoverage_enabled.set(this, false);
      _CSSCoverage_stylesheetURLs.set(this, new Map);
      _CSSCoverage_stylesheetSources.set(this, new Map);
      _CSSCoverage_eventListeners.set(this, []);
      _CSSCoverage_resetOnNavigation.set(this, false);
      __classPrivateFieldSet(this, _CSSCoverage_client, client, "f");
    }
    async start(options = {}) {
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _CSSCoverage_enabled, "f"), "CSSCoverage is already enabled");
      const { resetOnNavigation = true } = options;
      __classPrivateFieldSet(this, _CSSCoverage_resetOnNavigation, resetOnNavigation, "f");
      __classPrivateFieldSet(this, _CSSCoverage_enabled, true, "f");
      __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, "f").clear();
      __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, "f").clear();
      __classPrivateFieldSet(this, _CSSCoverage_eventListeners, [
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _CSSCoverage_client, "f"), "CSS.styleSheetAdded", __classPrivateFieldGet(this, _CSSCoverage_instances, "m", _CSSCoverage_onStyleSheet).bind(this)),
        (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _CSSCoverage_client, "f"), "Runtime.executionContextsCleared", __classPrivateFieldGet(this, _CSSCoverage_instances, "m", _CSSCoverage_onExecutionContextsCleared).bind(this))
      ], "f");
      await Promise.all([
        __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("DOM.enable"),
        __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("CSS.enable"),
        __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("CSS.startRuleUsageTracking")
      ]);
    }
    async stop() {
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _CSSCoverage_enabled, "f"), "CSSCoverage is not enabled");
      __classPrivateFieldSet(this, _CSSCoverage_enabled, false, "f");
      const ruleTrackingResponse = await __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("CSS.stopRuleUsageTracking");
      await Promise.all([
        __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("CSS.disable"),
        __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("DOM.disable")
      ]);
      (0, util_js_2.removeEventListeners)(__classPrivateFieldGet(this, _CSSCoverage_eventListeners, "f"));
      const styleSheetIdToCoverage = new Map;
      for (const entry of ruleTrackingResponse.ruleUsage) {
        let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
        if (!ranges) {
          ranges = [];
          styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
        }
        ranges.push({
          startOffset: entry.startOffset,
          endOffset: entry.endOffset,
          count: entry.used ? 1 : 0
        });
      }
      const coverage = [];
      for (const styleSheetId of __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, "f").keys()) {
        const url = __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, "f").get(styleSheetId);
        (0, assert_js_1.assert)(typeof url !== "undefined", `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
        const text = __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, "f").get(styleSheetId);
        (0, assert_js_1.assert)(typeof text !== "undefined", `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
        const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
        coverage.push({ url, ranges, text });
      }
      return coverage;
    }
  }
  exports.CSSCoverage = CSSCoverage;
  _CSSCoverage_client = new WeakMap, _CSSCoverage_enabled = new WeakMap, _CSSCoverage_stylesheetURLs = new WeakMap, _CSSCoverage_stylesheetSources = new WeakMap, _CSSCoverage_eventListeners = new WeakMap, _CSSCoverage_resetOnNavigation = new WeakMap, _CSSCoverage_instances = new WeakSet, _CSSCoverage_onExecutionContextsCleared = function _CSSCoverage_onExecutionContextsCleared() {
    if (!__classPrivateFieldGet(this, _CSSCoverage_resetOnNavigation, "f")) {
      return;
    }
    __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, "f").clear();
    __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, "f").clear();
  }, _CSSCoverage_onStyleSheet = async function _CSSCoverage_onStyleSheet(event) {
    const header = event.header;
    if (!header.sourceURL) {
      return;
    }
    try {
      const response = await __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("CSS.getStyleSheetText", {
        styleSheetId: header.styleSheetId
      });
      __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, "f").set(header.styleSheetId, header.sourceURL);
      __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, "f").set(header.styleSheetId, response.text);
    } catch (error) {
      (0, util_js_1.debugError)(error);
    }
  };
  function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range of nestedRanges) {
      points.push({ offset: range.startOffset, type: 0, range });
      points.push({ offset: range.endOffset, type: 1, range });
    }
    points.sort((a, b) => {
      if (a.offset !== b.offset) {
        return a.offset - b.offset;
      }
      if (a.type !== b.type) {
        return b.type - a.type;
      }
      const aLength = a.range.endOffset - a.range.startOffset;
      const bLength = b.range.endOffset - b.range.startOffset;
      if (a.type === 0) {
        return bLength - aLength;
      }
      return aLength - bLength;
    });
    const hitCountStack = [];
    const results2 = [];
    let lastOffset = 0;
    for (const point of points) {
      if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
        const lastResult = results2[results2.length - 1];
        if (lastResult && lastResult.end === lastOffset) {
          lastResult.end = point.offset;
        } else {
          results2.push({ start: lastOffset, end: point.offset });
        }
      }
      lastOffset = point.offset;
      if (point.type === 0) {
        hitCountStack.push(point.range.count);
      } else {
        hitCountStack.pop();
      }
    }
    return results2.filter((range) => {
      return range.end - range.start > 0;
    });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Dialog.js
var require_Dialog = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Dialog_client;
  var _Dialog_type;
  var _Dialog_message;
  var _Dialog_defaultValue;
  var _Dialog_handled;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Dialog = undefined;
  var assert_js_1 = require_assert();

  class Dialog {
    constructor(client, type, message, defaultValue = "") {
      _Dialog_client.set(this, undefined);
      _Dialog_type.set(this, undefined);
      _Dialog_message.set(this, undefined);
      _Dialog_defaultValue.set(this, undefined);
      _Dialog_handled.set(this, false);
      __classPrivateFieldSet(this, _Dialog_client, client, "f");
      __classPrivateFieldSet(this, _Dialog_type, type, "f");
      __classPrivateFieldSet(this, _Dialog_message, message, "f");
      __classPrivateFieldSet(this, _Dialog_defaultValue, defaultValue, "f");
    }
    type() {
      return __classPrivateFieldGet(this, _Dialog_type, "f");
    }
    message() {
      return __classPrivateFieldGet(this, _Dialog_message, "f");
    }
    defaultValue() {
      return __classPrivateFieldGet(this, _Dialog_defaultValue, "f");
    }
    async accept(promptText) {
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _Dialog_handled, "f"), "Cannot accept dialog which is already handled!");
      __classPrivateFieldSet(this, _Dialog_handled, true, "f");
      await __classPrivateFieldGet(this, _Dialog_client, "f").send("Page.handleJavaScriptDialog", {
        accept: true,
        promptText
      });
    }
    async dismiss() {
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _Dialog_handled, "f"), "Cannot dismiss dialog which is already handled!");
      __classPrivateFieldSet(this, _Dialog_handled, true, "f");
      await __classPrivateFieldGet(this, _Dialog_client, "f").send("Page.handleJavaScriptDialog", {
        accept: false
      });
    }
  }
  exports.Dialog = Dialog;
  _Dialog_client = new WeakMap, _Dialog_type = new WeakMap, _Dialog_message = new WeakMap, _Dialog_defaultValue = new WeakMap, _Dialog_handled = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/EmulationManager.js
var require_EmulationManager = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _EmulationManager_client;
  var _EmulationManager_emulatingMobile;
  var _EmulationManager_hasTouch;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmulationManager = undefined;

  class EmulationManager {
    constructor(client) {
      _EmulationManager_client.set(this, undefined);
      _EmulationManager_emulatingMobile.set(this, false);
      _EmulationManager_hasTouch.set(this, false);
      __classPrivateFieldSet(this, _EmulationManager_client, client, "f");
    }
    async emulateViewport(viewport) {
      const mobile = viewport.isMobile || false;
      const width2 = viewport.width;
      const height2 = viewport.height;
      const deviceScaleFactor = viewport.deviceScaleFactor || 1;
      const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
      const hasTouch = viewport.hasTouch || false;
      await Promise.all([
        __classPrivateFieldGet(this, _EmulationManager_client, "f").send("Emulation.setDeviceMetricsOverride", {
          mobile,
          width: width2,
          height: height2,
          deviceScaleFactor,
          screenOrientation
        }),
        __classPrivateFieldGet(this, _EmulationManager_client, "f").send("Emulation.setTouchEmulationEnabled", {
          enabled: hasTouch
        })
      ]);
      const reloadNeeded = __classPrivateFieldGet(this, _EmulationManager_emulatingMobile, "f") !== mobile || __classPrivateFieldGet(this, _EmulationManager_hasTouch, "f") !== hasTouch;
      __classPrivateFieldSet(this, _EmulationManager_emulatingMobile, mobile, "f");
      __classPrivateFieldSet(this, _EmulationManager_hasTouch, hasTouch, "f");
      return reloadNeeded;
    }
  }
  exports.EmulationManager = EmulationManager;
  _EmulationManager_client = new WeakMap, _EmulationManager_emulatingMobile = new WeakMap, _EmulationManager_hasTouch = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/FileChooser.js
var require_FileChooser = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _FileChooser_element;
  var _FileChooser_multiple;
  var _FileChooser_handled;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FileChooser = undefined;
  var assert_js_1 = require_assert();

  class FileChooser {
    constructor(element, event) {
      _FileChooser_element.set(this, undefined);
      _FileChooser_multiple.set(this, undefined);
      _FileChooser_handled.set(this, false);
      __classPrivateFieldSet(this, _FileChooser_element, element, "f");
      __classPrivateFieldSet(this, _FileChooser_multiple, event.mode !== "selectSingle", "f");
    }
    isMultiple() {
      return __classPrivateFieldGet(this, _FileChooser_multiple, "f");
    }
    async accept(filePaths) {
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _FileChooser_handled, "f"), "Cannot accept FileChooser which is already handled!");
      __classPrivateFieldSet(this, _FileChooser_handled, true, "f");
      await __classPrivateFieldGet(this, _FileChooser_element, "f").uploadFile(...filePaths);
    }
    cancel() {
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _FileChooser_handled, "f"), "Cannot cancel FileChooser which is already handled!");
      __classPrivateFieldSet(this, _FileChooser_handled, true, "f");
    }
  }
  exports.FileChooser = FileChooser;
  _FileChooser_element = new WeakMap, _FileChooser_multiple = new WeakMap, _FileChooser_handled = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/USKeyboardLayout.js
var require_USKeyboardLayout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._keyDefinitions = undefined;
  exports._keyDefinitions = {
    "0": { keyCode: 48, key: "0", code: "Digit0" },
    "1": { keyCode: 49, key: "1", code: "Digit1" },
    "2": { keyCode: 50, key: "2", code: "Digit2" },
    "3": { keyCode: 51, key: "3", code: "Digit3" },
    "4": { keyCode: 52, key: "4", code: "Digit4" },
    "5": { keyCode: 53, key: "5", code: "Digit5" },
    "6": { keyCode: 54, key: "6", code: "Digit6" },
    "7": { keyCode: 55, key: "7", code: "Digit7" },
    "8": { keyCode: 56, key: "8", code: "Digit8" },
    "9": { keyCode: 57, key: "9", code: "Digit9" },
    Power: { key: "Power", code: "Power" },
    Eject: { key: "Eject", code: "Eject" },
    Abort: { keyCode: 3, code: "Abort", key: "Cancel" },
    Help: { keyCode: 6, code: "Help", key: "Help" },
    Backspace: { keyCode: 8, code: "Backspace", key: "Backspace" },
    Tab: { keyCode: 9, code: "Tab", key: "Tab" },
    Numpad5: {
      keyCode: 12,
      shiftKeyCode: 101,
      key: "Clear",
      code: "Numpad5",
      shiftKey: "5",
      location: 3
    },
    NumpadEnter: {
      keyCode: 13,
      code: "NumpadEnter",
      key: "Enter",
      text: "\r",
      location: 3
    },
    Enter: { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    "\r": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    "\n": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    ShiftLeft: { keyCode: 16, code: "ShiftLeft", key: "Shift", location: 1 },
    ShiftRight: { keyCode: 16, code: "ShiftRight", key: "Shift", location: 2 },
    ControlLeft: {
      keyCode: 17,
      code: "ControlLeft",
      key: "Control",
      location: 1
    },
    ControlRight: {
      keyCode: 17,
      code: "ControlRight",
      key: "Control",
      location: 2
    },
    AltLeft: { keyCode: 18, code: "AltLeft", key: "Alt", location: 1 },
    AltRight: { keyCode: 18, code: "AltRight", key: "Alt", location: 2 },
    Pause: { keyCode: 19, code: "Pause", key: "Pause" },
    CapsLock: { keyCode: 20, code: "CapsLock", key: "CapsLock" },
    Escape: { keyCode: 27, code: "Escape", key: "Escape" },
    Convert: { keyCode: 28, code: "Convert", key: "Convert" },
    NonConvert: { keyCode: 29, code: "NonConvert", key: "NonConvert" },
    Space: { keyCode: 32, code: "Space", key: " " },
    Numpad9: {
      keyCode: 33,
      shiftKeyCode: 105,
      key: "PageUp",
      code: "Numpad9",
      shiftKey: "9",
      location: 3
    },
    PageUp: { keyCode: 33, code: "PageUp", key: "PageUp" },
    Numpad3: {
      keyCode: 34,
      shiftKeyCode: 99,
      key: "PageDown",
      code: "Numpad3",
      shiftKey: "3",
      location: 3
    },
    PageDown: { keyCode: 34, code: "PageDown", key: "PageDown" },
    End: { keyCode: 35, code: "End", key: "End" },
    Numpad1: {
      keyCode: 35,
      shiftKeyCode: 97,
      key: "End",
      code: "Numpad1",
      shiftKey: "1",
      location: 3
    },
    Home: { keyCode: 36, code: "Home", key: "Home" },
    Numpad7: {
      keyCode: 36,
      shiftKeyCode: 103,
      key: "Home",
      code: "Numpad7",
      shiftKey: "7",
      location: 3
    },
    ArrowLeft: { keyCode: 37, code: "ArrowLeft", key: "ArrowLeft" },
    Numpad4: {
      keyCode: 37,
      shiftKeyCode: 100,
      key: "ArrowLeft",
      code: "Numpad4",
      shiftKey: "4",
      location: 3
    },
    Numpad8: {
      keyCode: 38,
      shiftKeyCode: 104,
      key: "ArrowUp",
      code: "Numpad8",
      shiftKey: "8",
      location: 3
    },
    ArrowUp: { keyCode: 38, code: "ArrowUp", key: "ArrowUp" },
    ArrowRight: { keyCode: 39, code: "ArrowRight", key: "ArrowRight" },
    Numpad6: {
      keyCode: 39,
      shiftKeyCode: 102,
      key: "ArrowRight",
      code: "Numpad6",
      shiftKey: "6",
      location: 3
    },
    Numpad2: {
      keyCode: 40,
      shiftKeyCode: 98,
      key: "ArrowDown",
      code: "Numpad2",
      shiftKey: "2",
      location: 3
    },
    ArrowDown: { keyCode: 40, code: "ArrowDown", key: "ArrowDown" },
    Select: { keyCode: 41, code: "Select", key: "Select" },
    Open: { keyCode: 43, code: "Open", key: "Execute" },
    PrintScreen: { keyCode: 44, code: "PrintScreen", key: "PrintScreen" },
    Insert: { keyCode: 45, code: "Insert", key: "Insert" },
    Numpad0: {
      keyCode: 45,
      shiftKeyCode: 96,
      key: "Insert",
      code: "Numpad0",
      shiftKey: "0",
      location: 3
    },
    Delete: { keyCode: 46, code: "Delete", key: "Delete" },
    NumpadDecimal: {
      keyCode: 46,
      shiftKeyCode: 110,
      code: "NumpadDecimal",
      key: "\x00",
      shiftKey: ".",
      location: 3
    },
    Digit0: { keyCode: 48, code: "Digit0", shiftKey: ")", key: "0" },
    Digit1: { keyCode: 49, code: "Digit1", shiftKey: "!", key: "1" },
    Digit2: { keyCode: 50, code: "Digit2", shiftKey: "@", key: "2" },
    Digit3: { keyCode: 51, code: "Digit3", shiftKey: "#", key: "3" },
    Digit4: { keyCode: 52, code: "Digit4", shiftKey: "$", key: "4" },
    Digit5: { keyCode: 53, code: "Digit5", shiftKey: "%", key: "5" },
    Digit6: { keyCode: 54, code: "Digit6", shiftKey: "^", key: "6" },
    Digit7: { keyCode: 55, code: "Digit7", shiftKey: "&", key: "7" },
    Digit8: { keyCode: 56, code: "Digit8", shiftKey: "*", key: "8" },
    Digit9: { keyCode: 57, code: "Digit9", shiftKey: "(", key: "9" },
    KeyA: { keyCode: 65, code: "KeyA", shiftKey: "A", key: "a" },
    KeyB: { keyCode: 66, code: "KeyB", shiftKey: "B", key: "b" },
    KeyC: { keyCode: 67, code: "KeyC", shiftKey: "C", key: "c" },
    KeyD: { keyCode: 68, code: "KeyD", shiftKey: "D", key: "d" },
    KeyE: { keyCode: 69, code: "KeyE", shiftKey: "E", key: "e" },
    KeyF: { keyCode: 70, code: "KeyF", shiftKey: "F", key: "f" },
    KeyG: { keyCode: 71, code: "KeyG", shiftKey: "G", key: "g" },
    KeyH: { keyCode: 72, code: "KeyH", shiftKey: "H", key: "h" },
    KeyI: { keyCode: 73, code: "KeyI", shiftKey: "I", key: "i" },
    KeyJ: { keyCode: 74, code: "KeyJ", shiftKey: "J", key: "j" },
    KeyK: { keyCode: 75, code: "KeyK", shiftKey: "K", key: "k" },
    KeyL: { keyCode: 76, code: "KeyL", shiftKey: "L", key: "l" },
    KeyM: { keyCode: 77, code: "KeyM", shiftKey: "M", key: "m" },
    KeyN: { keyCode: 78, code: "KeyN", shiftKey: "N", key: "n" },
    KeyO: { keyCode: 79, code: "KeyO", shiftKey: "O", key: "o" },
    KeyP: { keyCode: 80, code: "KeyP", shiftKey: "P", key: "p" },
    KeyQ: { keyCode: 81, code: "KeyQ", shiftKey: "Q", key: "q" },
    KeyR: { keyCode: 82, code: "KeyR", shiftKey: "R", key: "r" },
    KeyS: { keyCode: 83, code: "KeyS", shiftKey: "S", key: "s" },
    KeyT: { keyCode: 84, code: "KeyT", shiftKey: "T", key: "t" },
    KeyU: { keyCode: 85, code: "KeyU", shiftKey: "U", key: "u" },
    KeyV: { keyCode: 86, code: "KeyV", shiftKey: "V", key: "v" },
    KeyW: { keyCode: 87, code: "KeyW", shiftKey: "W", key: "w" },
    KeyX: { keyCode: 88, code: "KeyX", shiftKey: "X", key: "x" },
    KeyY: { keyCode: 89, code: "KeyY", shiftKey: "Y", key: "y" },
    KeyZ: { keyCode: 90, code: "KeyZ", shiftKey: "Z", key: "z" },
    MetaLeft: { keyCode: 91, code: "MetaLeft", key: "Meta", location: 1 },
    MetaRight: { keyCode: 92, code: "MetaRight", key: "Meta", location: 2 },
    ContextMenu: { keyCode: 93, code: "ContextMenu", key: "ContextMenu" },
    NumpadMultiply: {
      keyCode: 106,
      code: "NumpadMultiply",
      key: "*",
      location: 3
    },
    NumpadAdd: { keyCode: 107, code: "NumpadAdd", key: "+", location: 3 },
    NumpadSubtract: {
      keyCode: 109,
      code: "NumpadSubtract",
      key: "-",
      location: 3
    },
    NumpadDivide: { keyCode: 111, code: "NumpadDivide", key: "/", location: 3 },
    F1: { keyCode: 112, code: "F1", key: "F1" },
    F2: { keyCode: 113, code: "F2", key: "F2" },
    F3: { keyCode: 114, code: "F3", key: "F3" },
    F4: { keyCode: 115, code: "F4", key: "F4" },
    F5: { keyCode: 116, code: "F5", key: "F5" },
    F6: { keyCode: 117, code: "F6", key: "F6" },
    F7: { keyCode: 118, code: "F7", key: "F7" },
    F8: { keyCode: 119, code: "F8", key: "F8" },
    F9: { keyCode: 120, code: "F9", key: "F9" },
    F10: { keyCode: 121, code: "F10", key: "F10" },
    F11: { keyCode: 122, code: "F11", key: "F11" },
    F12: { keyCode: 123, code: "F12", key: "F12" },
    F13: { keyCode: 124, code: "F13", key: "F13" },
    F14: { keyCode: 125, code: "F14", key: "F14" },
    F15: { keyCode: 126, code: "F15", key: "F15" },
    F16: { keyCode: 127, code: "F16", key: "F16" },
    F17: { keyCode: 128, code: "F17", key: "F17" },
    F18: { keyCode: 129, code: "F18", key: "F18" },
    F19: { keyCode: 130, code: "F19", key: "F19" },
    F20: { keyCode: 131, code: "F20", key: "F20" },
    F21: { keyCode: 132, code: "F21", key: "F21" },
    F22: { keyCode: 133, code: "F22", key: "F22" },
    F23: { keyCode: 134, code: "F23", key: "F23" },
    F24: { keyCode: 135, code: "F24", key: "F24" },
    NumLock: { keyCode: 144, code: "NumLock", key: "NumLock" },
    ScrollLock: { keyCode: 145, code: "ScrollLock", key: "ScrollLock" },
    AudioVolumeMute: {
      keyCode: 173,
      code: "AudioVolumeMute",
      key: "AudioVolumeMute"
    },
    AudioVolumeDown: {
      keyCode: 174,
      code: "AudioVolumeDown",
      key: "AudioVolumeDown"
    },
    AudioVolumeUp: { keyCode: 175, code: "AudioVolumeUp", key: "AudioVolumeUp" },
    MediaTrackNext: {
      keyCode: 176,
      code: "MediaTrackNext",
      key: "MediaTrackNext"
    },
    MediaTrackPrevious: {
      keyCode: 177,
      code: "MediaTrackPrevious",
      key: "MediaTrackPrevious"
    },
    MediaStop: { keyCode: 178, code: "MediaStop", key: "MediaStop" },
    MediaPlayPause: {
      keyCode: 179,
      code: "MediaPlayPause",
      key: "MediaPlayPause"
    },
    Semicolon: { keyCode: 186, code: "Semicolon", shiftKey: ":", key: ";" },
    Equal: { keyCode: 187, code: "Equal", shiftKey: "+", key: "=" },
    NumpadEqual: { keyCode: 187, code: "NumpadEqual", key: "=", location: 3 },
    Comma: { keyCode: 188, code: "Comma", shiftKey: "<", key: "," },
    Minus: { keyCode: 189, code: "Minus", shiftKey: "_", key: "-" },
    Period: { keyCode: 190, code: "Period", shiftKey: ">", key: "." },
    Slash: { keyCode: 191, code: "Slash", shiftKey: "?", key: "/" },
    Backquote: { keyCode: 192, code: "Backquote", shiftKey: "~", key: "`" },
    BracketLeft: { keyCode: 219, code: "BracketLeft", shiftKey: "{", key: "[" },
    Backslash: { keyCode: 220, code: "Backslash", shiftKey: "|", key: "\\" },
    BracketRight: { keyCode: 221, code: "BracketRight", shiftKey: "}", key: "]" },
    Quote: { keyCode: 222, code: "Quote", shiftKey: '"', key: "'" },
    AltGraph: { keyCode: 225, code: "AltGraph", key: "AltGraph" },
    Props: { keyCode: 247, code: "Props", key: "CrSel" },
    Cancel: { keyCode: 3, key: "Cancel", code: "Abort" },
    Clear: { keyCode: 12, key: "Clear", code: "Numpad5", location: 3 },
    Shift: { keyCode: 16, key: "Shift", code: "ShiftLeft", location: 1 },
    Control: { keyCode: 17, key: "Control", code: "ControlLeft", location: 1 },
    Alt: { keyCode: 18, key: "Alt", code: "AltLeft", location: 1 },
    Accept: { keyCode: 30, key: "Accept" },
    ModeChange: { keyCode: 31, key: "ModeChange" },
    " ": { keyCode: 32, key: " ", code: "Space" },
    Print: { keyCode: 42, key: "Print" },
    Execute: { keyCode: 43, key: "Execute", code: "Open" },
    "\x00": { keyCode: 46, key: "\x00", code: "NumpadDecimal", location: 3 },
    a: { keyCode: 65, key: "a", code: "KeyA" },
    b: { keyCode: 66, key: "b", code: "KeyB" },
    c: { keyCode: 67, key: "c", code: "KeyC" },
    d: { keyCode: 68, key: "d", code: "KeyD" },
    e: { keyCode: 69, key: "e", code: "KeyE" },
    f: { keyCode: 70, key: "f", code: "KeyF" },
    g: { keyCode: 71, key: "g", code: "KeyG" },
    h: { keyCode: 72, key: "h", code: "KeyH" },
    i: { keyCode: 73, key: "i", code: "KeyI" },
    j: { keyCode: 74, key: "j", code: "KeyJ" },
    k: { keyCode: 75, key: "k", code: "KeyK" },
    l: { keyCode: 76, key: "l", code: "KeyL" },
    m: { keyCode: 77, key: "m", code: "KeyM" },
    n: { keyCode: 78, key: "n", code: "KeyN" },
    o: { keyCode: 79, key: "o", code: "KeyO" },
    p: { keyCode: 80, key: "p", code: "KeyP" },
    q: { keyCode: 81, key: "q", code: "KeyQ" },
    r: { keyCode: 82, key: "r", code: "KeyR" },
    s: { keyCode: 83, key: "s", code: "KeyS" },
    t: { keyCode: 84, key: "t", code: "KeyT" },
    u: { keyCode: 85, key: "u", code: "KeyU" },
    v: { keyCode: 86, key: "v", code: "KeyV" },
    w: { keyCode: 87, key: "w", code: "KeyW" },
    x: { keyCode: 88, key: "x", code: "KeyX" },
    y: { keyCode: 89, key: "y", code: "KeyY" },
    z: { keyCode: 90, key: "z", code: "KeyZ" },
    Meta: { keyCode: 91, key: "Meta", code: "MetaLeft", location: 1 },
    "*": { keyCode: 106, key: "*", code: "NumpadMultiply", location: 3 },
    "+": { keyCode: 107, key: "+", code: "NumpadAdd", location: 3 },
    "-": { keyCode: 109, key: "-", code: "NumpadSubtract", location: 3 },
    "/": { keyCode: 111, key: "/", code: "NumpadDivide", location: 3 },
    ";": { keyCode: 186, key: ";", code: "Semicolon" },
    "=": { keyCode: 187, key: "=", code: "Equal" },
    ",": { keyCode: 188, key: ",", code: "Comma" },
    ".": { keyCode: 190, key: ".", code: "Period" },
    "`": { keyCode: 192, key: "`", code: "Backquote" },
    "[": { keyCode: 219, key: "[", code: "BracketLeft" },
    "\\": { keyCode: 220, key: "\\", code: "Backslash" },
    "]": { keyCode: 221, key: "]", code: "BracketRight" },
    "'": { keyCode: 222, key: "'", code: "Quote" },
    Attn: { keyCode: 246, key: "Attn" },
    CrSel: { keyCode: 247, key: "CrSel", code: "Props" },
    ExSel: { keyCode: 248, key: "ExSel" },
    EraseEof: { keyCode: 249, key: "EraseEof" },
    Play: { keyCode: 250, key: "Play" },
    ZoomOut: { keyCode: 251, key: "ZoomOut" },
    ")": { keyCode: 48, key: ")", code: "Digit0" },
    "!": { keyCode: 49, key: "!", code: "Digit1" },
    "@": { keyCode: 50, key: "@", code: "Digit2" },
    "#": { keyCode: 51, key: "#", code: "Digit3" },
    $: { keyCode: 52, key: "$", code: "Digit4" },
    "%": { keyCode: 53, key: "%", code: "Digit5" },
    "^": { keyCode: 54, key: "^", code: "Digit6" },
    "&": { keyCode: 55, key: "&", code: "Digit7" },
    "(": { keyCode: 57, key: "(", code: "Digit9" },
    A: { keyCode: 65, key: "A", code: "KeyA" },
    B: { keyCode: 66, key: "B", code: "KeyB" },
    C: { keyCode: 67, key: "C", code: "KeyC" },
    D: { keyCode: 68, key: "D", code: "KeyD" },
    E: { keyCode: 69, key: "E", code: "KeyE" },
    F: { keyCode: 70, key: "F", code: "KeyF" },
    G: { keyCode: 71, key: "G", code: "KeyG" },
    H: { keyCode: 72, key: "H", code: "KeyH" },
    I: { keyCode: 73, key: "I", code: "KeyI" },
    J: { keyCode: 74, key: "J", code: "KeyJ" },
    K: { keyCode: 75, key: "K", code: "KeyK" },
    L: { keyCode: 76, key: "L", code: "KeyL" },
    M: { keyCode: 77, key: "M", code: "KeyM" },
    N: { keyCode: 78, key: "N", code: "KeyN" },
    O: { keyCode: 79, key: "O", code: "KeyO" },
    P: { keyCode: 80, key: "P", code: "KeyP" },
    Q: { keyCode: 81, key: "Q", code: "KeyQ" },
    R: { keyCode: 82, key: "R", code: "KeyR" },
    S: { keyCode: 83, key: "S", code: "KeyS" },
    T: { keyCode: 84, key: "T", code: "KeyT" },
    U: { keyCode: 85, key: "U", code: "KeyU" },
    V: { keyCode: 86, key: "V", code: "KeyV" },
    W: { keyCode: 87, key: "W", code: "KeyW" },
    X: { keyCode: 88, key: "X", code: "KeyX" },
    Y: { keyCode: 89, key: "Y", code: "KeyY" },
    Z: { keyCode: 90, key: "Z", code: "KeyZ" },
    ":": { keyCode: 186, key: ":", code: "Semicolon" },
    "<": { keyCode: 188, key: "<", code: "Comma" },
    _: { keyCode: 189, key: "_", code: "Minus" },
    ">": { keyCode: 190, key: ">", code: "Period" },
    "?": { keyCode: 191, key: "?", code: "Slash" },
    "~": { keyCode: 192, key: "~", code: "Backquote" },
    "{": { keyCode: 219, key: "{", code: "BracketLeft" },
    "|": { keyCode: 220, key: "|", code: "Backslash" },
    "}": { keyCode: 221, key: "}", code: "BracketRight" },
    '"': { keyCode: 222, key: '"', code: "Quote" },
    SoftLeft: { key: "SoftLeft", code: "SoftLeft", location: 4 },
    SoftRight: { key: "SoftRight", code: "SoftRight", location: 4 },
    Camera: { keyCode: 44, key: "Camera", code: "Camera", location: 4 },
    Call: { key: "Call", code: "Call", location: 4 },
    EndCall: { keyCode: 95, key: "EndCall", code: "EndCall", location: 4 },
    VolumeDown: {
      keyCode: 182,
      key: "VolumeDown",
      code: "VolumeDown",
      location: 4
    },
    VolumeUp: { keyCode: 183, key: "VolumeUp", code: "VolumeUp", location: 4 }
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Input.js
var require_Input = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Keyboard_instances;
  var _Keyboard_client;
  var _Keyboard_pressedKeys;
  var _Keyboard_modifierBit;
  var _Keyboard_keyDescriptionForString;
  var _Mouse_client;
  var _Mouse_keyboard;
  var _Mouse_x;
  var _Mouse_y;
  var _Mouse_button;
  var _Touchscreen_client;
  var _Touchscreen_keyboard;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Touchscreen = exports.Mouse = exports.Keyboard = undefined;
  var assert_js_1 = require_assert();
  var USKeyboardLayout_js_1 = require_USKeyboardLayout();

  class Keyboard {
    constructor(client) {
      _Keyboard_instances.add(this);
      _Keyboard_client.set(this, undefined);
      _Keyboard_pressedKeys.set(this, new Set);
      this._modifiers = 0;
      __classPrivateFieldSet(this, _Keyboard_client, client, "f");
    }
    async down(key2, options = { text: undefined }) {
      const description = __classPrivateFieldGet(this, _Keyboard_instances, "m", _Keyboard_keyDescriptionForString).call(this, key2);
      const autoRepeat = __classPrivateFieldGet(this, _Keyboard_pressedKeys, "f").has(description.code);
      __classPrivateFieldGet(this, _Keyboard_pressedKeys, "f").add(description.code);
      this._modifiers |= __classPrivateFieldGet(this, _Keyboard_instances, "m", _Keyboard_modifierBit).call(this, description.key);
      const text = options.text === undefined ? description.text : options.text;
      await __classPrivateFieldGet(this, _Keyboard_client, "f").send("Input.dispatchKeyEvent", {
        type: text ? "keyDown" : "rawKeyDown",
        modifiers: this._modifiers,
        windowsVirtualKeyCode: description.keyCode,
        code: description.code,
        key: description.key,
        text,
        unmodifiedText: text,
        autoRepeat,
        location: description.location,
        isKeypad: description.location === 3
      });
    }
    async up(key2) {
      const description = __classPrivateFieldGet(this, _Keyboard_instances, "m", _Keyboard_keyDescriptionForString).call(this, key2);
      this._modifiers &= ~__classPrivateFieldGet(this, _Keyboard_instances, "m", _Keyboard_modifierBit).call(this, description.key);
      __classPrivateFieldGet(this, _Keyboard_pressedKeys, "f").delete(description.code);
      await __classPrivateFieldGet(this, _Keyboard_client, "f").send("Input.dispatchKeyEvent", {
        type: "keyUp",
        modifiers: this._modifiers,
        key: description.key,
        windowsVirtualKeyCode: description.keyCode,
        code: description.code,
        location: description.location
      });
    }
    async sendCharacter(char) {
      await __classPrivateFieldGet(this, _Keyboard_client, "f").send("Input.insertText", { text: char });
    }
    charIsKey(char) {
      return !!USKeyboardLayout_js_1._keyDefinitions[char];
    }
    async type(text, options = {}) {
      const delay = options.delay || undefined;
      for (const char of text) {
        if (this.charIsKey(char)) {
          await this.press(char, { delay });
        } else {
          if (delay) {
            await new Promise((f) => {
              return setTimeout(f, delay);
            });
          }
          await this.sendCharacter(char);
        }
      }
    }
    async press(key2, options = {}) {
      const { delay = null } = options;
      await this.down(key2, options);
      if (delay) {
        await new Promise((f) => {
          return setTimeout(f, options.delay);
        });
      }
      await this.up(key2);
    }
  }
  exports.Keyboard = Keyboard;
  _Keyboard_client = new WeakMap, _Keyboard_pressedKeys = new WeakMap, _Keyboard_instances = new WeakSet, _Keyboard_modifierBit = function _Keyboard_modifierBit(key2) {
    if (key2 === "Alt") {
      return 1;
    }
    if (key2 === "Control") {
      return 2;
    }
    if (key2 === "Meta") {
      return 4;
    }
    if (key2 === "Shift") {
      return 8;
    }
    return 0;
  }, _Keyboard_keyDescriptionForString = function _Keyboard_keyDescriptionForString(keyString) {
    const shift = this._modifiers & 8;
    const description = {
      key: "",
      keyCode: 0,
      code: "",
      text: "",
      location: 0
    };
    const definition = USKeyboardLayout_js_1._keyDefinitions[keyString];
    (0, assert_js_1.assert)(definition, `Unknown key: "${keyString}"`);
    if (definition.key) {
      description.key = definition.key;
    }
    if (shift && definition.shiftKey) {
      description.key = definition.shiftKey;
    }
    if (definition.keyCode) {
      description.keyCode = definition.keyCode;
    }
    if (shift && definition.shiftKeyCode) {
      description.keyCode = definition.shiftKeyCode;
    }
    if (definition.code) {
      description.code = definition.code;
    }
    if (definition.location) {
      description.location = definition.location;
    }
    if (description.key.length === 1) {
      description.text = description.key;
    }
    if (definition.text) {
      description.text = definition.text;
    }
    if (shift && definition.shiftText) {
      description.text = definition.shiftText;
    }
    if (this._modifiers & ~8) {
      description.text = "";
    }
    return description;
  };

  class Mouse {
    constructor(client, keyboard) {
      _Mouse_client.set(this, undefined);
      _Mouse_keyboard.set(this, undefined);
      _Mouse_x.set(this, 0);
      _Mouse_y.set(this, 0);
      _Mouse_button.set(this, "none");
      __classPrivateFieldSet(this, _Mouse_client, client, "f");
      __classPrivateFieldSet(this, _Mouse_keyboard, keyboard, "f");
    }
    async move(x, y, options = {}) {
      const { steps = 1 } = options;
      const fromX = __classPrivateFieldGet(this, _Mouse_x, "f"), fromY = __classPrivateFieldGet(this, _Mouse_y, "f");
      __classPrivateFieldSet(this, _Mouse_x, x, "f");
      __classPrivateFieldSet(this, _Mouse_y, y, "f");
      for (let i = 1;i <= steps; i++) {
        await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchMouseEvent", {
          type: "mouseMoved",
          button: __classPrivateFieldGet(this, _Mouse_button, "f"),
          x: fromX + (__classPrivateFieldGet(this, _Mouse_x, "f") - fromX) * (i / steps),
          y: fromY + (__classPrivateFieldGet(this, _Mouse_y, "f") - fromY) * (i / steps),
          modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers
        });
      }
    }
    async click(x, y, options = {}) {
      const { delay = null } = options;
      if (delay !== null) {
        await this.move(x, y);
        await this.down(options);
        await new Promise((f) => {
          return setTimeout(f, delay);
        });
        await this.up(options);
      } else {
        await this.move(x, y);
        await this.down(options);
        await this.up(options);
      }
    }
    async down(options = {}) {
      const { button = "left", clickCount = 1 } = options;
      __classPrivateFieldSet(this, _Mouse_button, button, "f");
      await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchMouseEvent", {
        type: "mousePressed",
        button,
        x: __classPrivateFieldGet(this, _Mouse_x, "f"),
        y: __classPrivateFieldGet(this, _Mouse_y, "f"),
        modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
        clickCount
      });
    }
    async up(options = {}) {
      const { button = "left", clickCount = 1 } = options;
      __classPrivateFieldSet(this, _Mouse_button, "none", "f");
      await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchMouseEvent", {
        type: "mouseReleased",
        button,
        x: __classPrivateFieldGet(this, _Mouse_x, "f"),
        y: __classPrivateFieldGet(this, _Mouse_y, "f"),
        modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
        clickCount
      });
    }
    async wheel(options = {}) {
      const { deltaX = 0, deltaY = 0 } = options;
      await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchMouseEvent", {
        type: "mouseWheel",
        x: __classPrivateFieldGet(this, _Mouse_x, "f"),
        y: __classPrivateFieldGet(this, _Mouse_y, "f"),
        deltaX,
        deltaY,
        modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
        pointerType: "mouse"
      });
    }
    async drag(start, target) {
      const promise = new Promise((resolve) => {
        __classPrivateFieldGet(this, _Mouse_client, "f").once("Input.dragIntercepted", (event) => {
          return resolve(event.data);
        });
      });
      await this.move(start.x, start.y);
      await this.down();
      await this.move(target.x, target.y);
      return promise;
    }
    async dragEnter(target, data) {
      await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchDragEvent", {
        type: "dragEnter",
        x: target.x,
        y: target.y,
        modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
        data
      });
    }
    async dragOver(target, data) {
      await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchDragEvent", {
        type: "dragOver",
        x: target.x,
        y: target.y,
        modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
        data
      });
    }
    async drop(target, data) {
      await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchDragEvent", {
        type: "drop",
        x: target.x,
        y: target.y,
        modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
        data
      });
    }
    async dragAndDrop(start, target, options = {}) {
      const { delay = null } = options;
      const data = await this.drag(start, target);
      await this.dragEnter(target, data);
      await this.dragOver(target, data);
      if (delay) {
        await new Promise((resolve) => {
          return setTimeout(resolve, delay);
        });
      }
      await this.drop(target, data);
      await this.up();
    }
  }
  exports.Mouse = Mouse;
  _Mouse_client = new WeakMap, _Mouse_keyboard = new WeakMap, _Mouse_x = new WeakMap, _Mouse_y = new WeakMap, _Mouse_button = new WeakMap;

  class Touchscreen {
    constructor(client, keyboard) {
      _Touchscreen_client.set(this, undefined);
      _Touchscreen_keyboard.set(this, undefined);
      __classPrivateFieldSet(this, _Touchscreen_client, client, "f");
      __classPrivateFieldSet(this, _Touchscreen_keyboard, keyboard, "f");
    }
    async tap(x, y) {
      const touchPoints = [{ x: Math.round(x), y: Math.round(y) }];
      await __classPrivateFieldGet(this, _Touchscreen_client, "f").send("Input.dispatchTouchEvent", {
        type: "touchStart",
        touchPoints,
        modifiers: __classPrivateFieldGet(this, _Touchscreen_keyboard, "f")._modifiers
      });
      await __classPrivateFieldGet(this, _Touchscreen_client, "f").send("Input.dispatchTouchEvent", {
        type: "touchEnd",
        touchPoints: [],
        modifiers: __classPrivateFieldGet(this, _Touchscreen_keyboard, "f")._modifiers
      });
    }
  }
  exports.Touchscreen = Touchscreen;
  _Touchscreen_client = new WeakMap, _Touchscreen_keyboard = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/PDFOptions.js
var require_PDFOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._paperFormats = undefined;
  exports._paperFormats = {
    letter: { width: 8.5, height: 11 },
    legal: { width: 8.5, height: 14 },
    tabloid: { width: 11, height: 17 },
    ledger: { width: 17, height: 11 },
    a0: { width: 33.1, height: 46.8 },
    a1: { width: 23.4, height: 33.1 },
    a2: { width: 16.54, height: 23.4 },
    a3: { width: 11.7, height: 16.54 },
    a4: { width: 8.27, height: 11.7 },
    a5: { width: 5.83, height: 8.27 },
    a6: { width: 4.13, height: 5.83 }
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/TimeoutSettings.js
var require_TimeoutSettings = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _TimeoutSettings_defaultTimeout;
  var _TimeoutSettings_defaultNavigationTimeout;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeoutSettings = undefined;
  var DEFAULT_TIMEOUT = 30000;

  class TimeoutSettings {
    constructor() {
      _TimeoutSettings_defaultTimeout.set(this, undefined);
      _TimeoutSettings_defaultNavigationTimeout.set(this, undefined);
      __classPrivateFieldSet(this, _TimeoutSettings_defaultTimeout, null, "f");
      __classPrivateFieldSet(this, _TimeoutSettings_defaultNavigationTimeout, null, "f");
    }
    setDefaultTimeout(timeout) {
      __classPrivateFieldSet(this, _TimeoutSettings_defaultTimeout, timeout, "f");
    }
    setDefaultNavigationTimeout(timeout) {
      __classPrivateFieldSet(this, _TimeoutSettings_defaultNavigationTimeout, timeout, "f");
    }
    navigationTimeout() {
      if (__classPrivateFieldGet(this, _TimeoutSettings_defaultNavigationTimeout, "f") !== null) {
        return __classPrivateFieldGet(this, _TimeoutSettings_defaultNavigationTimeout, "f");
      }
      if (__classPrivateFieldGet(this, _TimeoutSettings_defaultTimeout, "f") !== null) {
        return __classPrivateFieldGet(this, _TimeoutSettings_defaultTimeout, "f");
      }
      return DEFAULT_TIMEOUT;
    }
    timeout() {
      if (__classPrivateFieldGet(this, _TimeoutSettings_defaultTimeout, "f") !== null) {
        return __classPrivateFieldGet(this, _TimeoutSettings_defaultTimeout, "f");
      }
      return DEFAULT_TIMEOUT;
    }
  }
  exports.TimeoutSettings = TimeoutSettings;
  _TimeoutSettings_defaultTimeout = new WeakMap, _TimeoutSettings_defaultNavigationTimeout = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Tracing.js
var require_Tracing = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Tracing_client;
  var _Tracing_recording;
  var _Tracing_path;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tracing = undefined;
  var assert_js_1 = require_assert();
  var util_js_1 = require_util();
  var ErrorLike_js_1 = require_ErrorLike();

  class Tracing {
    constructor(client) {
      _Tracing_client.set(this, undefined);
      _Tracing_recording.set(this, false);
      _Tracing_path.set(this, undefined);
      __classPrivateFieldSet(this, _Tracing_client, client, "f");
    }
    async start(options = {}) {
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _Tracing_recording, "f"), "Cannot start recording trace while already recording trace.");
      const defaultCategories = [
        "-*",
        "devtools.timeline",
        "v8.execute",
        "disabled-by-default-devtools.timeline",
        "disabled-by-default-devtools.timeline.frame",
        "toplevel",
        "blink.console",
        "blink.user_timing",
        "latencyInfo",
        "disabled-by-default-devtools.timeline.stack",
        "disabled-by-default-v8.cpu_profiler"
      ];
      const { path, screenshots = false, categories = defaultCategories } = options;
      if (screenshots) {
        categories.push("disabled-by-default-devtools.screenshot");
      }
      const excludedCategories = categories.filter((cat) => {
        return cat.startsWith("-");
      }).map((cat) => {
        return cat.slice(1);
      });
      const includedCategories = categories.filter((cat) => {
        return !cat.startsWith("-");
      });
      __classPrivateFieldSet(this, _Tracing_path, path, "f");
      __classPrivateFieldSet(this, _Tracing_recording, true, "f");
      await __classPrivateFieldGet(this, _Tracing_client, "f").send("Tracing.start", {
        transferMode: "ReturnAsStream",
        traceConfig: {
          excludedCategories,
          includedCategories
        }
      });
    }
    async stop() {
      let resolve;
      let reject;
      const contentPromise = new Promise((x, y) => {
        resolve = x;
        reject = y;
      });
      __classPrivateFieldGet(this, _Tracing_client, "f").once("Tracing.tracingComplete", async (event) => {
        try {
          const readable = await (0, util_js_1.getReadableFromProtocolStream)(__classPrivateFieldGet(this, _Tracing_client, "f"), event.stream);
          const buffer = await (0, util_js_1.getReadableAsBuffer)(readable, __classPrivateFieldGet(this, _Tracing_path, "f"));
          resolve(buffer !== null && buffer !== undefined ? buffer : undefined);
        } catch (error) {
          if ((0, ErrorLike_js_1.isErrorLike)(error)) {
            reject(error);
          } else {
            reject(new Error(`Unknown error: ${error}`));
          }
        }
      });
      await __classPrivateFieldGet(this, _Tracing_client, "f").send("Tracing.end");
      __classPrivateFieldSet(this, _Tracing_recording, false, "f");
      return contentPromise;
    }
  }
  exports.Tracing = Tracing;
  _Tracing_client = new WeakMap, _Tracing_recording = new WeakMap, _Tracing_path = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/api/Page.js
var require_Page = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Page_handlerMap;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unitToPixels = exports.supportedMetrics = exports.Page = undefined;
  var EventEmitter_js_1 = require_EventEmitter();

  class Page extends EventEmitter_js_1.EventEmitter {
    constructor() {
      super();
      _Page_handlerMap.set(this, new WeakMap);
    }
    isDragInterceptionEnabled() {
      throw new Error("Not implemented");
    }
    isJavaScriptEnabled() {
      throw new Error("Not implemented");
    }
    on(eventName, handler) {
      if (eventName === "request") {
        const wrap = __classPrivateFieldGet(this, _Page_handlerMap, "f").get(handler) || ((event) => {
          event.enqueueInterceptAction(() => {
            return handler(event);
          });
        });
        __classPrivateFieldGet(this, _Page_handlerMap, "f").set(handler, wrap);
        return super.on(eventName, wrap);
      }
      return super.on(eventName, handler);
    }
    once(eventName, handler) {
      return super.once(eventName, handler);
    }
    off(eventName, handler) {
      if (eventName === "request") {
        handler = __classPrivateFieldGet(this, _Page_handlerMap, "f").get(handler) || handler;
      }
      return super.off(eventName, handler);
    }
    waitForFileChooser() {
      throw new Error("Not implemented");
    }
    async setGeolocation() {
      throw new Error("Not implemented");
    }
    target() {
      throw new Error("Not implemented");
    }
    browser() {
      throw new Error("Not implemented");
    }
    browserContext() {
      throw new Error("Not implemented");
    }
    mainFrame() {
      throw new Error("Not implemented");
    }
    get keyboard() {
      throw new Error("Not implemented");
    }
    get touchscreen() {
      throw new Error("Not implemented");
    }
    get coverage() {
      throw new Error("Not implemented");
    }
    get tracing() {
      throw new Error("Not implemented");
    }
    get accessibility() {
      throw new Error("Not implemented");
    }
    frames() {
      throw new Error("Not implemented");
    }
    workers() {
      throw new Error("Not implemented");
    }
    async setRequestInterception() {
      throw new Error("Not implemented");
    }
    async setDragInterception() {
      throw new Error("Not implemented");
    }
    setOfflineMode() {
      throw new Error("Not implemented");
    }
    emulateNetworkConditions() {
      throw new Error("Not implemented");
    }
    setDefaultNavigationTimeout() {
      throw new Error("Not implemented");
    }
    setDefaultTimeout() {
      throw new Error("Not implemented");
    }
    getDefaultTimeout() {
      throw new Error("Not implemented");
    }
    async $() {
      throw new Error("Not implemented");
    }
    async $$() {
      throw new Error("Not implemented");
    }
    async evaluateHandle() {
      throw new Error("Not implemented");
    }
    async queryObjects() {
      throw new Error("Not implemented");
    }
    async $eval() {
      throw new Error("Not implemented");
    }
    async $$eval() {
      throw new Error("Not implemented");
    }
    async $x() {
      throw new Error("Not implemented");
    }
    async cookies() {
      throw new Error("Not implemented");
    }
    async deleteCookie() {
      throw new Error("Not implemented");
    }
    async setCookie() {
      throw new Error("Not implemented");
    }
    async addScriptTag() {
      throw new Error("Not implemented");
    }
    async addStyleTag() {
      throw new Error("Not implemented");
    }
    async exposeFunction() {
      throw new Error("Not implemented");
    }
    async authenticate() {
      throw new Error("Not implemented");
    }
    async setExtraHTTPHeaders() {
      throw new Error("Not implemented");
    }
    async setUserAgent() {
      throw new Error("Not implemented");
    }
    async metrics() {
      throw new Error("Not implemented");
    }
    url() {
      throw new Error("Not implemented");
    }
    async content() {
      throw new Error("Not implemented");
    }
    async setContent() {
      throw new Error("Not implemented");
    }
    async goto() {
      throw new Error("Not implemented");
    }
    async reload() {
      throw new Error("Not implemented");
    }
    async waitForNavigation() {
      throw new Error("Not implemented");
    }
    async waitForRequest() {
      throw new Error("Not implemented");
    }
    async waitForResponse() {
      throw new Error("Not implemented");
    }
    async waitForNetworkIdle() {
      throw new Error("Not implemented");
    }
    async waitForFrame() {
      throw new Error("Not implemented");
    }
    async goBack() {
      throw new Error("Not implemented");
    }
    async goForward() {
      throw new Error("Not implemented");
    }
    async bringToFront() {
      throw new Error("Not implemented");
    }
    async emulate() {
      throw new Error("Not implemented");
    }
    async setJavaScriptEnabled() {
      throw new Error("Not implemented");
    }
    async setBypassCSP() {
      throw new Error("Not implemented");
    }
    async emulateMediaType() {
      throw new Error("Not implemented");
    }
    async emulateCPUThrottling() {
      throw new Error("Not implemented");
    }
    async emulateMediaFeatures() {
      throw new Error("Not implemented");
    }
    async emulateTimezone() {
      throw new Error("Not implemented");
    }
    async emulateIdleState() {
      throw new Error("Not implemented");
    }
    async emulateVisionDeficiency() {
      throw new Error("Not implemented");
    }
    async setViewport() {
      throw new Error("Not implemented");
    }
    viewport() {
      throw new Error("Not implemented");
    }
    async evaluate() {
      throw new Error("Not implemented");
    }
    async evaluateOnNewDocument() {
      throw new Error("Not implemented");
    }
    async setCacheEnabled() {
      throw new Error("Not implemented");
    }
    async screenshot() {
      throw new Error("Not implemented");
    }
    async createPDFStream() {
      throw new Error("Not implemented");
    }
    async pdf() {
      throw new Error("Not implemented");
    }
    async title() {
      throw new Error("Not implemented");
    }
    async close() {
      throw new Error("Not implemented");
    }
    isClosed() {
      throw new Error("Not implemented");
    }
    get mouse() {
      throw new Error("Not implemented");
    }
    click() {
      throw new Error("Not implemented");
    }
    focus() {
      throw new Error("Not implemented");
    }
    hover() {
      throw new Error("Not implemented");
    }
    select() {
      throw new Error("Not implemented");
    }
    tap() {
      throw new Error("Not implemented");
    }
    type() {
      throw new Error("Not implemented");
    }
    waitForTimeout() {
      throw new Error("Not implemented");
    }
    async waitForSelector() {
      throw new Error("Not implemented");
    }
    waitForXPath() {
      throw new Error("Not implemented");
    }
    waitForFunction() {
      throw new Error("Not implemented");
    }
  }
  exports.Page = Page;
  _Page_handlerMap = new WeakMap;
  exports.supportedMetrics = new Set([
    "Timestamp",
    "Documents",
    "Frames",
    "JSEventListeners",
    "Nodes",
    "LayoutCount",
    "RecalcStyleCount",
    "LayoutDuration",
    "RecalcStyleDuration",
    "ScriptDuration",
    "TaskDuration",
    "JSHeapUsedSize",
    "JSHeapTotalSize"
  ]);
  exports.unitToPixels = {
    px: 1,
    in: 96,
    cm: 37.8,
    mm: 3.78
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Page.js
var require_Page2 = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _CDPPage_instances;
  var _CDPPage_closed;
  var _CDPPage_client;
  var _CDPPage_target;
  var _CDPPage_keyboard;
  var _CDPPage_mouse;
  var _CDPPage_timeoutSettings;
  var _CDPPage_touchscreen;
  var _CDPPage_accessibility;
  var _CDPPage_frameManager;
  var _CDPPage_emulationManager;
  var _CDPPage_tracing;
  var _CDPPage_pageBindings;
  var _CDPPage_coverage;
  var _CDPPage_javascriptEnabled;
  var _CDPPage_viewport;
  var _CDPPage_screenshotTaskQueue;
  var _CDPPage_workers;
  var _CDPPage_fileChooserPromises;
  var _CDPPage_disconnectPromise;
  var _CDPPage_userDragInterceptionEnabled;
  var _CDPPage_onDetachedFromTarget;
  var _CDPPage_onAttachedToTarget;
  var _CDPPage_initialize;
  var _CDPPage_onFileChooser;
  var _CDPPage_onTargetCrashed;
  var _CDPPage_onLogEntryAdded;
  var _CDPPage_emitMetrics;
  var _CDPPage_buildMetricsObject;
  var _CDPPage_handleException;
  var _CDPPage_onConsoleAPI;
  var _CDPPage_onBindingCalled;
  var _CDPPage_addConsoleMessage;
  var _CDPPage_onDialog;
  var _CDPPage_resetDefaultBackgroundColor;
  var _CDPPage_setTransparentBackgroundColor;
  var _CDPPage_sessionClosePromise;
  var _CDPPage_go;
  var _CDPPage_screenshotTask;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CDPPage = undefined;
  var assert_js_1 = require_assert();
  var DeferredPromise_js_1 = require_DeferredPromise();
  var ErrorLike_js_1 = require_ErrorLike();
  var Accessibility_js_1 = require_Accessibility();
  var Connection_js_1 = require_Connection();
  var ConsoleMessage_js_1 = require_ConsoleMessage();
  var Coverage_js_1 = require_Coverage();
  var Dialog_js_1 = require_Dialog();
  var EmulationManager_js_1 = require_EmulationManager();
  var FileChooser_js_1 = require_FileChooser();
  var FrameManager_js_1 = require_FrameManager();
  var Input_js_1 = require_Input();
  var IsolatedWorld_js_1 = require_IsolatedWorld();
  var NetworkManager_js_1 = require_NetworkManager();
  var PDFOptions_js_1 = require_PDFOptions();
  var TimeoutSettings_js_1 = require_TimeoutSettings();
  var Tracing_js_1 = require_Tracing();
  var util_js_1 = require_util();
  var WebWorker_js_1 = require_WebWorker();
  var Page_js_1 = require_Page();

  class CDPPage extends Page_js_1.Page {
    constructor(client, target, ignoreHTTPSErrors, screenshotTaskQueue) {
      super();
      _CDPPage_instances.add(this);
      _CDPPage_closed.set(this, false);
      _CDPPage_client.set(this, undefined);
      _CDPPage_target.set(this, undefined);
      _CDPPage_keyboard.set(this, undefined);
      _CDPPage_mouse.set(this, undefined);
      _CDPPage_timeoutSettings.set(this, new TimeoutSettings_js_1.TimeoutSettings);
      _CDPPage_touchscreen.set(this, undefined);
      _CDPPage_accessibility.set(this, undefined);
      _CDPPage_frameManager.set(this, undefined);
      _CDPPage_emulationManager.set(this, undefined);
      _CDPPage_tracing.set(this, undefined);
      _CDPPage_pageBindings.set(this, new Map);
      _CDPPage_coverage.set(this, undefined);
      _CDPPage_javascriptEnabled.set(this, true);
      _CDPPage_viewport.set(this, undefined);
      _CDPPage_screenshotTaskQueue.set(this, undefined);
      _CDPPage_workers.set(this, new Map);
      _CDPPage_fileChooserPromises.set(this, new Set);
      _CDPPage_disconnectPromise.set(this, undefined);
      _CDPPage_userDragInterceptionEnabled.set(this, false);
      _CDPPage_onDetachedFromTarget.set(this, (target2) => {
        var _a;
        const sessionId = (_a = target2._session()) === null || _a === undefined ? undefined : _a.id();
        __classPrivateFieldGet(this, _CDPPage_frameManager, "f").onDetachedFromTarget(target2);
        const worker = __classPrivateFieldGet(this, _CDPPage_workers, "f").get(sessionId);
        if (!worker) {
          return;
        }
        __classPrivateFieldGet(this, _CDPPage_workers, "f").delete(sessionId);
        this.emit("workerdestroyed", worker);
      });
      _CDPPage_onAttachedToTarget.set(this, async (createdTarget) => {
        __classPrivateFieldGet(this, _CDPPage_frameManager, "f").onAttachedToTarget(createdTarget);
        if (createdTarget._getTargetInfo().type === "worker") {
          const session = createdTarget._session();
          (0, assert_js_1.assert)(session);
          const worker = new WebWorker_js_1.WebWorker(session, createdTarget.url(), __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_addConsoleMessage).bind(this), __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_handleException).bind(this));
          __classPrivateFieldGet(this, _CDPPage_workers, "f").set(session.id(), worker);
          this.emit("workercreated", worker);
        }
        if (createdTarget._session()) {
          __classPrivateFieldGet(this, _CDPPage_target, "f")._targetManager().addTargetInterceptor(createdTarget._session(), __classPrivateFieldGet(this, _CDPPage_onAttachedToTarget, "f"));
        }
      });
      __classPrivateFieldSet(this, _CDPPage_client, client, "f");
      __classPrivateFieldSet(this, _CDPPage_target, target, "f");
      __classPrivateFieldSet(this, _CDPPage_keyboard, new Input_js_1.Keyboard(client), "f");
      __classPrivateFieldSet(this, _CDPPage_mouse, new Input_js_1.Mouse(client, __classPrivateFieldGet(this, _CDPPage_keyboard, "f")), "f");
      __classPrivateFieldSet(this, _CDPPage_touchscreen, new Input_js_1.Touchscreen(client, __classPrivateFieldGet(this, _CDPPage_keyboard, "f")), "f");
      __classPrivateFieldSet(this, _CDPPage_accessibility, new Accessibility_js_1.Accessibility(client), "f");
      __classPrivateFieldSet(this, _CDPPage_frameManager, new FrameManager_js_1.FrameManager(client, this, ignoreHTTPSErrors, __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f")), "f");
      __classPrivateFieldSet(this, _CDPPage_emulationManager, new EmulationManager_js_1.EmulationManager(client), "f");
      __classPrivateFieldSet(this, _CDPPage_tracing, new Tracing_js_1.Tracing(client), "f");
      __classPrivateFieldSet(this, _CDPPage_coverage, new Coverage_js_1.Coverage(client), "f");
      __classPrivateFieldSet(this, _CDPPage_screenshotTaskQueue, screenshotTaskQueue, "f");
      __classPrivateFieldSet(this, _CDPPage_viewport, null, "f");
      __classPrivateFieldGet(this, _CDPPage_target, "f")._targetManager().addTargetInterceptor(__classPrivateFieldGet(this, _CDPPage_client, "f"), __classPrivateFieldGet(this, _CDPPage_onAttachedToTarget, "f"));
      __classPrivateFieldGet(this, _CDPPage_target, "f")._targetManager().on("targetGone", __classPrivateFieldGet(this, _CDPPage_onDetachedFromTarget, "f"));
      __classPrivateFieldGet(this, _CDPPage_frameManager, "f").on(FrameManager_js_1.FrameManagerEmittedEvents.FrameAttached, (event) => {
        return this.emit("frameattached", event);
      });
      __classPrivateFieldGet(this, _CDPPage_frameManager, "f").on(FrameManager_js_1.FrameManagerEmittedEvents.FrameDetached, (event) => {
        return this.emit("framedetached", event);
      });
      __classPrivateFieldGet(this, _CDPPage_frameManager, "f").on(FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigated, (event) => {
        return this.emit("framenavigated", event);
      });
      const networkManager = __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager;
      networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.Request, (event) => {
        return this.emit("request", event);
      });
      networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestServedFromCache, (event) => {
        return this.emit("requestservedfromcache", event);
      });
      networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.Response, (event) => {
        return this.emit("response", event);
      });
      networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed, (event) => {
        return this.emit("requestfailed", event);
      });
      networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFinished, (event) => {
        return this.emit("requestfinished", event);
      });
      client.on("Page.domContentEventFired", () => {
        return this.emit("domcontentloaded");
      });
      client.on("Page.loadEventFired", () => {
        return this.emit("load");
      });
      client.on("Runtime.consoleAPICalled", (event) => {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onConsoleAPI).call(this, event);
      });
      client.on("Runtime.bindingCalled", (event) => {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onBindingCalled).call(this, event);
      });
      client.on("Page.javascriptDialogOpening", (event) => {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onDialog).call(this, event);
      });
      client.on("Runtime.exceptionThrown", (exception) => {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_handleException).call(this, exception.exceptionDetails);
      });
      client.on("Inspector.targetCrashed", () => {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onTargetCrashed).call(this);
      });
      client.on("Performance.metrics", (event) => {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_emitMetrics).call(this, event);
      });
      client.on("Log.entryAdded", (event) => {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onLogEntryAdded).call(this, event);
      });
      client.on("Page.fileChooserOpened", (event) => {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onFileChooser).call(this, event);
      });
      __classPrivateFieldGet(this, _CDPPage_target, "f")._isClosedPromise.then(() => {
        __classPrivateFieldGet(this, _CDPPage_target, "f")._targetManager().removeTargetInterceptor(__classPrivateFieldGet(this, _CDPPage_client, "f"), __classPrivateFieldGet(this, _CDPPage_onAttachedToTarget, "f"));
        __classPrivateFieldGet(this, _CDPPage_target, "f")._targetManager().off("targetGone", __classPrivateFieldGet(this, _CDPPage_onDetachedFromTarget, "f"));
        this.emit("close");
        __classPrivateFieldSet(this, _CDPPage_closed, true, "f");
      });
    }
    static async _create(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
      const page = new CDPPage(client, target, ignoreHTTPSErrors, screenshotTaskQueue);
      await __classPrivateFieldGet(page, _CDPPage_instances, "m", _CDPPage_initialize).call(page);
      if (defaultViewport) {
        try {
          await page.setViewport(defaultViewport);
        } catch (err) {
          if ((0, ErrorLike_js_1.isErrorLike)(err) && (0, Connection_js_1.isTargetClosedError)(err)) {
            (0, util_js_1.debugError)(err);
          } else {
            throw err;
          }
        }
      }
      return page;
    }
    isDragInterceptionEnabled() {
      return __classPrivateFieldGet(this, _CDPPage_userDragInterceptionEnabled, "f");
    }
    isJavaScriptEnabled() {
      return __classPrivateFieldGet(this, _CDPPage_javascriptEnabled, "f");
    }
    waitForFileChooser(options = {}) {
      const needsEnable = __classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f").size === 0;
      const { timeout = __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout() } = options;
      const promise = (0, DeferredPromise_js_1.createDeferredPromise)({
        message: `Waiting for \`FileChooser\` failed: ${timeout}ms exceeded`,
        timeout
      });
      __classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f").add(promise);
      let enablePromise;
      if (needsEnable) {
        enablePromise = __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.setInterceptFileChooserDialog", {
          enabled: true
        });
      }
      return Promise.all([promise, enablePromise]).then(([result]) => {
        return result;
      }).catch((error) => {
        __classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f").delete(promise);
        throw error;
      });
    }
    async setGeolocation(options) {
      const { longitude, latitude, accuracy = 0 } = options;
      if (longitude < -180 || longitude > 180) {
        throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
      }
      if (latitude < -90 || latitude > 90) {
        throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
      }
      if (accuracy < 0) {
        throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
      }
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setGeolocationOverride", {
        longitude,
        latitude,
        accuracy
      });
    }
    target() {
      return __classPrivateFieldGet(this, _CDPPage_target, "f");
    }
    _client() {
      return __classPrivateFieldGet(this, _CDPPage_client, "f");
    }
    browser() {
      return __classPrivateFieldGet(this, _CDPPage_target, "f").browser();
    }
    browserContext() {
      return __classPrivateFieldGet(this, _CDPPage_target, "f").browserContext();
    }
    mainFrame() {
      return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame();
    }
    get keyboard() {
      return __classPrivateFieldGet(this, _CDPPage_keyboard, "f");
    }
    get touchscreen() {
      return __classPrivateFieldGet(this, _CDPPage_touchscreen, "f");
    }
    get coverage() {
      return __classPrivateFieldGet(this, _CDPPage_coverage, "f");
    }
    get tracing() {
      return __classPrivateFieldGet(this, _CDPPage_tracing, "f");
    }
    get accessibility() {
      return __classPrivateFieldGet(this, _CDPPage_accessibility, "f");
    }
    frames() {
      return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").frames();
    }
    workers() {
      return Array.from(__classPrivateFieldGet(this, _CDPPage_workers, "f").values());
    }
    async setRequestInterception(value) {
      return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.setRequestInterception(value);
    }
    async setDragInterception(enabled) {
      __classPrivateFieldSet(this, _CDPPage_userDragInterceptionEnabled, enabled, "f");
      return __classPrivateFieldGet(this, _CDPPage_client, "f").send("Input.setInterceptDrags", { enabled });
    }
    setOfflineMode(enabled) {
      return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.setOfflineMode(enabled);
    }
    emulateNetworkConditions(networkConditions) {
      return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.emulateNetworkConditions(networkConditions);
    }
    setDefaultNavigationTimeout(timeout) {
      __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
      __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").setDefaultTimeout(timeout);
    }
    getDefaultTimeout() {
      return __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout();
    }
    async $(selector) {
      return this.mainFrame().$(selector);
    }
    async $$(selector) {
      return this.mainFrame().$$(selector);
    }
    async evaluateHandle(pageFunction, ...args) {
      const context = await this.mainFrame().executionContext();
      return context.evaluateHandle(pageFunction, ...args);
    }
    async queryObjects(prototypeHandle) {
      const context = await this.mainFrame().executionContext();
      (0, assert_js_1.assert)(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
      const remoteObject = prototypeHandle.remoteObject();
      (0, assert_js_1.assert)(remoteObject.objectId, "Prototype JSHandle must not be referencing primitive value");
      const response = await context._client.send("Runtime.queryObjects", {
        prototypeObjectId: remoteObject.objectId
      });
      return (0, util_js_1.createJSHandle)(context, response.objects);
    }
    async $eval(selector, pageFunction, ...args) {
      return this.mainFrame().$eval(selector, pageFunction, ...args);
    }
    async $$eval(selector, pageFunction, ...args) {
      return this.mainFrame().$$eval(selector, pageFunction, ...args);
    }
    async $x(expression) {
      return this.mainFrame().$x(expression);
    }
    async cookies(...urls) {
      const originalCookies = (await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Network.getCookies", {
        urls: urls.length ? urls : [this.url()]
      })).cookies;
      const unsupportedCookieAttributes = ["priority"];
      const filterUnsupportedAttributes = (cookie) => {
        for (const attr of unsupportedCookieAttributes) {
          delete cookie[attr];
        }
        return cookie;
      };
      return originalCookies.map(filterUnsupportedAttributes);
    }
    async deleteCookie(...cookies) {
      const pageURL = this.url();
      for (const cookie of cookies) {
        const item = Object.assign({}, cookie);
        if (!cookie.url && pageURL.startsWith("http")) {
          item.url = pageURL;
        }
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Network.deleteCookies", item);
      }
    }
    async setCookie(...cookies) {
      const pageURL = this.url();
      const startsWithHTTP = pageURL.startsWith("http");
      const items = cookies.map((cookie) => {
        const item = Object.assign({}, cookie);
        if (!item.url && startsWithHTTP) {
          item.url = pageURL;
        }
        (0, assert_js_1.assert)(item.url !== "about:blank", `Blank page can not have cookie "${item.name}"`);
        (0, assert_js_1.assert)(!String.prototype.startsWith.call(item.url || "", "data:"), `Data URL page can not have cookie "${item.name}"`);
        return item;
      });
      await this.deleteCookie(...items);
      if (items.length) {
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Network.setCookies", { cookies: items });
      }
    }
    async addScriptTag(options) {
      return this.mainFrame().addScriptTag(options);
    }
    async addStyleTag(options) {
      return this.mainFrame().addStyleTag(options);
    }
    async exposeFunction(name, pptrFunction) {
      if (__classPrivateFieldGet(this, _CDPPage_pageBindings, "f").has(name)) {
        throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
      }
      let exposedFunction;
      switch (typeof pptrFunction) {
        case "function":
          exposedFunction = pptrFunction;
          break;
        default:
          exposedFunction = pptrFunction.default;
          break;
      }
      __classPrivateFieldGet(this, _CDPPage_pageBindings, "f").set(name, exposedFunction);
      const expression = (0, util_js_1.pageBindingInitString)("exposedFun", name);
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Runtime.addBinding", { name });
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.addScriptToEvaluateOnNewDocument", {
        source: expression
      });
      await Promise.all(this.frames().map((frame) => {
        return frame.evaluate(expression).catch(util_js_1.debugError);
      }));
    }
    async authenticate(credentials) {
      return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.authenticate(credentials);
    }
    async setExtraHTTPHeaders(headers) {
      return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.setExtraHTTPHeaders(headers);
    }
    async setUserAgent(userAgent, userAgentMetadata) {
      return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.setUserAgent(userAgent, userAgentMetadata);
    }
    async metrics() {
      const response = await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Performance.getMetrics");
      return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_buildMetricsObject).call(this, response.metrics);
    }
    url() {
      return this.mainFrame().url();
    }
    async content() {
      return await __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame().content();
    }
    async setContent(html, options = {}) {
      await __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame().setContent(html, options);
    }
    async goto(url, options = {}) {
      return await __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame().goto(url, options);
    }
    async reload(options) {
      const result = await Promise.all([
        this.waitForNavigation(options),
        __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.reload")
      ]);
      return result[0];
    }
    async waitForNavigation(options = {}) {
      return await __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame().waitForNavigation(options);
    }
    async waitForRequest(urlOrPredicate, options = {}) {
      const { timeout = __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout() } = options;
      return (0, util_js_1.waitForEvent)(__classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Request, async (request) => {
        if ((0, util_js_1.isString)(urlOrPredicate)) {
          return urlOrPredicate === request.url();
        }
        if (typeof urlOrPredicate === "function") {
          return !!await urlOrPredicate(request);
        }
        return false;
      }, timeout, __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_sessionClosePromise).call(this));
    }
    async waitForResponse(urlOrPredicate, options = {}) {
      const { timeout = __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout() } = options;
      return (0, util_js_1.waitForEvent)(__classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Response, async (response) => {
        if ((0, util_js_1.isString)(urlOrPredicate)) {
          return urlOrPredicate === response.url();
        }
        if (typeof urlOrPredicate === "function") {
          return !!await urlOrPredicate(response);
        }
        return false;
      }, timeout, __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_sessionClosePromise).call(this));
    }
    async waitForNetworkIdle(options = {}) {
      const { idleTime = 500, timeout = __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout() } = options;
      const networkManager = __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager;
      let idleResolveCallback;
      const idlePromise = new Promise((resolve) => {
        idleResolveCallback = resolve;
      });
      let abortRejectCallback;
      const abortPromise = new Promise((_2, reject) => {
        abortRejectCallback = reject;
      });
      let idleTimer;
      const onIdle = () => {
        return idleResolveCallback();
      };
      const cleanup = () => {
        idleTimer && clearTimeout(idleTimer);
        abortRejectCallback(new Error("abort"));
      };
      const evaluate = () => {
        idleTimer && clearTimeout(idleTimer);
        if (networkManager.numRequestsInProgress() === 0) {
          idleTimer = setTimeout(onIdle, idleTime);
        }
      };
      evaluate();
      const eventHandler = () => {
        evaluate();
        return false;
      };
      const listenToEvent = (event) => {
        return (0, util_js_1.waitForEvent)(networkManager, event, eventHandler, timeout, abortPromise);
      };
      const eventPromises = [
        listenToEvent(NetworkManager_js_1.NetworkManagerEmittedEvents.Request),
        listenToEvent(NetworkManager_js_1.NetworkManagerEmittedEvents.Response)
      ];
      await Promise.race([
        idlePromise,
        ...eventPromises,
        __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_sessionClosePromise).call(this)
      ]).then((r) => {
        cleanup();
        return r;
      }, (error) => {
        cleanup();
        throw error;
      });
    }
    async waitForFrame(urlOrPredicate, options = {}) {
      const { timeout = __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout() } = options;
      let predicate;
      if ((0, util_js_1.isString)(urlOrPredicate)) {
        predicate = (frame) => {
          return Promise.resolve(urlOrPredicate === frame.url());
        };
      } else {
        predicate = (frame) => {
          const value = urlOrPredicate(frame);
          if (typeof value === "boolean") {
            return Promise.resolve(value);
          }
          return value;
        };
      }
      const eventRace = Promise.race([
        (0, util_js_1.waitForEvent)(__classPrivateFieldGet(this, _CDPPage_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameAttached, predicate, timeout, __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_sessionClosePromise).call(this)),
        (0, util_js_1.waitForEvent)(__classPrivateFieldGet(this, _CDPPage_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigated, predicate, timeout, __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_sessionClosePromise).call(this)),
        ...this.frames().map(async (frame) => {
          if (await predicate(frame)) {
            return frame;
          }
          return await eventRace;
        })
      ]);
      return eventRace;
    }
    async goBack(options = {}) {
      return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_go).call(this, -1, options);
    }
    async goForward(options = {}) {
      return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_go).call(this, 1, options);
    }
    async bringToFront() {
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.bringToFront");
    }
    async emulate(options) {
      await Promise.all([
        this.setViewport(options.viewport),
        this.setUserAgent(options.userAgent)
      ]);
    }
    async setJavaScriptEnabled(enabled) {
      if (__classPrivateFieldGet(this, _CDPPage_javascriptEnabled, "f") === enabled) {
        return;
      }
      __classPrivateFieldSet(this, _CDPPage_javascriptEnabled, enabled, "f");
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setScriptExecutionDisabled", {
        value: !enabled
      });
    }
    async setBypassCSP(enabled) {
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.setBypassCSP", { enabled });
    }
    async emulateMediaType(type) {
      (0, assert_js_1.assert)(type === "screen" || type === "print" || (type !== null && type !== undefined ? type : undefined) === undefined, "Unsupported media type: " + type);
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setEmulatedMedia", {
        media: type || ""
      });
    }
    async emulateCPUThrottling(factor) {
      (0, assert_js_1.assert)(factor === null || factor >= 1, "Throttling rate should be greater or equal to 1");
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setCPUThrottlingRate", {
        rate: factor !== null ? factor : 1
      });
    }
    async emulateMediaFeatures(features) {
      if (!features) {
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setEmulatedMedia", {});
      }
      if (Array.isArray(features)) {
        for (const mediaFeature of features) {
          const name = mediaFeature.name;
          (0, assert_js_1.assert)(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name), "Unsupported media feature: " + name);
        }
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setEmulatedMedia", {
          features
        });
      }
    }
    async emulateTimezone(timezoneId) {
      try {
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setTimezoneOverride", {
          timezoneId: timezoneId || ""
        });
      } catch (error) {
        if ((0, ErrorLike_js_1.isErrorLike)(error) && error.message.includes("Invalid timezone")) {
          throw new Error(`Invalid timezone ID: ${timezoneId}`);
        }
        throw error;
      }
    }
    async emulateIdleState(overrides) {
      if (overrides) {
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setIdleOverride", {
          isUserActive: overrides.isUserActive,
          isScreenUnlocked: overrides.isScreenUnlocked
        });
      } else {
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.clearIdleOverride");
      }
    }
    async emulateVisionDeficiency(type) {
      const visionDeficiencies = new Set([
        "none",
        "achromatopsia",
        "blurredVision",
        "deuteranopia",
        "protanopia",
        "tritanopia"
      ]);
      try {
        (0, assert_js_1.assert)(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setEmulatedVisionDeficiency", {
          type: type || "none"
        });
      } catch (error) {
        throw error;
      }
    }
    async setViewport(viewport) {
      const needsReload = await __classPrivateFieldGet(this, _CDPPage_emulationManager, "f").emulateViewport(viewport);
      __classPrivateFieldSet(this, _CDPPage_viewport, viewport, "f");
      if (needsReload) {
        await this.reload();
      }
    }
    viewport() {
      return __classPrivateFieldGet(this, _CDPPage_viewport, "f");
    }
    async evaluate(pageFunction, ...args) {
      return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame().evaluate(pageFunction, ...args);
    }
    async evaluateOnNewDocument(pageFunction, ...args) {
      const source = (0, util_js_1.evaluationString)(pageFunction, ...args);
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.addScriptToEvaluateOnNewDocument", {
        source
      });
    }
    async setCacheEnabled(enabled = true) {
      await __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.setCacheEnabled(enabled);
    }
    async screenshot(options = {}) {
      let screenshotType = "png";
      if (options.type) {
        screenshotType = options.type;
      } else if (options.path) {
        const filePath = options.path;
        const extension = filePath.slice(filePath.lastIndexOf(".") + 1).toLowerCase();
        switch (extension) {
          case "png":
            screenshotType = "png";
            break;
          case "jpeg":
          case "jpg":
            screenshotType = "jpeg";
            break;
          case "webp":
            screenshotType = "webp";
            break;
          default:
            throw new Error(`Unsupported screenshot type for extension \`.${extension}\``);
        }
      }
      if (options.quality) {
        (0, assert_js_1.assert)(screenshotType === "jpeg" || screenshotType === "webp", "options.quality is unsupported for the " + screenshotType + " screenshots");
        (0, assert_js_1.assert)(typeof options.quality === "number", "Expected options.quality to be a number but found " + typeof options.quality);
        (0, assert_js_1.assert)(Number.isInteger(options.quality), "Expected options.quality to be an integer");
        (0, assert_js_1.assert)(options.quality >= 0 && options.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options.quality);
      }
      (0, assert_js_1.assert)(!options.clip || !options.fullPage, "options.clip and options.fullPage are exclusive");
      if (options.clip) {
        (0, assert_js_1.assert)(typeof options.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options.clip.x);
        (0, assert_js_1.assert)(typeof options.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options.clip.y);
        (0, assert_js_1.assert)(typeof options.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options.clip.width);
        (0, assert_js_1.assert)(typeof options.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options.clip.height);
        (0, assert_js_1.assert)(options.clip.width !== 0, "Expected options.clip.width not to be 0.");
        (0, assert_js_1.assert)(options.clip.height !== 0, "Expected options.clip.height not to be 0.");
      }
      return __classPrivateFieldGet(this, _CDPPage_screenshotTaskQueue, "f").postTask(() => {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_screenshotTask).call(this, screenshotType, options);
      });
    }
    async createPDFStream(options = {}) {
      const { scale = 1, displayHeaderFooter = false, headerTemplate = "", footerTemplate = "", printBackground = false, landscape = false, pageRanges = "", preferCSSPageSize = false, margin = {}, omitBackground = false, timeout = 30000 } = options;
      let paperWidth = 8.5;
      let paperHeight = 11;
      if (options.format) {
        const format = PDFOptions_js_1._paperFormats[options.format.toLowerCase()];
        (0, assert_js_1.assert)(format, "Unknown paper format: " + options.format);
        paperWidth = format.width;
        paperHeight = format.height;
      } else {
        paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
        paperHeight = convertPrintParameterToInches(options.height) || paperHeight;
      }
      const marginTop = convertPrintParameterToInches(margin.top) || 0;
      const marginLeft = convertPrintParameterToInches(margin.left) || 0;
      const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
      const marginRight = convertPrintParameterToInches(margin.right) || 0;
      if (omitBackground) {
        await __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_setTransparentBackgroundColor).call(this);
      }
      const printCommandPromise = __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.printToPDF", {
        transferMode: "ReturnAsStream",
        landscape,
        displayHeaderFooter,
        headerTemplate,
        footerTemplate,
        printBackground,
        scale,
        paperWidth,
        paperHeight,
        marginTop,
        marginBottom,
        marginLeft,
        marginRight,
        pageRanges,
        preferCSSPageSize
      });
      const result = await (0, util_js_1.waitWithTimeout)(printCommandPromise, "Page.printToPDF", timeout);
      if (omitBackground) {
        await __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_resetDefaultBackgroundColor).call(this);
      }
      (0, assert_js_1.assert)(result.stream, "`stream` is missing from `Page.printToPDF");
      return (0, util_js_1.getReadableFromProtocolStream)(__classPrivateFieldGet(this, _CDPPage_client, "f"), result.stream);
    }
    async pdf(options = {}) {
      const { path = undefined } = options;
      const readable = await this.createPDFStream(options);
      const buffer = await (0, util_js_1.getReadableAsBuffer)(readable, path);
      (0, assert_js_1.assert)(buffer, "Could not create buffer");
      return buffer;
    }
    async title() {
      return this.mainFrame().title();
    }
    async close(options = { runBeforeUnload: undefined }) {
      const connection = __classPrivateFieldGet(this, _CDPPage_client, "f").connection();
      (0, assert_js_1.assert)(connection, "Protocol error: Connection closed. Most likely the page has been closed.");
      const runBeforeUnload = !!options.runBeforeUnload;
      if (runBeforeUnload) {
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.close");
      } else {
        await connection.send("Target.closeTarget", {
          targetId: __classPrivateFieldGet(this, _CDPPage_target, "f")._targetId
        });
        await __classPrivateFieldGet(this, _CDPPage_target, "f")._isClosedPromise;
      }
    }
    isClosed() {
      return __classPrivateFieldGet(this, _CDPPage_closed, "f");
    }
    get mouse() {
      return __classPrivateFieldGet(this, _CDPPage_mouse, "f");
    }
    click(selector, options = {}) {
      return this.mainFrame().click(selector, options);
    }
    focus(selector) {
      return this.mainFrame().focus(selector);
    }
    hover(selector) {
      return this.mainFrame().hover(selector);
    }
    select(selector, ...values) {
      return this.mainFrame().select(selector, ...values);
    }
    tap(selector) {
      return this.mainFrame().tap(selector);
    }
    type(selector, text, options) {
      return this.mainFrame().type(selector, text, options);
    }
    waitForTimeout(milliseconds) {
      return this.mainFrame().waitForTimeout(milliseconds);
    }
    async waitForSelector(selector, options = {}) {
      return await this.mainFrame().waitForSelector(selector, options);
    }
    waitForXPath(xpath, options = {}) {
      return this.mainFrame().waitForXPath(xpath, options);
    }
    waitForFunction(pageFunction, options = {}, ...args) {
      return this.mainFrame().waitForFunction(pageFunction, options, ...args);
    }
  }
  exports.CDPPage = CDPPage;
  _CDPPage_closed = new WeakMap, _CDPPage_client = new WeakMap, _CDPPage_target = new WeakMap, _CDPPage_keyboard = new WeakMap, _CDPPage_mouse = new WeakMap, _CDPPage_timeoutSettings = new WeakMap, _CDPPage_touchscreen = new WeakMap, _CDPPage_accessibility = new WeakMap, _CDPPage_frameManager = new WeakMap, _CDPPage_emulationManager = new WeakMap, _CDPPage_tracing = new WeakMap, _CDPPage_pageBindings = new WeakMap, _CDPPage_coverage = new WeakMap, _CDPPage_javascriptEnabled = new WeakMap, _CDPPage_viewport = new WeakMap, _CDPPage_screenshotTaskQueue = new WeakMap, _CDPPage_workers = new WeakMap, _CDPPage_fileChooserPromises = new WeakMap, _CDPPage_disconnectPromise = new WeakMap, _CDPPage_userDragInterceptionEnabled = new WeakMap, _CDPPage_onDetachedFromTarget = new WeakMap, _CDPPage_onAttachedToTarget = new WeakMap, _CDPPage_instances = new WeakSet, _CDPPage_initialize = async function _CDPPage_initialize() {
    try {
      await Promise.all([
        __classPrivateFieldGet(this, _CDPPage_frameManager, "f").initialize(),
        __classPrivateFieldGet(this, _CDPPage_client, "f").send("Performance.enable"),
        __classPrivateFieldGet(this, _CDPPage_client, "f").send("Log.enable")
      ]);
    } catch (err) {
      if ((0, ErrorLike_js_1.isErrorLike)(err) && (0, Connection_js_1.isTargetClosedError)(err)) {
        (0, util_js_1.debugError)(err);
      } else {
        throw err;
      }
    }
  }, _CDPPage_onFileChooser = async function _CDPPage_onFileChooser(event) {
    if (!__classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f").size) {
      return;
    }
    const frame = __classPrivateFieldGet(this, _CDPPage_frameManager, "f").frame(event.frameId);
    (0, assert_js_1.assert)(frame, "This should never happen.");
    const handle = await frame.worlds[IsolatedWorld_js_1.MAIN_WORLD].adoptBackendNode(event.backendNodeId);
    const fileChooser = new FileChooser_js_1.FileChooser(handle, event);
    for (const promise of __classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f")) {
      promise.resolve(fileChooser);
    }
    __classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f").clear();
  }, _CDPPage_onTargetCrashed = function _CDPPage_onTargetCrashed() {
    this.emit("error", new Error("Page crashed!"));
  }, _CDPPage_onLogEntryAdded = function _CDPPage_onLogEntryAdded(event) {
    const { level, text, args, source, url, lineNumber } = event.entry;
    if (args) {
      args.map((arg) => {
        return (0, util_js_1.releaseObject)(__classPrivateFieldGet(this, _CDPPage_client, "f"), arg);
      });
    }
    if (source !== "worker") {
      this.emit("console", new ConsoleMessage_js_1.ConsoleMessage(level, text, [], [{ url, lineNumber }]));
    }
  }, _CDPPage_emitMetrics = function _CDPPage_emitMetrics(event) {
    this.emit("metrics", {
      title: event.title,
      metrics: __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_buildMetricsObject).call(this, event.metrics)
    });
  }, _CDPPage_buildMetricsObject = function _CDPPage_buildMetricsObject(metrics) {
    const result = {};
    for (const metric of metrics || []) {
      if (supportedMetrics.has(metric.name)) {
        result[metric.name] = metric.value;
      }
    }
    return result;
  }, _CDPPage_handleException = function _CDPPage_handleException(exceptionDetails) {
    const message = (0, util_js_1.getExceptionMessage)(exceptionDetails);
    const err = new Error(message);
    err.stack = "";
    this.emit("pageerror", err);
  }, _CDPPage_onConsoleAPI = async function _CDPPage_onConsoleAPI(event) {
    if (event.executionContextId === 0) {
      return;
    }
    const context = __classPrivateFieldGet(this, _CDPPage_frameManager, "f").executionContextById(event.executionContextId, __classPrivateFieldGet(this, _CDPPage_client, "f"));
    const values = event.args.map((arg) => {
      return (0, util_js_1.createJSHandle)(context, arg);
    });
    __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_addConsoleMessage).call(this, event.type, values, event.stackTrace);
  }, _CDPPage_onBindingCalled = async function _CDPPage_onBindingCalled(event) {
    let payload;
    try {
      payload = JSON.parse(event.payload);
    } catch {
      return;
    }
    const { type, name, seq, args } = payload;
    if (type !== "exposedFun" || !__classPrivateFieldGet(this, _CDPPage_pageBindings, "f").has(name)) {
      return;
    }
    let expression = null;
    try {
      const pageBinding = __classPrivateFieldGet(this, _CDPPage_pageBindings, "f").get(name);
      (0, assert_js_1.assert)(pageBinding);
      const result = await pageBinding(...args);
      expression = (0, util_js_1.pageBindingDeliverResultString)(name, seq, result);
    } catch (error) {
      if ((0, ErrorLike_js_1.isErrorLike)(error)) {
        expression = (0, util_js_1.pageBindingDeliverErrorString)(name, seq, error.message, error.stack);
      } else {
        expression = (0, util_js_1.pageBindingDeliverErrorValueString)(name, seq, error);
      }
    }
    __classPrivateFieldGet(this, _CDPPage_client, "f").send("Runtime.evaluate", {
      expression,
      contextId: event.executionContextId
    }).catch(util_js_1.debugError);
  }, _CDPPage_addConsoleMessage = function _CDPPage_addConsoleMessage(eventType, args, stackTrace) {
    if (!this.listenerCount("console")) {
      args.forEach((arg) => {
        return arg.dispose();
      });
      return;
    }
    const textTokens = [];
    for (const arg of args) {
      const remoteObject = arg.remoteObject();
      if (remoteObject.objectId) {
        textTokens.push(arg.toString());
      } else {
        textTokens.push((0, util_js_1.valueFromRemoteObject)(remoteObject));
      }
    }
    const stackTraceLocations = [];
    if (stackTrace) {
      for (const callFrame of stackTrace.callFrames) {
        stackTraceLocations.push({
          url: callFrame.url,
          lineNumber: callFrame.lineNumber,
          columnNumber: callFrame.columnNumber
        });
      }
    }
    const message = new ConsoleMessage_js_1.ConsoleMessage(eventType, textTokens.join(" "), args, stackTraceLocations);
    this.emit("console", message);
  }, _CDPPage_onDialog = function _CDPPage_onDialog(event) {
    let dialogType = null;
    const validDialogTypes = new Set([
      "alert",
      "confirm",
      "prompt",
      "beforeunload"
    ]);
    if (validDialogTypes.has(event.type)) {
      dialogType = event.type;
    }
    (0, assert_js_1.assert)(dialogType, "Unknown javascript dialog type: " + event.type);
    const dialog = new Dialog_js_1.Dialog(__classPrivateFieldGet(this, _CDPPage_client, "f"), dialogType, event.message, event.defaultPrompt);
    this.emit("dialog", dialog);
  }, _CDPPage_resetDefaultBackgroundColor = async function _CDPPage_resetDefaultBackgroundColor() {
    await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setDefaultBackgroundColorOverride");
  }, _CDPPage_setTransparentBackgroundColor = async function _CDPPage_setTransparentBackgroundColor() {
    await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setDefaultBackgroundColorOverride", {
      color: { r: 0, g: 0, b: 0, a: 0 }
    });
  }, _CDPPage_sessionClosePromise = function _CDPPage_sessionClosePromise() {
    if (!__classPrivateFieldGet(this, _CDPPage_disconnectPromise, "f")) {
      __classPrivateFieldSet(this, _CDPPage_disconnectPromise, new Promise((fulfill) => {
        return __classPrivateFieldGet(this, _CDPPage_client, "f").once(Connection_js_1.CDPSessionEmittedEvents.Disconnected, () => {
          return fulfill(new Error("Target closed"));
        });
      }), "f");
    }
    return __classPrivateFieldGet(this, _CDPPage_disconnectPromise, "f");
  }, _CDPPage_go = async function _CDPPage_go(delta, options) {
    const history = await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.getNavigationHistory");
    const entry = history.entries[history.currentIndex + delta];
    if (!entry) {
      return null;
    }
    const result = await Promise.all([
      this.waitForNavigation(options),
      __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.navigateToHistoryEntry", { entryId: entry.id })
    ]);
    return result[0];
  }, _CDPPage_screenshotTask = async function _CDPPage_screenshotTask(format, options = {}) {
    await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Target.activateTarget", {
      targetId: __classPrivateFieldGet(this, _CDPPage_target, "f")._targetId
    });
    let clip = options.clip ? processClip(options.clip) : undefined;
    const captureBeyondViewport = typeof options.captureBeyondViewport === "boolean" ? options.captureBeyondViewport : true;
    const fromSurface = typeof options.fromSurface === "boolean" ? options.fromSurface : undefined;
    if (options.fullPage) {
      const metrics = await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.getLayoutMetrics");
      const { width: width2, height: height2 } = metrics.cssContentSize || metrics.contentSize;
      clip = { x: 0, y: 0, width: width2, height: height2, scale: 1 };
      if (!captureBeyondViewport) {
        const { isMobile = false, deviceScaleFactor = 1, isLandscape = false } = __classPrivateFieldGet(this, _CDPPage_viewport, "f") || {};
        const screenOrientation = isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setDeviceMetricsOverride", {
          mobile: isMobile,
          width: width2,
          height: height2,
          deviceScaleFactor,
          screenOrientation
        });
      }
    }
    const shouldSetDefaultBackground = options.omitBackground && (format === "png" || format === "webp");
    if (shouldSetDefaultBackground) {
      await __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_setTransparentBackgroundColor).call(this);
    }
    const result = await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.captureScreenshot", {
      format,
      quality: options.quality,
      clip: clip ? {
        ...clip,
        scale: clip.scale === undefined ? 1 : clip.scale
      } : undefined,
      captureBeyondViewport,
      fromSurface
    });
    if (shouldSetDefaultBackground) {
      await __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_resetDefaultBackgroundColor).call(this);
    }
    if (options.fullPage && __classPrivateFieldGet(this, _CDPPage_viewport, "f")) {
      await this.setViewport(__classPrivateFieldGet(this, _CDPPage_viewport, "f"));
    }
    const buffer = options.encoding === "base64" ? result.data : Buffer.from(result.data, "base64");
    if (options.path) {
      try {
        const fs = (await (0, util_js_1.importFS)()).promises;
        await fs.writeFile(options.path, buffer);
      } catch (error) {
        if (error instanceof TypeError) {
          throw new Error("Screenshots can only be written to a file path in a Node-like environment.");
        }
        throw error;
      }
    }
    return buffer;
    function processClip(clip2) {
      const x = Math.round(clip2.x);
      const y = Math.round(clip2.y);
      const width2 = Math.round(clip2.width + clip2.x - x);
      const height2 = Math.round(clip2.height + clip2.y - y);
      return { x, y, width: width2, height: height2, scale: clip2.scale };
    }
  };
  var supportedMetrics = new Set([
    "Timestamp",
    "Documents",
    "Frames",
    "JSEventListeners",
    "Nodes",
    "LayoutCount",
    "RecalcStyleCount",
    "LayoutDuration",
    "RecalcStyleDuration",
    "ScriptDuration",
    "TaskDuration",
    "JSHeapUsedSize",
    "JSHeapTotalSize"
  ]);
  var unitToPixels = {
    px: 1,
    in: 96,
    cm: 37.8,
    mm: 3.78
  };
  function convertPrintParameterToInches(parameter) {
    if (typeof parameter === "undefined") {
      return;
    }
    let pixels;
    if ((0, util_js_1.isNumber)(parameter)) {
      pixels = parameter;
    } else if ((0, util_js_1.isString)(parameter)) {
      const text = parameter;
      let unit = text.substring(text.length - 2).toLowerCase();
      let valueText = "";
      if (unit in unitToPixels) {
        valueText = text.substring(0, text.length - 2);
      } else {
        unit = "px";
        valueText = text;
      }
      const value = Number(valueText);
      (0, assert_js_1.assert)(!isNaN(value), "Failed to parse parameter value: " + text);
      pixels = value * unitToPixels[unit];
    } else {
      throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
    }
    return pixels / 96;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Target.js
var require_Target = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Target_browserContext;
  var _Target_session;
  var _Target_targetInfo;
  var _Target_sessionFactory;
  var _Target_ignoreHTTPSErrors;
  var _Target_defaultViewport;
  var _Target_pagePromise;
  var _Target_workerPromise;
  var _Target_screenshotTaskQueue;
  var _Target_targetManager;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Target = undefined;
  var WebWorker_js_1 = require_WebWorker();
  var Page_js_1 = require_Page2();

  class Target {
    constructor(targetInfo, session, browserContext, targetManager, sessionFactory, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue, isPageTargetCallback) {
      _Target_browserContext.set(this, undefined);
      _Target_session.set(this, undefined);
      _Target_targetInfo.set(this, undefined);
      _Target_sessionFactory.set(this, undefined);
      _Target_ignoreHTTPSErrors.set(this, undefined);
      _Target_defaultViewport.set(this, undefined);
      _Target_pagePromise.set(this, undefined);
      _Target_workerPromise.set(this, undefined);
      _Target_screenshotTaskQueue.set(this, undefined);
      _Target_targetManager.set(this, undefined);
      __classPrivateFieldSet(this, _Target_session, session, "f");
      __classPrivateFieldSet(this, _Target_targetManager, targetManager, "f");
      __classPrivateFieldSet(this, _Target_targetInfo, targetInfo, "f");
      __classPrivateFieldSet(this, _Target_browserContext, browserContext, "f");
      this._targetId = targetInfo.targetId;
      __classPrivateFieldSet(this, _Target_sessionFactory, sessionFactory, "f");
      __classPrivateFieldSet(this, _Target_ignoreHTTPSErrors, ignoreHTTPSErrors, "f");
      __classPrivateFieldSet(this, _Target_defaultViewport, defaultViewport !== null && defaultViewport !== undefined ? defaultViewport : undefined, "f");
      __classPrivateFieldSet(this, _Target_screenshotTaskQueue, screenshotTaskQueue, "f");
      this._isPageTargetCallback = isPageTargetCallback;
      this._initializedPromise = new Promise((fulfill) => {
        return this._initializedCallback = fulfill;
      }).then(async (success) => {
        if (!success) {
          return false;
        }
        const opener = this.opener();
        if (!opener || !__classPrivateFieldGet(opener, _Target_pagePromise, "f") || this.type() !== "page") {
          return true;
        }
        const openerPage = await __classPrivateFieldGet(opener, _Target_pagePromise, "f");
        if (!openerPage.listenerCount("popup")) {
          return true;
        }
        const popupPage = await this.page();
        openerPage.emit("popup", popupPage);
        return true;
      });
      this._isClosedPromise = new Promise((fulfill) => {
        return this._closedCallback = fulfill;
      });
      this._isInitialized = !this._isPageTargetCallback(__classPrivateFieldGet(this, _Target_targetInfo, "f")) || __classPrivateFieldGet(this, _Target_targetInfo, "f").url !== "";
      if (this._isInitialized) {
        this._initializedCallback(true);
      }
    }
    _session() {
      return __classPrivateFieldGet(this, _Target_session, "f");
    }
    createCDPSession() {
      return __classPrivateFieldGet(this, _Target_sessionFactory, "f").call(this, false);
    }
    _targetManager() {
      return __classPrivateFieldGet(this, _Target_targetManager, "f");
    }
    _getTargetInfo() {
      return __classPrivateFieldGet(this, _Target_targetInfo, "f");
    }
    async page() {
      var _a;
      if (this._isPageTargetCallback(__classPrivateFieldGet(this, _Target_targetInfo, "f")) && !__classPrivateFieldGet(this, _Target_pagePromise, "f")) {
        __classPrivateFieldSet(this, _Target_pagePromise, (__classPrivateFieldGet(this, _Target_session, "f") ? Promise.resolve(__classPrivateFieldGet(this, _Target_session, "f")) : __classPrivateFieldGet(this, _Target_sessionFactory, "f").call(this, true)).then((client) => {
          var _a2;
          return Page_js_1.CDPPage._create(client, this, __classPrivateFieldGet(this, _Target_ignoreHTTPSErrors, "f"), (_a2 = __classPrivateFieldGet(this, _Target_defaultViewport, "f")) !== null && _a2 !== undefined ? _a2 : null, __classPrivateFieldGet(this, _Target_screenshotTaskQueue, "f"));
        }), "f");
      }
      return (_a = await __classPrivateFieldGet(this, _Target_pagePromise, "f")) !== null && _a !== undefined ? _a : null;
    }
    async worker() {
      if (__classPrivateFieldGet(this, _Target_targetInfo, "f").type !== "service_worker" && __classPrivateFieldGet(this, _Target_targetInfo, "f").type !== "shared_worker") {
        return null;
      }
      if (!__classPrivateFieldGet(this, _Target_workerPromise, "f")) {
        __classPrivateFieldSet(this, _Target_workerPromise, (__classPrivateFieldGet(this, _Target_session, "f") ? Promise.resolve(__classPrivateFieldGet(this, _Target_session, "f")) : __classPrivateFieldGet(this, _Target_sessionFactory, "f").call(this, false)).then((client) => {
          return new WebWorker_js_1.WebWorker(client, __classPrivateFieldGet(this, _Target_targetInfo, "f").url, () => {}, () => {});
        }), "f");
      }
      return __classPrivateFieldGet(this, _Target_workerPromise, "f");
    }
    url() {
      return __classPrivateFieldGet(this, _Target_targetInfo, "f").url;
    }
    type() {
      const type = __classPrivateFieldGet(this, _Target_targetInfo, "f").type;
      if (type === "page" || type === "background_page" || type === "service_worker" || type === "shared_worker" || type === "browser" || type === "webview") {
        return type;
      }
      return "other";
    }
    browser() {
      return __classPrivateFieldGet(this, _Target_browserContext, "f").browser();
    }
    browserContext() {
      return __classPrivateFieldGet(this, _Target_browserContext, "f");
    }
    opener() {
      const { openerId } = __classPrivateFieldGet(this, _Target_targetInfo, "f");
      if (!openerId) {
        return;
      }
      return this.browser()._targets.get(openerId);
    }
    _targetInfoChanged(targetInfo) {
      __classPrivateFieldSet(this, _Target_targetInfo, targetInfo, "f");
      if (!this._isInitialized && (!this._isPageTargetCallback(__classPrivateFieldGet(this, _Target_targetInfo, "f")) || __classPrivateFieldGet(this, _Target_targetInfo, "f").url !== "")) {
        this._isInitialized = true;
        this._initializedCallback(true);
        return;
      }
    }
  }
  exports.Target = Target;
  _Target_browserContext = new WeakMap, _Target_session = new WeakMap, _Target_targetInfo = new WeakMap, _Target_sessionFactory = new WeakMap, _Target_ignoreHTTPSErrors = new WeakMap, _Target_defaultViewport = new WeakMap, _Target_pagePromise = new WeakMap, _Target_workerPromise = new WeakMap, _Target_screenshotTaskQueue = new WeakMap, _Target_targetManager = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/TaskQueue.js
var require_TaskQueue = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _TaskQueue_chain;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TaskQueue = undefined;

  class TaskQueue {
    constructor() {
      _TaskQueue_chain.set(this, undefined);
      __classPrivateFieldSet(this, _TaskQueue_chain, Promise.resolve(), "f");
    }
    postTask(task) {
      const result = __classPrivateFieldGet(this, _TaskQueue_chain, "f").then(task);
      __classPrivateFieldSet(this, _TaskQueue_chain, result.then(() => {
        return;
      }, () => {
        return;
      }), "f");
      return result;
    }
  }
  exports.TaskQueue = TaskQueue;
  _TaskQueue_chain = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/ChromeTargetManager.js
var require_ChromeTargetManager = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ChromeTargetManager_instances;
  var _ChromeTargetManager_connection;
  var _ChromeTargetManager_discoveredTargetsByTargetId;
  var _ChromeTargetManager_attachedTargetsByTargetId;
  var _ChromeTargetManager_attachedTargetsBySessionId;
  var _ChromeTargetManager_ignoredTargets;
  var _ChromeTargetManager_targetFilterCallback;
  var _ChromeTargetManager_targetFactory;
  var _ChromeTargetManager_targetInterceptors;
  var _ChromeTargetManager_attachedToTargetListenersBySession;
  var _ChromeTargetManager_detachedFromTargetListenersBySession;
  var _ChromeTargetManager_initializeCallback;
  var _ChromeTargetManager_initializePromise;
  var _ChromeTargetManager_targetsIdsForInit;
  var _ChromeTargetManager_storeExistingTargetsForInit;
  var _ChromeTargetManager_setupAttachmentListeners;
  var _ChromeTargetManager_removeAttachmentListeners;
  var _ChromeTargetManager_onSessionDetached;
  var _ChromeTargetManager_onTargetCreated;
  var _ChromeTargetManager_onTargetDestroyed;
  var _ChromeTargetManager_onTargetInfoChanged;
  var _ChromeTargetManager_onAttachedToTarget;
  var _ChromeTargetManager_finishInitializationIfReady;
  var _ChromeTargetManager_onDetachedFromTarget;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChromeTargetManager = undefined;
  var assert_js_1 = require_assert();
  var Connection_js_1 = require_Connection();
  var EventEmitter_js_1 = require_EventEmitter();
  var util_js_1 = require_util();

  class ChromeTargetManager extends EventEmitter_js_1.EventEmitter {
    constructor(connection, targetFactory, targetFilterCallback) {
      super();
      _ChromeTargetManager_instances.add(this);
      _ChromeTargetManager_connection.set(this, undefined);
      _ChromeTargetManager_discoveredTargetsByTargetId.set(this, new Map);
      _ChromeTargetManager_attachedTargetsByTargetId.set(this, new Map);
      _ChromeTargetManager_attachedTargetsBySessionId.set(this, new Map);
      _ChromeTargetManager_ignoredTargets.set(this, new Set);
      _ChromeTargetManager_targetFilterCallback.set(this, undefined);
      _ChromeTargetManager_targetFactory.set(this, undefined);
      _ChromeTargetManager_targetInterceptors.set(this, new WeakMap);
      _ChromeTargetManager_attachedToTargetListenersBySession.set(this, new WeakMap);
      _ChromeTargetManager_detachedFromTargetListenersBySession.set(this, new WeakMap);
      _ChromeTargetManager_initializeCallback.set(this, () => {});
      _ChromeTargetManager_initializePromise.set(this, new Promise((resolve) => {
        __classPrivateFieldSet(this, _ChromeTargetManager_initializeCallback, resolve, "f");
      }));
      _ChromeTargetManager_targetsIdsForInit.set(this, new Set);
      _ChromeTargetManager_storeExistingTargetsForInit.set(this, () => {
        for (const [targetId, targetInfo] of __classPrivateFieldGet(this, _ChromeTargetManager_discoveredTargetsByTargetId, "f").entries()) {
          if ((!__classPrivateFieldGet(this, _ChromeTargetManager_targetFilterCallback, "f") || __classPrivateFieldGet(this, _ChromeTargetManager_targetFilterCallback, "f").call(this, targetInfo)) && targetInfo.type !== "browser") {
            __classPrivateFieldGet(this, _ChromeTargetManager_targetsIdsForInit, "f").add(targetId);
          }
        }
      });
      _ChromeTargetManager_onSessionDetached.set(this, (session) => {
        __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_removeAttachmentListeners).call(this, session);
        __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").delete(session);
      });
      _ChromeTargetManager_onTargetCreated.set(this, async (event) => {
        __classPrivateFieldGet(this, _ChromeTargetManager_discoveredTargetsByTargetId, "f").set(event.targetInfo.targetId, event.targetInfo);
        this.emit("targetDiscovered", event.targetInfo);
        if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
          if (__classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").has(event.targetInfo.targetId)) {
            return;
          }
          const target = __classPrivateFieldGet(this, _ChromeTargetManager_targetFactory, "f").call(this, event.targetInfo, undefined);
          __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").set(event.targetInfo.targetId, target);
        }
        if (event.targetInfo.type === "shared_worker") {
          await __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f")._createSession(event.targetInfo, true);
        }
      });
      _ChromeTargetManager_onTargetDestroyed.set(this, (event) => {
        const targetInfo = __classPrivateFieldGet(this, _ChromeTargetManager_discoveredTargetsByTargetId, "f").get(event.targetId);
        __classPrivateFieldGet(this, _ChromeTargetManager_discoveredTargetsByTargetId, "f").delete(event.targetId);
        __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_finishInitializationIfReady).call(this, event.targetId);
        if ((targetInfo === null || targetInfo === undefined ? undefined : targetInfo.type) === "service_worker" && __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").has(event.targetId)) {
          const target = __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").get(event.targetId);
          this.emit("targetGone", target);
          __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").delete(event.targetId);
        }
      });
      _ChromeTargetManager_onTargetInfoChanged.set(this, (event) => {
        __classPrivateFieldGet(this, _ChromeTargetManager_discoveredTargetsByTargetId, "f").set(event.targetInfo.targetId, event.targetInfo);
        if (__classPrivateFieldGet(this, _ChromeTargetManager_ignoredTargets, "f").has(event.targetInfo.targetId) || !__classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").has(event.targetInfo.targetId) || !event.targetInfo.attached) {
          return;
        }
        const target = __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").get(event.targetInfo.targetId);
        this.emit("targetChanged", {
          target,
          targetInfo: event.targetInfo
        });
      });
      _ChromeTargetManager_onAttachedToTarget.set(this, async (parentSession, event) => {
        const targetInfo = event.targetInfo;
        const session = __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").session(event.sessionId);
        if (!session) {
          throw new Error(`Session ${event.sessionId} was not created.`);
        }
        const silentDetach = async () => {
          await session.send("Runtime.runIfWaitingForDebugger").catch(util_js_1.debugError);
          await parentSession.send("Target.detachFromTarget", {
            sessionId: session.id()
          }).catch(util_js_1.debugError);
        };
        if (!__classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").isAutoAttached(targetInfo.targetId)) {
          return;
        }
        if (targetInfo.type === "service_worker" && __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").isAutoAttached(targetInfo.targetId)) {
          __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_finishInitializationIfReady).call(this, targetInfo.targetId);
          await silentDetach();
          if (__classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").has(targetInfo.targetId)) {
            return;
          }
          const target2 = __classPrivateFieldGet(this, _ChromeTargetManager_targetFactory, "f").call(this, targetInfo);
          __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").set(targetInfo.targetId, target2);
          this.emit("targetAvailable", target2);
          return;
        }
        if (__classPrivateFieldGet(this, _ChromeTargetManager_targetFilterCallback, "f") && !__classPrivateFieldGet(this, _ChromeTargetManager_targetFilterCallback, "f").call(this, targetInfo)) {
          __classPrivateFieldGet(this, _ChromeTargetManager_ignoredTargets, "f").add(targetInfo.targetId);
          __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_finishInitializationIfReady).call(this, targetInfo.targetId);
          await silentDetach();
          return;
        }
        const existingTarget = __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").has(targetInfo.targetId);
        const target = existingTarget ? __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").get(targetInfo.targetId) : __classPrivateFieldGet(this, _ChromeTargetManager_targetFactory, "f").call(this, targetInfo, session);
        __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_setupAttachmentListeners).call(this, session);
        if (existingTarget) {
          __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").set(session.id(), __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").get(targetInfo.targetId));
        } else {
          __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").set(targetInfo.targetId, target);
          __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").set(session.id(), target);
        }
        for (const interceptor of __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").get(parentSession) || []) {
          if (!(parentSession instanceof Connection_js_1.Connection)) {
            (0, assert_js_1.assert)(__classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").has(parentSession.id()));
          }
          await interceptor(target, parentSession instanceof Connection_js_1.Connection ? null : __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").get(parentSession.id()));
        }
        __classPrivateFieldGet(this, _ChromeTargetManager_targetsIdsForInit, "f").delete(target._targetId);
        if (!existingTarget) {
          this.emit("targetAvailable", target);
        }
        __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_finishInitializationIfReady).call(this);
        await Promise.all([
          session.send("Target.setAutoAttach", {
            waitForDebuggerOnStart: true,
            flatten: true,
            autoAttach: true
          }),
          session.send("Runtime.runIfWaitingForDebugger")
        ]).catch(util_js_1.debugError);
      });
      _ChromeTargetManager_onDetachedFromTarget.set(this, (_parentSession, event) => {
        const target = __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").get(event.sessionId);
        __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").delete(event.sessionId);
        if (!target) {
          return;
        }
        __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").delete(target._targetId);
        this.emit("targetGone", target);
      });
      __classPrivateFieldSet(this, _ChromeTargetManager_connection, connection, "f");
      __classPrivateFieldSet(this, _ChromeTargetManager_targetFilterCallback, targetFilterCallback, "f");
      __classPrivateFieldSet(this, _ChromeTargetManager_targetFactory, targetFactory, "f");
      __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").on("Target.targetCreated", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetCreated, "f"));
      __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").on("Target.targetDestroyed", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetDestroyed, "f"));
      __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").on("Target.targetInfoChanged", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetInfoChanged, "f"));
      __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").on("sessiondetached", __classPrivateFieldGet(this, _ChromeTargetManager_onSessionDetached, "f"));
      __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_setupAttachmentListeners).call(this, __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f"));
      __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").send("Target.setDiscoverTargets", {
        discover: true,
        filter: [{ type: "tab", exclude: true }, {}]
      }).then(__classPrivateFieldGet(this, _ChromeTargetManager_storeExistingTargetsForInit, "f")).catch(util_js_1.debugError);
    }
    async initialize() {
      await __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").send("Target.setAutoAttach", {
        waitForDebuggerOnStart: true,
        flatten: true,
        autoAttach: true
      });
      __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_finishInitializationIfReady).call(this);
      await __classPrivateFieldGet(this, _ChromeTargetManager_initializePromise, "f");
    }
    dispose() {
      __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").off("Target.targetCreated", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetCreated, "f"));
      __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").off("Target.targetDestroyed", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetDestroyed, "f"));
      __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").off("Target.targetInfoChanged", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetInfoChanged, "f"));
      __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").off("sessiondetached", __classPrivateFieldGet(this, _ChromeTargetManager_onSessionDetached, "f"));
      __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_removeAttachmentListeners).call(this, __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f"));
    }
    getAvailableTargets() {
      return __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f");
    }
    addTargetInterceptor(session, interceptor) {
      const interceptors = __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").get(session) || [];
      interceptors.push(interceptor);
      __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").set(session, interceptors);
    }
    removeTargetInterceptor(client, interceptor) {
      const interceptors = __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").get(client) || [];
      __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").set(client, interceptors.filter((currentInterceptor) => {
        return currentInterceptor !== interceptor;
      }));
    }
  }
  exports.ChromeTargetManager = ChromeTargetManager;
  _ChromeTargetManager_connection = new WeakMap, _ChromeTargetManager_discoveredTargetsByTargetId = new WeakMap, _ChromeTargetManager_attachedTargetsByTargetId = new WeakMap, _ChromeTargetManager_attachedTargetsBySessionId = new WeakMap, _ChromeTargetManager_ignoredTargets = new WeakMap, _ChromeTargetManager_targetFilterCallback = new WeakMap, _ChromeTargetManager_targetFactory = new WeakMap, _ChromeTargetManager_targetInterceptors = new WeakMap, _ChromeTargetManager_attachedToTargetListenersBySession = new WeakMap, _ChromeTargetManager_detachedFromTargetListenersBySession = new WeakMap, _ChromeTargetManager_initializeCallback = new WeakMap, _ChromeTargetManager_initializePromise = new WeakMap, _ChromeTargetManager_targetsIdsForInit = new WeakMap, _ChromeTargetManager_storeExistingTargetsForInit = new WeakMap, _ChromeTargetManager_onSessionDetached = new WeakMap, _ChromeTargetManager_onTargetCreated = new WeakMap, _ChromeTargetManager_onTargetDestroyed = new WeakMap, _ChromeTargetManager_onTargetInfoChanged = new WeakMap, _ChromeTargetManager_onAttachedToTarget = new WeakMap, _ChromeTargetManager_onDetachedFromTarget = new WeakMap, _ChromeTargetManager_instances = new WeakSet, _ChromeTargetManager_setupAttachmentListeners = function _ChromeTargetManager_setupAttachmentListeners(session) {
    const listener = (event) => {
      return __classPrivateFieldGet(this, _ChromeTargetManager_onAttachedToTarget, "f").call(this, session, event);
    };
    (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _ChromeTargetManager_attachedToTargetListenersBySession, "f").has(session));
    __classPrivateFieldGet(this, _ChromeTargetManager_attachedToTargetListenersBySession, "f").set(session, listener);
    session.on("Target.attachedToTarget", listener);
    const detachedListener = (event) => {
      return __classPrivateFieldGet(this, _ChromeTargetManager_onDetachedFromTarget, "f").call(this, session, event);
    };
    (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _ChromeTargetManager_detachedFromTargetListenersBySession, "f").has(session));
    __classPrivateFieldGet(this, _ChromeTargetManager_detachedFromTargetListenersBySession, "f").set(session, detachedListener);
    session.on("Target.detachedFromTarget", detachedListener);
  }, _ChromeTargetManager_removeAttachmentListeners = function _ChromeTargetManager_removeAttachmentListeners(session) {
    if (__classPrivateFieldGet(this, _ChromeTargetManager_attachedToTargetListenersBySession, "f").has(session)) {
      session.off("Target.attachedToTarget", __classPrivateFieldGet(this, _ChromeTargetManager_attachedToTargetListenersBySession, "f").get(session));
      __classPrivateFieldGet(this, _ChromeTargetManager_attachedToTargetListenersBySession, "f").delete(session);
    }
    if (__classPrivateFieldGet(this, _ChromeTargetManager_detachedFromTargetListenersBySession, "f").has(session)) {
      session.off("Target.detachedFromTarget", __classPrivateFieldGet(this, _ChromeTargetManager_detachedFromTargetListenersBySession, "f").get(session));
      __classPrivateFieldGet(this, _ChromeTargetManager_detachedFromTargetListenersBySession, "f").delete(session);
    }
  }, _ChromeTargetManager_finishInitializationIfReady = function _ChromeTargetManager_finishInitializationIfReady(targetId) {
    targetId !== undefined && __classPrivateFieldGet(this, _ChromeTargetManager_targetsIdsForInit, "f").delete(targetId);
    if (__classPrivateFieldGet(this, _ChromeTargetManager_targetsIdsForInit, "f").size === 0) {
      __classPrivateFieldGet(this, _ChromeTargetManager_initializeCallback, "f").call(this);
    }
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/FirefoxTargetManager.js
var require_FirefoxTargetManager = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _FirefoxTargetManager_instances;
  var _FirefoxTargetManager_connection;
  var _FirefoxTargetManager_discoveredTargetsByTargetId;
  var _FirefoxTargetManager_availableTargetsByTargetId;
  var _FirefoxTargetManager_availableTargetsBySessionId;
  var _FirefoxTargetManager_ignoredTargets;
  var _FirefoxTargetManager_targetFilterCallback;
  var _FirefoxTargetManager_targetFactory;
  var _FirefoxTargetManager_targetInterceptors;
  var _FirefoxTargetManager_attachedToTargetListenersBySession;
  var _FirefoxTargetManager_initializeCallback;
  var _FirefoxTargetManager_initializePromise;
  var _FirefoxTargetManager_targetsIdsForInit;
  var _FirefoxTargetManager_onSessionDetached;
  var _FirefoxTargetManager_onTargetCreated;
  var _FirefoxTargetManager_onTargetDestroyed;
  var _FirefoxTargetManager_onAttachedToTarget;
  var _FirefoxTargetManager_finishInitializationIfReady;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FirefoxTargetManager = undefined;
  var assert_js_1 = require_assert();
  var Connection_js_1 = require_Connection();
  var EventEmitter_js_1 = require_EventEmitter();

  class FirefoxTargetManager extends EventEmitter_js_1.EventEmitter {
    constructor(connection, targetFactory, targetFilterCallback) {
      super();
      _FirefoxTargetManager_instances.add(this);
      _FirefoxTargetManager_connection.set(this, undefined);
      _FirefoxTargetManager_discoveredTargetsByTargetId.set(this, new Map);
      _FirefoxTargetManager_availableTargetsByTargetId.set(this, new Map);
      _FirefoxTargetManager_availableTargetsBySessionId.set(this, new Map);
      _FirefoxTargetManager_ignoredTargets.set(this, new Set);
      _FirefoxTargetManager_targetFilterCallback.set(this, undefined);
      _FirefoxTargetManager_targetFactory.set(this, undefined);
      _FirefoxTargetManager_targetInterceptors.set(this, new WeakMap);
      _FirefoxTargetManager_attachedToTargetListenersBySession.set(this, new WeakMap);
      _FirefoxTargetManager_initializeCallback.set(this, () => {});
      _FirefoxTargetManager_initializePromise.set(this, new Promise((resolve) => {
        __classPrivateFieldSet(this, _FirefoxTargetManager_initializeCallback, resolve, "f");
      }));
      _FirefoxTargetManager_targetsIdsForInit.set(this, new Set);
      _FirefoxTargetManager_onSessionDetached.set(this, (session) => {
        this.removeSessionListeners(session);
        __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").delete(session);
        __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsBySessionId, "f").delete(session.id());
      });
      _FirefoxTargetManager_onTargetCreated.set(this, async (event) => {
        if (__classPrivateFieldGet(this, _FirefoxTargetManager_discoveredTargetsByTargetId, "f").has(event.targetInfo.targetId)) {
          return;
        }
        __classPrivateFieldGet(this, _FirefoxTargetManager_discoveredTargetsByTargetId, "f").set(event.targetInfo.targetId, event.targetInfo);
        if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
          const target2 = __classPrivateFieldGet(this, _FirefoxTargetManager_targetFactory, "f").call(this, event.targetInfo, undefined);
          __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").set(event.targetInfo.targetId, target2);
          __classPrivateFieldGet(this, _FirefoxTargetManager_instances, "m", _FirefoxTargetManager_finishInitializationIfReady).call(this, target2._targetId);
          return;
        }
        if (__classPrivateFieldGet(this, _FirefoxTargetManager_targetFilterCallback, "f") && !__classPrivateFieldGet(this, _FirefoxTargetManager_targetFilterCallback, "f").call(this, event.targetInfo)) {
          __classPrivateFieldGet(this, _FirefoxTargetManager_ignoredTargets, "f").add(event.targetInfo.targetId);
          __classPrivateFieldGet(this, _FirefoxTargetManager_instances, "m", _FirefoxTargetManager_finishInitializationIfReady).call(this, event.targetInfo.targetId);
          return;
        }
        const target = __classPrivateFieldGet(this, _FirefoxTargetManager_targetFactory, "f").call(this, event.targetInfo, undefined);
        __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").set(event.targetInfo.targetId, target);
        this.emit("targetAvailable", target);
        __classPrivateFieldGet(this, _FirefoxTargetManager_instances, "m", _FirefoxTargetManager_finishInitializationIfReady).call(this, target._targetId);
      });
      _FirefoxTargetManager_onTargetDestroyed.set(this, (event) => {
        __classPrivateFieldGet(this, _FirefoxTargetManager_discoveredTargetsByTargetId, "f").delete(event.targetId);
        __classPrivateFieldGet(this, _FirefoxTargetManager_instances, "m", _FirefoxTargetManager_finishInitializationIfReady).call(this, event.targetId);
        const target = __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").get(event.targetId);
        if (target) {
          this.emit("targetGone", target);
          __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").delete(event.targetId);
        }
      });
      _FirefoxTargetManager_onAttachedToTarget.set(this, async (parentSession, event) => {
        const targetInfo = event.targetInfo;
        const session = __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").session(event.sessionId);
        if (!session) {
          throw new Error(`Session ${event.sessionId} was not created.`);
        }
        const target = __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").get(targetInfo.targetId);
        (0, assert_js_1.assert)(target, `Target ${targetInfo.targetId} is missing`);
        this.setupAttachmentListeners(session);
        __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsBySessionId, "f").set(session.id(), __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").get(targetInfo.targetId));
        for (const hook of __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").get(parentSession) || []) {
          if (!(parentSession instanceof Connection_js_1.Connection)) {
            (0, assert_js_1.assert)(__classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsBySessionId, "f").has(parentSession.id()));
          }
          await hook(target, parentSession instanceof Connection_js_1.Connection ? null : __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsBySessionId, "f").get(parentSession.id()));
        }
      });
      __classPrivateFieldSet(this, _FirefoxTargetManager_connection, connection, "f");
      __classPrivateFieldSet(this, _FirefoxTargetManager_targetFilterCallback, targetFilterCallback, "f");
      __classPrivateFieldSet(this, _FirefoxTargetManager_targetFactory, targetFactory, "f");
      __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").on("Target.targetCreated", __classPrivateFieldGet(this, _FirefoxTargetManager_onTargetCreated, "f"));
      __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").on("Target.targetDestroyed", __classPrivateFieldGet(this, _FirefoxTargetManager_onTargetDestroyed, "f"));
      __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").on("sessiondetached", __classPrivateFieldGet(this, _FirefoxTargetManager_onSessionDetached, "f"));
      this.setupAttachmentListeners(__classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f"));
    }
    addTargetInterceptor(client, interceptor) {
      const interceptors = __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").get(client) || [];
      interceptors.push(interceptor);
      __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").set(client, interceptors);
    }
    removeTargetInterceptor(client, interceptor) {
      const interceptors = __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").get(client) || [];
      __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").set(client, interceptors.filter((currentInterceptor) => {
        return currentInterceptor !== interceptor;
      }));
    }
    setupAttachmentListeners(session) {
      const listener = (event) => {
        return __classPrivateFieldGet(this, _FirefoxTargetManager_onAttachedToTarget, "f").call(this, session, event);
      };
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _FirefoxTargetManager_attachedToTargetListenersBySession, "f").has(session));
      __classPrivateFieldGet(this, _FirefoxTargetManager_attachedToTargetListenersBySession, "f").set(session, listener);
      session.on("Target.attachedToTarget", listener);
    }
    removeSessionListeners(session) {
      if (__classPrivateFieldGet(this, _FirefoxTargetManager_attachedToTargetListenersBySession, "f").has(session)) {
        session.off("Target.attachedToTarget", __classPrivateFieldGet(this, _FirefoxTargetManager_attachedToTargetListenersBySession, "f").get(session));
        __classPrivateFieldGet(this, _FirefoxTargetManager_attachedToTargetListenersBySession, "f").delete(session);
      }
    }
    getAvailableTargets() {
      return __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f");
    }
    dispose() {
      __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").off("Target.targetCreated", __classPrivateFieldGet(this, _FirefoxTargetManager_onTargetCreated, "f"));
      __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").off("Target.targetDestroyed", __classPrivateFieldGet(this, _FirefoxTargetManager_onTargetDestroyed, "f"));
    }
    async initialize() {
      await __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").send("Target.setDiscoverTargets", { discover: true });
      __classPrivateFieldSet(this, _FirefoxTargetManager_targetsIdsForInit, new Set(__classPrivateFieldGet(this, _FirefoxTargetManager_discoveredTargetsByTargetId, "f").keys()), "f");
      await __classPrivateFieldGet(this, _FirefoxTargetManager_initializePromise, "f");
    }
  }
  exports.FirefoxTargetManager = FirefoxTargetManager;
  _FirefoxTargetManager_connection = new WeakMap, _FirefoxTargetManager_discoveredTargetsByTargetId = new WeakMap, _FirefoxTargetManager_availableTargetsByTargetId = new WeakMap, _FirefoxTargetManager_availableTargetsBySessionId = new WeakMap, _FirefoxTargetManager_ignoredTargets = new WeakMap, _FirefoxTargetManager_targetFilterCallback = new WeakMap, _FirefoxTargetManager_targetFactory = new WeakMap, _FirefoxTargetManager_targetInterceptors = new WeakMap, _FirefoxTargetManager_attachedToTargetListenersBySession = new WeakMap, _FirefoxTargetManager_initializeCallback = new WeakMap, _FirefoxTargetManager_initializePromise = new WeakMap, _FirefoxTargetManager_targetsIdsForInit = new WeakMap, _FirefoxTargetManager_onSessionDetached = new WeakMap, _FirefoxTargetManager_onTargetCreated = new WeakMap, _FirefoxTargetManager_onTargetDestroyed = new WeakMap, _FirefoxTargetManager_onAttachedToTarget = new WeakMap, _FirefoxTargetManager_instances = new WeakSet, _FirefoxTargetManager_finishInitializationIfReady = function _FirefoxTargetManager_finishInitializationIfReady(targetId) {
    __classPrivateFieldGet(this, _FirefoxTargetManager_targetsIdsForInit, "f").delete(targetId);
    if (__classPrivateFieldGet(this, _FirefoxTargetManager_targetsIdsForInit, "f").size === 0) {
      __classPrivateFieldGet(this, _FirefoxTargetManager_initializeCallback, "f").call(this);
    }
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/api/Browser.js
var require_Browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BrowserContext = exports.Browser = exports.WEB_PERMISSION_TO_PROTOCOL_PERMISSION = undefined;
  var EventEmitter_js_1 = require_EventEmitter();
  exports.WEB_PERMISSION_TO_PROTOCOL_PERMISSION = new Map([
    ["geolocation", "geolocation"],
    ["midi", "midi"],
    ["notifications", "notifications"],
    ["camera", "videoCapture"],
    ["microphone", "audioCapture"],
    ["background-sync", "backgroundSync"],
    ["ambient-light-sensor", "sensors"],
    ["accelerometer", "sensors"],
    ["gyroscope", "sensors"],
    ["magnetometer", "sensors"],
    ["accessibility-events", "accessibilityEvents"],
    ["clipboard-read", "clipboardReadWrite"],
    ["clipboard-write", "clipboardReadWrite"],
    ["payment-handler", "paymentHandler"],
    ["persistent-storage", "durableStorage"],
    ["idle-detection", "idleDetection"],
    ["midi-sysex", "midiSysex"]
  ]);

  class Browser extends EventEmitter_js_1.EventEmitter {
    constructor() {
      super();
    }
    _attach() {
      throw new Error("Not implemented");
    }
    _detach() {
      throw new Error("Not implemented");
    }
    get _targets() {
      throw new Error("Not implemented");
    }
    process() {
      throw new Error("Not implemented");
    }
    _getIsPageTargetCallback() {
      throw new Error("Not implemented");
    }
    createIncognitoBrowserContext() {
      throw new Error("Not implemented");
    }
    browserContexts() {
      throw new Error("Not implemented");
    }
    defaultBrowserContext() {
      throw new Error("Not implemented");
    }
    _disposeContext() {
      throw new Error("Not implemented");
    }
    wsEndpoint() {
      throw new Error("Not implemented");
    }
    newPage() {
      throw new Error("Not implemented");
    }
    _createPageInContext() {
      throw new Error("Not implemented");
    }
    targets() {
      throw new Error("Not implemented");
    }
    target() {
      throw new Error("Not implemented");
    }
    waitForTarget() {
      throw new Error("Not implemented");
    }
    pages() {
      throw new Error("Not implemented");
    }
    version() {
      throw new Error("Not implemented");
    }
    userAgent() {
      throw new Error("Not implemented");
    }
    close() {
      throw new Error("Not implemented");
    }
    disconnect() {
      throw new Error("Not implemented");
    }
    isConnected() {
      throw new Error("Not implemented");
    }
  }
  exports.Browser = Browser;

  class BrowserContext extends EventEmitter_js_1.EventEmitter {
    constructor() {
      super();
    }
    targets() {
      throw new Error("Not implemented");
    }
    waitForTarget() {
      throw new Error("Not implemented");
    }
    pages() {
      throw new Error("Not implemented");
    }
    isIncognito() {
      throw new Error("Not implemented");
    }
    overridePermissions() {
      throw new Error("Not implemented");
    }
    clearPermissionOverrides() {
      throw new Error("Not implemented");
    }
    newPage() {
      throw new Error("Not implemented");
    }
    browser() {
      throw new Error("Not implemented");
    }
    close() {
      throw new Error("Not implemented");
    }
  }
  exports.BrowserContext = BrowserContext;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Browser.js
var require_Browser2 = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _CDPBrowser_instances;
  var _CDPBrowser_ignoreHTTPSErrors;
  var _CDPBrowser_defaultViewport;
  var _CDPBrowser_process;
  var _CDPBrowser_connection;
  var _CDPBrowser_closeCallback;
  var _CDPBrowser_targetFilterCallback;
  var _CDPBrowser_isPageTargetCallback;
  var _CDPBrowser_defaultContext;
  var _CDPBrowser_contexts;
  var _CDPBrowser_screenshotTaskQueue;
  var _CDPBrowser_targetManager;
  var _CDPBrowser_emitDisconnected;
  var _CDPBrowser_setIsPageTargetCallback;
  var _CDPBrowser_createTarget;
  var _CDPBrowser_onAttachedToTarget;
  var _CDPBrowser_onDetachedFromTarget;
  var _CDPBrowser_onTargetChanged;
  var _CDPBrowser_onTargetDiscovered;
  var _CDPBrowser_getVersion;
  var _CDPBrowserContext_connection;
  var _CDPBrowserContext_browser;
  var _CDPBrowserContext_id;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CDPBrowserContext = exports.CDPBrowser = undefined;
  var assert_js_1 = require_assert();
  var Connection_js_1 = require_Connection();
  var util_js_1 = require_util();
  var Target_js_1 = require_Target();
  var TaskQueue_js_1 = require_TaskQueue();
  var ChromeTargetManager_js_1 = require_ChromeTargetManager();
  var FirefoxTargetManager_js_1 = require_FirefoxTargetManager();
  var Browser_js_1 = require_Browser();

  class CDPBrowser extends Browser_js_1.Browser {
    constructor(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback) {
      super();
      _CDPBrowser_instances.add(this);
      _CDPBrowser_ignoreHTTPSErrors.set(this, undefined);
      _CDPBrowser_defaultViewport.set(this, undefined);
      _CDPBrowser_process.set(this, undefined);
      _CDPBrowser_connection.set(this, undefined);
      _CDPBrowser_closeCallback.set(this, undefined);
      _CDPBrowser_targetFilterCallback.set(this, undefined);
      _CDPBrowser_isPageTargetCallback.set(this, undefined);
      _CDPBrowser_defaultContext.set(this, undefined);
      _CDPBrowser_contexts.set(this, undefined);
      _CDPBrowser_screenshotTaskQueue.set(this, undefined);
      _CDPBrowser_targetManager.set(this, undefined);
      _CDPBrowser_emitDisconnected.set(this, () => {
        this.emit("disconnected");
      });
      _CDPBrowser_createTarget.set(this, (targetInfo, session) => {
        var _a;
        const { browserContextId } = targetInfo;
        const context = browserContextId && __classPrivateFieldGet(this, _CDPBrowser_contexts, "f").has(browserContextId) ? __classPrivateFieldGet(this, _CDPBrowser_contexts, "f").get(browserContextId) : __classPrivateFieldGet(this, _CDPBrowser_defaultContext, "f");
        if (!context) {
          throw new Error("Missing browser context");
        }
        return new Target_js_1.Target(targetInfo, session, context, __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f"), (isAutoAttachEmulated) => {
          return __classPrivateFieldGet(this, _CDPBrowser_connection, "f")._createSession(targetInfo, isAutoAttachEmulated);
        }, __classPrivateFieldGet(this, _CDPBrowser_ignoreHTTPSErrors, "f"), (_a = __classPrivateFieldGet(this, _CDPBrowser_defaultViewport, "f")) !== null && _a !== undefined ? _a : null, __classPrivateFieldGet(this, _CDPBrowser_screenshotTaskQueue, "f"), __classPrivateFieldGet(this, _CDPBrowser_isPageTargetCallback, "f"));
      });
      _CDPBrowser_onAttachedToTarget.set(this, async (target) => {
        if (await target._initializedPromise) {
          this.emit("targetcreated", target);
          target.browserContext().emit("targetcreated", target);
        }
      });
      _CDPBrowser_onDetachedFromTarget.set(this, async (target) => {
        target._initializedCallback(false);
        target._closedCallback();
        if (await target._initializedPromise) {
          this.emit("targetdestroyed", target);
          target.browserContext().emit("targetdestroyed", target);
        }
      });
      _CDPBrowser_onTargetChanged.set(this, ({ target, targetInfo }) => {
        const previousURL = target.url();
        const wasInitialized = target._isInitialized;
        target._targetInfoChanged(targetInfo);
        if (wasInitialized && previousURL !== target.url()) {
          this.emit("targetchanged", target);
          target.browserContext().emit("targetchanged", target);
        }
      });
      _CDPBrowser_onTargetDiscovered.set(this, (targetInfo) => {
        this.emit("targetdiscovered", targetInfo);
      });
      product = product || "chrome";
      __classPrivateFieldSet(this, _CDPBrowser_ignoreHTTPSErrors, ignoreHTTPSErrors, "f");
      __classPrivateFieldSet(this, _CDPBrowser_defaultViewport, defaultViewport, "f");
      __classPrivateFieldSet(this, _CDPBrowser_process, process2, "f");
      __classPrivateFieldSet(this, _CDPBrowser_screenshotTaskQueue, new TaskQueue_js_1.TaskQueue, "f");
      __classPrivateFieldSet(this, _CDPBrowser_connection, connection, "f");
      __classPrivateFieldSet(this, _CDPBrowser_closeCallback, closeCallback || function() {}, "f");
      __classPrivateFieldSet(this, _CDPBrowser_targetFilterCallback, targetFilterCallback || (() => {
        return true;
      }), "f");
      __classPrivateFieldGet(this, _CDPBrowser_instances, "m", _CDPBrowser_setIsPageTargetCallback).call(this, isPageTargetCallback);
      if (product === "firefox") {
        __classPrivateFieldSet(this, _CDPBrowser_targetManager, new FirefoxTargetManager_js_1.FirefoxTargetManager(connection, __classPrivateFieldGet(this, _CDPBrowser_createTarget, "f"), __classPrivateFieldGet(this, _CDPBrowser_targetFilterCallback, "f")), "f");
      } else {
        __classPrivateFieldSet(this, _CDPBrowser_targetManager, new ChromeTargetManager_js_1.ChromeTargetManager(connection, __classPrivateFieldGet(this, _CDPBrowser_createTarget, "f"), __classPrivateFieldGet(this, _CDPBrowser_targetFilterCallback, "f")), "f");
      }
      __classPrivateFieldSet(this, _CDPBrowser_defaultContext, new CDPBrowserContext(__classPrivateFieldGet(this, _CDPBrowser_connection, "f"), this), "f");
      __classPrivateFieldSet(this, _CDPBrowser_contexts, new Map, "f");
      for (const contextId of contextIds) {
        __classPrivateFieldGet(this, _CDPBrowser_contexts, "f").set(contextId, new CDPBrowserContext(__classPrivateFieldGet(this, _CDPBrowser_connection, "f"), this, contextId));
      }
    }
    static async _create(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback) {
      const browser = new CDPBrowser(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback);
      await browser._attach();
      return browser;
    }
    get _targets() {
      return __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").getAvailableTargets();
    }
    async _attach() {
      __classPrivateFieldGet(this, _CDPBrowser_connection, "f").on(Connection_js_1.ConnectionEmittedEvents.Disconnected, __classPrivateFieldGet(this, _CDPBrowser_emitDisconnected, "f"));
      __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").on("targetAvailable", __classPrivateFieldGet(this, _CDPBrowser_onAttachedToTarget, "f"));
      __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").on("targetGone", __classPrivateFieldGet(this, _CDPBrowser_onDetachedFromTarget, "f"));
      __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").on("targetChanged", __classPrivateFieldGet(this, _CDPBrowser_onTargetChanged, "f"));
      __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").on("targetDiscovered", __classPrivateFieldGet(this, _CDPBrowser_onTargetDiscovered, "f"));
      await __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").initialize();
    }
    _detach() {
      __classPrivateFieldGet(this, _CDPBrowser_connection, "f").off(Connection_js_1.ConnectionEmittedEvents.Disconnected, __classPrivateFieldGet(this, _CDPBrowser_emitDisconnected, "f"));
      __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").off("targetAvailable", __classPrivateFieldGet(this, _CDPBrowser_onAttachedToTarget, "f"));
      __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").off("targetGone", __classPrivateFieldGet(this, _CDPBrowser_onDetachedFromTarget, "f"));
      __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").off("targetChanged", __classPrivateFieldGet(this, _CDPBrowser_onTargetChanged, "f"));
      __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").off("targetDiscovered", __classPrivateFieldGet(this, _CDPBrowser_onTargetDiscovered, "f"));
    }
    process() {
      var _a;
      return (_a = __classPrivateFieldGet(this, _CDPBrowser_process, "f")) !== null && _a !== undefined ? _a : null;
    }
    _targetManager() {
      return __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f");
    }
    _getIsPageTargetCallback() {
      return __classPrivateFieldGet(this, _CDPBrowser_isPageTargetCallback, "f");
    }
    async createIncognitoBrowserContext(options = {}) {
      const { proxyServer, proxyBypassList } = options;
      const { browserContextId } = await __classPrivateFieldGet(this, _CDPBrowser_connection, "f").send("Target.createBrowserContext", {
        proxyServer,
        proxyBypassList: proxyBypassList && proxyBypassList.join(",")
      });
      const context = new CDPBrowserContext(__classPrivateFieldGet(this, _CDPBrowser_connection, "f"), this, browserContextId);
      __classPrivateFieldGet(this, _CDPBrowser_contexts, "f").set(browserContextId, context);
      return context;
    }
    browserContexts() {
      return [__classPrivateFieldGet(this, _CDPBrowser_defaultContext, "f"), ...Array.from(__classPrivateFieldGet(this, _CDPBrowser_contexts, "f").values())];
    }
    defaultBrowserContext() {
      return __classPrivateFieldGet(this, _CDPBrowser_defaultContext, "f");
    }
    async _disposeContext(contextId) {
      if (!contextId) {
        return;
      }
      await __classPrivateFieldGet(this, _CDPBrowser_connection, "f").send("Target.disposeBrowserContext", {
        browserContextId: contextId
      });
      __classPrivateFieldGet(this, _CDPBrowser_contexts, "f").delete(contextId);
    }
    wsEndpoint() {
      return __classPrivateFieldGet(this, _CDPBrowser_connection, "f").url();
    }
    async newPage() {
      return __classPrivateFieldGet(this, _CDPBrowser_defaultContext, "f").newPage();
    }
    async _createPageInContext(contextId) {
      const { targetId } = await __classPrivateFieldGet(this, _CDPBrowser_connection, "f").send("Target.createTarget", {
        url: "about:blank",
        browserContextId: contextId || undefined
      });
      const target = __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").getAvailableTargets().get(targetId);
      if (!target) {
        throw new Error(`Missing target for page (id = ${targetId})`);
      }
      const initialized = await target._initializedPromise;
      if (!initialized) {
        throw new Error(`Failed to create target for page (id = ${targetId})`);
      }
      const page = await target.page();
      if (!page) {
        throw new Error(`Failed to create a page for context (id = ${contextId})`);
      }
      return page;
    }
    targets() {
      return Array.from(__classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").getAvailableTargets().values()).filter((target) => {
        return target._isInitialized;
      });
    }
    target() {
      const browserTarget = this.targets().find((target) => {
        return target.type() === "browser";
      });
      if (!browserTarget) {
        throw new Error("Browser target is not found");
      }
      return browserTarget;
    }
    async waitForTarget(predicate, options = {}) {
      const { timeout = 30000 } = options;
      let resolve;
      let isResolved = false;
      const targetPromise = new Promise((x) => {
        return resolve = x;
      });
      this.on("targetcreated", check);
      this.on("targetchanged", check);
      try {
        this.targets().forEach(check);
        if (!timeout) {
          return await targetPromise;
        }
        return await (0, util_js_1.waitWithTimeout)(targetPromise, "target", timeout);
      } finally {
        this.off("targetcreated", check);
        this.off("targetchanged", check);
      }
      async function check(target) {
        if (await predicate(target) && !isResolved) {
          isResolved = true;
          resolve(target);
        }
      }
    }
    async pages() {
      const contextPages = await Promise.all(this.browserContexts().map((context) => {
        return context.pages();
      }));
      return contextPages.reduce((acc, x) => {
        return acc.concat(x);
      }, []);
    }
    async version() {
      const version = await __classPrivateFieldGet(this, _CDPBrowser_instances, "m", _CDPBrowser_getVersion).call(this);
      return version.product;
    }
    async userAgent() {
      const version = await __classPrivateFieldGet(this, _CDPBrowser_instances, "m", _CDPBrowser_getVersion).call(this);
      return version.userAgent;
    }
    async close() {
      await __classPrivateFieldGet(this, _CDPBrowser_closeCallback, "f").call(null);
      this.disconnect();
    }
    disconnect() {
      __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").dispose();
      __classPrivateFieldGet(this, _CDPBrowser_connection, "f").dispose();
    }
    isConnected() {
      return !__classPrivateFieldGet(this, _CDPBrowser_connection, "f")._closed;
    }
  }
  exports.CDPBrowser = CDPBrowser;
  _CDPBrowser_ignoreHTTPSErrors = new WeakMap, _CDPBrowser_defaultViewport = new WeakMap, _CDPBrowser_process = new WeakMap, _CDPBrowser_connection = new WeakMap, _CDPBrowser_closeCallback = new WeakMap, _CDPBrowser_targetFilterCallback = new WeakMap, _CDPBrowser_isPageTargetCallback = new WeakMap, _CDPBrowser_defaultContext = new WeakMap, _CDPBrowser_contexts = new WeakMap, _CDPBrowser_screenshotTaskQueue = new WeakMap, _CDPBrowser_targetManager = new WeakMap, _CDPBrowser_emitDisconnected = new WeakMap, _CDPBrowser_createTarget = new WeakMap, _CDPBrowser_onAttachedToTarget = new WeakMap, _CDPBrowser_onDetachedFromTarget = new WeakMap, _CDPBrowser_onTargetChanged = new WeakMap, _CDPBrowser_onTargetDiscovered = new WeakMap, _CDPBrowser_instances = new WeakSet, _CDPBrowser_setIsPageTargetCallback = function _CDPBrowser_setIsPageTargetCallback(isPageTargetCallback) {
    __classPrivateFieldSet(this, _CDPBrowser_isPageTargetCallback, isPageTargetCallback || ((target) => {
      return target.type === "page" || target.type === "background_page" || target.type === "webview";
    }), "f");
  }, _CDPBrowser_getVersion = function _CDPBrowser_getVersion() {
    return __classPrivateFieldGet(this, _CDPBrowser_connection, "f").send("Browser.getVersion");
  };

  class CDPBrowserContext extends Browser_js_1.BrowserContext {
    constructor(connection, browser, contextId) {
      super();
      _CDPBrowserContext_connection.set(this, undefined);
      _CDPBrowserContext_browser.set(this, undefined);
      _CDPBrowserContext_id.set(this, undefined);
      __classPrivateFieldSet(this, _CDPBrowserContext_connection, connection, "f");
      __classPrivateFieldSet(this, _CDPBrowserContext_browser, browser, "f");
      __classPrivateFieldSet(this, _CDPBrowserContext_id, contextId, "f");
    }
    targets() {
      return __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f").targets().filter((target) => {
        return target.browserContext() === this;
      });
    }
    waitForTarget(predicate, options = {}) {
      return __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f").waitForTarget((target) => {
        return target.browserContext() === this && predicate(target);
      }, options);
    }
    async pages() {
      const pages = await Promise.all(this.targets().filter((target) => {
        var _a;
        return target.type() === "page" || target.type() === "other" && ((_a = __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f")._getIsPageTargetCallback()) === null || _a === undefined ? undefined : _a(target._getTargetInfo()));
      }).map((target) => {
        return target.page();
      }));
      return pages.filter((page) => {
        return !!page;
      });
    }
    isIncognito() {
      return !!__classPrivateFieldGet(this, _CDPBrowserContext_id, "f");
    }
    async overridePermissions(origin, permissions) {
      const protocolPermissions = permissions.map((permission) => {
        const protocolPermission = Browser_js_1.WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
        if (!protocolPermission) {
          throw new Error("Unknown permission: " + permission);
        }
        return protocolPermission;
      });
      await __classPrivateFieldGet(this, _CDPBrowserContext_connection, "f").send("Browser.grantPermissions", {
        origin,
        browserContextId: __classPrivateFieldGet(this, _CDPBrowserContext_id, "f") || undefined,
        permissions: protocolPermissions
      });
    }
    async clearPermissionOverrides() {
      await __classPrivateFieldGet(this, _CDPBrowserContext_connection, "f").send("Browser.resetPermissions", {
        browserContextId: __classPrivateFieldGet(this, _CDPBrowserContext_id, "f") || undefined
      });
    }
    newPage() {
      return __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f")._createPageInContext(__classPrivateFieldGet(this, _CDPBrowserContext_id, "f"));
    }
    browser() {
      return __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f");
    }
    async close() {
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _CDPBrowserContext_id, "f"), "Non-incognito profiles cannot be closed!");
      await __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f")._disposeContext(__classPrivateFieldGet(this, _CDPBrowserContext_id, "f"));
    }
  }
  exports.CDPBrowserContext = CDPBrowserContext;
  _CDPBrowserContext_connection = new WeakMap, _CDPBrowserContext_browser = new WeakMap, _CDPBrowserContext_id = new WeakMap;
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var conversions = {};
  module.exports = conversions;
  function sign(x) {
    return x < 0 ? -1 : 1;
  }
  function evenRound(x) {
    if (x % 1 === 0.5 && (x & 1) === 0) {
      return Math.floor(x);
    } else {
      return Math.round(x);
    }
  }
  function createNumberConversion(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
      --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;
    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
    return function(V, opts) {
      if (!opts)
        opts = {};
      let x = +V;
      if (opts.enforceRange) {
        if (!Number.isFinite(x)) {
          throw new TypeError("Argument is not a finite number");
        }
        x = sign(x) * Math.floor(Math.abs(x));
        if (x < lowerBound || x > upperBound) {
          throw new TypeError("Argument is not in byte range");
        }
        return x;
      }
      if (!isNaN(x) && opts.clamp) {
        x = evenRound(x);
        if (x < lowerBound)
          x = lowerBound;
        if (x > upperBound)
          x = upperBound;
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      x = sign(x) * Math.floor(Math.abs(x));
      x = x % moduloVal;
      if (!typeOpts.unsigned && x >= moduloBound) {
        return x - moduloVal;
      } else if (typeOpts.unsigned) {
        if (x < 0) {
          x += moduloVal;
        } else if (x === -0) {
          return 0;
        }
      }
      return x;
    };
  }
  conversions["void"] = function() {
    return;
  };
  conversions["boolean"] = function(val) {
    return !!val;
  };
  conversions["byte"] = createNumberConversion(8, { unsigned: false });
  conversions["octet"] = createNumberConversion(8, { unsigned: true });
  conversions["short"] = createNumberConversion(16, { unsigned: false });
  conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
  conversions["long"] = createNumberConversion(32, { unsigned: false });
  conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
  conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
  conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
  conversions["double"] = function(V) {
    const x = +V;
    if (!Number.isFinite(x)) {
      throw new TypeError("Argument is not a finite floating-point value");
    }
    return x;
  };
  conversions["unrestricted double"] = function(V) {
    const x = +V;
    if (isNaN(x)) {
      throw new TypeError("Argument is NaN");
    }
    return x;
  };
  conversions["float"] = conversions["double"];
  conversions["unrestricted float"] = conversions["unrestricted double"];
  conversions["DOMString"] = function(V, opts) {
    if (!opts)
      opts = {};
    if (opts.treatNullAsEmptyString && V === null) {
      return "";
    }
    return String(V);
  };
  conversions["ByteString"] = function(V, opts) {
    const x = String(V);
    let c = undefined;
    for (let i = 0;(c = x.codePointAt(i)) !== undefined; ++i) {
      if (c > 255) {
        throw new TypeError("Argument is not a valid bytestring");
      }
    }
    return x;
  };
  conversions["USVString"] = function(V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for (let i = 0;i < n; ++i) {
      const c = S.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        U.push(String.fromCodePoint(c));
      } else if (56320 <= c && c <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else {
        if (i === n - 1) {
          U.push(String.fromCodePoint(65533));
        } else {
          const d = S.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            const a = c & 1023;
            const b = d & 1023;
            U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
            ++i;
          } else {
            U.push(String.fromCodePoint(65533));
          }
        }
      }
    }
    return U.join("");
  };
  conversions["Date"] = function(V, opts) {
    if (!(V instanceof Date)) {
      throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
      return;
    }
    return V;
  };
  conversions["RegExp"] = function(V, opts) {
    if (!(V instanceof RegExp)) {
      V = new RegExp(V);
    }
    return V;
  };
});

// node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  exports.mixin = function mixin(target, source) {
    const keys = Object.getOwnPropertyNames(source);
    for (let i = 0;i < keys.length; ++i) {
      Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
    }
  };
  exports.wrapperSymbol = Symbol("wrapper");
  exports.implSymbol = Symbol("impl");
  exports.wrapperForImpl = function(impl) {
    return impl[exports.wrapperSymbol];
  };
  exports.implForWrapper = function(wrapper) {
    return wrapper[exports.implSymbol];
  };
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS((exports, module) => {
  module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1000, 1000], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6000], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8000, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8000]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9000], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [30000]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13000, 13000], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43000, 43000], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64000, 64000], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66000, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[120000, 120000], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128000, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23000]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149000]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32000]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195000, 195000], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [40000]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918000, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS((exports, module) => {
  var punycode = __require("punycode");
  var mappingTable = require_mappingTable();
  var PROCESSING_OPTIONS = {
    TRANSITIONAL: 0,
    NONTRANSITIONAL: 1
  };
  function normalize(str) {
    return str.split("\x00").map(function(s) {
      return s.normalize("NFC");
    }).join("\x00");
  }
  function findStatus(val) {
    var start = 0;
    var end = mappingTable.length - 1;
    while (start <= end) {
      var mid = Math.floor((start + end) / 2);
      var target = mappingTable[mid];
      if (target[0][0] <= val && target[0][1] >= val) {
        return target;
      } else if (target[0][0] > val) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  }
  var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  function countSymbols(string) {
    return string.replace(regexAstralSymbols, "_").length;
  }
  function mapChars(domain_name, useSTD3, processing_option) {
    var hasError = false;
    var processed = "";
    var len = countSymbols(domain_name);
    for (var i = 0;i < len; ++i) {
      var codePoint = domain_name.codePointAt(i);
      var status = findStatus(codePoint);
      switch (status[1]) {
        case "disallowed":
          hasError = true;
          processed += String.fromCodePoint(codePoint);
          break;
        case "ignored":
          break;
        case "mapped":
          processed += String.fromCodePoint.apply(String, status[2]);
          break;
        case "deviation":
          if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
            processed += String.fromCodePoint.apply(String, status[2]);
          } else {
            processed += String.fromCodePoint(codePoint);
          }
          break;
        case "valid":
          processed += String.fromCodePoint(codePoint);
          break;
        case "disallowed_STD3_mapped":
          if (useSTD3) {
            hasError = true;
            processed += String.fromCodePoint(codePoint);
          } else {
            processed += String.fromCodePoint.apply(String, status[2]);
          }
          break;
        case "disallowed_STD3_valid":
          if (useSTD3) {
            hasError = true;
          }
          processed += String.fromCodePoint(codePoint);
          break;
      }
    }
    return {
      string: processed,
      error: hasError
    };
  }
  var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
  function validateLabel(label, processing_option) {
    if (label.substr(0, 4) === "xn--") {
      label = punycode.toUnicode(label);
      processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
    }
    var error = false;
    if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
      error = true;
    }
    var len = countSymbols(label);
    for (var i = 0;i < len; ++i) {
      var status = findStatus(label.codePointAt(i));
      if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
        error = true;
        break;
      }
    }
    return {
      label,
      error
    };
  }
  function processing(domain_name, useSTD3, processing_option) {
    var result = mapChars(domain_name, useSTD3, processing_option);
    result.string = normalize(result.string);
    var labels = result.string.split(".");
    for (var i = 0;i < labels.length; ++i) {
      try {
        var validation = validateLabel(labels[i]);
        labels[i] = validation.label;
        result.error = result.error || validation.error;
      } catch (e) {
        result.error = true;
      }
    }
    return {
      string: labels.join("."),
      error: result.error
    };
  }
  exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
    var result = processing(domain_name, useSTD3, processing_option);
    var labels = result.string.split(".");
    labels = labels.map(function(l2) {
      try {
        return punycode.toASCII(l2);
      } catch (e) {
        result.error = true;
        return l2;
      }
    });
    if (verifyDnsLength) {
      var total = labels.slice(0, labels.length - 1).join(".").length;
      if (total.length > 253 || total.length === 0) {
        result.error = true;
      }
      for (var i = 0;i < labels.length; ++i) {
        if (labels.length > 63 || labels.length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error)
      return null;
    return labels.join(".");
  };
  exports.toUnicode = function(domain_name, useSTD3) {
    var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
    return {
      domain: result.string,
      error: result.error
    };
  };
  exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS((exports, module) => {
  var punycode = __require("punycode");
  var tr46 = require_tr46();
  var specialSchemes = {
    ftp: 21,
    file: null,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  function countSymbols(str) {
    return punycode.ucs2.decode(str).length;
  }
  function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
  }
  function isASCIIDigit(c) {
    return c >= 48 && c <= 57;
  }
  function isASCIIAlpha(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  }
  function isASCIIAlphanumeric(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
  }
  function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  }
  function isSingleDot(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  }
  function isDoubleDot(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  }
  function isWindowsDriveLetterCodePoints(cp1, cp2) {
    return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
  }
  function isWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
  }
  function isNormalizedWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
  }
  function containsForbiddenHostCodePoint(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
  }
  function containsForbiddenHostCodePointExcludingPercent(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
  }
  function isSpecialScheme(scheme) {
    return specialSchemes[scheme] !== undefined;
  }
  function isSpecial(url) {
    return isSpecialScheme(url.scheme);
  }
  function defaultPort(scheme) {
    return specialSchemes[scheme];
  }
  function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
      hex = "0" + hex;
    }
    return "%" + hex;
  }
  function utf8PercentEncode(c) {
    const buf = new Buffer(c);
    let str = "";
    for (let i = 0;i < buf.length; ++i) {
      str += percentEncode(buf[i]);
    }
    return str;
  }
  function utf8PercentDecode(str) {
    const input = new Buffer(str);
    const output = [];
    for (let i = 0;i < input.length; ++i) {
      if (input[i] !== 37) {
        output.push(input[i]);
      } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
        output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
        i += 2;
      } else {
        output.push(input[i]);
      }
    }
    return new Buffer(output).toString();
  }
  function isC0ControlPercentEncode(c) {
    return c <= 31 || c > 126;
  }
  var extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
  function isPathPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  }
  var extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
  function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  }
  function percentEncodeChar(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    if (encodeSetPredicate(c)) {
      return utf8PercentEncode(cStr);
    }
    return cStr;
  }
  function parseIPv4Number(input) {
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R = 8;
    }
    if (input === "") {
      return 0;
    }
    const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
    if (regex.test(input)) {
      return failure;
    }
    return parseInt(input, R);
  }
  function parseIPv4(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return input;
    }
    const numbers = [];
    for (const part of parts) {
      if (part === "") {
        return input;
      }
      const n = parseIPv4Number(part);
      if (n === failure) {
        return input;
      }
      numbers.push(n);
    }
    for (let i = 0;i < numbers.length - 1; ++i) {
      if (numbers[i] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers) {
      ipv4 += n * Math.pow(256, 3 - counter);
      ++counter;
    }
    return ipv4;
  }
  function serializeIPv4(address) {
    let output = "";
    let n = address;
    for (let i = 1;i <= 4; ++i) {
      output = String(n % 256) + output;
      if (i !== 4) {
        output = "." + output;
      }
      n = Math.floor(n / 256);
    }
    return output;
  }
  function parseIPv6(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = punycode.ucs2.decode(input);
    if (input[pointer] === 58) {
      if (input[pointer + 1] !== 58) {
        return failure;
      }
      pointer += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer] === 58) {
        if (compress !== null) {
          return failure;
        }
        ++pointer;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && isASCIIHex(input[pointer])) {
        value = value * 16 + parseInt(at(input, pointer), 16);
        ++pointer;
        ++length;
      }
      if (input[pointer] === 46) {
        if (length === 0) {
          return failure;
        }
        pointer -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer] !== undefined) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer] === 46 && numbersSeen < 4) {
              ++pointer;
            } else {
              return failure;
            }
          }
          if (!isASCIIDigit(input[pointer])) {
            return failure;
          }
          while (isASCIIDigit(input[pointer])) {
            const number = parseInt(at(input, pointer));
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer] === 58) {
        ++pointer;
        if (input[pointer] === undefined) {
          return failure;
        }
      } else if (input[pointer] !== undefined) {
        return failure;
      }
      address[pieceIndex] = value;
      ++pieceIndex;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  }
  function serializeIPv6(address) {
    let output = "";
    const seqResult = findLongestZeroSequence(address);
    const compress = seqResult.idx;
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  }
  function parseHost(input, isSpecialArg) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (!isSpecialArg) {
      return parseOpaqueHost(input);
    }
    const domain = utf8PercentDecode(input);
    const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
    if (asciiDomain === null) {
      return failure;
    }
    if (containsForbiddenHostCodePoint(asciiDomain)) {
      return failure;
    }
    const ipv4Host = parseIPv4(asciiDomain);
    if (typeof ipv4Host === "number" || ipv4Host === failure) {
      return ipv4Host;
    }
    return asciiDomain;
  }
  function parseOpaqueHost(input) {
    if (containsForbiddenHostCodePointExcludingPercent(input)) {
      return failure;
    }
    let output = "";
    const decoded = punycode.ucs2.decode(input);
    for (let i = 0;i < decoded.length; ++i) {
      output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
    }
    return output;
  }
  function findLongestZeroSequence(arr) {
    let maxIdx = null;
    let maxLen = 1;
    let currStart = null;
    let currLen = 0;
    for (let i = 0;i < arr.length; ++i) {
      if (arr[i] !== 0) {
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        currStart = null;
        currLen = 0;
      } else {
        if (currStart === null) {
          currStart = i;
        }
        ++currLen;
      }
    }
    if (currLen > maxLen) {
      maxIdx = currStart;
      maxLen = currLen;
    }
    return {
      idx: maxIdx,
      len: maxLen
    };
  }
  function serializeHost(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return "[" + serializeIPv6(host) + "]";
    }
    return host;
  }
  function trimControlChars(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
  }
  function trimTabAndNewline(url) {
    return url.replace(/\u0009|\u000A|\u000D/g, "");
  }
  function shortenPath(url) {
    const path = url.path;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  }
  function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
  }
  function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
  }
  function isNormalizedWindowsDriveLetter(string) {
    return /^[A-Za-z]:$/.test(string);
  }
  function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null,
        cannotBeABaseURL: false
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = punycode.ucs2.decode(this.input);
    for (;this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer];
      const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
      const ret = this["parse " + this.state](c, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  }
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (isASCIIAlpha(c)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
      this.buffer += cStr.toLowerCase();
    } else if (c === 58) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      this.buffer = "";
      if (this.stateOverride) {
        return false;
      }
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === 47) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.cannotBeABaseURL = true;
        this.url.path.push("");
        this.state = "cannot-be-a-base-URL path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
      return failure;
    } else if (this.base.cannotBeABaseURL && c === 35) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.url.cannotBeABaseURL = true;
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === 47) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (isNaN(c)) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    } else if (c === 47) {
      this.state = "relative slash";
    } else if (c === 63) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (isSpecial(this.url) && c === 92) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice(0, this.base.path.length - 1);
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === 47 || c === 92)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c === 47) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== 47 && c !== 92) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === 64) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = "%40" + this.buffer;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer = 0;pointer < len; ++pointer) {
        const codePoint = this.buffer.codePointAt(pointer);
        if (codePoint === 58 && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c === 58 && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
      if (this.stateOverride === "hostname") {
        return false;
      }
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c === 91) {
        this.arrFlag = true;
      } else if (c === 93) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (isASCIIDigit(c)) {
      this.buffer += cStr;
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > Math.pow(2, 16) - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);
  URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      if (isNaN(c)) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 63) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          shortenPath(this.url);
        } else {
          this.parseError = true;
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === 47 || c === 92) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        } else {
          this.url.host = this.base.host;
        }
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
      if (c === 92) {
        this.parseError = true;
      }
      this.state = "path";
      if (c !== 47 && c !== 92) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c !== undefined) {
      this.state = "path";
      if (c !== 47) {
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
      if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          if (this.url.host !== "" && this.url.host !== null) {
            this.parseError = true;
            this.url.host = "";
          }
          this.buffer = this.buffer[0] + ":";
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
        while (this.url.path.length > 1 && this.url.path[0] === "") {
          this.parseError = true;
          this.url.path.shift();
        }
      }
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      }
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += percentEncodeChar(c, isPathPercentEncode);
    }
    return true;
  };
  URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
    if (c === 63) {
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c) && c !== 37) {
        this.parseError = true;
      }
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c)) {
        this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (isNaN(c) || !this.stateOverride && c === 35) {
      if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
        this.encodingOverride = "utf-8";
      }
      const buffer = new Buffer(this.buffer);
      for (let i = 0;i < buffer.length; ++i) {
        if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
          this.url.query += percentEncode(buffer[i]);
        } else {
          this.url.query += String.fromCodePoint(buffer[i]);
        }
      }
      this.buffer = "";
      if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (isNaN(c)) {} else if (c === 0) {
      this.parseError = true;
    } else {
      if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
    }
    return true;
  };
  function serializeURL(url, excludeFragment) {
    let output = url.scheme + ":";
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += ":" + url.password;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += ":" + url.port;
      }
    } else if (url.host === null && url.scheme === "file") {
      output += "//";
    }
    if (url.cannotBeABaseURL) {
      output += url.path[0];
    } else {
      for (const string of url.path) {
        output += "/" + string;
      }
    }
    if (url.query !== null) {
      output += "?" + url.query;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += "#" + url.fragment;
    }
    return output;
  }
  function serializeOrigin(tuple) {
    let result = tuple.scheme + "://";
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result += ":" + tuple.port;
    }
    return result;
  }
  exports.serializeURL = serializeURL;
  exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob":
        try {
          return exports.serializeURLOrigin(exports.parseURL(url.path[0]));
        } catch (e) {
          return "null";
        }
      case "ftp":
      case "gopher":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "file://";
      default:
        return "null";
    }
  };
  exports.basicURLParse = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
      return "failure";
    }
    return usm.url;
  };
  exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode.ucs2.decode(username);
    for (let i = 0;i < decoded.length; ++i) {
      url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
  };
  exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode.ucs2.decode(password);
    for (let i = 0;i < decoded.length; ++i) {
      url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
  };
  exports.serializeHost = serializeHost;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.serializeInteger = function(integer) {
    return String(integer);
  };
  exports.parseURL = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS((exports) => {
  var usm = require_url_state_machine();
  exports.implementation = class URLImpl {
    constructor(constructorArgs) {
      const url = constructorArgs[0];
      const base = constructorArgs[1];
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === "failure") {
          throw new TypeError("Invalid base URL");
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v) {
      const parsedURL = usm.basicURLParse(v);
      if (parsedURL === "failure") {
        throw new TypeError("Invalid URL");
      }
      this._url = parsedURL;
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return this._url.scheme + ":";
    }
    set protocol(v) {
      usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v);
    }
    get password() {
      return this._url.password;
    }
    set password(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
    }
    set host(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      if (this._url.cannotBeABaseURL) {
        return this._url.path[0];
      }
      if (this._url.path.length === 0) {
        return "";
      }
      return "/" + this._url.path.join("/");
    }
    set pathname(v) {
      if (this._url.cannotBeABaseURL) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return "?" + this._url.query;
    }
    set search(v) {
      const url = this._url;
      if (v === "") {
        url.query = null;
        return;
      }
      const input = v[0] === "?" ? v.substring(1) : v;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return "#" + this._url.fragment;
    }
    set hash(v) {
      if (v === "") {
        this._url.fragment = null;
        return;
      }
      const input = v[0] === "#" ? v.substring(1) : v;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
  };
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS((exports, module) => {
  var conversions = require_lib();
  var utils = require_utils();
  var Impl = require_URL_impl();
  var impl = utils.implSymbol;
  function URL2(url) {
    if (!this || this[impl] || !(this instanceof URL2)) {
      throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    }
    if (arguments.length < 1) {
      throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    }
    const args = [];
    for (let i = 0;i < arguments.length && i < 2; ++i) {
      args[i] = arguments[i];
    }
    args[0] = conversions["USVString"](args[0]);
    if (args[1] !== undefined) {
      args[1] = conversions["USVString"](args[1]);
    }
    module.exports.setup(this, args);
  }
  URL2.prototype.toJSON = function toJSON() {
    if (!this || !module.exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    const args = [];
    for (let i = 0;i < arguments.length && i < 0; ++i) {
      args[i] = arguments[i];
    }
    return this[impl].toJSON.apply(this[impl], args);
  };
  Object.defineProperty(URL2.prototype, "href", {
    get() {
      return this[impl].href;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].href = V;
    },
    enumerable: true,
    configurable: true
  });
  URL2.prototype.toString = function() {
    if (!this || !module.exports.is(this)) {
      throw new TypeError("Illegal invocation");
    }
    return this.href;
  };
  Object.defineProperty(URL2.prototype, "origin", {
    get() {
      return this[impl].origin;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "protocol", {
    get() {
      return this[impl].protocol;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].protocol = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "username", {
    get() {
      return this[impl].username;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].username = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "password", {
    get() {
      return this[impl].password;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].password = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "host", {
    get() {
      return this[impl].host;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].host = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "hostname", {
    get() {
      return this[impl].hostname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hostname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "port", {
    get() {
      return this[impl].port;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].port = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "pathname", {
    get() {
      return this[impl].pathname;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].pathname = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "search", {
    get() {
      return this[impl].search;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].search = V;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(URL2.prototype, "hash", {
    get() {
      return this[impl].hash;
    },
    set(V) {
      V = conversions["USVString"](V);
      this[impl].hash = V;
    },
    enumerable: true,
    configurable: true
  });
  module.exports = {
    is(obj2) {
      return !!obj2 && obj2[impl] instanceof Impl.implementation;
    },
    create(constructorArgs, privateData) {
      let obj2 = Object.create(URL2.prototype);
      this.setup(obj2, constructorArgs, privateData);
      return obj2;
    },
    setup(obj2, constructorArgs, privateData) {
      if (!privateData)
        privateData = {};
      privateData.wrapper = obj2;
      obj2[impl] = new Impl.implementation(constructorArgs, privateData);
      obj2[impl][utils.wrapperSymbol] = obj2;
    },
    interface: URL2,
    expose: {
      Window: { URL: URL2 },
      Worker: { URL: URL2 }
    }
  };
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS((exports) => {
  exports.URL = require_URL().interface;
  exports.serializeURL = require_url_state_machine().serializeURL;
  exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
  exports.basicURLParse = require_url_state_machine().basicURLParse;
  exports.setTheUsername = require_url_state_machine().setTheUsername;
  exports.setThePassword = require_url_state_machine().setThePassword;
  exports.serializeHost = require_url_state_machine().serializeHost;
  exports.serializeInteger = require_url_state_machine().serializeInteger;
  exports.parseURL = require_url_state_machine().parseURL;
});

// node_modules/cross-fetch/node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var Stream = _interopDefault(__require("stream"));
  var http = _interopDefault(__require("http"));
  var Url = _interopDefault(__require("url"));
  var whatwgUrl = _interopDefault(require_public_api());
  var https = _interopDefault(__require("https"));
  var zlib = _interopDefault(__require("zlib"));
  var Readable = Stream.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");

  class Blob2 {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0;i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob2) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== undefined && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable;
      readable._read = function() {};
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === undefined) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === undefined) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob2([], { type: arguments[2] });
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  }
  Object.defineProperties(Blob2.prototype, {
    size: { enumerable: true },
    type: { enumerable: true },
    slice: { enumerable: true }
  });
  Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = (()=>{throw new Error("Cannot require module "+"encoding");})().convert;
  } catch (e) {}
  var INTERNALS = Symbol("Body internals");
  var PassThrough = Stream.PassThrough;
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob2([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: { enumerable: true },
    bodyUsed: { enumerable: true },
    arrayBuffer: { enumerable: true },
    blob: { enumerable: true },
    json: { enumerable: true },
    text: { enumerable: true }
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj2) {
    if (typeof obj2 !== "object" || typeof obj2.append !== "function" || typeof obj2.delete !== "function" || typeof obj2.get !== "function" || typeof obj2.getAll !== "function" || typeof obj2.has !== "function" || typeof obj2.set !== "function") {
      return false;
    }
    return obj2.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj2) === "[object URLSearchParams]" || typeof obj2.sort === "function";
  }
  function isBlob(obj2) {
    return typeof obj2 === "object" && typeof obj2.arrayBuffer === "function" && typeof obj2.type === "string" && typeof obj2.stream === "function" && typeof obj2.constructor === "function" && typeof obj2.constructor.name === "string" && /^(Blob|File)$/.test(obj2.constructor.name) && /^(Blob|File)$/.test(obj2[Symbol.toStringTag]);
  }
  function clone(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough;
      p2 = new PassThrough;
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof Stream) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key2 in map) {
      if (key2.toLowerCase() === name) {
        return key2;
      }
    }
    return;
  }
  var MAP = Symbol("map");

  class Headers {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this[MAP] = Object.create(null);
      if (init instanceof Headers) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key2 of Object.keys(init)) {
            const value = init[key2];
            this.append(key2, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key2 = find(this[MAP], name);
      if (key2 === undefined) {
        return null;
      }
      return this[MAP][key2].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let pairs = getHeaders(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key2 = find(this[MAP], name);
      this[MAP][key2 !== undefined ? key2 : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key2 = find(this[MAP], name);
      if (key2 !== undefined) {
        this[MAP][key2].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== undefined;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key2 = find(this[MAP], name);
      if (key2 !== undefined) {
        delete this[MAP][key2];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  }
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: { enumerable: true },
    forEach: { enumerable: true },
    set: { enumerable: true },
    append: { enumerable: true },
    has: { enumerable: true },
    delete: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true }
  });
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  var INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const { target, kind, index } = _INTERNAL;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: undefined,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj2 = Object.assign({ __proto__: null }, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== undefined) {
      obj2[hostHeaderKey] = obj2[hostHeaderKey][0];
    }
    return obj2;
  }
  function createHeadersLenient(obj2) {
    const headers = new Headers;
    for (const name of Object.keys(obj2)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj2[name])) {
        for (const val of obj2[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === undefined) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj2[name])) {
        headers[MAP][name] = [obj2[name]];
      }
    }
    return headers;
  }
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = http.STATUS_CODES;

  class Response {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  }
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: { enumerable: true },
    status: { enumerable: true },
    ok: { enumerable: true },
    redirected: { enumerable: true },
    statusText: { enumerable: true },
    headers: { enumerable: true },
    clone: { enumerable: true }
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var URL2 = Url.URL || whatwgUrl.URL;
  var parse_url = Url.parse;
  var format_url = Url.format;
  function parseURL(urlStr) {
    if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
      urlStr = new URL2(urlStr).toString();
    }
    return parse_url(urlStr);
  }
  var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }

  class Request {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parseURL(input.href);
        } else {
          parsedURL = parseURL(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parseURL(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
      this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request(this);
    }
  }
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: { enumerable: true },
    url: { enumerable: true },
    headers: { enumerable: true },
    redirect: { enumerable: true },
    clone: { enumerable: true },
    signal: { enumerable: true }
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    if (!headers.has("Connection") && !agent) {
      headers.set("Connection", "close");
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var URL$1 = Url.URL || whatwgUrl.URL;
  var PassThrough$1 = Stream.PassThrough;
  var isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
  };
  function fetch2(url, opts) {
    if (!fetch2.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch2.Promise;
    return new fetch2.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? https : http).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort() {
        let error = new AbortError("The user aborted a request.");
        reject(error);
        if (request.body && request.body instanceof Stream.Readable) {
          request.body.destroy(error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch2.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL$1(location, request.url).toString();
          } catch (err) {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (!isDomainOrSubdomain(request.url, locationURL)) {
                for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOpts.headers.delete(name);
                }
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = undefined;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch2(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1);
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1);
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            response = new Response(body, response_options);
            resolve(response);
          });
          return;
        }
        if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
          body = body.pipe(zlib.createBrotliDecompress());
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        response = new Response(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  }
  fetch2.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch2.Promise = global.Promise;
  module.exports = exports = fetch2;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = exports;
  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.FetchError = FetchError;
});

// node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS((exports, module) => {
  var nodeFetch = require_lib2();
  var realFetch = nodeFetch.default || nodeFetch;
  var fetch2 = function(url, options) {
    if (/^\/\//.test(url)) {
      url = "https:" + url;
    }
    return realFetch.call(this, url, options);
  };
  fetch2.ponyfill = true;
  module.exports = exports = fetch2;
  exports.fetch = fetch2;
  exports.Headers = nodeFetch.Headers;
  exports.Request = nodeFetch.Request;
  exports.Response = nodeFetch.Response;
  exports.default = fetch2;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/fetch.js
var require_fetch = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFetch = undefined;
  var getFetch = async () => {
    return globalThis.fetch || (await Promise.resolve().then(() => __importStar(require_node_ponyfill()))).fetch;
  };
  exports.getFetch = getFetch;
});

// node_modules/ws/lib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  module.exports = {
    BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {}
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var { EMPTY_BUFFER } = require_constants2();
  function concat(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength)
      return target.slice(0, offset);
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = Buffer.from(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error("Cannot require module "+"bufferutil");})();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants2();
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key2) => {
          let value = params[key2];
          if (value.length > 1) {
            throw new Error(`Parameter "${key2}" must have only a single value`);
          }
          value = value[0];
          if (key2 === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
            }
          } else if (key2 === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
            }
            value = num;
          } else if (key2 === "client_no_context_takeover" || key2 === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key2}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key2}"`);
          }
          params[key2] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key2 = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key2] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key2];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key2 = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key2] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key2];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin)
          data2 = data2.slice(0, data2.length - 4);
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error("Cannot require module "+"utf-8-validate");})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants2();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._state = GET_INFO;
      this._loop = false;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = buf.slice(n);
        return buf.slice(0, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = buf.slice(n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      let err;
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            err = this.getInfo();
            break;
          case GET_PAYLOAD_LENGTH_16:
            err = this.getPayloadLength16();
            break;
          case GET_PAYLOAD_LENGTH_64:
            err = this.getPayloadLength64();
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            err = this.getData(cb);
            break;
          default:
            this._loop = false;
            return;
        }
      } while (this._loop);
      cb(err);
    }
    getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        this._loop = false;
        return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        this._loop = false;
        return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        if (!this._fragmented) {
          this._loop = false;
          return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          this._loop = false;
          return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
        }
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        if (this._payloadLength > 125) {
          this._loop = false;
          return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
        }
      } else {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
        }
      } else if (this._masked) {
        this._loop = false;
        return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        return this.haveLength();
    }
    getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    haveLength() {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7)
        return this.controlMessage(data);
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      return this.dataMessage();
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
          }
          this._fragments.push(buf);
        }
        const er = this.dataMessage();
        if (er)
          return cb(er);
        this.startLoop(cb);
      });
    }
    dataMessage() {
      if (this._fin) {
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }
          this.emit("message", data, true);
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            this._loop = false;
            return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          }
          this.emit("message", buf, false);
        }
      }
      this._state = GET_INFO;
    }
    controlMessage(data) {
      if (this._opcode === 8) {
        this._loop = false;
        if (data.length === 0) {
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else if (data.length === 1) {
          return error(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
          }
          const buf = data.slice(2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          }
          this.emit("conclude", code, buf);
          this.end();
        }
      } else if (this._opcode === 9) {
        this.emit("ping", data);
      } else {
        this.emit("pong", data);
      }
      this._state = GET_INFO;
    }
  }
  module.exports = Receiver;
  function error(ErrorCtor, message, prefix, statusCode, errorCode) {
    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
    Error.captureStackTrace(err, error);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var net = __require("net");
  var tls = __require("tls");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER } = require_constants2();
  var { isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          randomFillSync(mask, 0, 4);
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      if (perMessageDeflate) {
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }), cb);
      }
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, (_2, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          if (typeof cb === "function")
            cb(err);
          for (let i = 0;i < this._queue.length; i++) {
            const params = this._queue[i];
            const callback = params[params.length - 1];
            if (typeof callback === "function")
              callback(err);
          }
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._deflating = false;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (!this._deflating && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var { kForOnEventAttribute, kListener } = require_constants2();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event2 {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event2.prototype, "target", { enumerable: true });
  Object.defineProperty(Event2.prototype, "type", { enumerable: true });

  class CloseEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, listener, options = {}) {
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          listener.call(this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          listener.call(this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          listener.call(this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event2("open");
          event[kTarget] = this;
          listener.call(this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = listener;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event: Event2,
    EventTarget,
    MessageEvent
  };
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function push(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module.exports = { format, parse };
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants2();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket2 extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket2.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      this._sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      socket.setTimeout(0);
      socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket2.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket2.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket2.CLOSED)
        return;
      if (this.readyState === WebSocket2.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        return abortHandshake(this, this._req, msg);
      }
      if (this.readyState === WebSocket2.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket2.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    pause() {
      if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket2.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket2.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket2.CLOSED)
        return;
      if (this.readyState === WebSocket2.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        return abortHandshake(this, this._req, msg);
      }
      if (this._socket) {
        this._readyState = WebSocket2.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket2, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket2, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket2.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket2, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket2.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket2, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket2.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket2.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket2.prototype.addEventListener = addEventListener;
  WebSocket2.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket2;
  function initAsClient(websocket, address, protocols, options) {
    const opts = {
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
      websocket._url = address.href;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
      websocket._url = address;
    }
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key2 = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect : netConnect;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key2,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key3, value] of Object.entries(headers)) {
            options.headers[key3.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket2.CONNECTING)
        return;
      req = websocket._req = null;
      if (res.headers.upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key2 + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    req.end();
  }
  function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket2.CLOSING;
    websocket.emit("error", err);
    websocket.emitClose();
  }
  function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
  }
  function tlsConnect(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  }
  function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket2.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function sendAfterClose(websocket, data, cb) {
    if (data) {
      const length = toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      cb(err);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  }
  function receiverOnDrain() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    websocket.emit("error", err);
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  }
  function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    websocket.pong(data, !websocket._isServer, NOOP);
    websocket.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function resume(stream) {
    stream.resume();
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket2.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket2.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket2.CLOSING;
      this.destroy();
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  function emitClose(stream) {
    stream.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function parse(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  module.exports = { parse };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var http = __require("http");
  var https = __require("https");
  var net = __require("net");
  var tls = __require("tls");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket2 = require_websocket();
  var { GUID, kWebSocket } = require_constants2();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket: WebSocket2,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key2 = req.headers["sec-websocket-key"];
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (req.headers.upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!key2 || !keyRegex.test(key2)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 8 && version !== 13) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key2, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key2, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key2, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key2 + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat(`\r
`).join(`\r
`));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
  function addListeners(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(`\r
`) + `\r
\r
` + message);
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message);
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS((exports, module) => {
  var WebSocket2 = require_websocket();
  WebSocket2.createWebSocketStream = require_stream();
  WebSocket2.Server = require_websocket_server();
  WebSocket2.Receiver = require_receiver();
  WebSocket2.Sender = require_sender();
  WebSocket2.WebSocket = WebSocket2;
  WebSocket2.WebSocketServer = WebSocket2.Server;
  module.exports = WebSocket2;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/generated/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.packageVersion = undefined;
  exports.packageVersion = "18.2.1";
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/NodeWebSocketTransport.js
var require_NodeWebSocketTransport = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  var _NodeWebSocketTransport_ws;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NodeWebSocketTransport = undefined;
  var ws_1 = __importDefault(require_ws());
  var version_js_1 = require_version();

  class NodeWebSocketTransport {
    constructor(ws) {
      _NodeWebSocketTransport_ws.set(this, undefined);
      __classPrivateFieldSet(this, _NodeWebSocketTransport_ws, ws, "f");
      __classPrivateFieldGet(this, _NodeWebSocketTransport_ws, "f").addEventListener("message", (event) => {
        if (this.onmessage) {
          this.onmessage.call(null, event.data);
        }
      });
      __classPrivateFieldGet(this, _NodeWebSocketTransport_ws, "f").addEventListener("close", () => {
        if (this.onclose) {
          this.onclose.call(null);
        }
      });
      __classPrivateFieldGet(this, _NodeWebSocketTransport_ws, "f").addEventListener("error", () => {});
    }
    static create(url) {
      return new Promise((resolve, reject) => {
        const ws = new ws_1.default(url, [], {
          followRedirects: true,
          perMessageDeflate: false,
          maxPayload: 256 * 1024 * 1024,
          headers: {
            "User-Agent": `Puppeteer ${version_js_1.packageVersion}`
          }
        });
        ws.addEventListener("open", () => {
          return resolve(new NodeWebSocketTransport(ws));
        });
        ws.addEventListener("error", reject);
      });
    }
    send(message) {
      __classPrivateFieldGet(this, _NodeWebSocketTransport_ws, "f").send(message);
    }
    close() {
      __classPrivateFieldGet(this, _NodeWebSocketTransport_ws, "f").close();
    }
  }
  exports.NodeWebSocketTransport = NodeWebSocketTransport;
  _NodeWebSocketTransport_ws = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/BrowserWebSocketTransport.js
var require_BrowserWebSocketTransport = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _BrowserWebSocketTransport_ws;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BrowserWebSocketTransport = undefined;

  class BrowserWebSocketTransport {
    constructor(ws) {
      _BrowserWebSocketTransport_ws.set(this, undefined);
      __classPrivateFieldSet(this, _BrowserWebSocketTransport_ws, ws, "f");
      __classPrivateFieldGet(this, _BrowserWebSocketTransport_ws, "f").addEventListener("message", (event) => {
        if (this.onmessage) {
          this.onmessage.call(null, event.data);
        }
      });
      __classPrivateFieldGet(this, _BrowserWebSocketTransport_ws, "f").addEventListener("close", () => {
        if (this.onclose) {
          this.onclose.call(null);
        }
      });
      __classPrivateFieldGet(this, _BrowserWebSocketTransport_ws, "f").addEventListener("error", () => {});
    }
    static create(url) {
      return new Promise((resolve, reject) => {
        const ws = new WebSocket(url);
        ws.addEventListener("open", () => {
          return resolve(new BrowserWebSocketTransport(ws));
        });
        ws.addEventListener("error", reject);
      });
    }
    send(message) {
      __classPrivateFieldGet(this, _BrowserWebSocketTransport_ws, "f").send(message);
    }
    close() {
      __classPrivateFieldGet(this, _BrowserWebSocketTransport_ws, "f").close();
    }
  }
  exports.BrowserWebSocketTransport = BrowserWebSocketTransport;
  _BrowserWebSocketTransport_ws = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/BrowserConnector.js
var require_BrowserConnector = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._connectToCDPBrowser = undefined;
  var util_js_1 = require_util();
  var ErrorLike_js_1 = require_ErrorLike();
  var environment_js_1 = require_environment();
  var assert_js_1 = require_assert();
  var Browser_js_1 = require_Browser2();
  var Connection_js_1 = require_Connection();
  var fetch_js_1 = require_fetch();
  var getWebSocketTransportClass = async () => {
    return environment_js_1.isNode ? (await Promise.resolve().then(() => __importStar(require_NodeWebSocketTransport()))).NodeWebSocketTransport : (await Promise.resolve().then(() => __importStar(require_BrowserWebSocketTransport()))).BrowserWebSocketTransport;
  };
  async function _connectToCDPBrowser(options) {
    const { browserWSEndpoint, browserURL, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, transport, slowMo = 0, targetFilter, _isPageTarget: isPageTarget } = options;
    (0, assert_js_1.assert)(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, "Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect");
    let connection;
    if (transport) {
      connection = new Connection_js_1.Connection("", transport, slowMo);
    } else if (browserWSEndpoint) {
      const WebSocketClass = await getWebSocketTransportClass();
      const connectionTransport = await WebSocketClass.create(browserWSEndpoint);
      connection = new Connection_js_1.Connection(browserWSEndpoint, connectionTransport, slowMo);
    } else if (browserURL) {
      const connectionURL = await getWSEndpoint(browserURL);
      const WebSocketClass = await getWebSocketTransportClass();
      const connectionTransport = await WebSocketClass.create(connectionURL);
      connection = new Connection_js_1.Connection(connectionURL, connectionTransport, slowMo);
    }
    const version = await connection.send("Browser.getVersion");
    const product = version.product.toLowerCase().includes("firefox") ? "firefox" : "chrome";
    const { browserContextIds } = await connection.send("Target.getBrowserContexts");
    const browser = await Browser_js_1.CDPBrowser._create(product || "chrome", connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, undefined, () => {
      return connection.send("Browser.close").catch(util_js_1.debugError);
    }, targetFilter, isPageTarget);
    return browser;
  }
  exports._connectToCDPBrowser = _connectToCDPBrowser;
  async function getWSEndpoint(browserURL) {
    const endpointURL = new URL("/json/version", browserURL);
    const fetch2 = await (0, fetch_js_1.getFetch)();
    try {
      const result = await fetch2(endpointURL.toString(), {
        method: "GET"
      });
      if (!result.ok) {
        throw new Error(`HTTP ${result.statusText}`);
      }
      const data = await result.json();
      return data.webSocketDebuggerUrl;
    } catch (error) {
      if ((0, ErrorLike_js_1.isErrorLike)(error)) {
        error.message = `Failed to fetch browser webSocket URL from ${endpointURL}: ` + error.message;
      }
      throw error;
    }
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Puppeteer.js
var require_Puppeteer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Puppeteer = undefined;
  var BrowserConnector_js_1 = require_BrowserConnector();
  var DeviceDescriptors_js_1 = require_DeviceDescriptors();
  var Errors_js_1 = require_Errors();
  var NetworkConditions_js_1 = require_NetworkConditions();
  var QueryHandler_js_1 = require_QueryHandler();

  class Puppeteer {
    constructor(settings) {
      this._changedProduct = false;
      this._isPuppeteerCore = settings.isPuppeteerCore;
      this.connect = this.connect.bind(this);
    }
    connect(options) {
      return (0, BrowserConnector_js_1._connectToCDPBrowser)(options);
    }
    get devices() {
      return DeviceDescriptors_js_1.devices;
    }
    get errors() {
      return Errors_js_1.errors;
    }
    get networkConditions() {
      return NetworkConditions_js_1.networkConditions;
    }
    registerCustomQueryHandler(name, queryHandler) {
      return (0, QueryHandler_js_1.registerCustomQueryHandler)(name, queryHandler);
    }
    unregisterCustomQueryHandler(name) {
      return (0, QueryHandler_js_1.unregisterCustomQueryHandler)(name);
    }
    customQueryHandlerNames() {
      return (0, QueryHandler_js_1.customQueryHandlerNames)();
    }
    clearCustomQueryHandlers() {
      return (0, QueryHandler_js_1.clearCustomQueryHandlers)();
    }
  }
  exports.Puppeteer = Puppeteer;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/revisions.js
var require_revisions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PUPPETEER_REVISIONS = undefined;
  exports.PUPPETEER_REVISIONS = Object.freeze({
    chromium: "1045629",
    firefox: "latest"
  });
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Connection.js
var require_Connection2 = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Connection_instances;
  var _Connection_transport;
  var _Connection_delay;
  var _Connection_lastId;
  var _Connection_closed;
  var _Connection_callbacks;
  var _Connection_onClose;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Connection = undefined;
  var Debug_js_1 = require_Debug();
  var debugProtocolSend = (0, Debug_js_1.debug)("puppeteer:webDriverBiDi:SEND ►");
  var debugProtocolReceive = (0, Debug_js_1.debug)("puppeteer:webDriverBiDi:RECV ◀");
  var EventEmitter_js_1 = require_EventEmitter();
  var Errors_js_1 = require_Errors();

  class Connection extends EventEmitter_js_1.EventEmitter {
    constructor(transport, delay = 0) {
      super();
      _Connection_instances.add(this);
      _Connection_transport.set(this, undefined);
      _Connection_delay.set(this, undefined);
      _Connection_lastId.set(this, 0);
      _Connection_closed.set(this, false);
      _Connection_callbacks.set(this, new Map);
      __classPrivateFieldSet(this, _Connection_delay, delay, "f");
      __classPrivateFieldSet(this, _Connection_transport, transport, "f");
      __classPrivateFieldGet(this, _Connection_transport, "f").onmessage = this.onMessage.bind(this);
      __classPrivateFieldGet(this, _Connection_transport, "f").onclose = __classPrivateFieldGet(this, _Connection_instances, "m", _Connection_onClose).bind(this);
    }
    get closed() {
      return __classPrivateFieldGet(this, _Connection_closed, "f");
    }
    send(method, params) {
      var _a;
      const id = __classPrivateFieldSet(this, _Connection_lastId, (_a = __classPrivateFieldGet(this, _Connection_lastId, "f"), ++_a), "f");
      const stringifiedMessage = JSON.stringify({
        id,
        method,
        params
      });
      debugProtocolSend(stringifiedMessage);
      __classPrivateFieldGet(this, _Connection_transport, "f").send(stringifiedMessage);
      return new Promise((resolve, reject) => {
        __classPrivateFieldGet(this, _Connection_callbacks, "f").set(id, {
          resolve,
          reject,
          error: new Errors_js_1.ProtocolError,
          method
        });
      });
    }
    async onMessage(message) {
      if (__classPrivateFieldGet(this, _Connection_delay, "f")) {
        await new Promise((f) => {
          return setTimeout(f, __classPrivateFieldGet(this, _Connection_delay, "f"));
        });
      }
      debugProtocolReceive(message);
      const object = JSON.parse(message);
      if ("id" in object) {
        const callback = __classPrivateFieldGet(this, _Connection_callbacks, "f").get(object.id);
        if (callback) {
          __classPrivateFieldGet(this, _Connection_callbacks, "f").delete(object.id);
          if ("error" in object) {
            callback.reject(createProtocolError(callback.error, callback.method, object));
          } else {
            callback.resolve(object.result);
          }
        }
      } else {
        this.emit(object.method, object.params);
      }
    }
    dispose() {
      __classPrivateFieldGet(this, _Connection_instances, "m", _Connection_onClose).call(this);
      __classPrivateFieldGet(this, _Connection_transport, "f").close();
    }
  }
  exports.Connection = Connection;
  _Connection_transport = new WeakMap, _Connection_delay = new WeakMap, _Connection_lastId = new WeakMap, _Connection_closed = new WeakMap, _Connection_callbacks = new WeakMap, _Connection_instances = new WeakSet, _Connection_onClose = function _Connection_onClose() {
    if (__classPrivateFieldGet(this, _Connection_closed, "f")) {
      return;
    }
    __classPrivateFieldSet(this, _Connection_closed, true, "f");
    __classPrivateFieldGet(this, _Connection_transport, "f").onmessage = undefined;
    __classPrivateFieldGet(this, _Connection_transport, "f").onclose = undefined;
    for (const callback of __classPrivateFieldGet(this, _Connection_callbacks, "f").values()) {
      callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Connection closed.`));
    }
    __classPrivateFieldGet(this, _Connection_callbacks, "f").clear();
  };
  function rewriteError(error, message, originalMessage) {
    error.message = message;
    error.originalMessage = originalMessage !== null && originalMessage !== undefined ? originalMessage : error.originalMessage;
    return error;
  }
  function createProtocolError(error, method, object) {
    let message = `Protocol error (${method}): ${object.error} ${object.message}`;
    if (object.stacktrace) {
      message += ` ${object.stacktrace}`;
    }
    return rewriteError(error, message, object.message);
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/PipeTransport.js
var require_PipeTransport = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _PipeTransport_instances;
  var _PipeTransport_pipeWrite;
  var _PipeTransport_eventListeners;
  var _PipeTransport_isClosed;
  var _PipeTransport_pendingMessage;
  var _PipeTransport_dispatch;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PipeTransport = undefined;
  var util_js_1 = require_util();
  var assert_js_1 = require_assert();

  class PipeTransport {
    constructor(pipeWrite, pipeRead) {
      _PipeTransport_instances.add(this);
      _PipeTransport_pipeWrite.set(this, undefined);
      _PipeTransport_eventListeners.set(this, undefined);
      _PipeTransport_isClosed.set(this, false);
      _PipeTransport_pendingMessage.set(this, "");
      __classPrivateFieldSet(this, _PipeTransport_pipeWrite, pipeWrite, "f");
      __classPrivateFieldSet(this, _PipeTransport_eventListeners, [
        (0, util_js_1.addEventListener)(pipeRead, "data", (buffer) => {
          return __classPrivateFieldGet(this, _PipeTransport_instances, "m", _PipeTransport_dispatch).call(this, buffer);
        }),
        (0, util_js_1.addEventListener)(pipeRead, "close", () => {
          if (this.onclose) {
            this.onclose.call(null);
          }
        }),
        (0, util_js_1.addEventListener)(pipeRead, "error", util_js_1.debugError),
        (0, util_js_1.addEventListener)(pipeWrite, "error", util_js_1.debugError)
      ], "f");
    }
    send(message) {
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _PipeTransport_isClosed, "f"), "`PipeTransport` is closed.");
      __classPrivateFieldGet(this, _PipeTransport_pipeWrite, "f").write(message);
      __classPrivateFieldGet(this, _PipeTransport_pipeWrite, "f").write("\x00");
    }
    close() {
      __classPrivateFieldSet(this, _PipeTransport_isClosed, true, "f");
      (0, util_js_1.removeEventListeners)(__classPrivateFieldGet(this, _PipeTransport_eventListeners, "f"));
    }
  }
  exports.PipeTransport = PipeTransport;
  _PipeTransport_pipeWrite = new WeakMap, _PipeTransport_eventListeners = new WeakMap, _PipeTransport_isClosed = new WeakMap, _PipeTransport_pendingMessage = new WeakMap, _PipeTransport_instances = new WeakSet, _PipeTransport_dispatch = function _PipeTransport_dispatch(buffer) {
    (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _PipeTransport_isClosed, "f"), "`PipeTransport` is closed.");
    let end = buffer.indexOf("\x00");
    if (end === -1) {
      __classPrivateFieldSet(this, _PipeTransport_pendingMessage, __classPrivateFieldGet(this, _PipeTransport_pendingMessage, "f") + buffer.toString(), "f");
      return;
    }
    const message = __classPrivateFieldGet(this, _PipeTransport_pendingMessage, "f") + buffer.toString(undefined, 0, end);
    if (this.onmessage) {
      this.onmessage.call(null, message);
    }
    let start = end + 1;
    end = buffer.indexOf("\x00", start);
    while (end !== -1) {
      if (this.onmessage) {
        this.onmessage.call(null, buffer.toString(undefined, start, end));
      }
      start = end + 1;
      end = buffer.indexOf("\x00", start);
    }
    __classPrivateFieldSet(this, _PipeTransport_pendingMessage, buffer.toString(undefined, start), "f");
  };
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/BrowserRunner.js
var require_BrowserRunner = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  var _BrowserRunner_product;
  var _BrowserRunner_executablePath;
  var _BrowserRunner_processArguments;
  var _BrowserRunner_userDataDir;
  var _BrowserRunner_isTempUserDataDir;
  var _BrowserRunner_closed;
  var _BrowserRunner_listeners;
  var _BrowserRunner_processClosing;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BrowserRunner = undefined;
  var childProcess = __importStar(__require("child_process"));
  var fs = __importStar(__require("fs"));
  var path = __importStar(__require("path"));
  var readline = __importStar(__require("readline"));
  var rimraf_1 = __importDefault(require_rimraf());
  var util_1 = __require("util");
  var Connection_js_1 = require_Connection2();
  var Connection_js_2 = require_Connection();
  var Debug_js_1 = require_Debug();
  var Errors_js_1 = require_Errors();
  var NodeWebSocketTransport_js_1 = require_NodeWebSocketTransport();
  var util_js_1 = require_util();
  var assert_js_1 = require_assert();
  var ErrorLike_js_1 = require_ErrorLike();
  var PipeTransport_js_1 = require_PipeTransport();
  var removeFolderAsync = (0, util_1.promisify)(rimraf_1.default);
  var renameAsync = (0, util_1.promisify)(fs.rename);
  var unlinkAsync = (0, util_1.promisify)(fs.unlink);
  var debugLauncher = (0, Debug_js_1.debug)("puppeteer:launcher");
  var PROCESS_ERROR_EXPLANATION = `Puppeteer was unable to kill the process which ran the browser binary.
This means that, on future Puppeteer launches, Puppeteer might not be able to launch the browser.
Please check your open processes and ensure that the browser processes that Puppeteer launched have been killed.
If you think this is a bug, please report it on the Puppeteer issue tracker.`;

  class BrowserRunner {
    constructor(product, executablePath, processArguments, userDataDir, isTempUserDataDir) {
      _BrowserRunner_product.set(this, undefined);
      _BrowserRunner_executablePath.set(this, undefined);
      _BrowserRunner_processArguments.set(this, undefined);
      _BrowserRunner_userDataDir.set(this, undefined);
      _BrowserRunner_isTempUserDataDir.set(this, undefined);
      _BrowserRunner_closed.set(this, true);
      _BrowserRunner_listeners.set(this, []);
      _BrowserRunner_processClosing.set(this, undefined);
      __classPrivateFieldSet(this, _BrowserRunner_product, product, "f");
      __classPrivateFieldSet(this, _BrowserRunner_executablePath, executablePath, "f");
      __classPrivateFieldSet(this, _BrowserRunner_processArguments, processArguments, "f");
      __classPrivateFieldSet(this, _BrowserRunner_userDataDir, userDataDir, "f");
      __classPrivateFieldSet(this, _BrowserRunner_isTempUserDataDir, isTempUserDataDir, "f");
    }
    start(options) {
      var _a, _b;
      const { handleSIGINT, handleSIGTERM, handleSIGHUP, dumpio, env, pipe } = options;
      let stdio;
      if (pipe) {
        if (dumpio) {
          stdio = ["ignore", "pipe", "pipe", "pipe", "pipe"];
        } else {
          stdio = ["ignore", "ignore", "ignore", "pipe", "pipe"];
        }
      } else {
        if (dumpio) {
          stdio = ["pipe", "pipe", "pipe"];
        } else {
          stdio = ["pipe", "ignore", "pipe"];
        }
      }
      (0, assert_js_1.assert)(!this.proc, "This process has previously been started.");
      debugLauncher(`Calling ${__classPrivateFieldGet(this, _BrowserRunner_executablePath, "f")} ${__classPrivateFieldGet(this, _BrowserRunner_processArguments, "f").join(" ")}`);
      this.proc = childProcess.spawn(__classPrivateFieldGet(this, _BrowserRunner_executablePath, "f"), __classPrivateFieldGet(this, _BrowserRunner_processArguments, "f"), {
        detached: process.platform !== "win32",
        env,
        stdio
      });
      if (dumpio) {
        (_a = this.proc.stderr) === null || _a === undefined || _a.pipe(process.stderr);
        (_b = this.proc.stdout) === null || _b === undefined || _b.pipe(process.stdout);
      }
      __classPrivateFieldSet(this, _BrowserRunner_closed, false, "f");
      __classPrivateFieldSet(this, _BrowserRunner_processClosing, new Promise((fulfill, reject) => {
        this.proc.once("exit", async () => {
          __classPrivateFieldSet(this, _BrowserRunner_closed, true, "f");
          if (__classPrivateFieldGet(this, _BrowserRunner_isTempUserDataDir, "f")) {
            try {
              await removeFolderAsync(__classPrivateFieldGet(this, _BrowserRunner_userDataDir, "f"));
              fulfill();
            } catch (error) {
              (0, util_js_1.debugError)(error);
              reject(error);
            }
          } else {
            if (__classPrivateFieldGet(this, _BrowserRunner_product, "f") === "firefox") {
              try {
                await unlinkAsync(path.join(__classPrivateFieldGet(this, _BrowserRunner_userDataDir, "f"), "user.js"));
                const prefsBackupPath = path.join(__classPrivateFieldGet(this, _BrowserRunner_userDataDir, "f"), "prefs.js.puppeteer");
                if (fs.existsSync(prefsBackupPath)) {
                  const prefsPath = path.join(__classPrivateFieldGet(this, _BrowserRunner_userDataDir, "f"), "prefs.js");
                  await unlinkAsync(prefsPath);
                  await renameAsync(prefsBackupPath, prefsPath);
                }
              } catch (error) {
                (0, util_js_1.debugError)(error);
                reject(error);
              }
            }
            fulfill();
          }
        });
      }), "f");
      __classPrivateFieldSet(this, _BrowserRunner_listeners, [(0, util_js_1.addEventListener)(process, "exit", this.kill.bind(this))], "f");
      if (handleSIGINT) {
        __classPrivateFieldGet(this, _BrowserRunner_listeners, "f").push((0, util_js_1.addEventListener)(process, "SIGINT", () => {
          this.kill();
          process.exit(130);
        }));
      }
      if (handleSIGTERM) {
        __classPrivateFieldGet(this, _BrowserRunner_listeners, "f").push((0, util_js_1.addEventListener)(process, "SIGTERM", this.close.bind(this)));
      }
      if (handleSIGHUP) {
        __classPrivateFieldGet(this, _BrowserRunner_listeners, "f").push((0, util_js_1.addEventListener)(process, "SIGHUP", this.close.bind(this)));
      }
    }
    close() {
      if (__classPrivateFieldGet(this, _BrowserRunner_closed, "f")) {
        return Promise.resolve();
      }
      if (__classPrivateFieldGet(this, _BrowserRunner_isTempUserDataDir, "f")) {
        this.kill();
      } else if (this.connection) {
        this.connection.send("Browser.close").catch((error) => {
          (0, util_js_1.debugError)(error);
          this.kill();
        });
      }
      (0, util_js_1.removeEventListeners)(__classPrivateFieldGet(this, _BrowserRunner_listeners, "f"));
      return __classPrivateFieldGet(this, _BrowserRunner_processClosing, "f");
    }
    kill() {
      if (this.proc && this.proc.pid && pidExists(this.proc.pid)) {
        const proc = this.proc;
        try {
          if (process.platform === "win32") {
            childProcess.exec(`taskkill /pid ${this.proc.pid} /T /F`, (error) => {
              if (error) {
                proc.kill();
              }
            });
          } else {
            const processGroupId = -this.proc.pid;
            try {
              process.kill(processGroupId, "SIGKILL");
            } catch (error) {
              proc.kill("SIGKILL");
            }
          }
        } catch (error) {
          throw new Error(`${PROCESS_ERROR_EXPLANATION}
Error cause: ${(0, ErrorLike_js_1.isErrorLike)(error) ? error.stack : error}`);
        }
      }
      try {
        if (__classPrivateFieldGet(this, _BrowserRunner_isTempUserDataDir, "f")) {
          rimraf_1.default.sync(__classPrivateFieldGet(this, _BrowserRunner_userDataDir, "f"));
        }
      } catch (error) {}
      (0, util_js_1.removeEventListeners)(__classPrivateFieldGet(this, _BrowserRunner_listeners, "f"));
    }
    async setupWebDriverBiDiConnection(options) {
      (0, assert_js_1.assert)(this.proc, "BrowserRunner not started.");
      const { timeout, slowMo, preferredRevision } = options;
      let browserWSEndpoint = await waitForWSEndpoint(this.proc, timeout, preferredRevision, /^WebDriver BiDi listening on (ws:\/\/.*)$/);
      browserWSEndpoint += "/session";
      const transport = await NodeWebSocketTransport_js_1.NodeWebSocketTransport.create(browserWSEndpoint);
      return new Connection_js_1.Connection(transport, slowMo);
    }
    async setupConnection(options) {
      (0, assert_js_1.assert)(this.proc, "BrowserRunner not started.");
      const { usePipe, timeout, slowMo, preferredRevision } = options;
      if (!usePipe) {
        const browserWSEndpoint = await waitForWSEndpoint(this.proc, timeout, preferredRevision);
        const transport = await NodeWebSocketTransport_js_1.NodeWebSocketTransport.create(browserWSEndpoint);
        this.connection = new Connection_js_2.Connection(browserWSEndpoint, transport, slowMo);
      } else {
        const { 3: pipeWrite, 4: pipeRead } = this.proc.stdio;
        const transport = new PipeTransport_js_1.PipeTransport(pipeWrite, pipeRead);
        this.connection = new Connection_js_2.Connection("", transport, slowMo);
      }
      return this.connection;
    }
  }
  exports.BrowserRunner = BrowserRunner;
  _BrowserRunner_product = new WeakMap, _BrowserRunner_executablePath = new WeakMap, _BrowserRunner_processArguments = new WeakMap, _BrowserRunner_userDataDir = new WeakMap, _BrowserRunner_isTempUserDataDir = new WeakMap, _BrowserRunner_closed = new WeakMap, _BrowserRunner_listeners = new WeakMap, _BrowserRunner_processClosing = new WeakMap;
  function waitForWSEndpoint(browserProcess, timeout, preferredRevision, regex = /^DevTools listening on (ws:\/\/.*)$/) {
    (0, assert_js_1.assert)(browserProcess.stderr, "`browserProcess` does not have stderr.");
    const rl = readline.createInterface(browserProcess.stderr);
    let stderr = "";
    return new Promise((resolve, reject) => {
      const listeners = [
        (0, util_js_1.addEventListener)(rl, "line", onLine),
        (0, util_js_1.addEventListener)(rl, "close", () => {
          return onClose();
        }),
        (0, util_js_1.addEventListener)(browserProcess, "exit", () => {
          return onClose();
        }),
        (0, util_js_1.addEventListener)(browserProcess, "error", (error) => {
          return onClose(error);
        })
      ];
      const timeoutId = timeout ? setTimeout(onTimeout, timeout) : 0;
      function onClose(error) {
        cleanup();
        reject(new Error([
          "Failed to launch the browser process!" + (error ? " " + error.message : ""),
          stderr,
          "",
          "TROUBLESHOOTING: https://github.com/puppeteer/puppeteer/blob/main/docs/troubleshooting.md",
          ""
        ].join(`
`)));
      }
      function onTimeout() {
        cleanup();
        reject(new Errors_js_1.TimeoutError(`Timed out after ${timeout} ms while trying to connect to the browser! Only Chrome at revision r${preferredRevision} is guaranteed to work.`));
      }
      function onLine(line) {
        stderr += line + `
`;
        const match = line.match(regex);
        if (!match) {
          return;
        }
        cleanup();
        resolve(match[1]);
      }
      function cleanup() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        (0, util_js_1.removeEventListeners)(listeners);
      }
    });
  }
  function pidExists(pid) {
    try {
      return process.kill(pid, 0);
    } catch (error) {
      if ((0, ErrorLike_js_1.isErrnoException)(error)) {
        if (error.code && error.code === "ESRCH") {
          return false;
        }
      }
      throw error;
    }
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/util.js
var require_util2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getPackageDirectory = exports.tmpdir = undefined;
  var fs_1 = __require("fs");
  var path_1 = __require("path");
  var os_1 = __require("os");
  var tmpdir = () => {
    return process.env["PUPPETEER_TMP_DIR"] || (0, os_1.tmpdir)();
  };
  exports.tmpdir = tmpdir;
  var getPackageDirectory = (from) => {
    let found = (0, fs_1.existsSync)((0, path_1.join)(from, "package.json"));
    const root = (0, path_1.parse)(from).root;
    while (!found) {
      if (from === root) {
        throw new Error("Cannot find package directory");
      }
      from = (0, path_1.dirname)(from);
      found = (0, fs_1.existsSync)((0, path_1.join)(from, "package.json"));
    }
    return from;
  };
  exports.getPackageDirectory = getPackageDirectory;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/ChromeLauncher.js
var require_ChromeLauncher = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChromeLauncher = undefined;
  var fs_1 = __importDefault(__require("fs"));
  var path_1 = __importDefault(__require("path"));
  var Browser_js_1 = require_Browser2();
  var assert_js_1 = require_assert();
  var BrowserRunner_js_1 = require_BrowserRunner();
  var ProductLauncher_js_1 = require_ProductLauncher();
  var util_js_1 = require_util2();

  class ChromeLauncher {
    constructor(projectRoot, preferredRevision, isPuppeteerCore) {
      this._projectRoot = projectRoot;
      this._preferredRevision = preferredRevision;
      this._isPuppeteerCore = isPuppeteerCore;
    }
    async launch(options = {}) {
      const { ignoreDefaultArgs = false, args = [], dumpio = false, channel, executablePath, pipe = false, env = process.env, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, slowMo = 0, timeout = 30000, waitForInitialPage = true, debuggingPort } = options;
      const chromeArguments = [];
      if (!ignoreDefaultArgs) {
        chromeArguments.push(...this.defaultArgs(options));
      } else if (Array.isArray(ignoreDefaultArgs)) {
        chromeArguments.push(...this.defaultArgs(options).filter((arg) => {
          return !ignoreDefaultArgs.includes(arg);
        }));
      } else {
        chromeArguments.push(...args);
      }
      if (!chromeArguments.some((argument) => {
        return argument.startsWith("--remote-debugging-");
      })) {
        if (pipe) {
          (0, assert_js_1.assert)(!debuggingPort, "Browser should be launched with either pipe or debugging port - not both.");
          chromeArguments.push("--remote-debugging-pipe");
        } else {
          chromeArguments.push(`--remote-debugging-port=${debuggingPort || 0}`);
        }
      }
      let isTempUserDataDir = false;
      let userDataDirIndex = chromeArguments.findIndex((arg) => {
        return arg.startsWith("--user-data-dir");
      });
      if (userDataDirIndex < 0) {
        isTempUserDataDir = true;
        chromeArguments.push(`--user-data-dir=${await fs_1.default.promises.mkdtemp(path_1.default.join((0, util_js_1.tmpdir)(), "puppeteer_dev_chrome_profile-"))}`);
        userDataDirIndex = chromeArguments.length - 1;
      }
      const userDataDir = chromeArguments[userDataDirIndex].split("=", 2)[1];
      (0, assert_js_1.assert)(typeof userDataDir === "string", "`--user-data-dir` is malformed");
      let chromeExecutable = executablePath;
      if (channel) {
        (0, assert_js_1.assert)(!chromeExecutable, "`executablePath` must not be specified when `channel` is given.");
        chromeExecutable = (0, ProductLauncher_js_1.executablePathForChannel)(channel);
      } else if (!chromeExecutable) {
        const { missingText, executablePath: executablePath2 } = (0, ProductLauncher_js_1.resolveExecutablePath)(this);
        if (missingText) {
          throw new Error(missingText);
        }
        chromeExecutable = executablePath2;
      }
      const usePipe = chromeArguments.includes("--remote-debugging-pipe");
      const runner = new BrowserRunner_js_1.BrowserRunner(this.product, chromeExecutable, chromeArguments, userDataDir, isTempUserDataDir);
      runner.start({
        handleSIGHUP,
        handleSIGTERM,
        handleSIGINT,
        dumpio,
        env,
        pipe: usePipe
      });
      let browser;
      try {
        const connection = await runner.setupConnection({
          usePipe,
          timeout,
          slowMo,
          preferredRevision: this._preferredRevision
        });
        browser = await Browser_js_1.CDPBrowser._create(this.product, connection, [], ignoreHTTPSErrors, defaultViewport, runner.proc, runner.close.bind(runner), options.targetFilter);
      } catch (error) {
        runner.kill();
        throw error;
      }
      if (waitForInitialPage) {
        try {
          await browser.waitForTarget((t) => {
            return t.type() === "page";
          }, { timeout });
        } catch (error) {
          await browser.close();
          throw error;
        }
      }
      return browser;
    }
    defaultArgs(options = {}) {
      const chromeArguments = [
        "--allow-pre-commit-input",
        "--disable-background-networking",
        "--enable-features=NetworkServiceInProcess2",
        "--disable-background-timer-throttling",
        "--disable-backgrounding-occluded-windows",
        "--disable-breakpad",
        "--disable-client-side-phishing-detection",
        "--disable-component-extensions-with-background-pages",
        "--disable-default-apps",
        "--disable-dev-shm-usage",
        "--disable-extensions",
        "--disable-features=Translate,BackForwardCache,AcceptCHFrame,AvoidUnnecessaryBeforeUnloadCheckSync",
        "--disable-hang-monitor",
        "--disable-ipc-flooding-protection",
        "--disable-popup-blocking",
        "--disable-prompt-on-repost",
        "--disable-renderer-backgrounding",
        "--disable-sync",
        "--force-color-profile=srgb",
        "--metrics-recording-only",
        "--no-first-run",
        "--enable-automation",
        "--password-store=basic",
        "--use-mock-keychain",
        "--enable-blink-features=IdleDetection",
        "--export-tagged-pdf"
      ];
      const { devtools = false, headless = !devtools, args = [], userDataDir } = options;
      if (userDataDir) {
        chromeArguments.push(`--user-data-dir=${path_1.default.resolve(userDataDir)}`);
      }
      if (devtools) {
        chromeArguments.push("--auto-open-devtools-for-tabs");
      }
      if (headless) {
        chromeArguments.push(headless === "chrome" ? "--headless=chrome" : "--headless", "--hide-scrollbars", "--mute-audio");
      }
      if (args.every((arg) => {
        return arg.startsWith("-");
      })) {
        chromeArguments.push("about:blank");
      }
      chromeArguments.push(...args);
      return chromeArguments;
    }
    executablePath(channel) {
      if (channel) {
        return (0, ProductLauncher_js_1.executablePathForChannel)(channel);
      } else {
        const results2 = (0, ProductLauncher_js_1.resolveExecutablePath)(this);
        return results2.executablePath;
      }
    }
    get product() {
      return "chrome";
    }
  }
  exports.ChromeLauncher = ChromeLauncher;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Page.js
var require_Page3 = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Page_connection;
  var _Page_contextId;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Page = undefined;
  var Page_js_1 = require_Page();

  class Page extends Page_js_1.Page {
    constructor(connection, contextId) {
      super();
      _Page_connection.set(this, undefined);
      _Page_contextId.set(this, undefined);
      __classPrivateFieldSet(this, _Page_connection, connection, "f");
      __classPrivateFieldSet(this, _Page_contextId, contextId, "f");
    }
    async close() {
      await __classPrivateFieldGet(this, _Page_connection, "f").send("browsingContext.close", {
        context: __classPrivateFieldGet(this, _Page_contextId, "f")
      });
    }
    async evaluate(pageFunction, ..._args) {
      const str = `(${pageFunction.toString()})()`;
      const result = await __classPrivateFieldGet(this, _Page_connection, "f").send("script.evaluate", {
        expression: str,
        target: { context: __classPrivateFieldGet(this, _Page_contextId, "f") },
        awaitPromise: true
      });
      return result.result.value;
    }
  }
  exports.Page = Page;
  _Page_connection = new WeakMap, _Page_contextId = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/BrowserContext.js
var require_BrowserContext = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _BrowserContext_connection;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BrowserContext = undefined;
  var Browser_js_1 = require_Browser();
  var Page_js_1 = require_Page3();

  class BrowserContext extends Browser_js_1.BrowserContext {
    constructor(connection) {
      super();
      _BrowserContext_connection.set(this, undefined);
      __classPrivateFieldSet(this, _BrowserContext_connection, connection, "f");
    }
    async newPage() {
      const result = await __classPrivateFieldGet(this, _BrowserContext_connection, "f").send("browsingContext.create", {
        type: "tab"
      });
      return new Page_js_1.Page(__classPrivateFieldGet(this, _BrowserContext_connection, "f"), result.context);
    }
    async close() {}
  }
  exports.BrowserContext = BrowserContext;
  _BrowserContext_connection = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Browser.js
var require_Browser3 = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Browser_process;
  var _Browser_closeCallback;
  var _Browser_connection;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Browser = undefined;
  var Browser_js_1 = require_Browser();
  var BrowserContext_js_1 = require_BrowserContext();

  class Browser extends Browser_js_1.Browser {
    constructor(opts) {
      super();
      _Browser_process.set(this, undefined);
      _Browser_closeCallback.set(this, undefined);
      _Browser_connection.set(this, undefined);
      __classPrivateFieldSet(this, _Browser_process, opts.process, "f");
      __classPrivateFieldSet(this, _Browser_closeCallback, opts.closeCallback, "f");
      __classPrivateFieldSet(this, _Browser_connection, opts.connection, "f");
    }
    static async create(opts) {
      await opts.connection.send("session.new", {});
      return new Browser(opts);
    }
    async close() {
      var _a;
      await ((_a = __classPrivateFieldGet(this, _Browser_closeCallback, "f")) === null || _a === undefined ? undefined : _a.call(null));
      __classPrivateFieldGet(this, _Browser_connection, "f").dispose();
    }
    isConnected() {
      return !__classPrivateFieldGet(this, _Browser_connection, "f").closed;
    }
    process() {
      var _a;
      return (_a = __classPrivateFieldGet(this, _Browser_process, "f")) !== null && _a !== undefined ? _a : null;
    }
    async createIncognitoBrowserContext(_options) {
      return new BrowserContext_js_1.BrowserContext(__classPrivateFieldGet(this, _Browser_connection, "f"));
    }
  }
  exports.Browser = Browser;
  _Browser_process = new WeakMap, _Browser_closeCallback = new WeakMap, _Browser_connection = new WeakMap;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/FirefoxLauncher.js
var require_FirefoxLauncher = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FirefoxLauncher = undefined;
  var fs_1 = __importDefault(__require("fs"));
  var os_1 = __importDefault(__require("os"));
  var path_1 = __importDefault(__require("path"));
  var Browser_js_1 = require_Browser3();
  var Browser_js_2 = require_Browser2();
  var assert_js_1 = require_assert();
  var BrowserFetcher_js_1 = require_BrowserFetcher();
  var BrowserRunner_js_1 = require_BrowserRunner();
  var ProductLauncher_js_1 = require_ProductLauncher();
  var util_js_1 = require_util2();

  class FirefoxLauncher {
    constructor(projectRoot, preferredRevision, isPuppeteerCore) {
      this._projectRoot = projectRoot;
      this._preferredRevision = preferredRevision;
      this._isPuppeteerCore = isPuppeteerCore;
    }
    async launch(options = {}) {
      const { ignoreDefaultArgs = false, args = [], dumpio = false, executablePath = null, pipe = false, env = process.env, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, slowMo = 0, timeout = 30000, extraPrefsFirefox = {}, waitForInitialPage = true, debuggingPort = null, protocol = "cdp" } = options;
      const firefoxArguments = [];
      if (!ignoreDefaultArgs) {
        firefoxArguments.push(...this.defaultArgs(options));
      } else if (Array.isArray(ignoreDefaultArgs)) {
        firefoxArguments.push(...this.defaultArgs(options).filter((arg) => {
          return !ignoreDefaultArgs.includes(arg);
        }));
      } else {
        firefoxArguments.push(...args);
      }
      if (!firefoxArguments.some((argument) => {
        return argument.startsWith("--remote-debugging-");
      })) {
        if (pipe) {
          (0, assert_js_1.assert)(debuggingPort === null, "Browser should be launched with either pipe or debugging port - not both.");
        }
        firefoxArguments.push(`--remote-debugging-port=${debuggingPort || 0}`);
      }
      let userDataDir;
      let isTempUserDataDir = true;
      const profileArgIndex = firefoxArguments.findIndex((arg) => {
        return ["-profile", "--profile"].includes(arg);
      });
      if (profileArgIndex !== -1) {
        userDataDir = firefoxArguments[profileArgIndex + 1];
        if (!userDataDir || !fs_1.default.existsSync(userDataDir)) {
          throw new Error(`Firefox profile not found at '${userDataDir}'`);
        }
        isTempUserDataDir = false;
        const prefs = this.defaultPreferences(extraPrefsFirefox);
        this.writePreferences(prefs, userDataDir);
      } else {
        userDataDir = await this._createProfile(extraPrefsFirefox);
        firefoxArguments.push("--profile");
        firefoxArguments.push(userDataDir);
      }
      if (!this._isPuppeteerCore) {
        await this._updateRevision();
      }
      let firefoxExecutable = executablePath;
      if (!executablePath) {
        const { missingText, executablePath: executablePath2 } = (0, ProductLauncher_js_1.resolveExecutablePath)(this);
        if (missingText) {
          throw new Error(missingText);
        }
        firefoxExecutable = executablePath2;
      }
      if (!firefoxExecutable) {
        throw new Error("firefoxExecutable is not found.");
      }
      const runner = new BrowserRunner_js_1.BrowserRunner(this.product, firefoxExecutable, firefoxArguments, userDataDir, isTempUserDataDir);
      runner.start({
        handleSIGHUP,
        handleSIGTERM,
        handleSIGINT,
        dumpio,
        env,
        pipe
      });
      if (protocol === "webDriverBiDi") {
        let browser2;
        try {
          const connection = await runner.setupWebDriverBiDiConnection({
            timeout,
            slowMo,
            preferredRevision: this._preferredRevision
          });
          browser2 = await Browser_js_1.Browser.create({
            connection,
            closeCallback: runner.close.bind(runner),
            process: runner.proc
          });
        } catch (error) {
          runner.kill();
          throw error;
        }
        return browser2;
      }
      let browser;
      try {
        const connection = await runner.setupConnection({
          usePipe: pipe,
          timeout,
          slowMo,
          preferredRevision: this._preferredRevision
        });
        browser = await Browser_js_2.CDPBrowser._create(this.product, connection, [], ignoreHTTPSErrors, defaultViewport, runner.proc, runner.close.bind(runner), options.targetFilter);
      } catch (error) {
        runner.kill();
        throw error;
      }
      if (waitForInitialPage) {
        try {
          await browser.waitForTarget((t) => {
            return t.type() === "page";
          }, { timeout });
        } catch (error) {
          await browser.close();
          throw error;
        }
      }
      return browser;
    }
    executablePath() {
      return (0, ProductLauncher_js_1.resolveExecutablePath)(this).executablePath;
    }
    async _updateRevision() {
      if (this._preferredRevision === "latest") {
        if (!this._projectRoot) {
          throw new Error("_projectRoot is undefined. Unable to create a BrowserFetcher.");
        }
        const browserFetcher = new BrowserFetcher_js_1.BrowserFetcher(this._projectRoot, {
          product: this.product
        });
        const localRevisions = await browserFetcher.localRevisions();
        if (localRevisions[0]) {
          this._preferredRevision = localRevisions[0];
        }
      }
    }
    get product() {
      return "firefox";
    }
    defaultArgs(options = {}) {
      const { devtools = false, headless = !devtools, args = [], userDataDir = null } = options;
      const firefoxArguments = ["--no-remote"];
      switch (os_1.default.platform()) {
        case "darwin":
          firefoxArguments.push("--foreground");
          break;
        case "win32":
          firefoxArguments.push("--wait-for-browser");
          break;
      }
      if (userDataDir) {
        firefoxArguments.push("--profile");
        firefoxArguments.push(userDataDir);
      }
      if (headless) {
        firefoxArguments.push("--headless");
      }
      if (devtools) {
        firefoxArguments.push("--devtools");
      }
      if (args.every((arg) => {
        return arg.startsWith("-");
      })) {
        firefoxArguments.push("about:blank");
      }
      firefoxArguments.push(...args);
      return firefoxArguments;
    }
    defaultPreferences(extraPrefs) {
      const server = "dummy.test";
      const defaultPrefs = {
        "app.normandy.api_url": "",
        "app.update.checkInstallTime": false,
        "app.update.disabledForTesting": true,
        "apz.content_response_timeout": 60000,
        "browser.contentblocking.features.standard": "-tp,tpPrivate,cookieBehavior0,-cm,-fp",
        "browser.dom.window.dump.enabled": true,
        "browser.newtabpage.activity-stream.feeds.system.topstories": false,
        "browser.newtabpage.enabled": false,
        "browser.pagethumbnails.capturing_disabled": true,
        "browser.safebrowsing.blockedURIs.enabled": false,
        "browser.safebrowsing.downloads.enabled": false,
        "browser.safebrowsing.malware.enabled": false,
        "browser.safebrowsing.passwords.enabled": false,
        "browser.safebrowsing.phishing.enabled": false,
        "browser.search.update": false,
        "browser.sessionstore.resume_from_crash": false,
        "browser.shell.checkDefaultBrowser": false,
        "browser.startup.homepage": "about:blank",
        "browser.startup.homepage_override.mstone": "ignore",
        "browser.startup.page": 0,
        "browser.tabs.disableBackgroundZombification": false,
        "browser.tabs.warnOnCloseOtherTabs": false,
        "browser.tabs.warnOnOpen": false,
        "browser.uitour.enabled": false,
        "browser.urlbar.suggest.searches": false,
        "browser.usedOnWindows10.introURL": "",
        "browser.warnOnQuit": false,
        "datareporting.healthreport.documentServerURI": `http://${server}/dummy/healthreport/`,
        "datareporting.healthreport.logging.consoleEnabled": false,
        "datareporting.healthreport.service.enabled": false,
        "datareporting.healthreport.service.firstRun": false,
        "datareporting.healthreport.uploadEnabled": false,
        "datareporting.policy.dataSubmissionEnabled": false,
        "datareporting.policy.dataSubmissionPolicyBypassNotification": true,
        "devtools.jsonview.enabled": false,
        "dom.disable_open_during_load": false,
        "dom.file.createInChild": true,
        "dom.ipc.reportProcessHangs": false,
        "dom.max_chrome_script_run_time": 0,
        "dom.max_script_run_time": 0,
        "extensions.autoDisableScopes": 0,
        "extensions.enabledScopes": 5,
        "extensions.getAddons.cache.enabled": false,
        "extensions.installDistroAddons": false,
        "extensions.screenshots.disabled": true,
        "extensions.update.enabled": false,
        "extensions.update.notifyUser": false,
        "extensions.webservice.discoverURL": `http://${server}/dummy/discoveryURL`,
        "fission.bfcacheInParent": false,
        "fission.webContentIsolationStrategy": 0,
        "focusmanager.testmode": true,
        "general.useragent.updates.enabled": false,
        "geo.provider.testing": true,
        "geo.wifi.scan": false,
        "hangmonitor.timeout": 0,
        "javascript.options.showInConsole": true,
        "media.gmp-manager.updateEnabled": false,
        "network.cookie.cookieBehavior": 0,
        "network.cookie.sameSite.laxByDefault": false,
        "network.http.prompt-temp-redirect": false,
        "network.http.speculative-parallel-limit": 0,
        "network.manage-offline-status": false,
        "network.sntp.pools": server,
        "plugin.state.flash": 0,
        "privacy.trackingprotection.enabled": false,
        "remote.enabled": true,
        "security.certerrors.mitm.priming.enabled": false,
        "security.fileuri.strict_origin_policy": false,
        "security.notification_enable_delay": 0,
        "services.settings.server": `http://${server}/dummy/blocklist/`,
        "signon.autofillForms": false,
        "signon.rememberSignons": false,
        "startup.homepage_welcome_url": "about:blank",
        "startup.homepage_welcome_url.additional": "",
        "toolkit.cosmeticAnimations.enabled": false,
        "toolkit.startup.max_resumed_crashes": -1
      };
      return Object.assign(defaultPrefs, extraPrefs);
    }
    async writePreferences(prefs, profilePath) {
      const lines = Object.entries(prefs).map(([key2, value]) => {
        return `user_pref(${JSON.stringify(key2)}, ${JSON.stringify(value)});`;
      });
      await fs_1.default.promises.writeFile(path_1.default.join(profilePath, "user.js"), lines.join(`
`));
      const prefsPath = path_1.default.join(profilePath, "prefs.js");
      if (fs_1.default.existsSync(prefsPath)) {
        const prefsBackupPath = path_1.default.join(profilePath, "prefs.js.puppeteer");
        await fs_1.default.promises.copyFile(prefsPath, prefsBackupPath);
      }
    }
    async _createProfile(extraPrefs) {
      const temporaryProfilePath = await fs_1.default.promises.mkdtemp(path_1.default.join((0, util_js_1.tmpdir)(), "puppeteer_dev_firefox_profile-"));
      const prefs = this.defaultPreferences(extraPrefs);
      await this.writePreferences(prefs, temporaryProfilePath);
      return temporaryProfilePath;
    }
  }
  exports.FirefoxLauncher = FirefoxLauncher;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/ProductLauncher.js
var require_ProductLauncher = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLauncher = exports.resolveExecutablePath = exports.executablePathForChannel = undefined;
  var fs_1 = __require("fs");
  var os_1 = __importDefault(__require("os"));
  var BrowserFetcher_js_1 = require_BrowserFetcher();
  var ChromeLauncher_js_1 = require_ChromeLauncher();
  var FirefoxLauncher_js_1 = require_FirefoxLauncher();
  function executablePathForChannel(channel) {
    const platform = os_1.default.platform();
    let chromePath;
    switch (platform) {
      case "win32":
        switch (channel) {
          case "chrome":
            chromePath = `${process.env["PROGRAMFILES"]}\\Google\\Chrome\\Application\\chrome.exe`;
            break;
          case "chrome-beta":
            chromePath = `${process.env["PROGRAMFILES"]}\\Google\\Chrome Beta\\Application\\chrome.exe`;
            break;
          case "chrome-canary":
            chromePath = `${process.env["PROGRAMFILES"]}\\Google\\Chrome SxS\\Application\\chrome.exe`;
            break;
          case "chrome-dev":
            chromePath = `${process.env["PROGRAMFILES"]}\\Google\\Chrome Dev\\Application\\chrome.exe`;
            break;
        }
        break;
      case "darwin":
        switch (channel) {
          case "chrome":
            chromePath = "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome";
            break;
          case "chrome-beta":
            chromePath = "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta";
            break;
          case "chrome-canary":
            chromePath = "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary";
            break;
          case "chrome-dev":
            chromePath = "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev";
            break;
        }
        break;
      case "linux":
        switch (channel) {
          case "chrome":
            chromePath = "/opt/google/chrome/chrome";
            break;
          case "chrome-beta":
            chromePath = "/opt/google/chrome-beta/chrome";
            break;
          case "chrome-dev":
            chromePath = "/opt/google/chrome-unstable/chrome";
            break;
        }
        break;
    }
    if (!chromePath) {
      throw new Error(`Unable to detect browser executable path for '${channel}' on ${platform}.`);
    }
    try {
      (0, fs_1.accessSync)(chromePath);
    } catch (error) {
      throw new Error(`Could not find Google Chrome executable for channel '${channel}' at '${chromePath}'.`);
    }
    return chromePath;
  }
  exports.executablePathForChannel = executablePathForChannel;
  function resolveExecutablePath(launcher) {
    const { product, _isPuppeteerCore, _projectRoot, _preferredRevision } = launcher;
    let downloadPath;
    if (!_isPuppeteerCore) {
      const executablePath = process.env["PUPPETEER_EXECUTABLE_PATH"] || process.env["npm_config_puppeteer_executable_path"] || process.env["npm_package_config_puppeteer_executable_path"];
      if (executablePath) {
        const missingText2 = !(0, fs_1.existsSync)(executablePath) ? "Tried to use PUPPETEER_EXECUTABLE_PATH env variable to launch browser but did not find any executable at: " + executablePath : undefined;
        return { executablePath, missingText: missingText2 };
      }
      const ubuntuChromiumPath = "/usr/bin/chromium-browser";
      if (product === "chrome" && os_1.default.platform() !== "darwin" && os_1.default.arch() === "arm64" && (0, fs_1.existsSync)(ubuntuChromiumPath)) {
        return { executablePath: ubuntuChromiumPath, missingText: undefined };
      }
      downloadPath = process.env["PUPPETEER_DOWNLOAD_PATH"] || process.env["npm_config_puppeteer_download_path"] || process.env["npm_package_config_puppeteer_download_path"];
    }
    if (!_projectRoot) {
      throw new Error("_projectRoot is undefined. Unable to create a BrowserFetcher.");
    }
    const browserFetcher = new BrowserFetcher_js_1.BrowserFetcher(_projectRoot, {
      product,
      path: downloadPath
    });
    if (!_isPuppeteerCore && product === "chrome") {
      const revision = process.env["PUPPETEER_CHROMIUM_REVISION"];
      if (revision) {
        const revisionInfo2 = browserFetcher.revisionInfo(revision);
        const missingText2 = !revisionInfo2.local ? "Tried to use PUPPETEER_CHROMIUM_REVISION env variable to launch browser but did not find executable at: " + revisionInfo2.executablePath : undefined;
        return { executablePath: revisionInfo2.executablePath, missingText: missingText2 };
      }
    }
    const revisionInfo = browserFetcher.revisionInfo(_preferredRevision);
    const firefoxHelp = `Run \`PUPPETEER_PRODUCT=firefox npm install\` to download a supported Firefox browser binary.`;
    const chromeHelp = `Run \`npm install\` to download the correct Chromium revision (${launcher._preferredRevision}).`;
    const missingText = !revisionInfo.local ? `Could not find expected browser (${product}) locally. ${product === "chrome" ? chromeHelp : firefoxHelp}` : undefined;
    return { executablePath: revisionInfo.executablePath, missingText };
  }
  exports.resolveExecutablePath = resolveExecutablePath;
  function createLauncher(projectRoot, preferredRevision, isPuppeteerCore, product = "chrome") {
    switch (product) {
      case "firefox":
        return new FirefoxLauncher_js_1.FirefoxLauncher(projectRoot, preferredRevision, isPuppeteerCore);
      case "chrome":
        return new ChromeLauncher_js_1.ChromeLauncher(projectRoot, preferredRevision, isPuppeteerCore);
    }
  }
  exports.createLauncher = createLauncher;
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/PuppeteerNode.js
var require_PuppeteerNode = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _PuppeteerNode_launcher;
  var _PuppeteerNode_projectRoot;
  var _PuppeteerNode_productName;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PuppeteerNode = undefined;
  var Puppeteer_js_1 = require_Puppeteer();
  var revisions_js_1 = require_revisions();
  var BrowserFetcher_js_1 = require_BrowserFetcher();
  var ProductLauncher_js_1 = require_ProductLauncher();

  class PuppeteerNode extends Puppeteer_js_1.Puppeteer {
    constructor(settings) {
      const { projectRoot, preferredRevision, productName, ...commonSettings } = settings;
      super(commonSettings);
      _PuppeteerNode_launcher.set(this, undefined);
      _PuppeteerNode_projectRoot.set(this, undefined);
      _PuppeteerNode_productName.set(this, undefined);
      this._preferredRevision = revisions_js_1.PUPPETEER_REVISIONS.chromium;
      __classPrivateFieldSet(this, _PuppeteerNode_projectRoot, projectRoot, "f");
      __classPrivateFieldSet(this, _PuppeteerNode_productName, productName, "f");
      if (preferredRevision) {
        this._preferredRevision = preferredRevision;
      }
      this.connect = this.connect.bind(this);
      this.launch = this.launch.bind(this);
      this.executablePath = this.executablePath.bind(this);
      this.defaultArgs = this.defaultArgs.bind(this);
      this.createBrowserFetcher = this.createBrowserFetcher.bind(this);
    }
    connect(options) {
      return super.connect(options);
    }
    get _productName() {
      return __classPrivateFieldGet(this, _PuppeteerNode_productName, "f");
    }
    set _productName(name) {
      if (__classPrivateFieldGet(this, _PuppeteerNode_productName, "f") !== name) {
        this._changedProduct = true;
      }
      __classPrivateFieldSet(this, _PuppeteerNode_productName, name, "f");
    }
    launch(options = {}) {
      if (options.product) {
        this._productName = options.product;
      }
      return this._launcher.launch(options);
    }
    executablePath(channel) {
      return this._launcher.executablePath(channel);
    }
    get _launcher() {
      if (!__classPrivateFieldGet(this, _PuppeteerNode_launcher, "f") || __classPrivateFieldGet(this, _PuppeteerNode_launcher, "f").product !== this._productName || this._changedProduct) {
        switch (this._productName) {
          case "firefox":
            this._preferredRevision = revisions_js_1.PUPPETEER_REVISIONS.firefox;
            break;
          case "chrome":
          default:
            this._preferredRevision = revisions_js_1.PUPPETEER_REVISIONS.chromium;
        }
        this._changedProduct = false;
        __classPrivateFieldSet(this, _PuppeteerNode_launcher, (0, ProductLauncher_js_1.createLauncher)(__classPrivateFieldGet(this, _PuppeteerNode_projectRoot, "f"), this._preferredRevision, this._isPuppeteerCore, this._productName), "f");
      }
      return __classPrivateFieldGet(this, _PuppeteerNode_launcher, "f");
    }
    get product() {
      return this._launcher.product;
    }
    defaultArgs(options = {}) {
      return this._launcher.defaultArgs(options);
    }
    createBrowserFetcher(options) {
      if (!__classPrivateFieldGet(this, _PuppeteerNode_projectRoot, "f")) {
        throw new Error("_projectRoot is undefined. Unable to create a BrowserFetcher.");
      }
      return new BrowserFetcher_js_1.BrowserFetcher(__classPrivateFieldGet(this, _PuppeteerNode_projectRoot, "f"), options);
    }
  }
  exports.PuppeteerNode = PuppeteerNode;
  _PuppeteerNode_launcher = new WeakMap, _PuppeteerNode_projectRoot = new WeakMap, _PuppeteerNode_productName = new WeakMap;
});

// node_modules/puppeteer/lib/cjs/puppeteer/puppeteer.js
var require_puppeteer = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m2[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
    for (var p in m2)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.launch = exports.executablePath = exports.defaultArgs = exports.createBrowserFetcher = exports.connect = exports.BrowserFetcher = undefined;
  __exportStar(require_DeviceDescriptors(), exports);
  __exportStar(require_Errors(), exports);
  __exportStar(require_NetworkConditions(), exports);
  __exportStar(require_QueryHandler(), exports);
  var BrowserFetcher_js_1 = require_BrowserFetcher();
  Object.defineProperty(exports, "BrowserFetcher", { enumerable: true, get: function() {
    return BrowserFetcher_js_1.BrowserFetcher;
  } });
  var constants_js_1 = require_constants();
  var PuppeteerNode_js_1 = require_PuppeteerNode();
  var util_js_1 = require_util2();
  var revisions_js_1 = require_revisions();
  var productName = process.env["PUPPETEER_PRODUCT"] || process.env["npm_config_puppeteer_product"] || process.env["npm_package_config_puppeteer_product"];
  var preferredRevision;
  switch (productName) {
    case "firefox":
      preferredRevision = revisions_js_1.PUPPETEER_REVISIONS.firefox;
      break;
    default:
      preferredRevision = revisions_js_1.PUPPETEER_REVISIONS.chromium;
  }
  var puppeteer = new PuppeteerNode_js_1.PuppeteerNode({
    projectRoot: (0, util_js_1.getPackageDirectory)(constants_js_1.rootDirname),
    preferredRevision,
    isPuppeteerCore: false,
    productName
  });
  exports.connect = puppeteer.connect, exports.createBrowserFetcher = puppeteer.createBrowserFetcher, exports.defaultArgs = puppeteer.defaultArgs, exports.executablePath = puppeteer.executablePath, exports.launch = puppeteer.launch;
  exports.default = puppeteer;
});

// node_modules/@pedroslopez/moduleraid/moduleraid.js
var require_moduleraid = __commonJS((exports, module) => {
  var moduleRaid2 = function() {
    moduleRaid2.mID = Math.random().toString(36).substring(7);
    moduleRaid2.mObj = {};
    fillModuleArray = function() {
      (window.webpackChunkbuild || window.webpackChunkwhatsapp_web_client).push([
        [moduleRaid2.mID],
        {},
        function(e) {
          Object.keys(e.m).forEach(function(mod2) {
            moduleRaid2.mObj[mod2] = e(mod2);
          });
        }
      ]);
    };
    fillModuleArray();
    get = function get(id) {
      return moduleRaid2.mObj[id];
    };
    findModule = function findModule(query) {
      results = [];
      modules = Object.keys(moduleRaid2.mObj);
      modules.forEach(function(mKey) {
        mod = moduleRaid2.mObj[mKey];
        if (typeof mod !== "undefined") {
          if (typeof query === "string") {
            if (typeof mod.default === "object") {
              for (key in mod.default) {
                if (key == query)
                  results.push(mod);
              }
            }
            for (key in mod) {
              if (key == query)
                results.push(mod);
            }
          } else if (typeof query === "function") {
            if (query(mod)) {
              results.push(mod);
            }
          } else {
            throw new TypeError("findModule can only find via string and function, " + typeof query + " was passed");
          }
        }
      });
      return results;
    };
    return {
      modules: moduleRaid2.mObj,
      constructors: moduleRaid2.cArr,
      findModule,
      get
    };
  };
  if (typeof module === "object" && module.exports) {
    module.exports = moduleRaid2;
  } else {
    window.mR = moduleRaid2();
  }
});

// node_modules/node-webpmux/io.js
var require_io = __commonJS((exports, module) => {
  var fs = {};
  if (typeof window === "undefined") {
    const _fs = __require("fs");
    const { promisify } = __require("util");
    const { basename } = __require("path");
    fs = {
      read: promisify(_fs.read),
      write: promisify(_fs.write),
      open: promisify(_fs.open),
      close: promisify(_fs.close),
      basename,
      avail: true
    };
  } else {
    let f = async () => {
      throw new Error("Running inside a browser; filesystem support is not available");
    };
    fs = {
      read: f,
      write: f,
      open: f,
      close: f,
      basename: f,
      err: f,
      avail: false
    };
  }
  module.exports = fs;
});

// node_modules/node-webpmux/parser.js
var require_parser = __commonJS((exports, module) => {
  var IO = require_io();
  var nullByte = Buffer.alloc(1);
  nullByte[0] = 0;
  var intfTypes = {
    NONE: 0,
    FILE: 1,
    BUFFER: 2
  };
  var constants = {
    TYPE_LOSSY: 0,
    TYPE_LOSSLESS: 1,
    TYPE_EXTENDED: 2
  };
  function VP8Width(data) {
    return (data[7] << 8 | data[6]) & 16383;
  }
  function VP8Height(data) {
    return (data[9] << 8 | data[8]) & 16383;
  }
  function VP8LWidth(data) {
    return ((data[2] << 8 | data[1]) & 16383) + 1;
  }
  function VP8LHeight(data) {
    return ((data[4] << 16 | data[3] << 8 | data[2]) >> 6 & 16383) + 1;
  }
  function doesVP8LHaveAlpha(data) {
    return !!(data[4] & 16);
  }
  function createBasicChunk(name, data) {
    let header = Buffer.alloc(8), size = data.length;
    header.write(name, 0);
    header.writeUInt32LE(size, 4);
    if (size & 1) {
      return { size: size + 9, chunks: [header, data, nullByte] };
    } else {
      return { size: size + 8, chunks: [header, data] };
    }
  }

  class WebPReader {
    constructor() {
      this.type = intfTypes.NONE;
    }
    readFile(path) {
      this.type = intfTypes.FILE;
      this.path = path;
    }
    readBuffer(buf) {
      this.type = intfTypes.BUFFER;
      this.buf = buf;
      this.cursor = 0;
    }
    async readBytes(n, mod2) {
      let { type } = this;
      if (type == intfTypes.FILE) {
        let b = Buffer.alloc(n), br;
        br = (await IO.read(this.fp, b, 0, n, undefined)).bytesRead;
        return mod2 ? b : br == n ? b : undefined;
      } else if (type == intfTypes.BUFFER) {
        let b = this.buf.slice(this.cursor, this.cursor + n);
        this.cursor += n;
        return b;
      } else {
        throw new Error("Reader not initialized");
      }
    }
    async readFileHeader() {
      let buf = await this.readBytes(12);
      if (buf === undefined) {
        throw new Error("Reached end while reading header");
      }
      if (buf.toString("utf8", 0, 4) != "RIFF") {
        throw new Error("Bad header (not RIFF)");
      }
      if (buf.toString("utf8", 8, 12) != "WEBP") {
        throw new Error("Bad header (not WEBP)");
      }
      return { fileSize: buf.readUInt32LE(4) };
    }
    async readChunkHeader() {
      let buf = await this.readBytes(8, true);
      if (buf.length == 0) {
        return { fourCC: "\x00\x00\x00\x00", size: 0 };
      } else if (buf.length < 8) {
        throw new Error("Reached end while reading chunk header");
      }
      return { fourCC: buf.toString("utf8", 0, 4), size: buf.readUInt32LE(4) };
    }
    async readChunkContents(size) {
      let buf = await this.readBytes(size);
      if (size & 1) {
        await this.readBytes(1);
      }
      return buf;
    }
    async readChunk_raw(n, size) {
      let buf = await this.readChunkContents(size);
      if (buf === undefined) {
        throw new Error(`Reached end while reading ${n} chunk`);
      }
      return { raw: buf };
    }
    async readChunk_VP8(size) {
      let buf = await this.readChunkContents(size);
      if (buf === undefined) {
        throw new Error("Reached end while reading VP8 chunk");
      }
      return { raw: buf, width: VP8Width(buf), height: VP8Height(buf) };
    }
    async readChunk_VP8L(size) {
      let buf = await this.readChunkContents(size);
      if (buf === undefined) {
        throw new Error("Reached end while reading VP8L chunk");
      }
      return { raw: buf, alpha: doesVP8LHaveAlpha(buf), width: VP8LWidth(buf), height: VP8LHeight(buf) };
    }
    async readChunk_VP8X(size) {
      let buf = await this.readChunkContents(size);
      if (buf === undefined) {
        throw new Error("Reached end while reading VP8X chunk");
      }
      return {
        raw: buf,
        hasICCP: !!(buf[0] & 32),
        hasAlpha: !!(buf[0] & 16),
        hasEXIF: !!(buf[0] & 8),
        hasXMP: !!(buf[0] & 4),
        hasAnim: !!(buf[0] & 2),
        width: buf.readUIntLE(4, 3) + 1,
        height: buf.readUIntLE(7, 3) + 1
      };
    }
    async readChunk_ANIM(size) {
      let buf = await this.readChunkContents(size);
      if (buf === undefined) {
        throw new Error("Reached end while reading ANIM chunk");
      }
      return { raw: buf, bgColor: buf.slice(0, 4), loops: buf.readUInt16LE(4) };
    }
    async readChunk_ANMF(size) {
      let buf = await this.readChunkContents(size);
      if (buf === undefined) {
        throw new Error("Reached end while reading ANMF chunk");
      }
      let out = {
        raw: buf,
        x: buf.readUIntLE(0, 3),
        y: buf.readUIntLE(3, 3),
        width: buf.readUIntLE(6, 3) + 1,
        height: buf.readUIntLE(9, 3) + 1,
        delay: buf.readUIntLE(12, 3),
        blend: !(buf[15] & 2),
        dispose: !!(buf[15] & 1)
      }, keepLooping = true, anmfReader = new WebPReader;
      anmfReader.readBuffer(buf);
      anmfReader.cursor = 16;
      while (keepLooping) {
        let header = await anmfReader.readChunkHeader();
        switch (header.fourCC) {
          case "VP8 ":
            if (!out.vp8) {
              out.type = constants.TYPE_LOSSY;
              out.vp8 = await anmfReader.readChunk_VP8(header.size);
              if (out.alph) {
                out.vp8.alpha = true;
              }
            }
            break;
          case "VP8L":
            if (!out.vp8l) {
              out.type = constants.TYPE_LOSSLESS;
              out.vp8l = await anmfReader.readChunk_VP8L(header.size);
            }
            break;
          case "ALPH":
            if (!out.alph) {
              out.alph = await anmfReader.readChunk_ALPH(header.size);
              if (out.vp8) {
                out.vp8.alpha = true;
              }
            }
            break;
          case "\x00\x00\x00\x00":
          default:
            keepLooping = false;
            break;
        }
        if (anmfReader.cursor >= buf.length) {
          break;
        }
      }
      return out;
    }
    async readChunk_ALPH(size) {
      return this.readChunk_raw("ALPH", size);
    }
    async readChunk_ICCP(size) {
      return this.readChunk_raw("ICCP", size);
    }
    async readChunk_EXIF(size) {
      return this.readChunk_raw("EXIF", size);
    }
    async readChunk_XMP(size) {
      return this.readChunk_raw("XMP ", size);
    }
    async readChunk_skip(size) {
      let buf = await this.readChunkContents(size);
      if (buf === undefined) {
        throw new Error("Reached end while skipping chunk");
      }
    }
    async read() {
      if (this.type == intfTypes.FILE) {
        this.fp = await IO.open(this.path, "r");
      }
      let keepLooping = true, first = true, { fileSize } = await this.readFileHeader(), out = {};
      while (keepLooping) {
        let { fourCC, size } = await this.readChunkHeader();
        switch (fourCC) {
          case "VP8 ":
            if (!out.vp8) {
              out.vp8 = await this.readChunk_VP8(size);
              if (out.alph) {
                out.vp8.alpha = true;
              }
              if (first) {
                out.type = constants.TYPE_LOSSY;
                keepLooping = false;
              }
            } else {
              await this.readChunk_skip(size);
            }
            break;
          case "VP8L":
            if (!out.vp8l) {
              out.vp8l = await this.readChunk_VP8L(size);
              if (first) {
                out.type = constants.TYPE_LOSSLESS;
                keepLooping = false;
              }
            } else {
              await this.readChunk_skip(size);
            }
            break;
          case "VP8X":
            if (!out.extended) {
              out.type = constants.TYPE_EXTENDED;
              out.extended = await this.readChunk_VP8X(size);
            } else {
              await this.readChunk_skip(size);
            }
            break;
          case "ANIM":
            if (!out.anim) {
              let { raw, bgColor, loops } = await this.readChunk_ANIM(size);
              out.anim = {
                bgColor: [bgColor[2], bgColor[1], bgColor[0], bgColor[3]],
                loops,
                frames: [],
                raw
              };
            } else {
              await this.readChunk_skip(size);
            }
            break;
          case "ANMF":
            out.anim.frames.push(await this.readChunk_ANMF(size));
            break;
          case "ALPH":
            if (!out.alph) {
              out.alph = await this.readChunk_ALPH(size);
              if (out.vp8) {
                out.vp8.alpha = true;
              }
            } else {
              await this.readChunk_skip(size);
            }
            break;
          case "ICCP":
            if (!out.iccp) {
              out.iccp = await this.readChunk_ICCP(size);
            } else {
              await this.readChunk_skip(size);
            }
            break;
          case "EXIF":
            if (!out.exif) {
              out.exif = await this.readChunk_EXIF(size);
            } else {
              await this.readChunk_skip(size);
            }
            break;
          case "XMP ":
            if (!out.xmp) {
              out.xmp = await this.readChunk_XMP(size);
            } else {
              await this.readChunk_skip(size);
            }
            break;
          case "\x00\x00\x00\x00":
            keepLooping = false;
            break;
          default:
            await this.readChunk_skip(size);
            break;
        }
        first = false;
      }
      if (this.type == intfTypes.FILE) {
        await IO.close(this.fp);
      }
      return out;
    }
  }

  class WebPWriter {
    constructor() {
      this.type = intfTypes.NONE;
      this.chunks = [];
      this.width = this.height = 0;
    }
    reset() {
      this.chunks.length = 0;
      width = 0;
      height = 0;
    }
    writeFile(path) {
      this.type = intfTypes.FILE;
      this.path = path;
    }
    writeBuffer() {
      this.type = intfTypes.BUFFER;
    }
    async commit() {
      let { chunks } = this, size = 4, fp;
      if (this.type == intfTypes.NONE) {
        throw new Error("Writer not initialized");
      }
      if (chunks.length == 0) {
        throw new Error("Nothing to write");
      }
      for (let i = 1, l2 = chunks.length;i < l2; i++) {
        size += chunks[i].length;
      }
      chunks[0].writeUInt32LE(size, 4);
      if (this.type == intfTypes.FILE) {
        fp = await IO.open(this.path, "w");
        for (let i = 0, l2 = chunks.length;i < l2; i++) {
          await IO.write(fp, chunks[i], 0, undefined, undefined);
        }
        await IO.close(fp);
      } else {
        return Buffer.concat(chunks);
      }
    }
    writeBytes(...chunks) {
      if (this.type == intfTypes.NONE) {
        throw new Error("Writer not initialized");
      }
      this.chunks.push(...chunks);
    }
    writeFileHeader() {
      let buf = Buffer.alloc(12);
      buf.write("RIFF", 0);
      buf.write("WEBP", 8);
      this.writeBytes(buf);
    }
    writeChunk_VP8(vp8) {
      this.writeBytes(...createBasicChunk("VP8 ", vp8.raw).chunks);
    }
    writeChunk_VP8L(vp8l) {
      this.writeBytes(...createBasicChunk("VP8L", vp8l.raw).chunks);
    }
    writeChunk_VP8X(vp8x) {
      let buf = Buffer.alloc(18);
      buf.write("VP8X", 0);
      buf.writeUInt32LE(10, 4);
      buf.writeUIntLE(vp8x.width - 1, 12, 3);
      buf.writeUIntLE(vp8x.height - 1, 15, 3);
      if (vp8x.hasICCP) {
        buf[8] |= 32;
      }
      if (vp8x.hasAlpha) {
        buf[8] |= 16;
      }
      if (vp8x.hasEXIF) {
        buf[8] |= 8;
      }
      if (vp8x.hasXMP) {
        buf[8] |= 4;
      }
      if (vp8x.hasAnim) {
        buf[8] |= 2;
      }
      this.vp8x = buf;
      this.writeBytes(buf);
    }
    updateChunk_VP8X_size(width2, height2) {
      this.vp8x.writeUIntLE(width2, 12, 3);
      this.vp8x.writeUIntLE(height2, 15, 3);
    }
    writeChunk_ANIM(anim) {
      let buf = Buffer.alloc(14);
      buf.write("ANIM", 0);
      buf.writeUInt32LE(6, 4);
      buf.writeUInt8(anim.bgColor[2], 8);
      buf.writeUInt8(anim.bgColor[1], 9);
      buf.writeUInt8(anim.bgColor[0], 10);
      buf.writeUInt8(anim.bgColor[3], 11);
      buf.writeUInt16LE(anim.loops, 12);
      this.writeBytes(buf);
    }
    writeChunk_ANMF(anmf) {
      let buf = Buffer.alloc(24), { img } = anmf, size = 16, alpha = false;
      buf.write("ANMF", 0);
      buf.writeUIntLE(anmf.x, 8, 3);
      buf.writeUIntLE(anmf.y, 11, 3);
      buf.writeUIntLE(anmf.delay, 20, 3);
      if (!anmf.blend) {
        buf[23] |= 2;
      }
      if (anmf.dispose) {
        buf[23] |= 1;
      }
      switch (img.type) {
        case constants.TYPE_LOSSY:
          {
            let b;
            this.width = Math.max(this.width, img.vp8.width);
            this.height = Math.max(this.height, img.vp8.height);
            buf.writeUIntLE(img.vp8.width - 1, 14, 3);
            buf.writeUIntLE(img.vp8.height - 1, 17, 3);
            this.writeBytes(buf);
            if (img.vp8.alpha) {
              b = createBasicChunk("ALPH", img.alph.raw);
              this.writeBytes(...b.chunks);
              size += b.size;
            }
            b = createBasicChunk("VP8 ", img.vp8.raw);
            this.writeBytes(...b.chunks);
            size += b.size;
          }
          break;
        case constants.TYPE_LOSSLESS:
          {
            let b = createBasicChunk("VP8L", img.vp8l.raw);
            this.width = Math.max(this.width, img.vp8l.width);
            this.height = Math.max(this.height, img.vp8l.height);
            buf.writeUIntLE(img.vp8l.width - 1, 14, 3);
            buf.writeUIntLE(img.vp8l.height - 1, 17, 3);
            if (img.vp8l.alpha) {
              alpha = true;
            }
            this.writeBytes(buf, ...b.chunks);
            size += b.size;
          }
          break;
        case constants.TYPE_EXTENDED:
          if (img.extended.hasAnim) {
            let fr = img.anim.frames;
            if (img.extended.hasAlpha) {
              alpha = true;
            }
            for (let i = 0, l2 = fr.length;i < l2; i++) {
              let b = Buffer.alloc(8), c = fr[i].raw;
              this.width = Math.max(this.width, fr[i].width + anmf.x);
              this.height = Math.max(this.height, fr[i].height + anmf.y);
              b.write("ANMF", 0);
              b.writeUInt32LE(c.length, 4);
              c.writeUIntLE(anmf.x, 0, 3);
              c.writeUIntLE(anmf.y, 3, 3);
              c.writeUIntLE(anmf.delay, 12, 3);
              if (!anmf.blend) {
                c[15] |= 2;
              } else {
                c[15] &= 253;
              }
              if (anmf.dispose) {
                c[15] |= 1;
              } else {
                c[15] &= 254;
              }
              this.writeBytes(b, c);
              if (c.length & 1) {
                this.writeBytes(nullByte);
              }
            }
          } else {
            let b;
            this.width = Math.max(this.width, img.extended.width);
            this.height = Math.max(this.height, img.extended.height);
            if (img.vp8) {
              buf.writeUIntLE(img.vp8.width - 1, 14, 3);
              buf.writeUIntLE(img.vp8.height - 1, 17, 3);
              this.writeBytes(buf);
              if (img.alph) {
                b = createBasicChunk("ALPH", img.alph.raw);
                alpha = true;
                this.writeBytes(...b.chunks);
                size += b.size;
              }
              b = createBasicChunk("VP8 ", img.vp8.raw);
              this.writeBytes(...b.chunks);
              size += b.size;
            } else if (img.vp8l) {
              buf.writeUIntLE(img.vp8l.width - 1, 14, 3);
              buf.writeUIntLE(img.vp8l.height - 1, 17, 3);
              if (img.vp8l.alpha) {
                alpha = true;
              }
              b = createBasicChunk("VP8L", img.vp8l.raw);
              this.writeBytes(buf, ...b.chunks);
              size += b.size;
            }
          }
          break;
        default:
          throw new Error("Unknown image type");
      }
      buf.writeUInt32LE(size, 4);
      if (alpha) {
        this.vp8x[8] |= 16;
      }
    }
    writeChunk_ALPH(alph) {
      this.writeBytes(...createBasicChunk("ALPH", alph.raw).chunks);
    }
    writeChunk_ICCP(iccp) {
      this.writeBytes(...createBasicChunk("ICCP", iccp.raw).chunks);
    }
    writeChunk_EXIF(exif) {
      this.writeBytes(...createBasicChunk("EXIF", exif.raw).chunks);
    }
    writeChunk_XMP(xmp) {
      this.writeBytes(...createBasicChunk("XMP ", xmp.raw).chunks);
    }
  }
  module.exports = { WebPReader, WebPWriter };
});

// node_modules/node-webpmux/libwebp/libwebp.js
var require_libwebp = __commonJS((exports, module) => {
  var __dirname = "/Users/nadhi/Documents/GitHub/Whatsapp-Bot/node_modules/node-webpmux/libwebp", __filename = "/Users/nadhi/Documents/GitHub/Whatsapp-Bot/node_modules/node-webpmux/libwebp/libwebp.js";
  var LibWebP = (() => {
    var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : undefined;
    if (typeof __filename !== "undefined")
      _scriptDir = _scriptDir || __filename;
    return function(LibWebP2) {
      LibWebP2 = LibWebP2 || {};
      var Module = typeof LibWebP2 != "undefined" ? LibWebP2 : {};
      var readyPromiseResolve, readyPromiseReject;
      Module["ready"] = new Promise(function(resolve, reject) {
        readyPromiseResolve = resolve;
        readyPromiseReject = reject;
      });
      var moduleOverrides = Object.assign({}, Module);
      var arguments_ = [];
      var thisProgram = "./this.program";
      var quit_ = (status, toThrow) => {
        throw toThrow;
      };
      var ENVIRONMENT_IS_WEB = typeof window == "object";
      var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
      var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var read_, readAsync, readBinary, setWindowTitle;
      function logExceptionOnExit(e) {
        if (e instanceof ExitStatus)
          return;
        let toLog = e;
        err("exiting due to exception: " + toLog);
      }
      var fs;
      var nodePath;
      var requireNodeFS;
      if (ENVIRONMENT_IS_NODE) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = __require("path").dirname(scriptDirectory) + "/";
        } else {
          scriptDirectory = __dirname + "/";
        }
        requireNodeFS = () => {
          if (!nodePath) {
            fs = __require("fs");
            nodePath = __require("path");
          }
        };
        read_ = function shell_read(filename, binary) {
          requireNodeFS();
          filename = nodePath["normalize"](filename);
          return fs.readFileSync(filename, binary ? undefined : "utf8");
        };
        readBinary = (filename) => {
          var ret = read_(filename, true);
          if (!ret.buffer) {
            ret = new Uint8Array(ret);
          }
          return ret;
        };
        readAsync = (filename, onload, onerror) => {
          requireNodeFS();
          filename = nodePath["normalize"](filename);
          fs.readFile(filename, function(err2, data) {
            if (err2)
              onerror(err2);
            else
              onload(data.buffer);
          });
        };
        if (process["argv"].length > 1) {
          thisProgram = process["argv"][1].replace(/\\/g, "/");
        }
        arguments_ = process["argv"].slice(2);
        process["on"]("uncaughtException", function(ex) {
          if (!(ex instanceof ExitStatus)) {
            throw ex;
          }
        });
        process["on"]("unhandledRejection", function(reason) {
          throw reason;
        });
        quit_ = (status, toThrow) => {
          if (keepRuntimeAlive()) {
            process["exitCode"] = status;
            throw toThrow;
          }
          logExceptionOnExit(toThrow);
          process["exit"](status);
        };
        Module["inspect"] = function() {
          return "[Emscripten Module object]";
        };
      } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = self.location.href;
        } else if (typeof document != "undefined" && document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (_scriptDir) {
          scriptDirectory = _scriptDir;
        }
        if (scriptDirectory.indexOf("blob:") !== 0) {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
        } else {
          scriptDirectory = "";
        }
        {
          read_ = (url) => {
            var xhr = new XMLHttpRequest;
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          };
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = (url) => {
              var xhr = new XMLHttpRequest;
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = (url, onload, onerror) => {
            var xhr = new XMLHttpRequest;
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = () => {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                onload(xhr.response);
                return;
              }
              onerror();
            };
            xhr.onerror = onerror;
            xhr.send(null);
          };
        }
        setWindowTitle = (title) => document.title = title;
      } else {}
      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.warn.bind(console);
      Object.assign(Module, moduleOverrides);
      moduleOverrides = null;
      if (Module["arguments"])
        arguments_ = Module["arguments"];
      if (Module["thisProgram"])
        thisProgram = Module["thisProgram"];
      if (Module["quit"])
        quit_ = Module["quit"];
      var tempRet0 = 0;
      var setTempRet0 = (value) => {
        tempRet0 = value;
      };
      var wasmBinary;
      if (Module["wasmBinary"])
        wasmBinary = Module["wasmBinary"];
      var noExitRuntime = Module["noExitRuntime"] || true;
      if (typeof WebAssembly != "object") {
        abort("no native wasm support detected");
      }
      var wasmMemory;
      var ABORT = false;
      var EXITSTATUS;
      function assert(condition, text) {
        if (!condition) {
          abort(text);
        }
      }
      function getCFunc(ident) {
        var func = Module["_" + ident];
        return func;
      }
      function ccall(ident, returnType, argTypes, args, opts) {
        var toC = { string: function(str) {
          var ret2 = 0;
          if (str !== null && str !== undefined && str !== 0) {
            var len = (str.length << 2) + 1;
            ret2 = stackAlloc(len);
            stringToUTF8(str, ret2, len);
          }
          return ret2;
        }, array: function(arr) {
          var ret2 = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret2);
          return ret2;
        } };
        function convertReturnValue(ret2) {
          if (returnType === "string")
            return UTF8ToString(ret2);
          if (returnType === "boolean")
            return Boolean(ret2);
          return ret2;
        }
        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;
        if (args) {
          for (var i = 0;i < args.length; i++) {
            var converter = toC[argTypes[i]];
            if (converter) {
              if (stack === 0)
                stack = stackSave();
              cArgs[i] = converter(args[i]);
            } else {
              cArgs[i] = args[i];
            }
          }
        }
        var ret = func.apply(null, cArgs);
        function onDone(ret2) {
          if (stack !== 0)
            stackRestore(stack);
          return convertReturnValue(ret2);
        }
        ret = onDone(ret);
        return ret;
      }
      function cwrap(ident, returnType, argTypes, opts) {
        argTypes = argTypes || [];
        var numericArgs = argTypes.every(function(type) {
          return type === "number";
        });
        var numericRet = returnType !== "string";
        if (numericRet && numericArgs && !opts) {
          return getCFunc(ident);
        }
        return function() {
          return ccall(ident, returnType, argTypes, arguments, opts);
        };
      }
      var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined;
      function UTF8ArrayToString(heap, idx, maxBytesToRead) {
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (heap[endPtr] && !(endPtr >= endIdx))
          ++endPtr;
        if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
          return UTF8Decoder.decode(heap.subarray(idx, endPtr));
        } else {
          var str = "";
          while (idx < endPtr) {
            var u0 = heap[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = heap[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = heap[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
        }
        return str;
      }
      function UTF8ToString(ptr, maxBytesToRead) {
        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      }
      function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
        if (!(maxBytesToWrite > 0))
          return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i = 0;i < str.length; ++i) {
          var u = str.charCodeAt(i);
          if (u >= 55296 && u <= 57343) {
            var u1 = str.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }
          if (u <= 127) {
            if (outIdx >= endIdx)
              break;
            heap[outIdx++] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx)
              break;
            heap[outIdx++] = 192 | u >> 6;
            heap[outIdx++] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx)
              break;
            heap[outIdx++] = 224 | u >> 12;
            heap[outIdx++] = 128 | u >> 6 & 63;
            heap[outIdx++] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx)
              break;
            heap[outIdx++] = 240 | u >> 18;
            heap[outIdx++] = 128 | u >> 12 & 63;
            heap[outIdx++] = 128 | u >> 6 & 63;
            heap[outIdx++] = 128 | u & 63;
          }
        }
        heap[outIdx] = 0;
        return outIdx - startIdx;
      }
      function stringToUTF8(str, outPtr, maxBytesToWrite) {
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      }
      function lengthBytesUTF8(str) {
        var len = 0;
        for (var i = 0;i < str.length; ++i) {
          var u = str.charCodeAt(i);
          if (u >= 55296 && u <= 57343)
            u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
          if (u <= 127)
            ++len;
          else if (u <= 2047)
            len += 2;
          else if (u <= 65535)
            len += 3;
          else
            len += 4;
        }
        return len;
      }
      var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : undefined;
      function UTF16ToString(ptr, maxBytesToRead) {
        var endPtr = ptr;
        var idx = endPtr >> 1;
        var maxIdx = idx + maxBytesToRead / 2;
        while (!(idx >= maxIdx) && HEAPU16[idx])
          ++idx;
        endPtr = idx << 1;
        if (endPtr - ptr > 32 && UTF16Decoder) {
          return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
        } else {
          var str = "";
          for (var i = 0;!(i >= maxBytesToRead / 2); ++i) {
            var codeUnit = HEAP16[ptr + i * 2 >> 1];
            if (codeUnit == 0)
              break;
            str += String.fromCharCode(codeUnit);
          }
          return str;
        }
      }
      function stringToUTF16(str, outPtr, maxBytesToWrite) {
        if (maxBytesToWrite === undefined) {
          maxBytesToWrite = 2147483647;
        }
        if (maxBytesToWrite < 2)
          return 0;
        maxBytesToWrite -= 2;
        var startPtr = outPtr;
        var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
        for (var i = 0;i < numCharsToWrite; ++i) {
          var codeUnit = str.charCodeAt(i);
          HEAP16[outPtr >> 1] = codeUnit;
          outPtr += 2;
        }
        HEAP16[outPtr >> 1] = 0;
        return outPtr - startPtr;
      }
      function lengthBytesUTF16(str) {
        return str.length * 2;
      }
      function UTF32ToString(ptr, maxBytesToRead) {
        var i = 0;
        var str = "";
        while (!(i >= maxBytesToRead / 4)) {
          var utf32 = HEAP32[ptr + i * 4 >> 2];
          if (utf32 == 0)
            break;
          ++i;
          if (utf32 >= 65536) {
            var ch = utf32 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          } else {
            str += String.fromCharCode(utf32);
          }
        }
        return str;
      }
      function stringToUTF32(str, outPtr, maxBytesToWrite) {
        if (maxBytesToWrite === undefined) {
          maxBytesToWrite = 2147483647;
        }
        if (maxBytesToWrite < 4)
          return 0;
        var startPtr = outPtr;
        var endPtr = startPtr + maxBytesToWrite - 4;
        for (var i = 0;i < str.length; ++i) {
          var codeUnit = str.charCodeAt(i);
          if (codeUnit >= 55296 && codeUnit <= 57343) {
            var trailSurrogate = str.charCodeAt(++i);
            codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
          }
          HEAP32[outPtr >> 2] = codeUnit;
          outPtr += 4;
          if (outPtr + 4 > endPtr)
            break;
        }
        HEAP32[outPtr >> 2] = 0;
        return outPtr - startPtr;
      }
      function lengthBytesUTF32(str) {
        var len = 0;
        for (var i = 0;i < str.length; ++i) {
          var codeUnit = str.charCodeAt(i);
          if (codeUnit >= 55296 && codeUnit <= 57343)
            ++i;
          len += 4;
        }
        return len;
      }
      function writeArrayToMemory(array, buffer2) {
        HEAP8.set(array, buffer2);
      }
      function alignUp(x, multiple) {
        if (x % multiple > 0) {
          x += multiple - x % multiple;
        }
        return x;
      }
      var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateGlobalBufferAndViews(buf) {
        buffer = buf;
        Module["HEAP8"] = HEAP8 = new Int8Array(buf);
        Module["HEAP16"] = HEAP16 = new Int16Array(buf);
        Module["HEAP32"] = HEAP32 = new Int32Array(buf);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
        Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
        Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
      }
      var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
      var wasmTable;
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATPOSTRUN__ = [];
      var runtimeInitialized = false;
      var runtimeKeepaliveCounter = 0;
      function keepRuntimeAlive() {
        return noExitRuntime || runtimeKeepaliveCounter > 0;
      }
      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function")
            Module["preRun"] = [Module["preRun"]];
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        runtimeInitialized = true;
        callRuntimeCallbacks(__ATINIT__);
      }
      function postRun() {
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function")
            Module["postRun"] = [Module["postRun"]];
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnInit(cb) {
        __ATINIT__.unshift(cb);
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      var runDependencies = 0;
      var runDependencyWatcher = null;
      var dependenciesFulfilled = null;
      function addRunDependency(id) {
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
      }
      function removeRunDependency(id) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (runDependencies == 0) {
          if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
          }
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      Module["preloadedImages"] = {};
      Module["preloadedAudios"] = {};
      function abort(what) {
        {
          if (Module["onAbort"]) {
            Module["onAbort"](what);
          }
        }
        what = "Aborted(" + what + ")";
        err(what);
        ABORT = true;
        EXITSTATUS = 1;
        what += ". Build with -s ASSERTIONS=1 for more info.";
        var e = new WebAssembly.RuntimeError(what);
        readyPromiseReject(e);
        throw e;
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      function isDataURI(filename) {
        return filename.startsWith(dataURIPrefix);
      }
      function isFileURI(filename) {
        return filename.startsWith("file://");
      }
      var wasmBinaryFile;
      wasmBinaryFile = "libwebp.wasm";
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
      function getBinary(file) {
        try {
          if (file == wasmBinaryFile && wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(file);
          } else {
            throw "both async and sync fetching of the wasm failed";
          }
        } catch (err2) {
          abort(err2);
        }
      }
      function getBinaryPromise() {
        if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
          if (typeof fetch == "function" && !isFileURI(wasmBinaryFile)) {
            return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
              if (!response["ok"]) {
                throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
              }
              return response["arrayBuffer"]();
            }).catch(function() {
              return getBinary(wasmBinaryFile);
            });
          } else {
            if (readAsync) {
              return new Promise(function(resolve, reject) {
                readAsync(wasmBinaryFile, function(response) {
                  resolve(new Uint8Array(response));
                }, reject);
              });
            }
          }
        }
        return Promise.resolve().then(function() {
          return getBinary(wasmBinaryFile);
        });
      }
      function createWasm() {
        var info = { a: asmLibraryArg };
        function receiveInstance(instance, module2) {
          var exports3 = instance.exports;
          Module["asm"] = exports3;
          wasmMemory = Module["asm"]["r"];
          updateGlobalBufferAndViews(wasmMemory.buffer);
          wasmTable = Module["asm"]["z"];
          addOnInit(Module["asm"]["s"]);
          removeRunDependency("wasm-instantiate");
        }
        addRunDependency("wasm-instantiate");
        function receiveInstantiationResult(result) {
          receiveInstance(result["instance"]);
        }
        function instantiateArrayBuffer(receiver) {
          return getBinaryPromise().then(function(binary) {
            return WebAssembly.instantiate(binary, info);
          }).then(function(instance) {
            return instance;
          }).then(receiver, function(reason) {
            err("failed to asynchronously prepare wasm: " + reason);
            abort(reason);
          });
        }
        function instantiateAsync() {
          if (!wasmBinary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch == "function") {
            return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
              var result = WebAssembly.instantiateStreaming(response, info);
              return result.then(receiveInstantiationResult, function(reason) {
                err("wasm streaming compile failed: " + reason);
                err("falling back to ArrayBuffer instantiation");
                return instantiateArrayBuffer(receiveInstantiationResult);
              });
            });
          } else {
            return instantiateArrayBuffer(receiveInstantiationResult);
          }
        }
        if (Module["instantiateWasm"]) {
          try {
            var exports2 = Module["instantiateWasm"](info, receiveInstance);
            return exports2;
          } catch (e) {
            err("Module.instantiateWasm callback failed with error: " + e);
            return false;
          }
        }
        instantiateAsync().catch(readyPromiseReject);
        return {};
      }
      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          var callback = callbacks.shift();
          if (typeof callback == "function") {
            callback(Module);
            continue;
          }
          var func = callback.func;
          if (typeof func == "number") {
            if (callback.arg === undefined) {
              getWasmTableEntry(func)();
            } else {
              getWasmTableEntry(func)(callback.arg);
            }
          } else {
            func(callback.arg === undefined ? null : callback.arg);
          }
        }
      }
      var wasmTableMirror = [];
      function getWasmTableEntry(funcPtr) {
        var func = wasmTableMirror[funcPtr];
        if (!func) {
          if (funcPtr >= wasmTableMirror.length)
            wasmTableMirror.length = funcPtr + 1;
          wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
        }
        return func;
      }
      function ___assert_fail(condition, filename, line, func) {
        abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
      }
      function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}
      function getShiftFromSize(size) {
        switch (size) {
          case 1:
            return 0;
          case 2:
            return 1;
          case 4:
            return 2;
          case 8:
            return 3;
          default:
            throw new TypeError("Unknown type size: " + size);
        }
      }
      function embind_init_charCodes() {
        var codes = new Array(256);
        for (var i = 0;i < 256; ++i) {
          codes[i] = String.fromCharCode(i);
        }
        embind_charCodes = codes;
      }
      var embind_charCodes = undefined;
      function readLatin1String(ptr) {
        var ret = "";
        var c = ptr;
        while (HEAPU8[c]) {
          ret += embind_charCodes[HEAPU8[c++]];
        }
        return ret;
      }
      var awaitingDependencies = {};
      var registeredTypes = {};
      var typeDependencies = {};
      var char_0 = 48;
      var char_9 = 57;
      function makeLegalFunctionName(name) {
        if (name === undefined) {
          return "_unknown";
        }
        name = name.replace(/[^a-zA-Z0-9_]/g, "$");
        var f = name.charCodeAt(0);
        if (f >= char_0 && f <= char_9) {
          return "_" + name;
        } else {
          return name;
        }
      }
      function createNamedFunction(name, body) {
        name = makeLegalFunctionName(name);
        return new Function("body", "return function " + name + `() {
` + '    "use strict";' + `    return body.apply(this, arguments);
` + `};
`)(body);
      }
      function extendError(baseErrorType, errorName) {
        var errorClass = createNamedFunction(errorName, function(message) {
          this.name = errorName;
          this.message = message;
          var stack = new Error(message).stack;
          if (stack !== undefined) {
            this.stack = this.toString() + `
` + stack.replace(/^Error(:[^\n]*)?\n/, "");
          }
        });
        errorClass.prototype = Object.create(baseErrorType.prototype);
        errorClass.prototype.constructor = errorClass;
        errorClass.prototype.toString = function() {
          if (this.message === undefined) {
            return this.name;
          } else {
            return this.name + ": " + this.message;
          }
        };
        return errorClass;
      }
      var BindingError = undefined;
      function throwBindingError(message) {
        throw new BindingError(message);
      }
      var InternalError = undefined;
      function throwInternalError(message) {
        throw new InternalError(message);
      }
      function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
        myTypes.forEach(function(type) {
          typeDependencies[type] = dependentTypes;
        });
        function onComplete(typeConverters2) {
          var myTypeConverters = getTypeConverters(typeConverters2);
          if (myTypeConverters.length !== myTypes.length) {
            throwInternalError("Mismatched type converter count");
          }
          for (var i = 0;i < myTypes.length; ++i) {
            registerType(myTypes[i], myTypeConverters[i]);
          }
        }
        var typeConverters = new Array(dependentTypes.length);
        var unregisteredTypes = [];
        var registered = 0;
        dependentTypes.forEach(function(dt, i) {
          if (registeredTypes.hasOwnProperty(dt)) {
            typeConverters[i] = registeredTypes[dt];
          } else {
            unregisteredTypes.push(dt);
            if (!awaitingDependencies.hasOwnProperty(dt)) {
              awaitingDependencies[dt] = [];
            }
            awaitingDependencies[dt].push(function() {
              typeConverters[i] = registeredTypes[dt];
              ++registered;
              if (registered === unregisteredTypes.length) {
                onComplete(typeConverters);
              }
            });
          }
        });
        if (unregisteredTypes.length === 0) {
          onComplete(typeConverters);
        }
      }
      function registerType(rawType, registeredInstance, options = {}) {
        if (!("argPackAdvance" in registeredInstance)) {
          throw new TypeError("registerType registeredInstance requires argPackAdvance");
        }
        var name = registeredInstance.name;
        if (!rawType) {
          throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
        }
        if (registeredTypes.hasOwnProperty(rawType)) {
          if (options.ignoreDuplicateRegistrations) {
            return;
          } else {
            throwBindingError("Cannot register type '" + name + "' twice");
          }
        }
        registeredTypes[rawType] = registeredInstance;
        delete typeDependencies[rawType];
        if (awaitingDependencies.hasOwnProperty(rawType)) {
          var callbacks = awaitingDependencies[rawType];
          delete awaitingDependencies[rawType];
          callbacks.forEach(function(cb) {
            cb();
          });
        }
      }
      function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
        var shift = getShiftFromSize(size);
        name = readLatin1String(name);
        registerType(rawType, { name, fromWireType: function(wt) {
          return !!wt;
        }, toWireType: function(destructors, o) {
          return o ? trueValue : falseValue;
        }, argPackAdvance: 8, readValueFromPointer: function(pointer) {
          var heap;
          if (size === 1) {
            heap = HEAP8;
          } else if (size === 2) {
            heap = HEAP16;
          } else if (size === 4) {
            heap = HEAP32;
          } else {
            throw new TypeError("Unknown boolean type size: " + name);
          }
          return this["fromWireType"](heap[pointer >> shift]);
        }, destructorFunction: null });
      }
      function ClassHandle_isAliasOf(other) {
        if (!(this instanceof ClassHandle)) {
          return false;
        }
        if (!(other instanceof ClassHandle)) {
          return false;
        }
        var leftClass = this.$$.ptrType.registeredClass;
        var left = this.$$.ptr;
        var rightClass = other.$$.ptrType.registeredClass;
        var right = other.$$.ptr;
        while (leftClass.baseClass) {
          left = leftClass.upcast(left);
          leftClass = leftClass.baseClass;
        }
        while (rightClass.baseClass) {
          right = rightClass.upcast(right);
          rightClass = rightClass.baseClass;
        }
        return leftClass === rightClass && left === right;
      }
      function shallowCopyInternalPointer(o) {
        return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
      }
      function throwInstanceAlreadyDeleted(obj2) {
        function getInstanceTypeName(handle) {
          return handle.$$.ptrType.registeredClass.name;
        }
        throwBindingError(getInstanceTypeName(obj2) + " instance already deleted");
      }
      var finalizationRegistry = false;
      function detachFinalizer(handle) {}
      function runDestructor($$) {
        if ($$.smartPtr) {
          $$.smartPtrType.rawDestructor($$.smartPtr);
        } else {
          $$.ptrType.registeredClass.rawDestructor($$.ptr);
        }
      }
      function releaseClassHandle($$) {
        $$.count.value -= 1;
        var toDelete = $$.count.value === 0;
        if (toDelete) {
          runDestructor($$);
        }
      }
      function downcastPointer(ptr, ptrClass, desiredClass) {
        if (ptrClass === desiredClass) {
          return ptr;
        }
        if (desiredClass.baseClass === undefined) {
          return null;
        }
        var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
        if (rv === null) {
          return null;
        }
        return desiredClass.downcast(rv);
      }
      var registeredPointers = {};
      function getInheritedInstanceCount() {
        return Object.keys(registeredInstances).length;
      }
      function getLiveInheritedInstances() {
        var rv = [];
        for (var k in registeredInstances) {
          if (registeredInstances.hasOwnProperty(k)) {
            rv.push(registeredInstances[k]);
          }
        }
        return rv;
      }
      var deletionQueue = [];
      function flushPendingDeletes() {
        while (deletionQueue.length) {
          var obj2 = deletionQueue.pop();
          obj2.$$.deleteScheduled = false;
          obj2["delete"]();
        }
      }
      var delayFunction = undefined;
      function setDelayFunction(fn) {
        delayFunction = fn;
        if (deletionQueue.length && delayFunction) {
          delayFunction(flushPendingDeletes);
        }
      }
      function init_embind() {
        Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
        Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
        Module["flushPendingDeletes"] = flushPendingDeletes;
        Module["setDelayFunction"] = setDelayFunction;
      }
      var registeredInstances = {};
      function getBasestPointer(class_, ptr) {
        if (ptr === undefined) {
          throwBindingError("ptr should not be undefined");
        }
        while (class_.baseClass) {
          ptr = class_.upcast(ptr);
          class_ = class_.baseClass;
        }
        return ptr;
      }
      function getInheritedInstance(class_, ptr) {
        ptr = getBasestPointer(class_, ptr);
        return registeredInstances[ptr];
      }
      function makeClassHandle(prototype, record) {
        if (!record.ptrType || !record.ptr) {
          throwInternalError("makeClassHandle requires ptr and ptrType");
        }
        var hasSmartPtrType = !!record.smartPtrType;
        var hasSmartPtr = !!record.smartPtr;
        if (hasSmartPtrType !== hasSmartPtr) {
          throwInternalError("Both smartPtrType and smartPtr must be specified");
        }
        record.count = { value: 1 };
        return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
      }
      function RegisteredPointer_fromWireType(ptr) {
        var rawPointer = this.getPointee(ptr);
        if (!rawPointer) {
          this.destructor(ptr);
          return null;
        }
        var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
        if (registeredInstance !== undefined) {
          if (registeredInstance.$$.count.value === 0) {
            registeredInstance.$$.ptr = rawPointer;
            registeredInstance.$$.smartPtr = ptr;
            return registeredInstance["clone"]();
          } else {
            var rv = registeredInstance["clone"]();
            this.destructor(ptr);
            return rv;
          }
        }
        function makeDefaultHandle() {
          if (this.isSmartPointer) {
            return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
          } else {
            return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
          }
        }
        var actualType = this.registeredClass.getActualType(rawPointer);
        var registeredPointerRecord = registeredPointers[actualType];
        if (!registeredPointerRecord) {
          return makeDefaultHandle.call(this);
        }
        var toType;
        if (this.isConst) {
          toType = registeredPointerRecord.constPointerType;
        } else {
          toType = registeredPointerRecord.pointerType;
        }
        var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
        if (dp === null) {
          return makeDefaultHandle.call(this);
        }
        if (this.isSmartPointer) {
          return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
        } else {
          return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
        }
      }
      function attachFinalizer(handle) {
        if (typeof FinalizationRegistry === "undefined") {
          attachFinalizer = (handle2) => handle2;
          return handle;
        }
        finalizationRegistry = new FinalizationRegistry((info) => {
          releaseClassHandle(info.$$);
        });
        attachFinalizer = (handle2) => {
          var $$ = handle2.$$;
          var hasSmartPtr = !!$$.smartPtr;
          if (hasSmartPtr) {
            var info = { $$ };
            finalizationRegistry.register(handle2, info, handle2);
          }
          return handle2;
        };
        detachFinalizer = (handle2) => finalizationRegistry.unregister(handle2);
        return attachFinalizer(handle);
      }
      function ClassHandle_clone() {
        if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
        }
        if (this.$$.preservePointerOnDelete) {
          this.$$.count.value += 1;
          return this;
        } else {
          var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
          clone.$$.count.value += 1;
          clone.$$.deleteScheduled = false;
          return clone;
        }
      }
      function ClassHandle_delete() {
        if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
        }
        if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError("Object already scheduled for deletion");
        }
        detachFinalizer(this);
        releaseClassHandle(this.$$);
        if (!this.$$.preservePointerOnDelete) {
          this.$$.smartPtr = undefined;
          this.$$.ptr = undefined;
        }
      }
      function ClassHandle_isDeleted() {
        return !this.$$.ptr;
      }
      function ClassHandle_deleteLater() {
        if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
        }
        if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError("Object already scheduled for deletion");
        }
        deletionQueue.push(this);
        if (deletionQueue.length === 1 && delayFunction) {
          delayFunction(flushPendingDeletes);
        }
        this.$$.deleteScheduled = true;
        return this;
      }
      function init_ClassHandle() {
        ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
        ClassHandle.prototype["clone"] = ClassHandle_clone;
        ClassHandle.prototype["delete"] = ClassHandle_delete;
        ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
        ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
      }
      function ClassHandle() {}
      function ensureOverloadTable(proto, methodName, humanName) {
        if (proto[methodName].overloadTable === undefined) {
          var prevFunc = proto[methodName];
          proto[methodName] = function() {
            if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
              throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
            }
            return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
          };
          proto[methodName].overloadTable = [];
          proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
        }
      }
      function exposePublicSymbol(name, value, numArguments) {
        if (Module.hasOwnProperty(name)) {
          if (numArguments === undefined || Module[name].overloadTable !== undefined && Module[name].overloadTable[numArguments] !== undefined) {
            throwBindingError("Cannot register public name '" + name + "' twice");
          }
          ensureOverloadTable(Module, name, name);
          if (Module.hasOwnProperty(numArguments)) {
            throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
          }
          Module[name].overloadTable[numArguments] = value;
        } else {
          Module[name] = value;
          if (numArguments !== undefined) {
            Module[name].numArguments = numArguments;
          }
        }
      }
      function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
        this.name = name;
        this.constructor = constructor;
        this.instancePrototype = instancePrototype;
        this.rawDestructor = rawDestructor;
        this.baseClass = baseClass;
        this.getActualType = getActualType;
        this.upcast = upcast;
        this.downcast = downcast;
        this.pureVirtualFunctions = [];
      }
      function upcastPointer(ptr, ptrClass, desiredClass) {
        while (ptrClass !== desiredClass) {
          if (!ptrClass.upcast) {
            throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
          }
          ptr = ptrClass.upcast(ptr);
          ptrClass = ptrClass.baseClass;
        }
        return ptr;
      }
      function constNoSmartPtrRawPointerToWireType(destructors, handle) {
        if (handle === null) {
          if (this.isReference) {
            throwBindingError("null is not a valid " + this.name);
          }
          return 0;
        }
        if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
        }
        if (!handle.$$.ptr) {
          throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
        }
        var handleClass = handle.$$.ptrType.registeredClass;
        var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
        return ptr;
      }
      function genericPointerToWireType(destructors, handle) {
        var ptr;
        if (handle === null) {
          if (this.isReference) {
            throwBindingError("null is not a valid " + this.name);
          }
          if (this.isSmartPointer) {
            ptr = this.rawConstructor();
            if (destructors !== null) {
              destructors.push(this.rawDestructor, ptr);
            }
            return ptr;
          } else {
            return 0;
          }
        }
        if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
        }
        if (!handle.$$.ptr) {
          throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
        }
        if (!this.isConst && handle.$$.ptrType.isConst) {
          throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
        }
        var handleClass = handle.$$.ptrType.registeredClass;
        ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
        if (this.isSmartPointer) {
          if (handle.$$.smartPtr === undefined) {
            throwBindingError("Passing raw pointer to smart pointer is illegal");
          }
          switch (this.sharingPolicy) {
            case 0:
              if (handle.$$.smartPtrType === this) {
                ptr = handle.$$.smartPtr;
              } else {
                throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
              }
              break;
            case 1:
              ptr = handle.$$.smartPtr;
              break;
            case 2:
              if (handle.$$.smartPtrType === this) {
                ptr = handle.$$.smartPtr;
              } else {
                var clonedHandle = handle["clone"]();
                ptr = this.rawShare(ptr, Emval.toHandle(function() {
                  clonedHandle["delete"]();
                }));
                if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr);
                }
              }
              break;
            default:
              throwBindingError("Unsupporting sharing policy");
          }
        }
        return ptr;
      }
      function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
        if (handle === null) {
          if (this.isReference) {
            throwBindingError("null is not a valid " + this.name);
          }
          return 0;
        }
        if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
        }
        if (!handle.$$.ptr) {
          throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
        }
        if (handle.$$.ptrType.isConst) {
          throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
        }
        var handleClass = handle.$$.ptrType.registeredClass;
        var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
        return ptr;
      }
      function simpleReadValueFromPointer(pointer) {
        return this["fromWireType"](HEAPU32[pointer >> 2]);
      }
      function RegisteredPointer_getPointee(ptr) {
        if (this.rawGetPointee) {
          ptr = this.rawGetPointee(ptr);
        }
        return ptr;
      }
      function RegisteredPointer_destructor(ptr) {
        if (this.rawDestructor) {
          this.rawDestructor(ptr);
        }
      }
      function RegisteredPointer_deleteObject(handle) {
        if (handle !== null) {
          handle["delete"]();
        }
      }
      function init_RegisteredPointer() {
        RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
        RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
        RegisteredPointer.prototype["argPackAdvance"] = 8;
        RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
        RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
        RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
      }
      function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
        this.name = name;
        this.registeredClass = registeredClass;
        this.isReference = isReference;
        this.isConst = isConst;
        this.isSmartPointer = isSmartPointer;
        this.pointeeType = pointeeType;
        this.sharingPolicy = sharingPolicy;
        this.rawGetPointee = rawGetPointee;
        this.rawConstructor = rawConstructor;
        this.rawShare = rawShare;
        this.rawDestructor = rawDestructor;
        if (!isSmartPointer && registeredClass.baseClass === undefined) {
          if (isConst) {
            this["toWireType"] = constNoSmartPtrRawPointerToWireType;
            this.destructorFunction = null;
          } else {
            this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
            this.destructorFunction = null;
          }
        } else {
          this["toWireType"] = genericPointerToWireType;
        }
      }
      function replacePublicSymbol(name, value, numArguments) {
        if (!Module.hasOwnProperty(name)) {
          throwInternalError("Replacing nonexistant public symbol");
        }
        if (Module[name].overloadTable !== undefined && numArguments !== undefined) {
          Module[name].overloadTable[numArguments] = value;
        } else {
          Module[name] = value;
          Module[name].argCount = numArguments;
        }
      }
      function dynCallLegacy(sig, ptr, args) {
        var f = Module["dynCall_" + sig];
        return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
      }
      function dynCall(sig, ptr, args) {
        if (sig.includes("j")) {
          return dynCallLegacy(sig, ptr, args);
        }
        return getWasmTableEntry(ptr).apply(null, args);
      }
      function getDynCaller(sig, ptr) {
        var argCache = [];
        return function() {
          argCache.length = 0;
          Object.assign(argCache, arguments);
          return dynCall(sig, ptr, argCache);
        };
      }
      function embind__requireFunction(signature, rawFunction) {
        signature = readLatin1String(signature);
        function makeDynCaller() {
          if (signature.includes("j")) {
            return getDynCaller(signature, rawFunction);
          }
          return getWasmTableEntry(rawFunction);
        }
        var fp = makeDynCaller();
        if (typeof fp != "function") {
          throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
        }
        return fp;
      }
      var UnboundTypeError = undefined;
      function getTypeName(type) {
        var ptr = ___getTypeName(type);
        var rv = readLatin1String(ptr);
        _free(ptr);
        return rv;
      }
      function throwUnboundTypeError(message, types) {
        var unboundTypes = [];
        var seen = {};
        function visit(type) {
          if (seen[type]) {
            return;
          }
          if (registeredTypes[type]) {
            return;
          }
          if (typeDependencies[type]) {
            typeDependencies[type].forEach(visit);
            return;
          }
          unboundTypes.push(type);
          seen[type] = true;
        }
        types.forEach(visit);
        throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
      }
      function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
        name = readLatin1String(name);
        getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
        if (upcast) {
          upcast = embind__requireFunction(upcastSignature, upcast);
        }
        if (downcast) {
          downcast = embind__requireFunction(downcastSignature, downcast);
        }
        rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
        var legalFunctionName = makeLegalFunctionName(name);
        exposePublicSymbol(legalFunctionName, function() {
          throwUnboundTypeError("Cannot construct " + name + " due to unbound types", [baseClassRawType]);
        });
        whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
          base = base[0];
          var baseClass;
          var basePrototype;
          if (baseClassRawType) {
            baseClass = base.registeredClass;
            basePrototype = baseClass.instancePrototype;
          } else {
            basePrototype = ClassHandle.prototype;
          }
          var constructor = createNamedFunction(legalFunctionName, function() {
            if (Object.getPrototypeOf(this) !== instancePrototype) {
              throw new BindingError("Use 'new' to construct " + name);
            }
            if (registeredClass.constructor_body === undefined) {
              throw new BindingError(name + " has no accessible constructor");
            }
            var body = registeredClass.constructor_body[arguments.length];
            if (body === undefined) {
              throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
            }
            return body.apply(this, arguments);
          });
          var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
          constructor.prototype = instancePrototype;
          var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
          var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
          var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);
          var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);
          registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
          replacePublicSymbol(legalFunctionName, constructor);
          return [referenceConverter, pointerConverter, constPointerConverter];
        });
      }
      function heap32VectorToArray(count, firstElement) {
        var array = [];
        for (var i = 0;i < count; i++) {
          array.push(HEAP32[(firstElement >> 2) + i]);
        }
        return array;
      }
      function runDestructors(destructors) {
        while (destructors.length) {
          var ptr = destructors.pop();
          var del = destructors.pop();
          del(ptr);
        }
      }
      function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
        assert(argCount > 0);
        var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
        invoker = embind__requireFunction(invokerSignature, invoker);
        whenDependentTypesAreResolved([], [rawClassType], function(classType) {
          classType = classType[0];
          var humanName = "constructor " + classType.name;
          if (classType.registeredClass.constructor_body === undefined) {
            classType.registeredClass.constructor_body = [];
          }
          if (classType.registeredClass.constructor_body[argCount - 1] !== undefined) {
            throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          }
          classType.registeredClass.constructor_body[argCount - 1] = () => {
            throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
          };
          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
            argTypes.splice(1, 0, null);
            classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
            return [];
          });
          return [];
        });
      }
      function new_(constructor, argumentList) {
        if (!(constructor instanceof Function)) {
          throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
        }
        var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {});
        dummy.prototype = constructor.prototype;
        var obj2 = new dummy;
        var r = constructor.apply(obj2, argumentList);
        return r instanceof Object ? r : obj2;
      }
      function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
        var argCount = argTypes.length;
        if (argCount < 2) {
          throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
        }
        var isClassMethodFunc = argTypes[1] !== null && classType !== null;
        var needsDestructorStack = false;
        for (var i = 1;i < argTypes.length; ++i) {
          if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
            needsDestructorStack = true;
            break;
          }
        }
        var returns = argTypes[0].name !== "void";
        var argsList = "";
        var argsListWired = "";
        for (var i = 0;i < argCount - 2; ++i) {
          argsList += (i !== 0 ? ", " : "") + "arg" + i;
          argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
        }
        var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + `) {
` + "if (arguments.length !== " + (argCount - 2) + `) {
` + "throwBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + ` args!');
` + `}
`;
        if (needsDestructorStack) {
          invokerFnBody += `var destructors = [];
`;
        }
        var dtorStack = needsDestructorStack ? "destructors" : "null";
        var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
        var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
        if (isClassMethodFunc) {
          invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + `, this);
`;
        }
        for (var i = 0;i < argCount - 2; ++i) {
          invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + `
`;
          args1.push("argType" + i);
          args2.push(argTypes[i + 2]);
        }
        if (isClassMethodFunc) {
          argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
        }
        invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + `);
`;
        if (needsDestructorStack) {
          invokerFnBody += `runDestructors(destructors);
`;
        } else {
          for (var i = isClassMethodFunc ? 1 : 2;i < argTypes.length; ++i) {
            var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
            if (argTypes[i].destructorFunction !== null) {
              invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + `
`;
              args1.push(paramName + "_dtor");
              args2.push(argTypes[i].destructorFunction);
            }
          }
        }
        if (returns) {
          invokerFnBody += `var ret = retType.fromWireType(rv);
` + `return ret;
`;
        } else {}
        invokerFnBody += `}
`;
        args1.push(invokerFnBody);
        var invokerFunction = new_(Function, args1).apply(null, args2);
        return invokerFunction;
      }
      function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
        var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
        methodName = readLatin1String(methodName);
        rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
        whenDependentTypesAreResolved([], [rawClassType], function(classType) {
          classType = classType[0];
          var humanName = classType.name + "." + methodName;
          if (methodName.startsWith("@@")) {
            methodName = Symbol[methodName.substring(2)];
          }
          if (isPureVirtual) {
            classType.registeredClass.pureVirtualFunctions.push(methodName);
          }
          function unboundTypesHandler() {
            throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
          }
          var proto = classType.registeredClass.instancePrototype;
          var method = proto[methodName];
          if (method === undefined || method.overloadTable === undefined && method.className !== classType.name && method.argCount === argCount - 2) {
            unboundTypesHandler.argCount = argCount - 2;
            unboundTypesHandler.className = classType.name;
            proto[methodName] = unboundTypesHandler;
          } else {
            ensureOverloadTable(proto, methodName, humanName);
            proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
          }
          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
            var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
            if (proto[methodName].overloadTable === undefined) {
              memberFunction.argCount = argCount - 2;
              proto[methodName] = memberFunction;
            } else {
              proto[methodName].overloadTable[argCount - 2] = memberFunction;
            }
            return [];
          });
          return [];
        });
      }
      var emval_free_list = [];
      var emval_handle_array = [{}, { value: undefined }, { value: null }, { value: true }, { value: false }];
      function __emval_decref(handle) {
        if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
          emval_handle_array[handle] = undefined;
          emval_free_list.push(handle);
        }
      }
      function count_emval_handles() {
        var count = 0;
        for (var i = 5;i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== undefined) {
            ++count;
          }
        }
        return count;
      }
      function get_first_emval() {
        for (var i = 5;i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== undefined) {
            return emval_handle_array[i];
          }
        }
        return null;
      }
      function init_emval() {
        Module["count_emval_handles"] = count_emval_handles;
        Module["get_first_emval"] = get_first_emval;
      }
      var Emval = { toValue: function(handle) {
        if (!handle) {
          throwBindingError("Cannot use deleted val. handle = " + handle);
        }
        return emval_handle_array[handle].value;
      }, toHandle: function(value) {
        switch (value) {
          case undefined: {
            return 1;
          }
          case null: {
            return 2;
          }
          case true: {
            return 3;
          }
          case false: {
            return 4;
          }
          default: {
            var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
            emval_handle_array[handle] = { refcount: 1, value };
            return handle;
          }
        }
      } };
      function __embind_register_emval(rawType, name) {
        name = readLatin1String(name);
        registerType(rawType, { name, fromWireType: function(handle) {
          var rv = Emval.toValue(handle);
          __emval_decref(handle);
          return rv;
        }, toWireType: function(destructors, value) {
          return Emval.toHandle(value);
        }, argPackAdvance: 8, readValueFromPointer: simpleReadValueFromPointer, destructorFunction: null });
      }
      function _embind_repr(v) {
        if (v === null) {
          return "null";
        }
        var t = typeof v;
        if (t === "object" || t === "array" || t === "function") {
          return v.toString();
        } else {
          return "" + v;
        }
      }
      function floatReadValueFromPointer(name, shift) {
        switch (shift) {
          case 2:
            return function(pointer) {
              return this["fromWireType"](HEAPF32[pointer >> 2]);
            };
          case 3:
            return function(pointer) {
              return this["fromWireType"](HEAPF64[pointer >> 3]);
            };
          default:
            throw new TypeError("Unknown float type: " + name);
        }
      }
      function __embind_register_float(rawType, name, size) {
        var shift = getShiftFromSize(size);
        name = readLatin1String(name);
        registerType(rawType, { name, fromWireType: function(value) {
          return value;
        }, toWireType: function(destructors, value) {
          return value;
        }, argPackAdvance: 8, readValueFromPointer: floatReadValueFromPointer(name, shift), destructorFunction: null });
      }
      function integerReadValueFromPointer(name, shift, signed) {
        switch (shift) {
          case 0:
            return signed ? function readS8FromPointer(pointer) {
              return HEAP8[pointer];
            } : function readU8FromPointer(pointer) {
              return HEAPU8[pointer];
            };
          case 1:
            return signed ? function readS16FromPointer(pointer) {
              return HEAP16[pointer >> 1];
            } : function readU16FromPointer(pointer) {
              return HEAPU16[pointer >> 1];
            };
          case 2:
            return signed ? function readS32FromPointer(pointer) {
              return HEAP32[pointer >> 2];
            } : function readU32FromPointer(pointer) {
              return HEAPU32[pointer >> 2];
            };
          default:
            throw new TypeError("Unknown integer type: " + name);
        }
      }
      function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
        name = readLatin1String(name);
        if (maxRange === -1) {
          maxRange = 4294967295;
        }
        var shift = getShiftFromSize(size);
        var fromWireType = (value) => value;
        if (minRange === 0) {
          var bitshift = 32 - 8 * size;
          fromWireType = (value) => value << bitshift >>> bitshift;
        }
        var isUnsignedType = name.includes("unsigned");
        var checkAssertions = (value, toTypeName) => {};
        var toWireType;
        if (isUnsignedType) {
          toWireType = function(destructors, value) {
            checkAssertions(value, this.name);
            return value >>> 0;
          };
        } else {
          toWireType = function(destructors, value) {
            checkAssertions(value, this.name);
            return value;
          };
        }
        registerType(primitiveType, { name, fromWireType, toWireType, argPackAdvance: 8, readValueFromPointer: integerReadValueFromPointer(name, shift, minRange !== 0), destructorFunction: null });
      }
      function __embind_register_memory_view(rawType, dataTypeIndex, name) {
        var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        var TA = typeMapping[dataTypeIndex];
        function decodeMemoryView(handle) {
          handle = handle >> 2;
          var heap = HEAPU32;
          var size = heap[handle];
          var data = heap[handle + 1];
          return new TA(buffer, data, size);
        }
        name = readLatin1String(name);
        registerType(rawType, { name, fromWireType: decodeMemoryView, argPackAdvance: 8, readValueFromPointer: decodeMemoryView }, { ignoreDuplicateRegistrations: true });
      }
      function __embind_register_std_string(rawType, name) {
        name = readLatin1String(name);
        var stdStringIsUTF8 = name === "std::string";
        registerType(rawType, { name, fromWireType: function(value) {
          var length = HEAPU32[value >> 2];
          var str;
          if (stdStringIsUTF8) {
            var decodeStartPtr = value + 4;
            for (var i = 0;i <= length; ++i) {
              var currentBytePtr = value + 4 + i;
              if (i == length || HEAPU8[currentBytePtr] == 0) {
                var maxRead = currentBytePtr - decodeStartPtr;
                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                if (str === undefined) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + 1;
              }
            }
          } else {
            var a = new Array(length);
            for (var i = 0;i < length; ++i) {
              a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
            }
            str = a.join("");
          }
          _free(value);
          return str;
        }, toWireType: function(destructors, value) {
          if (value instanceof ArrayBuffer) {
            value = new Uint8Array(value);
          }
          var getLength;
          var valueIsOfTypeString = typeof value == "string";
          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
            throwBindingError("Cannot pass non-string to std::string");
          }
          if (stdStringIsUTF8 && valueIsOfTypeString) {
            getLength = () => lengthBytesUTF8(value);
          } else {
            getLength = () => value.length;
          }
          var length = getLength();
          var ptr = _malloc(4 + length + 1);
          HEAPU32[ptr >> 2] = length;
          if (stdStringIsUTF8 && valueIsOfTypeString) {
            stringToUTF8(value, ptr + 4, length + 1);
          } else {
            if (valueIsOfTypeString) {
              for (var i = 0;i < length; ++i) {
                var charCode = value.charCodeAt(i);
                if (charCode > 255) {
                  _free(ptr);
                  throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                }
                HEAPU8[ptr + 4 + i] = charCode;
              }
            } else {
              for (var i = 0;i < length; ++i) {
                HEAPU8[ptr + 4 + i] = value[i];
              }
            }
          }
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        }, argPackAdvance: 8, readValueFromPointer: simpleReadValueFromPointer, destructorFunction: function(ptr) {
          _free(ptr);
        } });
      }
      function __embind_register_std_wstring(rawType, charSize, name) {
        name = readLatin1String(name);
        var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
        if (charSize === 2) {
          decodeString = UTF16ToString;
          encodeString = stringToUTF16;
          lengthBytesUTF = lengthBytesUTF16;
          getHeap = () => HEAPU16;
          shift = 1;
        } else if (charSize === 4) {
          decodeString = UTF32ToString;
          encodeString = stringToUTF32;
          lengthBytesUTF = lengthBytesUTF32;
          getHeap = () => HEAPU32;
          shift = 2;
        }
        registerType(rawType, { name, fromWireType: function(value) {
          var length = HEAPU32[value >> 2];
          var HEAP = getHeap();
          var str;
          var decodeStartPtr = value + 4;
          for (var i = 0;i <= length; ++i) {
            var currentBytePtr = value + 4 + i * charSize;
            if (i == length || HEAP[currentBytePtr >> shift] == 0) {
              var maxReadBytes = currentBytePtr - decodeStartPtr;
              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
              if (str === undefined) {
                str = stringSegment;
              } else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + charSize;
            }
          }
          _free(value);
          return str;
        }, toWireType: function(destructors, value) {
          if (!(typeof value == "string")) {
            throwBindingError("Cannot pass non-string to C++ string type " + name);
          }
          var length = lengthBytesUTF(value);
          var ptr = _malloc(4 + length + charSize);
          HEAPU32[ptr >> 2] = length >> shift;
          encodeString(value, ptr + 4, length + charSize);
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        }, argPackAdvance: 8, readValueFromPointer: simpleReadValueFromPointer, destructorFunction: function(ptr) {
          _free(ptr);
        } });
      }
      function __embind_register_void(rawType, name) {
        name = readLatin1String(name);
        registerType(rawType, { isVoid: true, name, argPackAdvance: 0, fromWireType: function() {
          return;
        }, toWireType: function(destructors, o) {
          return;
        } });
      }
      function _abort() {
        abort("");
      }
      function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.copyWithin(dest, src, src + num);
      }
      function _emscripten_get_heap_max() {
        return 2147483648;
      }
      function emscripten_realloc_buffer(size) {
        try {
          wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
          updateGlobalBufferAndViews(wasmMemory.buffer);
          return 1;
        } catch (e) {}
      }
      function _emscripten_resize_heap(requestedSize) {
        var oldSize = HEAPU8.length;
        requestedSize = requestedSize >>> 0;
        var maxHeapSize = _emscripten_get_heap_max();
        if (requestedSize > maxHeapSize) {
          return false;
        }
        for (var cutDown = 1;cutDown <= 4; cutDown *= 2) {
          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
          var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
          var replacement = emscripten_realloc_buffer(newSize);
          if (replacement) {
            return true;
          }
        }
        return false;
      }
      function _setTempRet0(val) {
        setTempRet0(val);
      }
      embind_init_charCodes();
      BindingError = Module["BindingError"] = extendError(Error, "BindingError");
      InternalError = Module["InternalError"] = extendError(Error, "InternalError");
      init_ClassHandle();
      init_embind();
      init_RegisteredPointer();
      UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
      init_emval();
      var asmLibraryArg = { a: ___assert_fail, j: __embind_register_bigint, h: __embind_register_bool, q: __embind_register_class, p: __embind_register_class_constructor, b: __embind_register_class_function, o: __embind_register_emval, g: __embind_register_float, d: __embind_register_integer, c: __embind_register_memory_view, f: __embind_register_std_string, e: __embind_register_std_wstring, i: __embind_register_void, l: _abort, n: _emscripten_memcpy_big, m: _emscripten_resize_heap, k: _setTempRet0 };
      var asm = createWasm();
      var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
        return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["s"]).apply(null, arguments);
      };
      var _decodeRGBA = Module["_decodeRGBA"] = function() {
        return (_decodeRGBA = Module["_decodeRGBA"] = Module["asm"]["t"]).apply(null, arguments);
      };
      var _decodeFree = Module["_decodeFree"] = function() {
        return (_decodeFree = Module["_decodeFree"] = Module["asm"]["u"]).apply(null, arguments);
      };
      var _allocBuffer = Module["_allocBuffer"] = function() {
        return (_allocBuffer = Module["_allocBuffer"] = Module["asm"]["v"]).apply(null, arguments);
      };
      var _malloc = Module["_malloc"] = function() {
        return (_malloc = Module["_malloc"] = Module["asm"]["w"]).apply(null, arguments);
      };
      var _destroyBuffer = Module["_destroyBuffer"] = function() {
        return (_destroyBuffer = Module["_destroyBuffer"] = Module["asm"]["x"]).apply(null, arguments);
      };
      var _free = Module["_free"] = function() {
        return (_free = Module["_free"] = Module["asm"]["y"]).apply(null, arguments);
      };
      var ___getTypeName = Module["___getTypeName"] = function() {
        return (___getTypeName = Module["___getTypeName"] = Module["asm"]["A"]).apply(null, arguments);
      };
      var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
        return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["B"]).apply(null, arguments);
      };
      var stackSave = Module["stackSave"] = function() {
        return (stackSave = Module["stackSave"] = Module["asm"]["C"]).apply(null, arguments);
      };
      var stackRestore = Module["stackRestore"] = function() {
        return (stackRestore = Module["stackRestore"] = Module["asm"]["D"]).apply(null, arguments);
      };
      var stackAlloc = Module["stackAlloc"] = function() {
        return (stackAlloc = Module["stackAlloc"] = Module["asm"]["E"]).apply(null, arguments);
      };
      var dynCall_jiiiii = Module["dynCall_jiiiii"] = function() {
        return (dynCall_jiiiii = Module["dynCall_jiiiii"] = Module["asm"]["F"]).apply(null, arguments);
      };
      Module["cwrap"] = cwrap;
      var calledRun;
      function ExitStatus(status) {
        this.name = "ExitStatus";
        this.message = "Program terminated with exit(" + status + ")";
        this.status = status;
      }
      dependenciesFulfilled = function runCaller() {
        if (!calledRun)
          run();
        if (!calledRun)
          dependenciesFulfilled = runCaller;
      };
      function run(args) {
        args = args || arguments_;
        if (runDependencies > 0) {
          return;
        }
        preRun();
        if (runDependencies > 0) {
          return;
        }
        function doRun() {
          if (calledRun)
            return;
          calledRun = true;
          Module["calledRun"] = true;
          if (ABORT)
            return;
          initRuntime();
          readyPromiseResolve(Module);
          if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"]();
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
      }
      Module["run"] = run;
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function")
          Module["preInit"] = [Module["preInit"]];
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      run();
      return LibWebP2.ready;
    };
  })();
  if (typeof exports === "object" && typeof module === "object")
    module.exports = LibWebP;
  else if (typeof define === "function" && define["amd"])
    define([], function() {
      return LibWebP;
    });
  else if (typeof exports === "object")
    exports["LibWebP"] = LibWebP;
});

// node_modules/node-webpmux/libwebp.js
var require_libwebp2 = __commonJS((exports, module) => {
  var libwebpF = require_libwebp();
  var ranges = {
    preset: { n: 0, m: 5 },
    lossless: { n: 0, m: 9 },
    quality: { n: 0, m: 100 },
    method: { n: 0, m: 6 },
    exact: { n: 0, m: 1 }
  };
  function checkOpts(o) {
    for (let i = 0, keys = Object.keys(o), l2 = keys.length;i < l2; i++) {
      let key2 = keys[i], r = ranges[key2];
      if (!r) {
        continue;
      }
      if (o[key2] < r.n || o[key2] > r.m) {
        throw new Error(`${key2} out of range ${r.n}..${r.m}`);
      }
    }
  }
  function checkAdv(adv) {
    for (let i = 0, keys = Object.keys(adv), l2 = keys.length;i < l2; i++) {
      let key2 = keys[i], r = ranges[key2];
      if (!r) {
        continue;
      }
      if (adv[key2] < r.n || adv[key2] > r.m) {
        throw new Error(`advanced.${key2} out of range ${r.n}..${r.m}`);
      }
    }
  }
  module.exports = class libWebP {
    enc = 0;
    async init() {
      let Module = this.Module = await libwebpF();
      this.api = Module.WebPEnc;
      this.api.getResult = (e) => {
        return new Uint8Array(new Uint8Array(Module.HEAP8.buffer, e.getResult(), e.getResultSize()));
      };
      this.api.decodeRGBA = Module.cwrap("decodeRGBA", "number", ["number", "number"]);
      this.api.decodeFree = Module.cwrap("decodeFree", "", ["number"]);
      this.api.allocBuffer = Module.cwrap("allocBuffer", "number", ["number"]);
      this.api.destroyBuffer = Module.cwrap("destroyBuffer", "", ["number"]);
    }
    initEnc() {
      if (!this.enc) {
        this.enc = new this.Module.WebPEnc;
      }
    }
    destroyEnc() {
      if (this.enc) {
        this.enc.delete();
        delete this.enc;
      }
    }
    encodeImage(data, width2, height2, { preset, lossless, quality, method, exact, advanced } = {}) {
      let { api, Module } = this, p, ret = {}, enc;
      this.initEnc();
      enc = this.enc;
      enc.init();
      checkOpts({ preset, lossless, quality, method, exact });
      if (preset != null) {
        enc.setPreset(preset);
      }
      if (lossless != null) {
        enc.setLosslessPreset(lossless);
      }
      if (quality != null) {
        enc.setQuality(quality);
      }
      if (method != null) {
        enc.setMethod(method);
      }
      if (exact != null) {
        enc.setExact(!!exact);
      }
      if (advanced != null) {
        checkAdv(advanced);
        if (advanced.imageHint != null) {
          enc.advImageHint(advanced.imageHint);
        }
        if (advanced.targetSize != null) {
          enc.advTargetSize(advanced.targetSize);
        }
        if (advanced.targetPSNR != null) {
          enc.advTargetPSNR(advanced.targetPSNR);
        }
        if (advanced.segments != null) {
          enc.advSegments(advanced.segments);
        }
        if (advanced.snsStrength != null) {
          enc.advSnsStrength(advanced.snsStrength);
        }
        if (advanced.filterStrength != null) {
          enc.advFilterStrength(advanced.filterStrength);
        }
        if (advanced.filterSharpness != null) {
          enc.advFilterSharpness(advanced.filterSharpness);
        }
        if (advanced.filterType != null) {
          enc.advFilterType(advanced.filterType);
        }
        if (advanced.autoFilter != null) {
          enc.advAutoFilter(advanced.autoFilter);
        }
        if (advanced.alphaCompression != null) {
          enc.advAlphaCompression(advanced.alphaCompression);
        }
        if (advanced.alphaFiltering != null) {
          enc.advAlphaFiltering(advanced.alphaFiltering);
        }
        if (advanced.alphaQuality != null) {
          enc.advAlphaQuality(advanced.alphaQuality);
        }
        if (advanced.pass != null) {
          enc.advPass(advanced.pass);
        }
        if (advanced.showCompressed != null) {
          enc.advShowCompressed(advanced.showCompressed);
        }
        if (advanced.preprocessing != null) {
          enc.advPreprocessing(advanced.preprocessing);
        }
        if (advanced.partitions != null) {
          enc.advPartitions(advanced.partitions);
        }
        if (advanced.partitionLimit != null) {
          enc.advPartitionLimit(advanced.partitionLimit);
        }
        if (advanced.emulateJpegSize != null) {
          enc.advEmulateJpegSize(advanced.emulateJpegSize);
        }
        if (advanced.threadLevel != null) {
          enc.advThreadLevel(advanced.threadLevel);
        }
        if (advanced.lowMemory != null) {
          enc.advLowMemory(advanced.lowMemory);
        }
        if (advanced.nearLossless != null) {
          enc.advNearLossless(advanced.nearLossless);
        }
        if (advanced.useDeltaPalette != null) {
          enc.advUseDeltaPalette(advanced.useDeltaPalette);
        }
        if (advanced.useSharpYUV != null) {
          enc.advUseSharpYUV(advanced.useSharpYUV);
        }
        if (advanced.qMin != null) {
          enc.advQMin(advanced.qMin);
        }
        if (advanced.qMax != null) {
          enc.advQMax(advanced.qMax);
        }
      }
      p = api.allocBuffer(data.length);
      Module.HEAP8.set(data, p);
      enc.loadRGBA(p, width2, height2);
      api.destroyBuffer(p);
      ret.res = enc.encode();
      if (ret.res == 0) {
        ret.buf = api.getResult(enc);
      }
      this.destroyEnc();
      return ret;
    }
    decodeImage(data, width2, height2) {
      let { api, Module } = this, p, ret;
      let np = api.allocBuffer(data.length);
      Module.HEAP8.set(data, np);
      let bp = api.decodeRGBA(np, data.length);
      ret = new Uint8Array(new Uint8Array(Module.HEAP8.buffer, bp, width2 * height2 * 4));
      api.decodeFree(bp);
      api.destroyBuffer(np);
      return ret;
    }
  };
});

// node_modules/node-webpmux/webp.js
var require_webp = __commonJS((exports, module) => {
  var { WebPReader, WebPWriter } = require_parser();
  var IO = require_io();
  var emptyImageBuffer = Buffer.from([
    82,
    73,
    70,
    70,
    36,
    0,
    0,
    0,
    87,
    69,
    66,
    80,
    86,
    80,
    56,
    32,
    24,
    0,
    0,
    0,
    48,
    1,
    0,
    157,
    1,
    42,
    1,
    0,
    1,
    0,
    2,
    0,
    52,
    37,
    164,
    0,
    3,
    112,
    0,
    254,
    251,
    253,
    80,
    0
  ]);
  var constants = {
    TYPE_LOSSY: 0,
    TYPE_LOSSLESS: 1,
    TYPE_EXTENDED: 2
  };
  var encodeResults = {
    LIB_NOT_READY: -1,
    LIB_INVALID_CONFIG: -2,
    SUCCESS: 0,
    VP8_ENC_ERROR_OUT_OF_MEMORY: 1,
    VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY: 2,
    VP8_ENC_ERROR_NULL_PARAMETER: 3,
    VP8_ENC_ERROR_INVALID_CONFIGURATION: 4,
    VP8_ENC_ERROR_BAD_DIMENSION: 5,
    VP8_ENC_ERROR_PARTITION0_OVERFLOW: 6,
    VP8_ENC_ERROR_PARTITION_OVERFLOW: 7,
    VP8_ENC_ERROR_BAD_WRITE: 8,
    VP8_ENC_ERROR_FILE_TOO_BIG: 9,
    VP8_ENC_ERROR_USER_ABORT: 10,
    VP8_ENC_ERROR_LAST: 11
  };
  var imageHints = {
    DEFAULT: 0,
    PICTURE: 1,
    PHOTO: 2,
    GRAPH: 3
  };
  var imagePresets = {
    DEFAULT: 0,
    PICTURE: 1,
    PHOTO: 2,
    DRAWING: 3,
    ICON: 4,
    TEXT: 5
  };

  class Image2 {
    constructor() {
      this.data = null;
      this.loaded = false;
      this.path = "";
    }
    async initLib() {
      return Image2.initLib();
    }
    clear() {
      this.data = null;
      this.path = "";
      this.loaded = false;
    }
    get width() {
      let d = this.data;
      return !this.loaded ? undefined : d.extended ? d.extended.width : d.vp8l ? d.vp8l.width : d.vp8 ? d.vp8.width : undefined;
    }
    get height() {
      let d = this.data;
      return !this.loaded ? undefined : d.extended ? d.extended.height : d.vp8l ? d.vp8l.height : d.vp8 ? d.vp8.height : undefined;
    }
    get type() {
      return this.loaded ? this.data.type : undefined;
    }
    get hasAnim() {
      return this.loaded ? this.data.extended ? this.data.extended.hasAnim : false : false;
    }
    get hasAlpha() {
      return this.loaded ? this.data.extended ? this.data.extended.hasAlpha : this.data.vp8 ? this.data.vp8.alpha : this.data.vp8l ? this.data.vp8l.alpha : false : false;
    }
    get anim() {
      return this.hasAnim ? this.data.anim : undefined;
    }
    get frames() {
      return this.anim ? this.anim.frames : undefined;
    }
    get iccp() {
      return this.data.extended ? this.data.extended.hasICCP ? this.data.iccp.raw : undefined : undefined;
    }
    set iccp(raw) {
      if (!this.data.extended) {
        this._convertToExtended();
      }
      if (raw === undefined) {
        this.data.extended.hasICCP = false;
        delete this.data.iccp;
      } else {
        this.data.iccp = { raw };
        this.data.extended.hasICCP = true;
      }
    }
    get exif() {
      return this.data.extended ? this.data.extended.hasEXIF ? this.data.exif.raw : undefined : undefined;
    }
    set exif(raw) {
      if (!this.data.extended) {
        this._convertToExtended();
      }
      if (raw === undefined) {
        this.data.extended.hasEXIF = false;
        delete this.data.exif;
      } else {
        this.data.exif = { raw };
        this.data.extended.hasEXIF = true;
      }
    }
    get xmp() {
      return this.data.extended ? this.data.extended.hasXMP ? this.data.xmp.raw : undefined : undefined;
    }
    set xmp(raw) {
      if (!this.data.extended) {
        this._convertToExtended();
      }
      if (raw === undefined) {
        this.data.extended.hasXMP = false;
        delete this.data.xmp;
      } else {
        this.data.xmp = { raw };
        this.data.extended.hasXMP = true;
      }
    }
    _convertToExtended() {
      if (!this.loaded) {
        throw new Error("No image loaded");
      }
      this.data.type = constants.TYPE_EXTENDED;
      this.data.extended = {
        hasICCP: false,
        hasAlpha: false,
        hasEXIF: false,
        hasXMP: false,
        width: this.data.vp8 ? this.data.vp8.width : this.data.vp8l ? this.data.vp8l.width : 1,
        height: this.data.vp8 ? this.data.vp8.height : this.data.vp8l ? this.data.vp8l.height : 1
      };
    }
    async _demuxFrame(d, frame) {
      let { hasICCP, hasEXIF, hasXMP } = this.data.extended ? this.data.extended : { hasICCP: false, hasEXIF: false, hasXMP: false }, hasAlpha = frame.vp8 && frame.vp8.alpha, writer = new WebPWriter;
      if (typeof d === "string") {
        writer.writeFile(d);
      } else {
        writer.writeBuffer();
      }
      writer.writeFileHeader();
      if (hasICCP || hasEXIF || hasXMP || hasAlpha) {
        writer.writeChunk_VP8X({
          hasICCP,
          hasEXIF,
          hasXMP,
          hasAlpha: frame.vp8l && frame.vp8l.alpha || hasAlpha,
          width: frame.width,
          height: frame.height
        });
      }
      if (frame.vp8l) {
        writer.writeChunk_VP8L(frame.vp8l);
      } else if (frame.vp8) {
        if (frame.vp8.alpha) {
          writer.writeChunk_ALPH(frame.alph);
        }
        writer.writeChunk_VP8(frame.vp8);
      } else {
        throw new Error("Frame has no VP8/VP8L?");
      }
      if (hasICCP || hasEXIF || hasXMP || hasAlpha) {
        if (this.data.extended.hasICCP) {
          writer.writeChunk_ICCP(this.data.iccp);
        }
        if (this.data.extended.hasEXIF) {
          writer.writeChunk_EXIF(this.data.exif);
        }
        if (this.data.extended.hasXMP) {
          writer.writeChunk_XMP(this.data.xmp);
        }
      }
      return writer.commit();
    }
    async _save(writer, { width: width2 = undefined, height: height2 = undefined, frames = undefined, bgColor = [255, 255, 255, 255], loops = 0, delay = 100, x = 0, y = 0, blend = true, dispose = false, exif = false, iccp = false, xmp = false } = {}) {
      let _width = width2 !== undefined ? width2 : this.width - 1, _height = height2 !== undefined ? height2 : this.height - 1, isAnim = this.hasAnim || frames !== undefined;
      if (_width < 0 || _width > 1 << 24) {
        throw new Error("Width out of range");
      } else if (_height < 0 || _height > 1 << 24) {
        throw new Error("Height out of range");
      } else if (_height * _width > Math.pow(2, 32) - 1) {
        throw new Error(`Width * height too large (${_width}, ${_height})`);
      }
      if (isAnim) {
        if (loops < 0 || loops >= 1 << 24) {
          throw new Error("Loops out of range");
        } else if (delay < 0 || delay >= 1 << 24) {
          throw new Error("Delay out of range");
        } else if (x < 0 || x >= 1 << 24) {
          throw new Error("X out of range");
        } else if (y < 0 || y >= 1 << 24) {
          throw new Error("Y out of range");
        }
      } else {
        if (_width == 0 || _height == 0) {
          throw new Error("Width/height cannot be 0");
        }
      }
      writer.writeFileHeader();
      switch (this.type) {
        case constants.TYPE_LOSSY:
          writer.writeChunk_VP8(this.data.vp8);
          break;
        case constants.TYPE_LOSSLESS:
          writer.writeChunk_VP8L(this.data.vp8l);
          break;
        case constants.TYPE_EXTENDED:
          {
            let hasICCP = iccp === true ? !!this.iccp : iccp, hasEXIF = exif === true ? !!this.exif : exif, hasXMP = xmp === true ? !!this.xmp : xmp;
            writer.writeChunk_VP8X({
              hasICCP,
              hasEXIF,
              hasXMP,
              hasAlpha: this.data.alph || this.data.vp8l && this.data.vp8l.alpha,
              hasAnim: isAnim,
              width: _width,
              height: _height
            });
            if (hasICCP) {
              writer.writeChunk_ICCP(iccp !== true ? iccp : this.data.iccp);
            }
            if (isAnim) {
              let _frames = frames || this.frames;
              writer.writeChunk_ANIM({ bgColor, loops });
              for (let i = 0, l2 = _frames.length;i < l2; i++) {
                let fr = _frames[i], _delay = fr.delay == undefined ? delay : fr.delay, _x = fr.x == undefined ? x : fr.x, _y = fr.y == undefined ? y : fr.y, _blend = fr.blend == undefined ? blend : fr.blend, _dispose = fr.dispose == undefined ? dispose : fr.dispose, img;
                if (_delay < 0 || _delay >= 1 << 24) {
                  throw new Error(`Delay out of range on frame ${i}`);
                } else if (_x < 0 || _x >= 1 << 24) {
                  throw new Error(`X out of range on frame ${i}`);
                } else if (_y < 0 || _y >= 1 << 24) {
                  throw new Error(`Y out of range on frame ${i}`);
                }
                if (fr.path) {
                  img = new Image2;
                  await img.load(fr.path);
                  img = img.data;
                } else if (fr.buffer) {
                  img = new Image2;
                  await img.load(fr.buffer);
                  img = img.data;
                } else if (fr.img) {
                  img = fr.img.data;
                } else {
                  img = fr;
                }
                writer.writeChunk_ANMF({
                  x: _x,
                  y: _y,
                  delay: _delay,
                  blend: _blend,
                  dispose: _dispose,
                  img
                });
              }
              if (_width == 0 || _height == 0) {
                writer.updateChunk_VP8X_size(_width == 0 ? writer.width : _width, _height == 0 ? writer.height : _height);
              }
            } else {
              if (this.data.vp8) {
                if (this.data.alph) {
                  writer.writeChunk_ALPH(this.data.alph);
                }
                writer.writeChunk_VP8(this.data.vp8);
              } else if (this.data.vp8l) {
                writer.writeChunk_VP8L(this.data.vp8l);
              }
            }
            if (hasEXIF) {
              writer.writeChunk_EXIF(exif !== true ? exif : this.data.exif);
            }
            if (hasXMP) {
              writer.writeChunk_XMP(xmp !== true ? xmp : this.data.xmp);
            }
          }
          break;
        default:
          throw new Error("Unknown image type");
      }
      return writer.commit();
    }
    async load(d) {
      let reader = new WebPReader;
      if (typeof d === "string") {
        if (!IO.avail) {
          await IO.err();
        }
        reader.readFile(d);
        this.path = d;
      } else {
        reader.readBuffer(d);
      }
      this.data = await reader.read();
      this.loaded = true;
    }
    convertToAnim() {
      if (!this.data.extended) {
        this._convertToExtended();
      }
      if (this.hasAnim) {
        return;
      }
      if (this.data.vp8) {
        delete this.data.vp8;
      }
      if (this.data.vp8l) {
        delete this.data.vp8l;
      }
      if (this.data.alph) {
        delete this.data.alph;
      }
      this.data.extended.hasAnim = true;
      this.data.anim = {
        bgColor: [255, 255, 255, 255],
        loops: 0,
        frames: []
      };
    }
    async demux({ path = undefined, buffers = false, frame = -1, prefix = "#FNAME#", start = 0, end = 0 } = {}) {
      if (!this.hasAnim) {
        throw new Error("This image isn't an animation");
      }
      let _end = end == 0 ? this.frames.length : end, bufs = [];
      if (start < 0) {
        start = 0;
      }
      if (_end >= this.frames.length) {
        _end = this.frames.length - 1;
      }
      if (start > _end) {
        let n = start;
        start = _end;
        _end = n;
      }
      if (frame != -1) {
        start = _end = frame;
      }
      for (let i = start;i <= _end; i++) {
        let t = await this._demuxFrame(path ? `${path}/${prefix}_${i}.webp`.replace(/#FNAME#/g, IO.basename(this.path, ".webp")) : undefined, this.anim.frames[i]);
        if (buffers) {
          bufs.push(t);
        }
      }
      if (buffers) {
        return bufs;
      }
    }
    async replaceFrame(frameIndex, d) {
      if (!this.hasAnim) {
        throw new Error("WebP isn't animated");
      }
      if (typeof frameIndex !== "number") {
        throw new Error("Frame index expects a number");
      }
      if (frameIndex < 0 || frameIndex >= this.frames.length) {
        throw new Error(`Frame index out of bounds (0 <= index < ${this.frames.length})`);
      }
      let r = new Image2, fr = this.frames[frameIndex];
      await r.load(d);
      switch (r.type) {
        case constants.TYPE_LOSSY:
        case constants.TYPE_LOSSLESS:
          break;
        case constants.TYPE_EXTENDED:
          if (r.hasAnim) {
            throw new Error("Merging animations not currently supported");
          }
          break;
        default:
          throw new Error("Unknown WebP type");
      }
      switch (fr.type) {
        case constants.TYPE_LOSSY:
          if (fr.vp8.alpha) {
            delete fr.alph;
          }
          delete fr.vp8;
          break;
        case constants.TYPE_LOSSLESS:
          delete fr.vp8l;
          break;
        default:
          throw new Error("Unknown frame type");
      }
      switch (r.type) {
        case constants.TYPE_LOSSY:
          fr.vp8 = r.data.vp8;
          fr.type = constants.TYPE_LOSSY;
          break;
        case constants.TYPE_LOSSLESS:
          fr.vp8l = r.data.vp8l;
          fr.type = constants.TYPE_LOSSLESS;
          break;
        case constants.TYPE_EXTENDED:
          if (r.data.vp8) {
            fr.vp8 = r.data.vp8;
            if (r.data.vp8.alpha) {
              fr.alph = r.data.alph;
            }
            fr.type = constants.TYPE_LOSSY;
          } else if (r.data.vp8l) {
            fr.vp8l = r.data.vp8l;
            fr.type = constants.TYPE_LOSSLESS;
          }
          break;
      }
      fr.width = r.width;
      fr.height = r.height;
    }
    async save(path = this.path, { width: width2 = this.width, height: height2 = this.height, frames = this.frames, bgColor = this.hasAnim ? this.anim.bgColor : [255, 255, 255, 255], loops = this.hasAnim ? this.anim.loops : 0, delay = 100, x = 0, y = 0, blend = true, dispose = false, exif = !!this.exif, iccp = !!this.iccp, xmp = !!this.xmp } = {}) {
      let writer = new WebPWriter;
      if (path !== null) {
        if (!IO.avail) {
          await IO.err();
        }
        writer.writeFile(path);
      } else {
        writer.writeBuffer();
      }
      return this._save(writer, { width: width2, height: height2, frames, bgColor, loops, delay, x, y, blend, dispose, exif, iccp, xmp });
    }
    async getImageData() {
      if (!Image2.libwebp) {
        throw new Error("Must call Image.initLib() before using getImageData");
      }
      if (this.hasAnim) {
        throw new Error("Calling getImageData on animations is not supported");
      }
      let buf = await this.save(null);
      return Image2.libwebp.decodeImage(buf, this.width, this.height);
    }
    async setImageData(buf, { width: width2 = 0, height: height2 = 0, preset = undefined, quality = undefined, exact = undefined, lossless = undefined, method = undefined, advanced = undefined } = {}) {
      if (!Image2.libwebp) {
        throw new Error("Must call Image.initLib() before using setImageData");
      }
      if (this.hasAnim) {
        throw new Error("Calling setImageData on animations is not supported");
      }
      if (quality !== undefined && (quality < 0 || quality > 100)) {
        throw new Error("Quality out of range");
      }
      if (lossless !== undefined && (lossless < 0 || lossless > 9)) {
        throw new Error("Lossless preset out of range");
      }
      if (method !== undefined && (method < 0 || method > 6)) {
        throw new Error("Method out of range");
      }
      let ret = Image2.libwebp.encodeImage(buf, width2 > 0 ? width2 : this.width, height2 > 0 ? height2 : this.height, { preset, quality, exact, lossless, method, advanced }), img = new Image2, keepEx = false, ex;
      if (ret.res !== encodeResults.SUCCESS) {
        return ret.res;
      }
      await img.load(Buffer.from(ret.buf));
      switch (this.type) {
        case constants.TYPE_LOSSY:
          delete this.data.vp8;
          break;
        case constants.TYPE_LOSSLESS:
          delete this.data.vp8l;
          break;
        case constants.TYPE_EXTENDED:
          ex = this.data.extended;
          delete this.data.extended;
          if (ex.hasICCP || ex.hasEXIF || ex.hasXMP) {
            keepEx = true;
          }
          if (this.data.vp8) {
            delete this.data.vp8;
          }
          if (this.data.vp8l) {
            delete this.data.vp8l;
          }
          if (this.data.alph) {
            delete this.data.alph;
          }
          break;
      }
      switch (img.type) {
        case constants.TYPE_LOSSY:
          if (keepEx) {
            this.data.type = constants.TYPE_EXTENDED;
            ex.hasAlpha = false;
            ex.width = img.width;
            ex.height = img.height;
            this.data.extended = ex;
          } else {
            this.data.type = constants.TYPE_LOSSY;
          }
          this.data.vp8 = img.data.vp8;
          break;
        case constants.TYPE_LOSSLESS:
          if (keepEx) {
            this.data.type = constants.TYPE_EXTENDED;
            ex.hasAlpha = img.data.vp8l.alpha;
            ex.width = img.width;
            ex.height = img.height;
            this.data.extended = ex;
          } else {
            this.data.type = constants.TYPE_LOSSLESS;
          }
          this.data.vp8l = img.data.vp8l;
          break;
        case constants.TYPE_EXTENDED:
          this.data.type = constants.TYPE_EXTENDED;
          if (keepEx) {
            ex.hasAlpha = img.data.alph || img.data.vp8l && img.data.vp8l.alpha;
            ex.width = img.width;
            ex.height = img.height;
            this.data.extended = ex;
          } else {
            this.data.extended = img.data.extended;
          }
          if (img.data.vp8) {
            this.data.vp8 = img.data.vp8;
          }
          if (img.data.vp8l) {
            this.data.vp8l = img.data.vp8l;
          }
          if (img.data.alph) {
            this.data.alph = img.data.alph;
          }
          break;
      }
      return encodeResults.SUCCESS;
    }
    async getFrameData(frameIndex) {
      if (!Image2.libwebp) {
        throw new Error("Must call Image.initLib() before using getFrameData");
      }
      if (!this.hasAnim) {
        throw new Error("Calling getFrameData on non-animations is not supported");
      }
      if (typeof frameIndex !== "number") {
        throw new Error("Frame index expects a number");
      }
      if (frameIndex < 0 || frameIndex >= this.frames.length) {
        throw new Error("Frame index out of range");
      }
      let fr = this.frames[frameIndex], buf = await this._demuxFrame(null, fr);
      return Image2.libwebp.decodeImage(buf, fr.width, fr.height);
    }
    async setFrameData(frameIndex, buf, { width: width2 = 0, height: height2 = 0, preset = undefined, quality = undefined, exact = undefined, lossless = undefined, method = undefined, advanced = undefined } = {}) {
      if (!Image2.libwebp) {
        throw new Error("Must call Image.initLib() before using setFrameData");
      }
      if (!this.hasAnim) {
        throw new Error("Calling setFrameData on non-animations is not supported");
      }
      if (typeof frameIndex !== "number") {
        throw new Error("Frame index expects a number");
      }
      if (frameIndex < 0 || frameIndex >= this.frames.length) {
        throw new Error("Frame index out of range");
      }
      if (quality !== undefined && (quality < 0 || quality > 100)) {
        throw new Error("Quality out of range");
      }
      if (lossless !== undefined && (lossless < 0 || lossless > 9)) {
        throw new Error("Lossless preset out of range");
      }
      if (method !== undefined && (method < 0 || method > 6)) {
        throw new Error("Method out of range");
      }
      let fr = this.frames[frameIndex], ret = Image2.libwebp.encodeImage(buf, width2 > 0 ? width2 : fr.width, height2 > 0 ? height2 : fr.height, { preset, quality, exact, lossless, method, advanced }), img = new Image2;
      if (ret.res !== encodeResults.SUCCESS) {
        return ret.res;
      }
      await img.load(Buffer.from(ret.buf));
      switch (fr.type) {
        case constants.TYPE_LOSSY:
          delete fr.vp8;
          if (fr.alph) {
            delete fr.alph;
          }
          break;
        case constants.TYPE_LOSSLESS:
          delete fr.vp8l;
          break;
      }
      fr.width = img.width;
      fr.height = img.height;
      switch (img.type) {
        case constants.TYPE_LOSSY:
          fr.type = img.type;
          fr.vp8 = img.data.vp8;
          break;
        case constants.TYPE_LOSSLESS:
          fr.type = img.type;
          fr.vp8l = img.data.vp8l;
          break;
        case constants.TYPE_EXTENDED:
          if (img.data.vp8) {
            fr.type = constants.TYPE_LOSSY;
            fr.vp8 = img.data.vp8;
            if (img.data.vp8.alpha) {
              fr.alph = img.data.alph;
            }
          } else if (img.data.vp8l) {
            fr.type = constants.TYPE_LOSSLESS;
            fr.vp8l = img.data.vp8l;
          }
          break;
      }
      return encodeResults.SUCCESS;
    }
    static async initLib() {
      if (!Image2.libwebp) {
        const libWebP = require_libwebp2();
        Image2.libwebp = new libWebP;
        await Image2.libwebp.init();
      }
    }
    static async save(d, opts) {
      if (opts.frames && (opts.width === undefined || opts.height === undefined)) {
        throw new Error("Must provide both width and height when passing frames");
      }
      return (await Image2.getEmptyImage(!!opts.frames)).save(d, opts);
    }
    static async getEmptyImage(ext) {
      let img = new Image2;
      await img.load(emptyImageBuffer);
      if (ext) {
        img.exif = undefined;
      }
      return img;
    }
    static async generateFrame({ path = undefined, buffer = undefined, img = undefined, x = undefined, y = undefined, delay = undefined, blend = undefined, dispose = undefined } = {}) {
      let _img = img;
      if (!path && !buffer && !img || path && buffer && img) {
        throw new Error("Must provide either `path`, `buffer`, or `img`");
      }
      if (!img) {
        _img = new Image2;
        if (path) {
          await _img.load(path);
        } else {
          await _img.load(buffer);
        }
      }
      if (_img.hasAnim) {
        throw new Error("Merging animations is not currently supported");
      }
      return {
        img: _img,
        x,
        y,
        delay,
        blend,
        dispose
      };
    }
    static from(webp) {
      let img = new Image2;
      img.data = webp.data;
      img.loaded = webp.loaded;
      img.path = webp.path;
      return img;
    }
  }
  module.exports = {
    TYPE_LOSSY: constants.TYPE_LOSSY,
    TYPE_LOSSLESS: constants.TYPE_LOSSLESS,
    TYPE_EXTENDED: constants.TYPE_EXTENDED,
    encodeResults,
    hints: imageHints,
    presets: imagePresets,
    Image: Image2
  };
});

// node_modules/whatsapp-web.js/src/util/Util.js
var require_Util = __commonJS((exports, module) => {
  var path = __require("path");
  var Crypto = __require("crypto");
  var { tmpdir } = __require("os");
  var ffmpeg = __require("fluent-ffmpeg");
  var webp = require_webp();
  var fs = __require("fs").promises;
  var has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);

  class Util {
    constructor() {
      throw new Error(`The ${this.constructor.name} class may not be instantiated.`);
    }
    static generateHash(length) {
      var result = "";
      var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      var charactersLength = characters.length;
      for (var i = 0;i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    }
    static mergeDefault(def, given) {
      if (!given)
        return def;
      for (const key2 in def) {
        if (!has(given, key2) || given[key2] === undefined) {
          given[key2] = def[key2];
        } else if (given[key2] === Object(given[key2])) {
          given[key2] = Util.mergeDefault(def[key2], given[key2]);
        }
      }
      return given;
    }
    static async formatImageToWebpSticker(media, pupPage) {
      if (!media.mimetype.includes("image"))
        throw new Error("media is not a image");
      if (media.mimetype.includes("webp")) {
        return media;
      }
      return pupPage.evaluate((media2) => {
        return window.WWebJS.toStickerData(media2);
      }, media);
    }
    static async formatVideoToWebpSticker(media) {
      if (!media.mimetype.includes("video"))
        throw new Error("media is not a video");
      const videoType = media.mimetype.split("/")[1];
      const tempFile = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`);
      const stream = new (__require("stream")).Readable;
      const buffer = Buffer.from(media.data.replace(`data:${media.mimetype};base64,`, ""), "base64");
      stream.push(buffer);
      stream.push(null);
      await new Promise((resolve, reject) => {
        ffmpeg(stream).inputFormat(videoType).on("error", reject).on("end", () => resolve(true)).addOutputOptions([
          "-vcodec",
          "libwebp",
          "-vf",
          "scale='iw*min(300/iw,300/ih)':'ih*min(300/iw,300/ih)',format=rgba,pad=300:300:'(300-iw)/2':'(300-ih)/2':'#00000000',setsar=1,fps=10",
          "-loop",
          "0",
          "-ss",
          "00:00:00.0",
          "-t",
          "00:00:05.0",
          "-preset",
          "default",
          "-an",
          "-vsync",
          "0",
          "-s",
          "512:512"
        ]).toFormat("webp").save(tempFile);
      });
      const data = await fs.readFile(tempFile, "base64");
      await fs.unlink(tempFile);
      return {
        mimetype: "image/webp",
        data,
        filename: media.filename
      };
    }
    static async formatToWebpSticker(media, metadata, pupPage) {
      let webpMedia;
      if (media.mimetype.includes("image"))
        webpMedia = await this.formatImageToWebpSticker(media, pupPage);
      else if (media.mimetype.includes("video"))
        webpMedia = await this.formatVideoToWebpSticker(media);
      else
        throw new Error("Invalid media format");
      if (metadata.name || metadata.author) {
        const img = new webp.Image;
        const hash = this.generateHash(32);
        const stickerPackId = hash;
        const packname = metadata.name;
        const author = metadata.author;
        const categories = metadata.categories || [""];
        const json = { "sticker-pack-id": stickerPackId, "sticker-pack-name": packname, "sticker-pack-publisher": author, emojis: categories };
        let exifAttr = Buffer.from([73, 73, 42, 0, 8, 0, 0, 0, 1, 0, 65, 87, 7, 0, 0, 0, 0, 0, 22, 0, 0, 0]);
        let jsonBuffer = Buffer.from(JSON.stringify(json), "utf8");
        let exif = Buffer.concat([exifAttr, jsonBuffer]);
        exif.writeUIntLE(jsonBuffer.length, 14, 4);
        await img.load(Buffer.from(webpMedia.data, "base64"));
        img.exif = exif;
        webpMedia.data = (await img.save(null)).toString("base64");
      }
      return webpMedia;
    }
    static setFfmpegPath(path2) {
      ffmpeg.setFfmpegPath(path2);
    }
  }
  module.exports = Util;
});

// node_modules/whatsapp-web.js/src/util/InterfaceController.js
var require_InterfaceController = __commonJS((exports, module) => {
  class InterfaceController {
    constructor(props) {
      this.pupPage = props.pupPage;
    }
    async openChatWindow(chatId) {
      await this.pupPage.evaluate(async (chatId2) => {
        const chat = await window.WWebJS.getChat(chatId2, { getAsModel: false });
        await window.Store.Cmd.openChatBottom(chat);
      }, chatId);
    }
    async openChatDrawer(chatId) {
      await this.pupPage.evaluate(async (chatId2) => {
        let chat = await window.WWebJS.getChat(chatId2, { getAsModel: false });
        await window.Store.Cmd.openDrawerMid(chat);
      }, chatId);
    }
    async openChatSearch(chatId) {
      await this.pupPage.evaluate(async (chatId2) => {
        let chat = await window.WWebJS.getChat(chatId2, { getAsModel: false });
        await window.Store.Cmd.chatSearch(chat);
      }, chatId);
    }
    async openChatWindowAt(msgId) {
      await this.pupPage.evaluate(async (msgId2) => {
        const msg = window.Store.Msg.get(msgId2) || (await window.Store.Msg.getMessagesById([msgId2]))?.messages?.[0];
        const chat = window.Store.Chat.get(msg.id.remote) ?? await window.Store.Chat.find(msg.id.remote);
        const searchContext = await window.Store.SearchContext.getSearchContext(chat, msg.id);
        await window.Store.Cmd.openChatAt({ chat, msgContext: searchContext });
      }, msgId);
    }
    async openMessageDrawer(msgId) {
      await this.pupPage.evaluate(async (msgId2) => {
        const msg = window.Store.Msg.get(msgId2) || (await window.Store.Msg.getMessagesById([msgId2]))?.messages?.[0];
        await window.Store.Cmd.msgInfoDrawer(msg);
      }, msgId);
    }
    async closeRightDrawer() {
      await this.pupPage.evaluate(async () => {
        await window.Store.DrawerManager.closeDrawerRight();
      });
    }
    async getFeatures() {
      return await this.pupPage.evaluate(() => {
        if (!window.Store.Features)
          throw new Error("This version of Whatsapp Web does not support features");
        return window.Store.Features.F;
      });
    }
    async checkFeatureStatus(feature) {
      return await this.pupPage.evaluate((feature2) => {
        if (!window.Store.Features)
          throw new Error("This version of Whatsapp Web does not support features");
        return window.Store.Features.supportsFeature(feature2);
      }, feature);
    }
    async enableFeatures(features) {
      await this.pupPage.evaluate((features2) => {
        if (!window.Store.Features)
          throw new Error("This version of Whatsapp Web does not support features");
        for (const feature in features2) {
          window.Store.Features.setFeature(features2[feature], true);
        }
      }, features);
    }
    async disableFeatures(features) {
      await this.pupPage.evaluate((features2) => {
        if (!window.Store.Features)
          throw new Error("This version of Whatsapp Web does not support features");
        for (const feature in features2) {
          window.Store.Features.setFeature(features2[feature], false);
        }
      }, features);
    }
  }
  module.exports = InterfaceController;
});

// node_modules/whatsapp-web.js/src/util/Injected/AuthStore/AuthStore.js
var require_AuthStore = __commonJS((exports) => {
  exports.ExposeAuthStore = () => {
    window.AuthStore = {};
    window.AuthStore.AppState = window.require("WAWebSocketModel").Socket;
    window.AuthStore.Cmd = window.require("WAWebCmd").Cmd;
    window.AuthStore.Conn = window.require("WAWebConnModel").Conn;
    window.AuthStore.OfflineMessageHandler = window.require("WAWebOfflineHandler").OfflineMessageHandler;
    window.AuthStore.PairingCodeLinkUtils = window.require("WAWebAltDeviceLinkingApi");
    window.AuthStore.Base64Tools = window.require("WABase64");
    window.AuthStore.RegistrationUtils = {
      ...window.require("WAWebCompanionRegClientUtils"),
      ...window.require("WAWebAdvSignatureApi"),
      ...window.require("WAWebUserPrefsInfoStore"),
      ...window.require("WAWebSignalStoreApi")
    };
  };
});

// node_modules/whatsapp-web.js/src/util/Injected/Store.js
var require_Store = __commonJS((exports) => {
  exports.ExposeStore = () => {
    window.compareWwebVersions = (lOperand, operator, rOperand) => {
      if (![">", ">=", "<", "<=", "="].includes(operator)) {
        throw new class _2 extends Error {
          constructor(m2) {
            super(m2);
            this.name = "CompareWwebVersionsError";
          }
        }("Invalid comparison operator is provided");
      }
      if (typeof lOperand !== "string" || typeof rOperand !== "string") {
        throw new class _2 extends Error {
          constructor(m2) {
            super(m2);
            this.name = "CompareWwebVersionsError";
          }
        }("A non-string WWeb version type is provided");
      }
      lOperand = lOperand.replace(/-beta$/, "");
      rOperand = rOperand.replace(/-beta$/, "");
      while (lOperand.length !== rOperand.length) {
        lOperand.length > rOperand.length ? rOperand = rOperand.concat("0") : lOperand = lOperand.concat("0");
      }
      lOperand = Number(lOperand.replace(/\./g, ""));
      rOperand = Number(rOperand.replace(/\./g, ""));
      return operator === ">" ? lOperand > rOperand : operator === ">=" ? lOperand >= rOperand : operator === "<" ? lOperand < rOperand : operator === "<=" ? lOperand <= rOperand : operator === "=" ? lOperand === rOperand : false;
    };
    window.Store = Object.assign({}, window.require("WAWebCollections"));
    window.Store.AppState = window.require("WAWebSocketModel").Socket;
    window.Store.BlockContact = window.require("WAWebBlockContactAction");
    window.Store.Conn = window.require("WAWebConnModel").Conn;
    window.Store.Cmd = window.require("WAWebCmd").Cmd;
    window.Store.DownloadManager = window.require("WAWebDownloadManager").downloadManager;
    window.Store.GroupQueryAndUpdate = window.require("WAWebGroupQueryJob").queryAndUpdateGroupMetadataById;
    window.Store.MediaPrep = window.require("WAWebPrepRawMedia");
    window.Store.MediaObject = window.require("WAWebMediaStorage");
    window.Store.MediaTypes = window.require("WAWebMmsMediaTypes");
    window.Store.MediaUpload = window.require("WAWebMediaMmsV4Upload");
    window.Store.MsgKey = window.require("WAWebMsgKey");
    window.Store.OpaqueData = window.require("WAWebMediaOpaqueData");
    window.Store.QueryProduct = window.require("WAWebBizProductCatalogBridge");
    window.Store.QueryOrder = window.require("WAWebBizOrderBridge");
    window.Store.SendClear = window.require("WAWebChatClearBridge");
    window.Store.SendDelete = window.require("WAWebDeleteChatAction");
    window.Store.SendMessage = window.require("WAWebSendMsgChatAction");
    window.Store.EditMessage = window.require("WAWebSendMessageEditAction");
    window.Store.SendSeen = window.require("WAWebUpdateUnreadChatAction");
    window.Store.User = window.require("WAWebUserPrefsMeUser");
    window.Store.ContactMethods = window.require("WAWebContactGetters");
    window.Store.UserConstructor = window.require("WAWebWid");
    window.Store.Validators = window.require("WALinkify");
    window.Store.VCard = window.require("WAWebFrontendVcardUtils");
    window.Store.WidFactory = window.require("WAWebWidFactory");
    window.Store.ProfilePic = window.require("WAWebContactProfilePicThumbBridge");
    window.Store.PresenceUtils = window.require("WAWebPresenceChatAction");
    window.Store.ChatState = window.require("WAWebChatStateBridge");
    window.Store.findCommonGroups = window.require("WAWebFindCommonGroupsContactAction").findCommonGroups;
    window.Store.StatusUtils = window.require("WAWebContactStatusBridge");
    window.Store.ConversationMsgs = window.require("WAWebChatLoadMessages");
    window.Store.sendReactionToMsg = window.require("WAWebSendReactionMsgAction").sendReactionToMsg;
    window.Store.createOrUpdateReactionsModule = window.require("WAWebDBCreateOrUpdateReactions");
    window.Store.EphemeralFields = window.require("WAWebGetEphemeralFieldsMsgActionsUtils");
    window.Store.MsgActionChecks = window.require("WAWebMsgActionCapability");
    window.Store.QuotedMsg = window.require("WAWebQuotedMsgModelUtils");
    window.Store.LinkPreview = window.require("WAWebLinkPreviewChatAction");
    window.Store.Socket = window.require("WADeprecatedSendIq");
    window.Store.SocketWap = window.require("WAWap");
    window.Store.SearchContext = window.require("WAWebChatMessageSearch");
    window.Store.DrawerManager = window.require("WAWebDrawerManager").DrawerManager;
    window.Store.LidUtils = window.require("WAWebApiContact");
    window.Store.WidToJid = window.require("WAWebWidToJid");
    window.Store.JidToWid = window.require("WAWebJidToWid");
    window.Store.getMsgInfo = window.require("WAWebApiMessageInfoStore").queryMsgInfo;
    window.Store.pinUnpinMsg = window.require("WAWebSendPinMessageAction").sendPinInChatMsg;
    window.Store.QueryExist = window.require("WAWebQueryExistsJob").queryWidExists;
    window.Store.ReplyUtils = window.require("WAWebMsgReply");
    window.Store.BotSecret = window.require("WAWebBotMessageSecret");
    window.Store.BotProfiles = window.require("WAWebBotProfileCollection");
    window.Store.ContactCollection = window.require("WAWebContactCollection").ContactCollection;
    window.Store.DeviceList = window.require("WAWebApiDeviceList");
    window.Store.HistorySync = window.require("WAWebSendNonMessageDataRequest");
    window.Store.AddonReactionTable = window.require("WAWebAddonReactionTableMode").reactionTableMode;
    window.Store.ChatGetters = window.require("WAWebChatGetters");
    window.Store.Settings = {
      ...window.require("WAWebUserPrefsGeneral"),
      ...window.require("WAWebUserPrefsNotifications"),
      setPushname: window.require("WAWebSetPushnameConnAction").setPushname
    };
    window.Store.NumberInfo = {
      ...window.require("WAPhoneUtils"),
      ...window.require("WAPhoneFindCC")
    };
    window.Store.ForwardUtils = {
      ...window.require("WAWebForwardMessagesToChat")
    };
    window.Store.StickerTools = {
      ...window.require("WAWebImageUtils"),
      ...window.require("WAWebAddWebpMetadata")
    };
    window.Store.GroupUtils = {
      ...window.require("WAWebGroupCreateJob"),
      ...window.require("WAWebGroupModifyInfoJob"),
      ...window.require("WAWebExitGroupAction"),
      ...window.require("WAWebContactProfilePicThumbBridge")
    };
    window.Store.GroupParticipants = {
      ...window.require("WAWebModifyParticipantsGroupAction"),
      ...window.require("WASmaxGroupsAddParticipantsRPC")
    };
    window.Store.GroupInvite = {
      ...window.require("WAWebGroupInviteJob"),
      ...window.require("WAWebGroupQueryJob"),
      ...window.require("WAWebMexFetchGroupInviteCodeJob")
    };
    window.Store.GroupInviteV4 = {
      ...window.require("WAWebGroupInviteV4Job"),
      ...window.require("WAWebChatSendMessages")
    };
    window.Store.MembershipRequestUtils = {
      ...window.require("WAWebApiMembershipApprovalRequestStore"),
      ...window.require("WASmaxGroupsMembershipRequestsActionRPC")
    };
    window.Store.ChannelUtils = {
      ...window.require("WAWebLoadNewsletterPreviewChatAction"),
      ...window.require("WAWebNewsletterMetadataQueryJob"),
      ...window.require("WAWebNewsletterCreateQueryJob"),
      ...window.require("WAWebEditNewsletterMetadataAction"),
      ...window.require("WAWebNewsletterDeleteAction"),
      ...window.require("WAWebNewsletterSubscribeAction"),
      ...window.require("WAWebNewsletterUnsubscribeAction"),
      ...window.require("WAWebNewsletterDirectorySearchAction"),
      ...window.require("WAWebNewsletterToggleMuteStateJob"),
      ...window.require("WAWebNewsletterGatingUtils"),
      ...window.require("WAWebNewsletterModelUtils"),
      ...window.require("WAWebMexAcceptNewsletterAdminInviteJob"),
      ...window.require("WAWebMexRevokeNewsletterAdminInviteJob"),
      ...window.require("WAWebChangeNewsletterOwnerAction"),
      ...window.require("WAWebDemoteNewsletterAdminAction"),
      ...window.require("WAWebNewsletterDemoteAdminJob"),
      countryCodesIso: window.require("WAWebCountriesNativeCountryNames"),
      currentRegion: window.require("WAWebL10N").getRegion()
    };
    window.Store.SendChannelMessage = {
      ...window.require("WAWebNewsletterUpdateMsgsRecordsJob"),
      ...window.require("WAWebMsgDataFromModel"),
      ...window.require("WAWebNewsletterSendMessageJob"),
      ...window.require("WAWebNewsletterSendMsgAction"),
      ...window.require("WAMediaCalculateFilehash")
    };
    window.Store.ChannelSubscribers = {
      ...window.require("WAWebMexFetchNewsletterSubscribersJob"),
      ...window.require("WAWebNewsletterSubscriberListAction")
    };
    window.Store.AddressbookContactUtils = {
      ...window.require("WAWebSaveContactAction"),
      ...window.require("WAWebDeleteContactAction")
    };
    if (!window.Store.Chat._find || !window.Store.Chat.findImpl) {
      window.Store.Chat._find = (e) => {
        const target = window.Store.Chat.get(e);
        return target ? Promise.resolve(target) : Promise.resolve({
          id: e
        });
      };
      window.Store.Chat.findImpl = window.Store.Chat._find;
    }
    window.injectToFunction = (target, callback) => {
      const module2 = window.require(target.module);
      const originalFunction = module2[target.function];
      const modifiedFunction = (...args) => callback(originalFunction, ...args);
      module2[target.function] = modifiedFunction;
    };
    window.injectToFunction({ module: "WAWebBackendJobsCommon", function: "mediaTypeFromProtobuf" }, (func, ...args) => {
      const [proto] = args;
      return proto.locationMessage ? null : func(...args);
    });
    window.injectToFunction({ module: "WAWebE2EProtoUtils", function: "typeAttributeFromProtobuf" }, (func, ...args) => {
      const [proto] = args;
      return proto.locationMessage || proto.groupInviteMessage ? "text" : func(...args);
    });
  };
});

// node_modules/whatsapp-web.js/src/util/Injected/AuthStore/LegacyAuthStore.js
var require_LegacyAuthStore = __commonJS((exports, module) => {
  exports.ExposeLegacyAuthStore = (moduleRaidStr) => {
    eval("var moduleRaid = " + moduleRaidStr);
    window.mR = moduleRaid();
    window.AuthStore = {};
    window.AuthStore.AppState = window.mR.findModule("Socket")[0].Socket;
    window.AuthStore.Cmd = window.mR.findModule("Cmd")[0].Cmd;
    window.AuthStore.Conn = window.mR.findModule("Conn")[0].Conn;
    window.AuthStore.OfflineMessageHandler = window.mR.findModule("OfflineMessageHandler")[0].OfflineMessageHandler;
    window.AuthStore.PairingCodeLinkUtils = window.mR.findModule("initializeAltDeviceLinking")[0];
    window.AuthStore.Base64Tools = window.mR.findModule("encodeB64")[0];
    window.AuthStore.RegistrationUtils = {
      ...window.mR.findModule("getCompanionWebClientFromBrowser")[0],
      ...window.mR.findModule("verifyKeyIndexListAccountSignature")[0],
      ...window.mR.findModule("waNoiseInfo")[0],
      ...window.mR.findModule("waSignalStore")[0]
    };
  };
});

// node_modules/whatsapp-web.js/src/util/Injected/LegacyStore.js
var require_LegacyStore = __commonJS((exports) => {
  exports.ExposeLegacyStore = () => {
    window.Store = Object.assign({}, window.mR.findModule((m2) => m2.default && m2.default.Chat)[0].default);
    window.Store.AppState = window.mR.findModule("Socket")[0].Socket;
    window.Store.Conn = window.mR.findModule("Conn")[0].Conn;
    window.Store.BlockContact = window.mR.findModule("blockContact")[0];
    window.Store.Call = window.mR.findModule((module2) => module2.default && module2.default.Call)[0].default.Call;
    window.Store.Cmd = window.mR.findModule("Cmd")[0].Cmd;
    window.Store.CryptoLib = window.mR.findModule("decryptE2EMedia")[0];
    window.Store.DownloadManager = window.mR.findModule("downloadManager")[0].downloadManager;
    window.Store.GroupMetadata = window.mR.findModule("GroupMetadata")[0].default.GroupMetadata;
    window.Store.GroupQueryAndUpdate = window.mR.findModule("queryAndUpdateGroupMetadataById")[0].queryAndUpdateGroupMetadataById;
    window.Store.Label = window.mR.findModule("LabelCollection")[0].LabelCollection;
    window.Store.MediaPrep = window.mR.findModule("prepRawMedia")[0];
    window.Store.MediaObject = window.mR.findModule("getOrCreateMediaObject")[0];
    window.Store.NumberInfo = window.mR.findModule("formattedPhoneNumber")[0];
    window.Store.MediaTypes = window.mR.findModule("msgToMediaType")[0];
    window.Store.MediaUpload = window.mR.findModule("uploadMedia")[0];
    window.Store.MsgKey = window.mR.findModule((module2) => module2.default && module2.default.fromString)[0].default;
    window.Store.OpaqueData = window.mR.findModule((module2) => module2.default && module2.default.createFromData)[0].default;
    window.Store.QueryProduct = window.mR.findModule("queryProduct")[0];
    window.Store.QueryOrder = window.mR.findModule("queryOrder")[0];
    window.Store.SendClear = window.mR.findModule("sendClear")[0];
    window.Store.SendDelete = window.mR.findModule("sendDelete")[0];
    window.Store.SendMessage = window.mR.findModule("addAndSendMsgToChat")[0];
    window.Store.EditMessage = window.mR.findModule("addAndSendMessageEdit")[0];
    window.Store.SendSeen = window.mR.findModule("sendSeen")[0];
    window.Store.User = window.mR.findModule("getMaybeMeUser")[0];
    window.Store.ContactMethods = window.mR.findModule("getUserid")[0];
    window.Store.UploadUtils = window.mR.findModule((module2) => module2.default && module2.default.encryptAndUpload ? module2.default : null)[0].default;
    window.Store.UserConstructor = window.mR.findModule((module2) => module2.default && module2.default.prototype && module2.default.prototype.isServer && module2.default.prototype.isUser ? module2.default : null)[0].default;
    window.Store.Validators = window.mR.findModule("findLinks")[0];
    window.Store.VCard = window.mR.findModule("vcardFromContactModel")[0];
    window.Store.WidFactory = window.mR.findModule("createWid")[0];
    window.Store.ProfilePic = window.mR.findModule("profilePicResync")[0];
    window.Store.PresenceUtils = window.mR.findModule("sendPresenceAvailable")[0];
    window.Store.ChatState = window.mR.findModule("sendChatStateComposing")[0];
    window.Store.findCommonGroups = window.mR.findModule("findCommonGroups")[0].findCommonGroups;
    window.Store.StatusUtils = window.mR.findModule("setMyStatus")[0];
    window.Store.ConversationMsgs = window.mR.findModule("loadEarlierMsgs")[0];
    window.Store.sendReactionToMsg = window.mR.findModule("sendReactionToMsg")[0].sendReactionToMsg;
    window.Store.createOrUpdateReactionsModule = window.mR.findModule("createOrUpdateReactions")[0];
    window.Store.EphemeralFields = window.mR.findModule("getEphemeralFields")[0];
    window.Store.MsgActionChecks = window.mR.findModule("canSenderRevokeMsg")[0];
    window.Store.QuotedMsg = window.mR.findModule("getQuotedMsgObj")[0];
    window.Store.LinkPreview = window.mR.findModule("getLinkPreview")[0];
    window.Store.Socket = window.mR.findModule("deprecatedSendIq")[0];
    window.Store.SocketWap = window.mR.findModule("wap")[0];
    window.Store.SearchContext = window.mR.findModule("getSearchContext")[0].getSearchContext;
    window.Store.DrawerManager = window.mR.findModule("DrawerManager")[0].DrawerManager;
    window.Store.LidUtils = window.mR.findModule("getCurrentLid")[0];
    window.Store.WidToJid = window.mR.findModule("widToUserJid")[0];
    window.Store.JidToWid = window.mR.findModule("userJidToUserWid")[0];
    window.Store.getMsgInfo = (window.mR.findModule("sendQueryMsgInfo")[0] || {}).sendQueryMsgInfo || window.mR.findModule("queryMsgInfo")[0].queryMsgInfo;
    window.Store.pinUnpinMsg = window.mR.findModule("sendPinInChatMsg")[0].sendPinInChatMsg;
    window.Store.QueryExist = (m = window.mR.findModule("queryExists")[0]) ? m.queryExists : window.mR.findModule("queryExist")[0].queryWidExists;
    window.Store.ReplyUtils = (m = window.mR.findModule("canReplyMsg")).length > 0 && m[0];
    window.Store.Settings = {
      ...window.mR.findModule("ChatlistPanelState")[0],
      setPushname: window.mR.findModule((m2) => m2.setPushname && !m2.ChatlistPanelState)[0].setPushname
    };
    window.Store.StickerTools = {
      ...window.mR.findModule("toWebpSticker")[0],
      ...window.mR.findModule("addWebpMetadata")[0]
    };
    window.Store.GroupUtils = {
      ...window.mR.findModule("createGroup")[0],
      ...window.mR.findModule("setGroupDescription")[0],
      ...window.mR.findModule("sendExitGroup")[0],
      ...window.mR.findModule("sendSetPicture")[0]
    };
    window.Store.GroupParticipants = {
      ...window.mR.findModule("promoteParticipants")[0],
      ...window.mR.findModule("sendAddParticipantsRPC")[0]
    };
    window.Store.GroupInvite = {
      ...window.mR.findModule("resetGroupInviteCode")[0],
      ...window.mR.findModule("queryGroupInvite")[0]
    };
    window.Store.GroupInviteV4 = {
      ...window.mR.findModule("queryGroupInviteV4")[0],
      ...window.mR.findModule("sendGroupInviteMessage")[0]
    };
    window.Store.MembershipRequestUtils = {
      ...window.mR.findModule("getMembershipApprovalRequests")[0],
      ...window.mR.findModule("sendMembershipRequestsActionRPC")[0]
    };
    if (!window.Store.Chat._find) {
      window.Store.Chat._find = (e) => {
        const target = window.Store.Chat.get(e);
        return target ? Promise.resolve(target) : Promise.resolve({
          id: e
        });
      };
    }
    if ((m = window.mR.findModule("ChatCollection")[0]) && m.ChatCollection && typeof m.ChatCollection.findImpl === "undefined" && typeof m.ChatCollection._find !== "undefined")
      m.ChatCollection.findImpl = m.ChatCollection._find;
    const _isMDBackend = window.mR.findModule("isMDBackend");
    if (_isMDBackend && _isMDBackend[0] && _isMDBackend[0].isMDBackend) {
      window.Store.MDBackend = _isMDBackend[0].isMDBackend();
    } else {
      window.Store.MDBackend = true;
    }
    const _features = window.mR.findModule("FEATURE_CHANGE_EVENT")[0];
    if (_features) {
      window.Store.Features = _features.LegacyPhoneFeatures;
    }
    window.injectToFunction = (target, callback) => {
      const module2 = typeof target.module === "string" ? window.mR.findModule(target.module) : window.mR.modules[target.module];
      const originalFunction = module2[target.index][target.function];
      const modifiedFunction = (...args) => callback(originalFunction, ...args);
      module2[target.index][target.function] = modifiedFunction;
    };
    window.injectToFunction({ module: "mediaTypeFromProtobuf", index: 0, function: "mediaTypeFromProtobuf" }, (func, ...args) => {
      const [proto] = args;
      return proto.locationMessage ? null : func(...args);
    });
    window.injectToFunction({ module: "typeAttributeFromProtobuf", index: 0, function: "typeAttributeFromProtobuf" }, (func, ...args) => {
      const [proto] = args;
      return proto.locationMessage || proto.groupInviteMessage ? "text" : func(...args);
    });
  };
});

// node_modules/whatsapp-web.js/src/util/Injected/Utils.js
var require_Utils = __commonJS((exports) => {
  exports.LoadUtils = () => {
    window.WWebJS = {};
    window.WWebJS.forwardMessage = async (chatId, msgId) => {
      const msg = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
      const chat = await window.WWebJS.getChat(chatId, { getAsModel: false });
      if (window.compareWwebVersions(window.Debug.VERSION, ">", "2.3000.0")) {
        return window.Store.ForwardUtils.forwardMessagesToChats([msg], [chat], true);
      } else {
        return chat.forwardMessages([msg]);
      }
    };
    window.WWebJS.sendSeen = async (chatId) => {
      const chat = await window.WWebJS.getChat(chatId, { getAsModel: false });
      if (chat) {
        await window.Store.SendSeen.sendSeen(chat);
        return true;
      }
      return false;
    };
    window.WWebJS.sendMessage = async (chat, content, options = {}) => {
      const isChannel = window.Store.ChatGetters.getIsNewsletter(chat);
      let mediaOptions = {};
      if (options.media) {
        mediaOptions = await window.WWebJS.processMediaData(options.media, {
          forceSticker: options.sendMediaAsSticker,
          forceGif: options.sendVideoAsGif,
          forceVoice: options.sendAudioAsVoice,
          forceDocument: options.sendMediaAsDocument,
          sendToChannel: isChannel
        });
        mediaOptions.caption = options.caption;
        content = options.sendMediaAsSticker ? undefined : mediaOptions.preview;
        mediaOptions.isViewOnce = options.isViewOnce;
        delete options.media;
        delete options.sendMediaAsSticker;
      }
      let quotedMsgOptions = {};
      if (options.quotedMessageId) {
        let quotedMessage = window.Store.Msg.get(options.quotedMessageId);
        !quotedMessage && (quotedMessage = (await window.Store.Msg.getMessagesById([options.quotedMessageId]))?.messages?.[0]);
        if (quotedMessage["messages"]?.length == 1) {
          quotedMessage = quotedMessage["messages"][0];
          const canReply = window.Store.ReplyUtils ? window.Store.ReplyUtils.canReplyMsg(quotedMessage.unsafe()) : quotedMessage.canReply();
          if (canReply) {
            quotedMsgOptions = quotedMessage.msgContextInfo(chat);
          }
        } else {
          if (!options.ignoreQuoteErrors) {
            throw new Error("Could not get the quoted message.");
          }
        }
        delete options.ignoreQuoteErrors;
        delete options.quotedMessageId;
      }
      if (options.mentionedJidList) {
        options.mentionedJidList = await Promise.all(options.mentionedJidList.map(async (id) => {
          const wid = window.Store.WidFactory.createWid(id);
          if (await window.Store.QueryExist(wid)) {
            return wid;
          }
        }));
        options.mentionedJidList = options.mentionedJidList.filter(Boolean);
      }
      if (options.groupMentions) {
        options.groupMentions = options.groupMentions.map((e) => ({
          groupSubject: e.subject,
          groupJid: window.Store.WidFactory.createWid(e.id)
        }));
      }
      let locationOptions = {};
      if (options.location) {
        let { latitude, longitude, description, url } = options.location;
        url = window.Store.Validators.findLink(url)?.href;
        url && !description && (description = url);
        locationOptions = {
          type: "location",
          loc: description,
          lat: latitude,
          lng: longitude,
          clientUrl: url
        };
        delete options.location;
      }
      let _pollOptions = {};
      if (options.poll) {
        const { pollName, pollOptions } = options.poll;
        const { allowMultipleAnswers, messageSecret } = options.poll.options;
        _pollOptions = {
          kind: "pollCreation",
          type: "poll_creation",
          pollName,
          pollOptions,
          pollSelectableOptionsCount: allowMultipleAnswers ? 0 : 1,
          messageSecret: Array.isArray(messageSecret) && messageSecret.length === 32 ? new Uint8Array(messageSecret) : window.crypto.getRandomValues(new Uint8Array(32))
        };
        delete options.poll;
      }
      let vcardOptions = {};
      if (options.contactCard) {
        let contact = window.Store.Contact.get(options.contactCard);
        vcardOptions = {
          body: window.Store.VCard.vcardFromContactModel(contact).vcard,
          type: "vcard",
          vcardFormattedName: contact.formattedName
        };
        delete options.contactCard;
      } else if (options.contactCardList) {
        let contacts = options.contactCardList.map((c) => window.Store.Contact.get(c));
        let vcards = contacts.map((c) => window.Store.VCard.vcardFromContactModel(c));
        vcardOptions = {
          type: "multi_vcard",
          vcardList: vcards,
          body: undefined
        };
        delete options.contactCardList;
      } else if (options.parseVCards && typeof content === "string" && content.startsWith("BEGIN:VCARD")) {
        delete options.parseVCards;
        try {
          const parsed = window.Store.VCard.parseVcard(content);
          if (parsed) {
            vcardOptions = {
              type: "vcard",
              vcardFormattedName: window.Store.VCard.vcardGetNameFromParsed(parsed)
            };
          }
        } catch (_2) {}
      }
      if (options.linkPreview) {
        delete options.linkPreview;
        const link = window.Store.Validators.findLink(content);
        if (link) {
          let preview = await window.Store.LinkPreview.getLinkPreview(link);
          if (preview && preview.data) {
            preview = preview.data;
            preview.preview = true;
            preview.subtype = "url";
            options = { ...options, ...preview };
          }
        }
      }
      let buttonOptions = {};
      if (options.buttons) {
        let caption;
        if (options.buttons.type === "chat") {
          content = options.buttons.body;
          caption = content;
        } else {
          caption = options.caption ? options.caption : " ";
        }
        buttonOptions = {
          productHeaderImageRejected: false,
          isFromTemplate: false,
          isDynamicReplyButtonsMsg: true,
          title: options.buttons.title ? options.buttons.title : undefined,
          footer: options.buttons.footer ? options.buttons.footer : undefined,
          dynamicReplyButtons: options.buttons.buttons,
          replyButtons: options.buttons.buttons,
          caption
        };
        delete options.buttons;
      }
      let listOptions = {};
      if (options.list) {
        if (window.Store.Conn.platform === "smba" || window.Store.Conn.platform === "smbi") {
          throw "[LT01] Whatsapp business can't send this yet";
        }
        listOptions = {
          type: "list",
          footer: options.list.footer,
          list: {
            ...options.list,
            listType: 1
          },
          body: options.list.description
        };
        delete options.list;
        delete listOptions.list.footer;
      }
      const botOptions = {};
      if (options.invokedBotWid) {
        botOptions.messageSecret = window.crypto.getRandomValues(new Uint8Array(32));
        botOptions.botMessageSecret = await window.Store.BotSecret.genBotMsgSecretFromMsgSecret(botOptions.messageSecret);
        botOptions.invokedBotWid = window.Store.WidFactory.createWid(options.invokedBotWid);
        botOptions.botPersonaId = window.Store.BotProfiles.BotProfileCollection.get(options.invokedBotWid).personaId;
        delete options.invokedBotWid;
      }
      const lidUser = window.Store.User.getMaybeMeLidUser();
      const meUser = window.Store.User.getMaybeMeUser();
      const newId = await window.Store.MsgKey.newId();
      let from = chat.id.isLid() ? lidUser : meUser;
      let participant;
      if (chat.isGroup) {
        from = chat.groupMetadata && chat.groupMetadata.isLidAddressingMode ? lidUser : meUser;
        participant = window.Store.WidFactory.toUserWid(from);
      }
      const newMsgKey = new window.Store.MsgKey({
        from,
        to: chat.id,
        id: newId,
        participant,
        selfDir: "out"
      });
      const extraOptions = options.extraOptions || {};
      delete options.extraOptions;
      const ephemeralFields = window.Store.EphemeralFields.getEphemeralFields(chat);
      const message = {
        ...options,
        id: newMsgKey,
        ack: 0,
        body: content,
        from: meUser,
        to: chat.id,
        local: true,
        self: "out",
        t: parseInt(new Date().getTime() / 1000),
        isNewMsg: true,
        type: "chat",
        ...ephemeralFields,
        ...mediaOptions,
        ...mediaOptions.toJSON ? mediaOptions.toJSON() : {},
        ...quotedMsgOptions,
        ...locationOptions,
        ..._pollOptions,
        ...vcardOptions,
        ...buttonOptions,
        ...listOptions,
        ...botOptions,
        ...extraOptions
      };
      if (botOptions) {
        delete message.canonicalUrl;
      }
      if (isChannel) {
        const msg = new window.Store.Msg.modelClass(message);
        const msgDataFromMsgModel = window.Store.SendChannelMessage.msgDataFromMsgModel(msg);
        const isMedia = Object.keys(mediaOptions).length > 0;
        await window.Store.SendChannelMessage.addNewsletterMsgsRecords([msgDataFromMsgModel]);
        chat.msgs.add(msg);
        chat.t = msg.t;
        const sendChannelMsgResponse = await window.Store.SendChannelMessage.sendNewsletterMessageJob({
          msg,
          type: message.type === "chat" ? "text" : isMedia ? "media" : "pollCreation",
          newsletterJid: chat.id.toJid(),
          ...isMedia ? {
            mediaMetadata: msg.avParams(),
            mediaHandle: isMedia ? mediaOptions.mediaHandle : null
          } : {}
        });
        if (sendChannelMsgResponse.success) {
          msg.t = sendChannelMsgResponse.ack.t;
          msg.serverId = sendChannelMsgResponse.serverId;
        }
        msg.updateAck(1, true);
        await window.Store.SendChannelMessage.updateNewsletterMsgRecord(msg);
        return msg;
      }
      await window.Store.SendMessage.addAndSendMsgToChat(chat, message);
      return window.Store.Msg.get(newMsgKey._serialized);
    };
    window.WWebJS.editMessage = async (msg, content, options = {}) => {
      const extraOptions = options.extraOptions || {};
      delete options.extraOptions;
      if (options.mentionedJidList) {
        options.mentionedJidList = await Promise.all(options.mentionedJidList.map(async (id) => {
          const wid = window.Store.WidFactory.createWid(id);
          if (await window.Store.QueryExist(wid)) {
            return wid;
          }
        }));
        options.mentionedJidList = options.mentionedJidList.filter(Boolean);
      }
      if (options.groupMentions) {
        options.groupMentions = options.groupMentions.map((e) => ({
          groupSubject: e.subject,
          groupJid: window.Store.WidFactory.createWid(e.id)
        }));
      }
      if (options.linkPreview) {
        delete options.linkPreview;
        const link = window.Store.Validators.findLink(content);
        if (link) {
          const preview = await window.Store.LinkPreview.getLinkPreview(link);
          preview.preview = true;
          preview.subtype = "url";
          options = { ...options, ...preview };
        }
      }
      const internalOptions = {
        ...options,
        ...extraOptions
      };
      await window.Store.EditMessage.sendMessageEdit(msg, content, internalOptions);
      return window.Store.Msg.get(msg.id._serialized);
    };
    window.WWebJS.toStickerData = async (mediaInfo) => {
      if (mediaInfo.mimetype == "image/webp")
        return mediaInfo;
      const file = window.WWebJS.mediaInfoToFile(mediaInfo);
      const webpSticker = await window.Store.StickerTools.toWebpSticker(file);
      const webpBuffer = await webpSticker.arrayBuffer();
      const data = window.WWebJS.arrayBufferToBase64(webpBuffer);
      return {
        mimetype: "image/webp",
        data
      };
    };
    window.WWebJS.processMediaData = async (mediaInfo, { forceSticker, forceGif, forceVoice, forceDocument, sendToChannel }) => {
      const file = window.WWebJS.mediaInfoToFile(mediaInfo);
      const opaqueData = await window.Store.OpaqueData.createFromData(file, file.type);
      const mediaPrep = window.Store.MediaPrep.prepRawMedia(opaqueData, {
        asSticker: forceSticker,
        asGif: forceGif,
        isPtt: forceVoice,
        asDocument: forceDocument
      });
      const mediaData = await mediaPrep.waitForPrep();
      const mediaObject = window.Store.MediaObject.getOrCreateMediaObject(mediaData.filehash);
      const mediaType = window.Store.MediaTypes.msgToMediaType({
        type: mediaData.type,
        isGif: mediaData.isGif,
        isNewsletter: sendToChannel
      });
      if (forceVoice && mediaData.type === "ptt") {
        const waveform = mediaObject.contentInfo.waveform;
        mediaData.waveform = waveform || await window.WWebJS.generateWaveform(file);
      }
      if (!(mediaData.mediaBlob instanceof window.Store.OpaqueData)) {
        mediaData.mediaBlob = await window.Store.OpaqueData.createFromData(mediaData.mediaBlob, mediaData.mediaBlob.type);
      }
      mediaData.renderableUrl = mediaData.mediaBlob.url();
      mediaObject.consolidate(mediaData.toJSON());
      mediaData.mediaBlob.autorelease();
      const dataToUpload = {
        mimetype: mediaData.mimetype,
        mediaObject,
        mediaType,
        ...sendToChannel ? { calculateToken: window.Store.SendChannelMessage.getRandomFilehash } : {}
      };
      const uploadedMedia = !sendToChannel ? await window.Store.MediaUpload.uploadMedia(dataToUpload) : await window.Store.MediaUpload.uploadUnencryptedMedia(dataToUpload);
      const mediaEntry = uploadedMedia.mediaEntry;
      if (!mediaEntry) {
        throw new Error("upload failed: media entry was not created");
      }
      mediaData.set({
        clientUrl: mediaEntry.mmsUrl,
        deprecatedMms3Url: mediaEntry.deprecatedMms3Url,
        directPath: mediaEntry.directPath,
        mediaKey: mediaEntry.mediaKey,
        mediaKeyTimestamp: mediaEntry.mediaKeyTimestamp,
        filehash: mediaObject.filehash,
        encFilehash: mediaEntry.encFilehash,
        uploadhash: mediaEntry.uploadHash,
        size: mediaObject.size,
        streamingSidecar: mediaEntry.sidecar,
        firstFrameSidecar: mediaEntry.firstFrameSidecar,
        mediaHandle: sendToChannel ? mediaEntry.handle : null
      });
      return mediaData;
    };
    window.WWebJS.getMessageModel = (message) => {
      const msg = message.serialize();
      msg.isEphemeral = message.isEphemeral;
      msg.isStatusV3 = message.isStatusV3;
      msg.links = window.Store.Validators.findLinks(message.mediaObject ? message.caption : message.body).map((link) => ({
        link: link.href,
        isSuspicious: Boolean(link.suspiciousCharacters && link.suspiciousCharacters.size)
      }));
      if (msg.buttons) {
        msg.buttons = msg.buttons.serialize();
      }
      if (msg.dynamicReplyButtons) {
        msg.dynamicReplyButtons = JSON.parse(JSON.stringify(msg.dynamicReplyButtons));
      }
      if (msg.replyButtons) {
        msg.replyButtons = JSON.parse(JSON.stringify(msg.replyButtons));
      }
      if (typeof msg.id.remote === "object") {
        msg.id = Object.assign({}, msg.id, { remote: msg.id.remote._serialized });
      }
      delete msg.pendingAckUpdate;
      return msg;
    };
    window.WWebJS.getPollVoteModel = async (vote) => {
      const _vote = vote.serialize();
      if (!vote.parentMsgKey)
        return null;
      const msg = window.Store.Msg.get(vote.parentMsgKey) || (await window.Store.Msg.getMessagesById([vote.parentMsgKey]))?.messages?.[0];
      msg && (_vote.parentMessage = window.WWebJS.getMessageModel(msg));
      return _vote;
    };
    window.WWebJS.getChat = async (chatId, { getAsModel = true } = {}) => {
      const isChannel = /@\w*newsletter\b/.test(chatId);
      const chatWid = window.Store.WidFactory.createWid(chatId);
      let chat;
      if (isChannel) {
        try {
          chat = window.Store.NewsletterCollection.get(chatId);
          if (!chat) {
            await window.Store.ChannelUtils.loadNewsletterPreviewChat(chatId);
            chat = await window.Store.NewsletterCollection.find(chatWid);
          }
        } catch (err) {
          chat = null;
        }
      } else {
        chat = window.Store.Chat.get(chatWid) || await window.Store.Chat.find(chatWid);
      }
      return getAsModel && chat ? await window.WWebJS.getChatModel(chat, { isChannel }) : chat;
    };
    window.WWebJS.getChannelMetadata = async (inviteCode) => {
      const response = await window.Store.ChannelUtils.queryNewsletterMetadataByInviteCode(inviteCode, window.Store.ChannelUtils.getRoleByIdentifier(inviteCode));
      const picUrl = response.newsletterPictureMetadataMixin?.picture[0]?.queryPictureDirectPathOrEmptyResponseMixinGroup.value.directPath;
      return {
        id: response.idJid,
        createdAtTs: response.newsletterCreationTimeMetadataMixin.creationTimeValue,
        titleMetadata: {
          title: response.newsletterNameMetadataMixin.nameElementValue,
          updatedAtTs: response.newsletterNameMetadataMixin.nameUpdateTime
        },
        descriptionMetadata: {
          description: response.newsletterDescriptionMetadataMixin.descriptionQueryDescriptionResponseMixin.elementValue,
          updatedAtTs: response.newsletterDescriptionMetadataMixin.descriptionQueryDescriptionResponseMixin.updateTime
        },
        inviteLink: `https://whatsapp.com/channel/${response.newsletterInviteLinkMetadataMixin.inviteCode}`,
        membershipType: window.Store.ChannelUtils.getRoleByIdentifier(inviteCode),
        stateType: response.newsletterStateMetadataMixin.stateType,
        pictureUrl: picUrl ? `https://pps.whatsapp.net${picUrl}` : null,
        subscribersCount: response.newsletterSubscribersMetadataMixin.subscribersCount,
        isVerified: response.newsletterVerificationMetadataMixin.verificationState === "verified"
      };
    };
    window.WWebJS.getChats = async () => {
      const chats = window.Store.Chat.getModelsArray();
      const chatPromises = chats.map((chat) => window.WWebJS.getChatModel(chat));
      return await Promise.all(chatPromises);
    };
    window.WWebJS.getChannels = async () => {
      const channels = window.Store.NewsletterCollection.getModelsArray();
      const channelPromises = channels?.map((channel) => window.WWebJS.getChatModel(channel, { isChannel: true }));
      return await Promise.all(channelPromises);
    };
    window.WWebJS.getChatModel = async (chat, { isChannel = false } = {}) => {
      if (!chat)
        return null;
      const model = chat.serialize();
      model.isGroup = false;
      model.isMuted = chat.mute?.expiration !== 0;
      if (isChannel) {
        model.isChannel = window.Store.ChatGetters.getIsNewsletter(chat);
      } else {
        model.formattedTitle = chat.formattedTitle;
      }
      if (chat.groupMetadata) {
        model.isGroup = true;
        const chatWid = window.Store.WidFactory.createWid(chat.id._serialized);
        await window.Store.GroupMetadata.update(chatWid);
        chat.groupMetadata.participants._models.filter((x) => x.id._serialized.endsWith("@lid")).forEach((x) => {
          x.id = x.contact.phoneNumber;
        });
        model.groupMetadata = chat.groupMetadata.serialize();
        model.isReadOnly = chat.groupMetadata.announce;
      }
      if (chat.newsletterMetadata) {
        await window.Store.NewsletterMetadataCollection.update(chat.id);
        model.channelMetadata = chat.newsletterMetadata.serialize();
        model.channelMetadata.createdAtTs = chat.newsletterMetadata.creationTime;
      }
      model.lastMessage = null;
      if (model.msgs && model.msgs.length) {
        const lastMessage = chat.lastReceivedKey ? window.Store.Msg.get(chat.lastReceivedKey._serialized) || (await window.Store.Msg.getMessagesById([chat.lastReceivedKey._serialized]))?.messages?.[0] : null;
        lastMessage && (model.lastMessage = window.WWebJS.getMessageModel(lastMessage));
      }
      delete model.msgs;
      delete model.msgUnsyncedButtonReplyMsgs;
      delete model.unsyncedButtonReplies;
      return model;
    };
    window.WWebJS.getContactModel = (contact) => {
      let res = contact.serialize();
      res.isBusiness = contact.isBusiness === undefined ? false : contact.isBusiness;
      if (contact.businessProfile) {
        res.businessProfile = contact.businessProfile.serialize();
      }
      res.isMe = window.Store.ContactMethods.getIsMe(contact);
      res.isUser = window.Store.ContactMethods.getIsUser(contact);
      res.isGroup = window.Store.ContactMethods.getIsGroup(contact);
      res.isWAContact = window.Store.ContactMethods.getIsWAContact(contact);
      res.isMyContact = window.Store.ContactMethods.getIsMyContact(contact);
      res.isBlocked = contact.isContactBlocked;
      res.userid = window.Store.ContactMethods.getUserid(contact);
      res.isEnterprise = window.Store.ContactMethods.getIsEnterprise(contact);
      res.verifiedName = window.Store.ContactMethods.getVerifiedName(contact);
      res.verifiedLevel = window.Store.ContactMethods.getVerifiedLevel(contact);
      res.statusMute = window.Store.ContactMethods.getStatusMute(contact);
      res.name = window.Store.ContactMethods.getName(contact);
      res.shortName = window.Store.ContactMethods.getShortName(contact);
      res.pushname = window.Store.ContactMethods.getPushname(contact);
      return res;
    };
    window.WWebJS.getContact = async (contactId) => {
      const wid = window.Store.WidFactory.createWid(contactId);
      let contact = await window.Store.Contact.find(wid);
      if (contact.id._serialized.endsWith("@lid")) {
        contact.id = contact.phoneNumber;
      }
      const bizProfile = await window.Store.BusinessProfile.fetchBizProfile(wid);
      bizProfile.profileOptions && (contact.businessProfile = bizProfile);
      return window.WWebJS.getContactModel(contact);
    };
    window.WWebJS.getContacts = () => {
      const contacts = window.Store.Contact.getModelsArray();
      return contacts.map((contact) => window.WWebJS.getContactModel(contact));
    };
    window.WWebJS.mediaInfoToFile = ({ data, mimetype, filename }) => {
      const binaryData = window.atob(data);
      const buffer = new ArrayBuffer(binaryData.length);
      const view = new Uint8Array(buffer);
      for (let i = 0;i < binaryData.length; i++) {
        view[i] = binaryData.charCodeAt(i);
      }
      const blob = new Blob([buffer], { type: mimetype });
      return new File([blob], filename, {
        type: mimetype,
        lastModified: Date.now()
      });
    };
    window.WWebJS.arrayBufferToBase64 = (arrayBuffer) => {
      let binary = "";
      const bytes = new Uint8Array(arrayBuffer);
      const len = bytes.byteLength;
      for (let i = 0;i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    };
    window.WWebJS.arrayBufferToBase64Async = (arrayBuffer) => new Promise((resolve, reject) => {
      const blob = new Blob([arrayBuffer], {
        type: "application/octet-stream"
      });
      const fileReader = new FileReader;
      fileReader.onload = () => {
        const [, data] = fileReader.result.split(",");
        resolve(data);
      };
      fileReader.onerror = (e) => reject(e);
      fileReader.readAsDataURL(blob);
    });
    window.WWebJS.getFileHash = async (data) => {
      let buffer = await data.arrayBuffer();
      const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
      return btoa(String.fromCharCode(...new Uint8Array(hashBuffer)));
    };
    window.WWebJS.generateHash = async (length) => {
      var result = "";
      var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      var charactersLength = characters.length;
      for (var i = 0;i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    };
    window.WWebJS.generateWaveform = async (audioFile) => {
      try {
        const audioData = await audioFile.arrayBuffer();
        const audioContext = new AudioContext;
        const audioBuffer = await audioContext.decodeAudioData(audioData);
        const rawData = audioBuffer.getChannelData(0);
        const samples = 64;
        const blockSize = Math.floor(rawData.length / samples);
        const filteredData = [];
        for (let i = 0;i < samples; i++) {
          const blockStart = blockSize * i;
          let sum = 0;
          for (let j = 0;j < blockSize; j++) {
            sum = sum + Math.abs(rawData[blockStart + j]);
          }
          filteredData.push(sum / blockSize);
        }
        const multiplier = Math.pow(Math.max(...filteredData), -1);
        const normalizedData = filteredData.map((n) => n * multiplier);
        const waveform = new Uint8Array(normalizedData.map((n) => Math.floor(100 * n)));
        return waveform;
      } catch (e) {
        return;
      }
    };
    window.WWebJS.sendClearChat = async (chatId) => {
      let chat = await window.WWebJS.getChat(chatId, { getAsModel: false });
      if (chat !== undefined) {
        await window.Store.SendClear.sendClear(chat, false);
        return true;
      }
      return false;
    };
    window.WWebJS.sendDeleteChat = async (chatId) => {
      let chat = await window.WWebJS.getChat(chatId, { getAsModel: false });
      if (chat !== undefined) {
        await window.Store.SendDelete.sendDelete(chat);
        return true;
      }
      return false;
    };
    window.WWebJS.sendChatstate = async (state, chatId) => {
      chatId = window.Store.WidFactory.createWid(chatId);
      switch (state) {
        case "typing":
          await window.Store.ChatState.sendChatStateComposing(chatId);
          break;
        case "recording":
          await window.Store.ChatState.sendChatStateRecording(chatId);
          break;
        case "stop":
          await window.Store.ChatState.sendChatStatePaused(chatId);
          break;
        default:
          throw "Invalid chatstate";
      }
      return true;
    };
    window.WWebJS.getLabelModel = (label) => {
      let res = label.serialize();
      res.hexColor = label.hexColor;
      return res;
    };
    window.WWebJS.getLabels = () => {
      const labels = window.Store.Label.getModelsArray();
      return labels.map((label) => window.WWebJS.getLabelModel(label));
    };
    window.WWebJS.getLabel = (labelId) => {
      const label = window.Store.Label.get(labelId);
      return window.WWebJS.getLabelModel(label);
    };
    window.WWebJS.getChatLabels = async (chatId) => {
      const chat = await window.WWebJS.getChat(chatId);
      return (chat.labels || []).map((id) => window.WWebJS.getLabel(id));
    };
    window.WWebJS.getOrderDetail = async (orderId, token, chatId) => {
      const chatWid = window.Store.WidFactory.createWid(chatId);
      return window.Store.QueryOrder.queryOrder(chatWid, orderId, 80, 80, token);
    };
    window.WWebJS.getProductMetadata = async (productId) => {
      let sellerId = window.Store.Conn.wid;
      let product = await window.Store.QueryProduct.queryProduct(sellerId, productId);
      if (product && product.data) {
        return product.data;
      }
      return;
    };
    window.WWebJS.rejectCall = async (peerJid, id) => {
      peerJid = peerJid.split("@")[0] + "@s.whatsapp.net";
      let userId = window.Store.User.getMaybeMeUser().user + "@s.whatsapp.net";
      const stanza = window.Store.SocketWap.wap("call", {
        id: window.Store.SocketWap.generateId(),
        from: window.Store.SocketWap.USER_JID(userId),
        to: window.Store.SocketWap.USER_JID(peerJid)
      }, [
        window.Store.SocketWap.wap("reject", {
          "call-id": id,
          "call-creator": window.Store.SocketWap.USER_JID(peerJid),
          count: "0"
        })
      ]);
      await window.Store.Socket.deprecatedCastStanza(stanza);
    };
    window.WWebJS.cropAndResizeImage = async (media, options = {}) => {
      if (!media.mimetype.includes("image"))
        throw new Error("Media is not an image");
      if (options.mimetype && !options.mimetype.includes("image"))
        delete options.mimetype;
      options = Object.assign({ size: 640, mimetype: media.mimetype, quality: 0.75, asDataUrl: false }, options);
      const img = await new Promise((resolve, reject) => {
        const img2 = new Image;
        img2.onload = () => resolve(img2);
        img2.onerror = reject;
        img2.src = `data:${media.mimetype};base64,${media.data}`;
      });
      const sl = Math.min(img.width, img.height);
      const sx = Math.floor((img.width - sl) / 2);
      const sy = Math.floor((img.height - sl) / 2);
      const canvas = document.createElement("canvas");
      canvas.width = options.size;
      canvas.height = options.size;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, sx, sy, sl, sl, 0, 0, options.size, options.size);
      const dataUrl = canvas.toDataURL(options.mimetype, options.quality);
      if (options.asDataUrl)
        return dataUrl;
      return Object.assign(media, {
        mimetype: options.mimeType,
        data: dataUrl.replace(`data:${options.mimeType};base64,`, "")
      });
    };
    window.WWebJS.setPicture = async (chatid, media) => {
      const thumbnail = await window.WWebJS.cropAndResizeImage(media, { asDataUrl: true, mimetype: "image/jpeg", size: 96 });
      const profilePic = await window.WWebJS.cropAndResizeImage(media, { asDataUrl: true, mimetype: "image/jpeg", size: 640 });
      const chatWid = window.Store.WidFactory.createWid(chatid);
      try {
        const collection = window.Store.ProfilePicThumb.get(chatid);
        if (!collection.canSet())
          return;
        const res = await window.Store.GroupUtils.sendSetPicture(chatWid, thumbnail, profilePic);
        return res ? res.status === 200 : false;
      } catch (err) {
        if (err.name === "ServerStatusCodeError")
          return false;
        throw err;
      }
    };
    window.WWebJS.deletePicture = async (chatid) => {
      const chatWid = window.Store.WidFactory.createWid(chatid);
      try {
        const collection = window.Store.ProfilePicThumb.get(chatid);
        if (!collection.canDelete())
          return;
        const res = await window.Store.GroupUtils.requestDeletePicture(chatWid);
        return res ? res.status === 200 : false;
      } catch (err) {
        if (err.name === "ServerStatusCodeError")
          return false;
        throw err;
      }
    };
    window.WWebJS.getProfilePicThumbToBase64 = async (chatWid) => {
      const profilePicCollection = await window.Store.ProfilePicThumb.find(chatWid);
      const _readImageAsBase64 = (imageBlob) => {
        return new Promise((resolve) => {
          const reader = new FileReader;
          reader.onloadend = function() {
            const base64Image = reader.result;
            if (base64Image == null) {
              resolve(undefined);
            } else {
              const base64Data = base64Image.toString().split(",")[1];
              resolve(base64Data);
            }
          };
          reader.readAsDataURL(imageBlob);
        });
      };
      if (profilePicCollection?.img) {
        try {
          const response = await fetch(profilePicCollection.img);
          if (response.ok) {
            const imageBlob = await response.blob();
            if (imageBlob) {
              const base64Image = await _readImageAsBase64(imageBlob);
              return base64Image;
            }
          }
        } catch (error) {}
      }
      return;
    };
    window.WWebJS.getAddParticipantsRpcResult = async (groupMetadata, groupWid, participantWid) => {
      const participantLidArgs = groupMetadata?.isLidAddressingMode ? {
        phoneNumber: participantWid,
        lid: window.Store.LidUtils.getCurrentLid(participantWid)
      } : { phoneNumber: participantWid };
      const iqTo = window.Store.WidToJid.widToGroupJid(groupWid);
      const participantArgs = participantLidArgs.lid ? [{
        participantJid: window.Store.WidToJid.widToUserJid(participantLidArgs.lid),
        phoneNumberMixinArgs: {
          anyPhoneNumber: window.Store.WidToJid.widToUserJid(participantLidArgs.phoneNumber)
        }
      }] : [{
        participantJid: window.Store.WidToJid.widToUserJid(participantLidArgs.phoneNumber)
      }];
      let rpcResult, resultArgs;
      const isOldImpl = window.compareWwebVersions(window.Debug.VERSION, "<=", "2.2335.9");
      const data = {
        name: undefined,
        code: undefined,
        inviteV4Code: undefined,
        inviteV4CodeExp: undefined
      };
      try {
        rpcResult = await window.Store.GroupParticipants.sendAddParticipantsRPC({ participantArgs, iqTo });
        resultArgs = isOldImpl ? rpcResult.value.addParticipant[0].addParticipantsParticipantMixins : rpcResult.value.addParticipant[0].addParticipantsParticipantAddedOrNonRegisteredWaUserParticipantErrorLidResponseMixinGroup.value.addParticipantsParticipantMixins;
      } catch (err) {
        data.code = 400;
        return data;
      }
      if (rpcResult.name === "AddParticipantsResponseSuccess") {
        const code = resultArgs?.value.error || "200";
        data.name = resultArgs?.name;
        data.code = +code;
        data.inviteV4Code = resultArgs?.value.addRequestCode;
        data.inviteV4CodeExp = resultArgs?.value.addRequestExpiration?.toString();
      } else if (rpcResult.name === "AddParticipantsResponseClientError") {
        const { code } = rpcResult.value.errorAddParticipantsClientErrors.value;
        data.code = +code;
      } else if (rpcResult.name === "AddParticipantsResponseServerError") {
        const { code } = rpcResult.value.errorServerErrors.value;
        data.code = +code;
      }
      return data;
    };
    window.WWebJS.membershipRequestAction = async (groupId, action, requesterIds, sleep) => {
      const groupWid = window.Store.WidFactory.createWid(groupId);
      const group = await window.Store.Chat.find(groupWid);
      const toApprove = action === "Approve";
      let membershipRequests;
      let response;
      let result = [];
      await window.Store.GroupQueryAndUpdate({ id: groupId });
      if (!requesterIds?.length) {
        membershipRequests = group.groupMetadata.membershipApprovalRequests._models.map(({ id }) => id);
      } else {
        !Array.isArray(requesterIds) && (requesterIds = [requesterIds]);
        membershipRequests = requesterIds.map((r) => window.Store.WidFactory.createWid(r));
      }
      if (!membershipRequests.length)
        return [];
      const participantArgs = membershipRequests.map((m2) => ({
        participantArgs: [
          {
            participantJid: window.Store.WidToJid.widToUserJid(m2)
          }
        ]
      }));
      const groupJid = window.Store.WidToJid.widToGroupJid(groupWid);
      const _getSleepTime = (sleep2) => {
        if (!Array.isArray(sleep2) || sleep2.length === 2 && sleep2[0] === sleep2[1]) {
          return sleep2;
        }
        if (sleep2.length === 1) {
          return sleep2[0];
        }
        sleep2[1] - sleep2[0] < 100 && (sleep2[0] = sleep2[1]) && (sleep2[1] += 100);
        return Math.floor(Math.random() * (sleep2[1] - sleep2[0] + 1)) + sleep2[0];
      };
      const membReqResCodes = {
        default: `An unknown error occupied while ${toApprove ? "approving" : "rejecting"} the participant membership request`,
        400: "ParticipantNotFoundError",
        401: "ParticipantNotAuthorizedError",
        403: "ParticipantForbiddenError",
        404: "ParticipantRequestNotFoundError",
        408: "ParticipantTemporarilyBlockedError",
        409: "ParticipantConflictError",
        412: "ParticipantParentLinkedGroupsResourceConstraintError",
        500: "ParticipantResourceConstraintError"
      };
      try {
        for (const participant of participantArgs) {
          response = await window.Store.MembershipRequestUtils.sendMembershipRequestsActionRPC({
            iqTo: groupJid,
            [toApprove ? "approveArgs" : "rejectArgs"]: participant
          });
          if (response.name === "MembershipRequestsActionResponseSuccess") {
            const value = toApprove ? response.value.membershipRequestsActionApprove : response.value.membershipRequestsActionReject;
            if (value?.participant) {
              const [_2] = value.participant.map((p) => {
                const error = toApprove ? value.participant[0].membershipRequestsActionAcceptParticipantMixins?.value.error : value.participant[0].membershipRequestsActionRejectParticipantMixins?.value.error;
                return {
                  requesterId: window.Store.WidFactory.createWid(p.jid)._serialized,
                  ...error ? { error: +error, message: membReqResCodes[error] || membReqResCodes.default } : { message: `${toApprove ? "Approved" : "Rejected"} successfully` }
                };
              });
              _2 && result.push(_2);
            }
          } else {
            result.push({
              requesterId: window.Store.JidToWid.userJidToUserWid(participant.participantArgs[0].participantJid)._serialized,
              message: "ServerStatusCodeError"
            });
          }
          sleep && participantArgs.length > 1 && participantArgs.indexOf(participant) !== participantArgs.length - 1 && await new Promise((resolve) => setTimeout(resolve, _getSleepTime(sleep)));
        }
        return result;
      } catch (err) {
        return [];
      }
    };
    window.WWebJS.subscribeToUnsubscribeFromChannel = async (channelId, action, options = {}) => {
      const channel = await window.WWebJS.getChat(channelId, { getAsModel: false });
      if (!channel || channel.newsletterMetadata.membershipType === "owner")
        return false;
      options = { eventSurface: 3, deleteLocalModels: options.deleteLocalModels ?? true };
      try {
        if (action === "Subscribe") {
          await window.Store.ChannelUtils.subscribeToNewsletterAction(channel, options);
        } else if (action === "Unsubscribe") {
          await window.Store.ChannelUtils.unsubscribeFromNewsletterAction(channel, options);
        } else
          return false;
        return true;
      } catch (err) {
        if (err.name === "ServerStatusCodeError")
          return false;
        throw err;
      }
    };
    window.WWebJS.pinUnpinMsgAction = async (msgId, action, duration) => {
      const message = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
      if (!message)
        return false;
      const response = await window.Store.pinUnpinMsg(message, action, duration);
      return response.messageSendResult === "OK";
    };
    window.WWebJS.getStatusModel = (status) => {
      const res = status.serialize();
      delete res._msgs;
      return res;
    };
    window.WWebJS.getAllStatuses = () => {
      const statuses = window.Store.Status.getModelsArray();
      return statuses.map((status) => window.WWebJS.getStatusModel(status));
    };
  };
});

// node_modules/whatsapp-web.js/src/structures/Base.js
var require_Base = __commonJS((exports, module) => {
  class Base {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
    _patch(data) {
      return data;
    }
  }
  module.exports = Base;
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS((exports, module) => {
  function Mime() {
    this._types = Object.create(null);
    this._extensions = Object.create(null);
    for (let i = 0;i < arguments.length; i++) {
      this.define(arguments[i]);
    }
    this.define = this.define.bind(this);
    this.getType = this.getType.bind(this);
    this.getExtension = this.getExtension.bind(this);
  }
  Mime.prototype.define = function(typeMap, force) {
    for (let type in typeMap) {
      let extensions = typeMap[type].map(function(t) {
        return t.toLowerCase();
      });
      type = type.toLowerCase();
      for (let i = 0;i < extensions.length; i++) {
        const ext = extensions[i];
        if (ext[0] === "*") {
          continue;
        }
        if (!force && ext in this._types) {
          throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
        }
        this._types[ext] = type;
      }
      if (force || !this._extensions[type]) {
        const ext = extensions[0];
        this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
      }
    }
  };
  Mime.prototype.getType = function(path) {
    path = String(path);
    let last = path.replace(/^.*[/\\]/, "").toLowerCase();
    let ext = last.replace(/^.*\./, "").toLowerCase();
    let hasPath = last.length < path.length;
    let hasDot = ext.length < last.length - 1;
    return (hasDot || !hasPath) && this._types[ext] || null;
  };
  Mime.prototype.getExtension = function(type) {
    type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
    return type && this._extensions[type.toLowerCase()] || null;
  };
  module.exports = Mime;
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS((exports, module) => {
  module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
});

// node_modules/mime/types/other.js
var require_other = __commonJS((exports, module) => {
  module.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
});

// node_modules/mime/index.js
var require_mime = __commonJS((exports, module) => {
  var Mime = require_Mime();
  module.exports = new Mime(require_standard(), require_other());
});

// node_modules/node-fetch/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var Stream = _interopDefault(__require("stream"));
  var http = _interopDefault(__require("http"));
  var Url = _interopDefault(__require("url"));
  var whatwgUrl = _interopDefault(require_public_api());
  var https = _interopDefault(__require("https"));
  var zlib = _interopDefault(__require("zlib"));
  var Readable = Stream.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");

  class Blob2 {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0;i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob2) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== undefined && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable;
      readable._read = function() {};
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === undefined) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === undefined) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob2([], { type: arguments[2] });
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  }
  Object.defineProperties(Blob2.prototype, {
    size: { enumerable: true },
    type: { enumerable: true },
    slice: { enumerable: true }
  });
  Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = (()=>{throw new Error("Cannot require module "+"encoding");})().convert;
  } catch (e) {}
  var INTERNALS = Symbol("Body internals");
  var PassThrough = Stream.PassThrough;
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob2([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: { enumerable: true },
    bodyUsed: { enumerable: true },
    arrayBuffer: { enumerable: true },
    blob: { enumerable: true },
    json: { enumerable: true },
    text: { enumerable: true }
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj2) {
    if (typeof obj2 !== "object" || typeof obj2.append !== "function" || typeof obj2.delete !== "function" || typeof obj2.get !== "function" || typeof obj2.getAll !== "function" || typeof obj2.has !== "function" || typeof obj2.set !== "function") {
      return false;
    }
    return obj2.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj2) === "[object URLSearchParams]" || typeof obj2.sort === "function";
  }
  function isBlob(obj2) {
    return typeof obj2 === "object" && typeof obj2.arrayBuffer === "function" && typeof obj2.type === "string" && typeof obj2.stream === "function" && typeof obj2.constructor === "function" && typeof obj2.constructor.name === "string" && /^(Blob|File)$/.test(obj2.constructor.name) && /^(Blob|File)$/.test(obj2[Symbol.toStringTag]);
  }
  function clone(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough;
      p2 = new PassThrough;
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof Stream) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key2 in map) {
      if (key2.toLowerCase() === name) {
        return key2;
      }
    }
    return;
  }
  var MAP = Symbol("map");

  class Headers {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this[MAP] = Object.create(null);
      if (init instanceof Headers) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key2 of Object.keys(init)) {
            const value = init[key2];
            this.append(key2, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key2 = find(this[MAP], name);
      if (key2 === undefined) {
        return null;
      }
      return this[MAP][key2].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let pairs = getHeaders(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key2 = find(this[MAP], name);
      this[MAP][key2 !== undefined ? key2 : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key2 = find(this[MAP], name);
      if (key2 !== undefined) {
        this[MAP][key2].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== undefined;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key2 = find(this[MAP], name);
      if (key2 !== undefined) {
        delete this[MAP][key2];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  }
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: { enumerable: true },
    forEach: { enumerable: true },
    set: { enumerable: true },
    append: { enumerable: true },
    has: { enumerable: true },
    delete: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true }
  });
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  var INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const { target, kind, index } = _INTERNAL;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: undefined,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj2 = Object.assign({ __proto__: null }, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== undefined) {
      obj2[hostHeaderKey] = obj2[hostHeaderKey][0];
    }
    return obj2;
  }
  function createHeadersLenient(obj2) {
    const headers = new Headers;
    for (const name of Object.keys(obj2)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj2[name])) {
        for (const val of obj2[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === undefined) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj2[name])) {
        headers[MAP][name] = [obj2[name]];
      }
    }
    return headers;
  }
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = http.STATUS_CODES;

  class Response {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  }
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: { enumerable: true },
    status: { enumerable: true },
    ok: { enumerable: true },
    redirected: { enumerable: true },
    statusText: { enumerable: true },
    headers: { enumerable: true },
    clone: { enumerable: true }
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var URL2 = Url.URL || whatwgUrl.URL;
  var parse_url = Url.parse;
  var format_url = Url.format;
  function parseURL(urlStr) {
    if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
      urlStr = new URL2(urlStr).toString();
    }
    return parse_url(urlStr);
  }
  var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }

  class Request {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parseURL(input.href);
        } else {
          parsedURL = parseURL(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parseURL(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
      this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request(this);
    }
  }
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: { enumerable: true },
    url: { enumerable: true },
    headers: { enumerable: true },
    redirect: { enumerable: true },
    clone: { enumerable: true },
    signal: { enumerable: true }
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var URL$1 = Url.URL || whatwgUrl.URL;
  var PassThrough$1 = Stream.PassThrough;
  var isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
  };
  var isSameProtocol = function isSameProtocol(destination, original) {
    const orig = new URL$1(original).protocol;
    const dest = new URL$1(destination).protocol;
    return orig === dest;
  };
  function fetch2(url, opts) {
    if (!fetch2.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch2.Promise;
    return new fetch2.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? https : http).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort() {
        let error = new AbortError("The user aborted a request.");
        reject(error);
        if (request.body && request.body instanceof Stream.Readable) {
          destroyStream(request.body, error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        if (response && response.body) {
          destroyStream(response.body, err);
        }
        finalize();
      });
      fixResponseChunkedTransferBadEnding(req, function(err) {
        if (signal && signal.aborted) {
          return;
        }
        if (response && response.body) {
          destroyStream(response.body, err);
        }
      });
      if (parseInt(process.version.substring(1)) < 14) {
        req.on("socket", function(s) {
          s.addListener("close", function(hadError) {
            const hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              response.body.emit("error", err);
            }
          });
        });
      }
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch2.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL$1(location, request.url).toString();
          } catch (err) {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOpts.headers.delete(name);
                }
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = undefined;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch2(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1);
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1);
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            response = new Response(body, response_options);
            resolve(response);
          });
          raw.on("end", function() {
            if (!response) {
              response = new Response(body, response_options);
              resolve(response);
            }
          });
          return;
        }
        if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
          body = body.pipe(zlib.createBrotliDecompress());
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        response = new Response(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  }
  function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on("socket", function(s) {
      socket = s;
    });
    request.on("response", function(response) {
      const headers = response.headers;
      if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
        response.once("close", function(hadError) {
          const hasDataListener = socket && socket.listenerCount("data") > 0;
          if (hasDataListener && !hadError) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            errorCallback(err);
          }
        });
      }
    });
  }
  function destroyStream(stream, err) {
    if (stream.destroy) {
      stream.destroy(err);
    } else {
      stream.emit("error", err);
      stream.end();
    }
  }
  fetch2.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch2.Promise = global.Promise;
  module.exports = exports = fetch2;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = exports;
  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.FetchError = FetchError;
  exports.AbortError = AbortError;
});

// node_modules/whatsapp-web.js/src/structures/MessageMedia.js
var require_MessageMedia = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var mime = require_mime();
  var fetch2 = require_lib3();
  var { URL: URL2 } = __require("url");

  class MessageMedia {
    constructor(mimetype, data, filename, filesize) {
      this.mimetype = mimetype;
      this.data = data;
      this.filename = filename;
      this.filesize = filesize;
    }
    static fromFilePath(filePath) {
      const b64data = fs.readFileSync(filePath, { encoding: "base64" });
      const mimetype = mime.getType(filePath);
      const filename = path.basename(filePath);
      return new MessageMedia(mimetype, b64data, filename);
    }
    static async fromUrl(url, options = {}) {
      const pUrl = new URL2(url);
      let mimetype = mime.getType(pUrl.pathname);
      if (!mimetype && !options.unsafeMime)
        throw new Error("Unable to determine MIME type using URL. Set unsafeMime to true to download it anyway.");
      async function fetchData(url2, options2) {
        const reqOptions = Object.assign({ headers: { accept: "image/* video/* text/* audio/*" } }, options2);
        const response = await fetch2(url2, reqOptions);
        const mime2 = response.headers.get("Content-Type");
        const size = response.headers.get("Content-Length");
        const contentDisposition = response.headers.get("Content-Disposition");
        const name = contentDisposition ? contentDisposition.match(/((?<=filename=")(.*)(?="))/) : null;
        let data = "";
        if (response.buffer) {
          data = (await response.buffer()).toString("base64");
        } else {
          const bArray = new Uint8Array(await response.arrayBuffer());
          bArray.forEach((b) => {
            data += String.fromCharCode(b);
          });
          data = btoa(data);
        }
        return { data, mime: mime2, name, size };
      }
      const res = options.client ? await options.client.pupPage.evaluate(fetchData, url, options.reqOptions) : await fetchData(url, options.reqOptions);
      const filename = options.filename || (res.name ? res.name[0] : pUrl.pathname.split("/").pop() || "file");
      if (!mimetype)
        mimetype = res.mime;
      return new MessageMedia(mimetype, res.data, filename, res.size || null);
    }
  }
  module.exports = MessageMedia;
});

// node_modules/whatsapp-web.js/src/structures/Location.js
var require_Location = __commonJS((exports, module) => {
  class Location {
    constructor(latitude, longitude, options = {}) {
      this.latitude = latitude;
      this.longitude = longitude;
      this.name = options.name;
      this.address = options.address;
      this.url = options.url;
      this.description = this.name && this.address ? `${this.name}
${this.address}` : this.name || this.address || "";
    }
  }
  module.exports = Location;
});

// node_modules/whatsapp-web.js/src/structures/ProductMetadata.js
var require_ProductMetadata = __commonJS((exports, module) => {
  var Base = require_Base();

  class ProductMetadata extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.retailer_id = data.retailer_id;
      this.name = data.name;
      this.description = data.description;
      return super._patch(data);
    }
  }
  module.exports = ProductMetadata;
});

// node_modules/whatsapp-web.js/src/structures/Product.js
var require_Product = __commonJS((exports, module) => {
  var Base = require_Base();
  var ProductMetadata = require_ProductMetadata();

  class Product extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.price = data.price ? data.price : "";
      this.thumbnailUrl = data.thumbnailUrl;
      this.currency = data.currency;
      this.name = data.name;
      this.quantity = data.quantity;
      this.data = null;
      return super._patch(data);
    }
    async getData() {
      if (this.data === null) {
        let result = await this.client.pupPage.evaluate((productId) => {
          return window.WWebJS.getProductMetadata(productId);
        }, this.id);
        if (!result) {
          this.data = undefined;
        } else {
          this.data = new ProductMetadata(this.client, result);
        }
      }
      return this.data;
    }
  }
  module.exports = Product;
});

// node_modules/whatsapp-web.js/src/structures/Order.js
var require_Order = __commonJS((exports, module) => {
  var Base = require_Base();
  var Product = require_Product();

  class Order extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if (data.products) {
        this.products = data.products.map((product) => new Product(this.client, product));
      }
      this.subtotal = data.subtotal;
      this.total = data.total;
      this.currency = data.currency;
      this.createdAt = data.createdAt;
      return super._patch(data);
    }
  }
  module.exports = Order;
});

// node_modules/whatsapp-web.js/src/structures/Payment.js
var require_Payment = __commonJS((exports, module) => {
  var Base = require_Base();

  class Payment extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.paymentCurrency = data.paymentCurrency;
      this.paymentAmount1000 = data.paymentAmount1000;
      this.paymentMessageReceiverJid = data.paymentMessageReceiverJid;
      this.paymentTransactionTimestamp = data.paymentTransactionTimestamp;
      this.paymentStatus = data.paymentStatus;
      this.paymentTxnStatus = data.paymentTxnStatus;
      this.paymentNote = !data.paymentNoteMsg ? undefined : data.paymentNoteMsg.body ? data.paymentNoteMsg.body : undefined;
      return super._patch(data);
    }
  }
  module.exports = Payment;
});

// node_modules/whatsapp-web.js/src/structures/Reaction.js
var require_Reaction = __commonJS((exports, module) => {
  var Base = require_Base();

  class Reaction extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.msgKey;
      this.orphan = data.orphan;
      this.orphanReason = data.orphanReason;
      this.timestamp = data.timestamp;
      this.reaction = data.reactionText;
      this.read = data.read;
      this.msgId = data.parentMsgKey;
      this.senderId = data.senderUserJid;
      this.ack = data.ack;
      return super._patch(data);
    }
  }
  module.exports = Reaction;
});

// node_modules/whatsapp-web.js/src/structures/Contact.js
var require_Contact = __commonJS((exports, module) => {
  var Base = require_Base();

  class Contact extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.number = data.userid;
      this.isBusiness = data.isBusiness;
      this.isEnterprise = data.isEnterprise;
      this.labels = data.labels;
      this.name = data.name;
      this.pushname = data.pushname;
      this.sectionHeader = data.sectionHeader;
      this.shortName = data.shortName;
      this.statusMute = data.statusMute;
      this.type = data.type;
      this.verifiedLevel = data.verifiedLevel;
      this.verifiedName = data.verifiedName;
      this.isMe = data.isMe;
      this.isUser = data.isUser;
      this.isGroup = data.isGroup;
      this.isWAContact = data.isWAContact;
      this.isMyContact = data.isMyContact;
      this.isBlocked = data.isBlocked;
      return super._patch(data);
    }
    async getProfilePicUrl() {
      return await this.client.getProfilePicUrl(this.id._serialized);
    }
    async getFormattedNumber() {
      return await this.client.getFormattedNumber(this.id._serialized);
    }
    async getCountryCode() {
      return await this.client.getCountryCode(this.id._serialized);
    }
    async getChat() {
      if (this.isMe)
        return null;
      return await this.client.getChatById(this.id._serialized);
    }
    async block() {
      if (this.isGroup)
        return false;
      await this.client.pupPage.evaluate(async (contactId) => {
        const contact = window.Store.Contact.get(contactId);
        await window.Store.BlockContact.blockContact({ contact });
      }, this.id._serialized);
      this.isBlocked = true;
      return true;
    }
    async unblock() {
      if (this.isGroup)
        return false;
      await this.client.pupPage.evaluate(async (contactId) => {
        const contact = window.Store.Contact.get(contactId);
        await window.Store.BlockContact.unblockContact(contact);
      }, this.id._serialized);
      this.isBlocked = false;
      return true;
    }
    async getAbout() {
      const about = await this.client.pupPage.evaluate(async (contactId) => {
        const wid = window.Store.WidFactory.createWid(contactId);
        return window.Store.StatusUtils.getStatus(wid);
      }, this.id._serialized);
      if (typeof about.status !== "string")
        return null;
      return about.status;
    }
    async getCommonGroups() {
      return await this.client.getCommonGroups(this.id._serialized);
    }
  }
  module.exports = Contact;
});

// node_modules/whatsapp-web.js/src/structures/Message.js
var require_Message = __commonJS((exports, module) => {
  var Base = require_Base();
  var MessageMedia = require_MessageMedia();
  var Location = require_Location();
  var Order = require_Order();
  var Payment = require_Payment();
  var Reaction = require_Reaction();
  var Contact = require_Contact();
  var { MessageTypes } = require_Constants();

  class Message extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this._data = data;
      this.mediaKey = data.mediaKey;
      this.id = data.id;
      this.ack = data.ack;
      this.hasMedia = Boolean(data.directPath);
      this.body = this.hasMedia ? data.caption || "" : data.body || data.pollName || "";
      this.type = data.type;
      this.timestamp = data.t;
      this.from = typeof data.from === "object" && data.from !== null ? data.from._serialized : data.from;
      this.to = typeof data.to === "object" && data.to !== null ? data.to._serialized : data.to;
      this.author = typeof data.author === "object" && data.author !== null ? data.author._serialized : data.author;
      this.deviceType = typeof data.id.id === "string" && data.id.id.length > 21 ? "android" : typeof data.id.id === "string" && data.id.id.substring(0, 2) === "3A" ? "ios" : "web";
      this.isForwarded = data.isForwarded;
      this.forwardingScore = data.forwardingScore || 0;
      this.isStatus = data.isStatusV3 || data.id.remote === "status@broadcast";
      this.isStarred = data.star;
      this.broadcast = data.broadcast;
      this.fromMe = data.id.fromMe;
      this.hasQuotedMsg = data.quotedMsg ? true : false;
      this.hasReaction = data.hasReaction ? true : false;
      this.duration = data.duration ? data.duration : undefined;
      this.location = (() => {
        if (data.type !== MessageTypes.LOCATION) {
          return;
        }
        let description;
        if (data.loc && typeof data.loc === "string") {
          let splitted = data.loc.split(`
`);
          description = {
            name: splitted[0],
            address: splitted[1],
            url: data.clientUrl
          };
        }
        return new Location(data.lat, data.lng, description);
      })();
      this.vCards = data.type === MessageTypes.CONTACT_CARD_MULTI ? data.vcardList.map((c) => c.vcard) : data.type === MessageTypes.CONTACT_CARD ? [data.body] : [];
      this.inviteV4 = data.type === MessageTypes.GROUP_INVITE ? {
        inviteCode: data.inviteCode,
        inviteCodeExp: data.inviteCodeExp,
        groupId: data.inviteGrp,
        groupName: data.inviteGrpName,
        fromId: typeof data.from === "object" && "_serialized" in data.from ? data.from._serialized : data.from,
        toId: typeof data.to === "object" && "_serialized" in data.to ? data.to._serialized : data.to
      } : undefined;
      this.mentionedIds = data.mentionedJidList || [];
      this.groupMentions = data.groupMentions || [];
      this.orderId = data.orderId ? data.orderId : undefined;
      this.token = data.token ? data.token : undefined;
      this.isGif = Boolean(data.isGif);
      this.isEphemeral = data.isEphemeral;
      if (data.title) {
        this.title = data.title;
      }
      if (data.description) {
        this.description = data.description;
      }
      if (data.businessOwnerJid) {
        this.businessOwnerJid = data.businessOwnerJid;
      }
      if (data.productId) {
        this.productId = data.productId;
      }
      if (data.latestEditSenderTimestampMs) {
        this.latestEditSenderTimestampMs = data.latestEditSenderTimestampMs;
      }
      if (data.latestEditMsgKey) {
        this.latestEditMsgKey = data.latestEditMsgKey;
      }
      this.links = data.links;
      if (data.dynamicReplyButtons) {
        this.dynamicReplyButtons = data.dynamicReplyButtons;
      }
      if (data.selectedButtonId) {
        this.selectedButtonId = data.selectedButtonId;
      }
      if (data.listResponse && data.listResponse.singleSelectReply.selectedRowId) {
        this.selectedRowId = data.listResponse.singleSelectReply.selectedRowId;
      }
      if (this.type === MessageTypes.POLL_CREATION) {
        this.pollName = data.pollName;
        this.pollOptions = data.pollOptions;
        this.allowMultipleAnswers = Boolean(!data.pollSelectableOptionsCount);
        this.pollInvalidated = data.pollInvalidated;
        this.isSentCagPollCreation = data.isSentCagPollCreation;
        this.messageSecret = Object.keys(data.messageSecret).map((key2) => data.messageSecret[key2]);
      }
      return super._patch(data);
    }
    _getChatId() {
      return this.fromMe ? this.to : this.from;
    }
    async reload() {
      const newData = await this.client.pupPage.evaluate(async (msgId) => {
        const msg = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
        if (!msg)
          return null;
        return window.WWebJS.getMessageModel(msg);
      }, this.id._serialized);
      if (!newData)
        return null;
      this._patch(newData);
      return this;
    }
    get rawData() {
      return this._data;
    }
    getChat() {
      return this.client.getChatById(this._getChatId());
    }
    getContact() {
      return this.client.getContactById(this.author || this.from);
    }
    async getMentions() {
      return await Promise.all(this.mentionedIds.map(async (m2) => await this.client.getContactById(m2)));
    }
    async getGroupMentions() {
      return await Promise.all(this.groupMentions.map(async (m2) => await this.client.getChatById(m2.groupJid._serialized)));
    }
    async getQuotedMessage() {
      if (!this.hasQuotedMsg)
        return;
      const quotedMsg = await this.client.pupPage.evaluate(async (msgId) => {
        const msg = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
        const quotedMsg2 = window.Store.QuotedMsg.getQuotedMsgObj(msg);
        return window.WWebJS.getMessageModel(quotedMsg2);
      }, this.id._serialized);
      return new Message(this.client, quotedMsg);
    }
    async reply(content, chatId, options = {}) {
      if (!chatId) {
        chatId = this._getChatId();
      }
      options = {
        ...options,
        quotedMessageId: this.id._serialized
      };
      return this.client.sendMessage(chatId, content, options);
    }
    async react(reaction) {
      await this.client.pupPage.evaluate(async (messageId, reaction2) => {
        if (!messageId)
          return null;
        const msg = window.Store.Msg.get(messageId) || (await window.Store.Msg.getMessagesById([messageId]))?.messages?.[0];
        if (!msg)
          return null;
        await window.Store.sendReactionToMsg(msg, reaction2);
      }, this.id._serialized, reaction);
    }
    async acceptGroupV4Invite() {
      return await this.client.acceptGroupV4Invite(this.inviteV4);
    }
    async forward(chat) {
      const chatId = typeof chat === "string" ? chat : chat.id._serialized;
      await this.client.pupPage.evaluate(async (msgId, chatId2) => {
        return window.WWebJS.forwardMessage(chatId2, msgId);
      }, this.id._serialized, chatId);
    }
    async downloadMedia() {
      if (!this.hasMedia) {
        return;
      }
      const result = await this.client.pupPage.evaluate(async (msgId) => {
        const msg = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
        if (!msg || !msg.mediaData) {
          return null;
        }
        if (msg.mediaData.mediaStage != "RESOLVED") {
          await msg.downloadMedia({
            downloadEvenIfExpensive: true,
            rmrReason: 1
          });
        }
        if (msg.mediaData.mediaStage.includes("ERROR") || msg.mediaData.mediaStage === "FETCHING") {
          return;
        }
        try {
          const decryptedMedia = await window.Store.DownloadManager.downloadAndMaybeDecrypt({
            directPath: msg.directPath,
            encFilehash: msg.encFilehash,
            filehash: msg.filehash,
            mediaKey: msg.mediaKey,
            mediaKeyTimestamp: msg.mediaKeyTimestamp,
            type: msg.type,
            signal: new AbortController().signal
          });
          const data = await window.WWebJS.arrayBufferToBase64Async(decryptedMedia);
          return {
            data,
            mimetype: msg.mimetype,
            filename: msg.filename,
            filesize: msg.size
          };
        } catch (e) {
          if (e.status && e.status === 404)
            return;
          throw e;
        }
      }, this.id._serialized);
      if (!result)
        return;
      return new MessageMedia(result.mimetype, result.data, result.filename, result.filesize);
    }
    async delete(everyone, clearMedia = true) {
      await this.client.pupPage.evaluate(async (msgId, everyone2, clearMedia2) => {
        const msg = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
        const chat = window.Store.Chat.get(msg.id.remote) || await window.Store.Chat.find(msg.id.remote);
        const canRevoke = window.Store.MsgActionChecks.canSenderRevokeMsg(msg) || window.Store.MsgActionChecks.canAdminRevokeMsg(msg);
        if (everyone2 && canRevoke) {
          return window.compareWwebVersions(window.Debug.VERSION, ">=", "2.3000.0") ? window.Store.Cmd.sendRevokeMsgs(chat, { list: [msg], type: "message" }, { clearMedia: clearMedia2 }) : window.Store.Cmd.sendRevokeMsgs(chat, [msg], { clearMedia: true, type: msg.id.fromMe ? "Sender" : "Admin" });
        }
        return window.compareWwebVersions(window.Debug.VERSION, ">=", "2.3000.0") ? window.Store.Cmd.sendDeleteMsgs(chat, { list: [msg], type: "message" }, clearMedia2) : window.Store.Cmd.sendDeleteMsgs(chat, [msg], clearMedia2);
      }, this.id._serialized, everyone, clearMedia);
    }
    async star() {
      await this.client.pupPage.evaluate(async (msgId) => {
        const msg = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
        if (window.Store.MsgActionChecks.canStarMsg(msg)) {
          let chat = await window.Store.Chat.find(msg.id.remote);
          return window.Store.Cmd.sendStarMsgs(chat, [msg], false);
        }
      }, this.id._serialized);
    }
    async unstar() {
      await this.client.pupPage.evaluate(async (msgId) => {
        const msg = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
        if (window.Store.MsgActionChecks.canStarMsg(msg)) {
          let chat = await window.Store.Chat.find(msg.id.remote);
          return window.Store.Cmd.sendUnstarMsgs(chat, [msg], false);
        }
      }, this.id._serialized);
    }
    async pin(duration) {
      return await this.client.pupPage.evaluate(async (msgId, duration2) => {
        return await window.WWebJS.pinUnpinMsgAction(msgId, 1, duration2);
      }, this.id._serialized, duration);
    }
    async unpin() {
      return await this.client.pupPage.evaluate(async (msgId) => {
        return await window.WWebJS.pinUnpinMsgAction(msgId, 2);
      }, this.id._serialized);
    }
    async getInfo() {
      const info = await this.client.pupPage.evaluate(async (msgId) => {
        const msg = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
        if (!msg || !msg.id.fromMe)
          return null;
        return new Promise((resolve) => {
          setTimeout(async () => {
            resolve(await window.Store.getMsgInfo(msg.id));
          }, Date.now() - msg.t * 1000 < 1250 && Math.floor(Math.random() * (1200 - 1100 + 1)) + 1100 || 0);
        });
      }, this.id._serialized);
      return info;
    }
    async getOrder() {
      if (this.type === MessageTypes.ORDER) {
        const result = await this.client.pupPage.evaluate((orderId, token, chatId) => {
          return window.WWebJS.getOrderDetail(orderId, token, chatId);
        }, this.orderId, this.token, this._getChatId());
        if (!result)
          return;
        return new Order(this.client, result);
      }
      return;
    }
    async getPayment() {
      if (this.type === MessageTypes.PAYMENT) {
        const msg = await this.client.pupPage.evaluate(async (msgId) => {
          const msg2 = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
          if (!msg2)
            return null;
          return msg2.serialize();
        }, this.id._serialized);
        return new Payment(this.client, msg);
      }
      return;
    }
    async getReactions() {
      if (!this.hasReaction) {
        return;
      }
      const reactions = await this.client.pupPage.evaluate(async (msgId) => {
        const msgReactions = await window.Store.Reactions.find(msgId);
        if (!msgReactions || !msgReactions.reactions.length)
          return null;
        return msgReactions.reactions.serialize();
      }, this.id._serialized);
      if (!reactions) {
        return;
      }
      return reactions.map((reaction) => {
        reaction.senders = reaction.senders.map((sender) => {
          sender.timestamp = Math.round(sender.timestamp / 1000);
          return new Reaction(this.client, sender);
        });
        return reaction;
      });
    }
    async edit(content, options = {}) {
      if (options.mentions) {
        !Array.isArray(options.mentions) && (options.mentions = [options.mentions]);
        if (options.mentions.some((possiblyContact) => possiblyContact instanceof Contact)) {
          console.warn("Mentions with an array of Contact are now deprecated. See more at https://github.com/pedroslopez/whatsapp-web.js/pull/2166.");
          options.mentions = options.mentions.map((a) => a.id._serialized);
        }
      }
      options.groupMentions && !Array.isArray(options.groupMentions) && (options.groupMentions = [options.groupMentions]);
      let internalOptions = {
        linkPreview: options.linkPreview === false ? undefined : true,
        mentionedJidList: options.mentions || [],
        groupMentions: options.groupMentions,
        extraOptions: options.extra
      };
      if (!this.fromMe) {
        return null;
      }
      const messageEdit = await this.client.pupPage.evaluate(async (msgId, message, options2) => {
        const msg = window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
        if (!msg)
          return null;
        let canEdit = window.Store.MsgActionChecks.canEditText(msg) || window.Store.MsgActionChecks.canEditCaption(msg);
        if (canEdit) {
          const msgEdit = await window.WWebJS.editMessage(msg, message, options2);
          return msgEdit.serialize();
        }
        return null;
      }, this.id._serialized, content, internalOptions);
      if (messageEdit) {
        return new Message(this.client, messageEdit);
      }
      return null;
    }
  }
  module.exports = Message;
});

// node_modules/whatsapp-web.js/src/structures/Chat.js
var require_Chat = __commonJS((exports, module) => {
  var Base = require_Base();
  var Message = require_Message();

  class Chat extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.name = data.formattedTitle;
      this.isGroup = data.isGroup;
      this.isReadOnly = data.isReadOnly;
      this.unreadCount = data.unreadCount;
      this.timestamp = data.t;
      this.archived = data.archive;
      this.pinned = !!data.pin;
      this.isMuted = data.isMuted;
      this.muteExpiration = data.muteExpiration;
      this.lastMessage = data.lastMessage ? new Message(this.client, data.lastMessage) : undefined;
      return super._patch(data);
    }
    async sendMessage(content, options) {
      return this.client.sendMessage(this.id._serialized, content, options);
    }
    async sendSeen() {
      return this.client.sendSeen(this.id._serialized);
    }
    async clearMessages() {
      return this.client.pupPage.evaluate((chatId) => {
        return window.WWebJS.sendClearChat(chatId);
      }, this.id._serialized);
    }
    async delete() {
      return this.client.pupPage.evaluate((chatId) => {
        return window.WWebJS.sendDeleteChat(chatId);
      }, this.id._serialized);
    }
    async archive() {
      return this.client.archiveChat(this.id._serialized);
    }
    async unarchive() {
      return this.client.unarchiveChat(this.id._serialized);
    }
    async pin() {
      return this.client.pinChat(this.id._serialized);
    }
    async unpin() {
      return this.client.unpinChat(this.id._serialized);
    }
    async mute(unmuteDate) {
      const result = await this.client.muteChat(this.id._serialized, unmuteDate);
      this.isMuted = result.isMuted;
      this.muteExpiration = result.muteExpiration;
      return result;
    }
    async unmute() {
      const result = await this.client.unmuteChat(this.id._serialized);
      this.isMuted = result.isMuted;
      this.muteExpiration = result.muteExpiration;
      return result;
    }
    async markUnread() {
      return this.client.markChatUnread(this.id._serialized);
    }
    async fetchMessages(searchOptions) {
      let messages = await this.client.pupPage.evaluate(async (chatId, searchOptions2) => {
        const msgFilter = (m2) => {
          if (m2.isNotification) {
            return false;
          }
          if (searchOptions2 && searchOptions2.fromMe !== undefined && m2.id.fromMe !== searchOptions2.fromMe) {
            return false;
          }
          return true;
        };
        const chat = await window.WWebJS.getChat(chatId, { getAsModel: false });
        let msgs = chat.msgs.getModelsArray().filter(msgFilter);
        if (searchOptions2 && searchOptions2.limit > 0) {
          while (msgs.length < searchOptions2.limit) {
            const loadedMessages = await window.Store.ConversationMsgs.loadEarlierMsgs(chat);
            if (!loadedMessages || !loadedMessages.length)
              break;
            msgs = [...loadedMessages.filter(msgFilter), ...msgs];
          }
          if (msgs.length > searchOptions2.limit) {
            msgs.sort((a, b) => a.t > b.t ? 1 : -1);
            msgs = msgs.splice(msgs.length - searchOptions2.limit);
          }
        }
        return msgs.map((m2) => window.WWebJS.getMessageModel(m2));
      }, this.id._serialized, searchOptions);
      return messages.map((m2) => new Message(this.client, m2));
    }
    async sendStateTyping() {
      return this.client.pupPage.evaluate((chatId) => {
        window.WWebJS.sendChatstate("typing", chatId);
        return true;
      }, this.id._serialized);
    }
    async sendStateRecording() {
      return this.client.pupPage.evaluate((chatId) => {
        window.WWebJS.sendChatstate("recording", chatId);
        return true;
      }, this.id._serialized);
    }
    async clearState() {
      return this.client.pupPage.evaluate((chatId) => {
        window.WWebJS.sendChatstate("stop", chatId);
        return true;
      }, this.id._serialized);
    }
    async getContact() {
      return await this.client.getContactById(this.id._serialized);
    }
    async getLabels() {
      return this.client.getChatLabels(this.id._serialized);
    }
    async changeLabels(labelIds) {
      return this.client.addOrRemoveLabels(labelIds, [this.id._serialized]);
    }
    async syncHistory() {
      return this.client.syncHistory(this.id._serialized);
    }
  }
  module.exports = Chat;
});

// node_modules/whatsapp-web.js/src/structures/PrivateChat.js
var require_PrivateChat = __commonJS((exports, module) => {
  var Chat = require_Chat();

  class PrivateChat extends Chat {
  }
  module.exports = PrivateChat;
});

// node_modules/whatsapp-web.js/src/structures/GroupChat.js
var require_GroupChat = __commonJS((exports, module) => {
  var Chat = require_Chat();

  class GroupChat extends Chat {
    _patch(data) {
      this.groupMetadata = data.groupMetadata;
      return super._patch(data);
    }
    get owner() {
      return this.groupMetadata.owner;
    }
    get createdAt() {
      return new Date(this.groupMetadata.creation * 1000);
    }
    get description() {
      return this.groupMetadata.desc;
    }
    get participants() {
      return this.groupMetadata.participants;
    }
    async addParticipants(participantIds, options = {}) {
      return await this.client.pupPage.evaluate(async (groupId, participantIds2, options2) => {
        const { sleep = [250, 500], autoSendInviteV4 = true, comment = "" } = options2;
        const participantData = {};
        !Array.isArray(participantIds2) && (participantIds2 = [participantIds2]);
        const groupWid = window.Store.WidFactory.createWid(groupId);
        const group = await window.Store.Chat.find(groupWid);
        const participantWids = participantIds2.map((p) => window.Store.WidFactory.createWid(p));
        const errorCodes = {
          default: "An unknown error occupied while adding a participant",
          isGroupEmpty: "AddParticipantsError: The participant can't be added to an empty group",
          iAmNotAdmin: "AddParticipantsError: You have no admin rights to add a participant to a group",
          200: "The participant was added successfully",
          403: "The participant can be added by sending private invitation only",
          404: "The phone number is not registered on WhatsApp",
          408: "You cannot add this participant because they recently left the group",
          409: "The participant is already a group member",
          417: "The participant can't be added to the community. You can invite them privately to join this group through its invite link",
          419: "The participant can't be added because the group is full"
        };
        await window.Store.GroupQueryAndUpdate({ id: groupId });
        const groupMetadata = group.groupMetadata;
        const groupParticipants = groupMetadata?.participants;
        if (!groupParticipants) {
          return errorCodes.isGroupEmpty;
        }
        if (!group.iAmAdmin()) {
          return errorCodes.iAmNotAdmin;
        }
        const _getSleepTime = (sleep2) => {
          if (!Array.isArray(sleep2) || sleep2.length === 2 && sleep2[0] === sleep2[1]) {
            return sleep2;
          }
          if (sleep2.length === 1) {
            return sleep2[0];
          }
          sleep2[1] - sleep2[0] < 100 && (sleep2[0] = sleep2[1]) && (sleep2[1] += 100);
          return Math.floor(Math.random() * (sleep2[1] - sleep2[0] + 1)) + sleep2[0];
        };
        for (const pWid of participantWids) {
          const pId = pWid._serialized;
          participantData[pId] = {
            code: undefined,
            message: undefined,
            isInviteV4Sent: false
          };
          if (groupParticipants.some((p) => p.id._serialized === pId)) {
            participantData[pId].code = 409;
            participantData[pId].message = errorCodes[409];
            continue;
          }
          if (!(await window.Store.QueryExist(pWid))?.wid) {
            participantData[pId].code = 404;
            participantData[pId].message = errorCodes[404];
            continue;
          }
          const rpcResult = await window.WWebJS.getAddParticipantsRpcResult(groupMetadata, groupWid, pWid);
          const { code: rpcResultCode } = rpcResult;
          participantData[pId].code = rpcResultCode;
          participantData[pId].message = errorCodes[rpcResultCode] || errorCodes.default;
          if (autoSendInviteV4 && rpcResultCode === 403) {
            let userChat, isInviteV4Sent = false;
            window.Store.Contact.gadd(pWid, { silent: true });
            if (rpcResult.name === "ParticipantRequestCodeCanBeSent" && (userChat = await window.Store.Chat.find(pWid))) {
              const groupName = group.formattedTitle || group.name;
              const res = await window.Store.GroupInviteV4.sendGroupInviteMessage(userChat, group.id._serialized, groupName, rpcResult.inviteV4Code, rpcResult.inviteV4CodeExp, comment, await window.WWebJS.getProfilePicThumbToBase64(groupWid));
              isInviteV4Sent = window.compareWwebVersions(window.Debug.VERSION, "<", "2.2335.6") ? res === "OK" : res.messageSendResult === "OK";
            }
            participantData[pId].isInviteV4Sent = isInviteV4Sent;
          }
          sleep && participantWids.length > 1 && participantWids.indexOf(pWid) !== participantWids.length - 1 && await new Promise((resolve) => setTimeout(resolve, _getSleepTime(sleep)));
        }
        return participantData;
      }, this.id._serialized, participantIds, options);
    }
    async removeParticipants(participantIds) {
      return await this.client.pupPage.evaluate(async (chatId, participantIds2) => {
        const chat = await window.WWebJS.getChat(chatId, { getAsModel: false });
        const participants = participantIds2.map((p) => {
          return chat.groupMetadata.participants.get(p);
        }).filter((p) => Boolean(p));
        await window.Store.GroupParticipants.removeParticipants(chat, participants);
        return { status: 200 };
      }, this.id._serialized, participantIds);
    }
    async promoteParticipants(participantIds) {
      return await this.client.pupPage.evaluate(async (chatId, participantIds2) => {
        const chat = await window.WWebJS.getChat(chatId, { getAsModel: false });
        const participants = participantIds2.map((p) => {
          return chat.groupMetadata.participants.get(p);
        }).filter((p) => Boolean(p));
        await window.Store.GroupParticipants.promoteParticipants(chat, participants);
        return { status: 200 };
      }, this.id._serialized, participantIds);
    }
    async demoteParticipants(participantIds) {
      return await this.client.pupPage.evaluate(async (chatId, participantIds2) => {
        const chat = await window.WWebJS.getChat(chatId, { getAsModel: false });
        const participants = participantIds2.map((p) => {
          return chat.groupMetadata.participants.get(p);
        }).filter((p) => Boolean(p));
        await window.Store.GroupParticipants.demoteParticipants(chat, participants);
        return { status: 200 };
      }, this.id._serialized, participantIds);
    }
    async setSubject(subject) {
      const success = await this.client.pupPage.evaluate(async (chatId, subject2) => {
        const chatWid = window.Store.WidFactory.createWid(chatId);
        try {
          await window.Store.GroupUtils.setGroupSubject(chatWid, subject2);
          return true;
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return false;
          throw err;
        }
      }, this.id._serialized, subject);
      if (!success)
        return false;
      this.name = subject;
      return true;
    }
    async setDescription(description) {
      const success = await this.client.pupPage.evaluate(async (chatId, description2) => {
        const chatWid = window.Store.WidFactory.createWid(chatId);
        let descId = window.Store.GroupMetadata.get(chatWid).descId;
        let newId = await window.Store.MsgKey.newId();
        try {
          await window.Store.GroupUtils.setGroupDescription(chatWid, description2, newId, descId);
          return true;
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return false;
          throw err;
        }
      }, this.id._serialized, description);
      if (!success)
        return false;
      this.groupMetadata.desc = description;
      return true;
    }
    async setAddMembersAdminsOnly(adminsOnly = true) {
      const success = await this.client.pupPage.evaluate(async (groupId, adminsOnly2) => {
        const chatWid = window.Store.WidFactory.createWid(groupId);
        try {
          const response = await window.Store.GroupUtils.setGroupMemberAddMode(chatWid, "member_add_mode", adminsOnly2 ? 0 : 1);
          return response.name === "SetMemberAddModeResponseSuccess";
        } catch (err) {
          if (err.name === "SmaxParsingFailure")
            return false;
          throw err;
        }
      }, this.id._serialized, adminsOnly);
      success && (this.groupMetadata.memberAddMode = adminsOnly ? "admin_add" : "all_member_add");
      return success;
    }
    async setMessagesAdminsOnly(adminsOnly = true) {
      const success = await this.client.pupPage.evaluate(async (chatId, adminsOnly2) => {
        const chatWid = window.Store.WidFactory.createWid(chatId);
        try {
          await window.Store.GroupUtils.setGroupProperty(chatWid, "announcement", adminsOnly2 ? 1 : 0);
          return true;
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return false;
          throw err;
        }
      }, this.id._serialized, adminsOnly);
      if (!success)
        return false;
      this.groupMetadata.announce = adminsOnly;
      return true;
    }
    async setInfoAdminsOnly(adminsOnly = true) {
      const success = await this.client.pupPage.evaluate(async (chatId, adminsOnly2) => {
        const chatWid = window.Store.WidFactory.createWid(chatId);
        try {
          await window.Store.GroupUtils.setGroupProperty(chatWid, "restrict", adminsOnly2 ? 1 : 0);
          return true;
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return false;
          throw err;
        }
      }, this.id._serialized, adminsOnly);
      if (!success)
        return false;
      this.groupMetadata.restrict = adminsOnly;
      return true;
    }
    async deletePicture() {
      const success = await this.client.pupPage.evaluate((chatid) => {
        return window.WWebJS.deletePicture(chatid);
      }, this.id._serialized);
      return success;
    }
    async setPicture(media) {
      const success = await this.client.pupPage.evaluate((chatid, media2) => {
        return window.WWebJS.setPicture(chatid, media2);
      }, this.id._serialized, media);
      return success;
    }
    async getInviteCode() {
      const codeRes = await this.client.pupPage.evaluate(async (chatId) => {
        const chatWid = window.Store.WidFactory.createWid(chatId);
        try {
          return window.compareWwebVersions(window.Debug.VERSION, ">=", "2.3000.1020730154") ? await window.Store.GroupInvite.fetchMexGroupInviteCode(chatId) : await window.Store.GroupInvite.queryGroupInviteCode(chatWid, true);
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return;
          throw err;
        }
      }, this.id._serialized);
      return codeRes?.code ? codeRes?.code : codeRes;
    }
    async revokeInvite() {
      const codeRes = await this.client.pupPage.evaluate((chatId) => {
        const chatWid = window.Store.WidFactory.createWid(chatId);
        return window.Store.GroupInvite.resetGroupInviteCode(chatWid);
      }, this.id._serialized);
      return codeRes.code;
    }
    async getGroupMembershipRequests() {
      return await this.client.getGroupMembershipRequests(this.id._serialized);
    }
    async approveGroupMembershipRequests(options = {}) {
      return await this.client.approveGroupMembershipRequests(this.id._serialized, options);
    }
    async rejectGroupMembershipRequests(options = {}) {
      return await this.client.rejectGroupMembershipRequests(this.id._serialized, options);
    }
    async leave() {
      await this.client.pupPage.evaluate(async (chatId) => {
        const chat = await window.WWebJS.getChat(chatId, { getAsModel: false });
        return window.Store.GroupUtils.sendExitGroup(chat);
      }, this.id._serialized);
    }
  }
  module.exports = GroupChat;
});

// node_modules/whatsapp-web.js/src/structures/Channel.js
var require_Channel = __commonJS((exports, module) => {
  var Base = require_Base();
  var Message = require_Message();

  class Channel extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.channelMetadata = data.channelMetadata;
      this.id = data.id;
      this.name = data.name;
      this.description = data.channelMetadata.description;
      this.isChannel = data.isChannel;
      this.isGroup = data.isGroup;
      this.isReadOnly = data.isReadOnly;
      this.unreadCount = data.unreadCount;
      this.timestamp = data.t;
      this.isMuted = data.isMuted;
      this.muteExpiration = data.muteExpiration;
      this.lastMessage = data.lastMessage ? new Message(super.client, data.lastMessage) : undefined;
      return super._patch(data);
    }
    async getSubscribers(limit) {
      return await this.client.pupPage.evaluate(async (channelId, limit2) => {
        const channel = await window.WWebJS.getChat(channelId, { getAsModel: false });
        if (!channel)
          return [];
        !limit2 && (limit2 = window.Store.ChannelUtils.getMaxSubscriberNumber());
        const response = await window.Store.ChannelSubscribers.mexFetchNewsletterSubscribers(channelId, limit2);
        const contacts = window.Store.ChannelSubscribers.getSubscribersInContacts(response.subscribers);
        return Promise.all(contacts.map((obj2) => ({
          ...obj2,
          contact: window.WWebJS.getContactModel(obj2.contact)
        })));
      }, this.id._serialized, limit);
    }
    async setSubject(newSubject) {
      const success = await this._setChannelMetadata({ name: newSubject }, { editName: true });
      success && (this.name = newSubject);
      return success;
    }
    async setDescription(newDescription) {
      const success = await this._setChannelMetadata({ description: newDescription }, { editDescription: true });
      success && (this.description = newDescription);
      return success;
    }
    async setProfilePicture(newProfilePicture) {
      return await this._setChannelMetadata({ picture: newProfilePicture }, { editPicture: true });
    }
    async setReactionSetting(reactionCode) {
      if (![0, 1, 2].includes(reactionCode))
        return false;
      const reactionMapper = {
        0: 3,
        1: 1,
        2: 0
      };
      const success = await this._setChannelMetadata({ reactionCodesSetting: reactionMapper[reactionCode] }, { editReactionCodesSetting: true });
      success && (this.channelMetadata.reactionCodesSetting = reactionCode);
      return success;
    }
    async mute() {
      const success = await this._muteUnmuteChannel("MUTE");
      if (success) {
        this.isMuted = true;
        this.muteExpiration = -1;
      }
      return success;
    }
    async unmute() {
      const success = await this._muteUnmuteChannel("UNMUTE");
      if (success) {
        this.isMuted = false;
        this.muteExpiration = 0;
      }
      return success;
    }
    async sendMessage(content, options) {
      return this.client.sendMessage(this.id._serialized, content, options);
    }
    async sendSeen() {
      return this.client.sendSeen(this.id._serialized);
    }
    async sendChannelAdminInvite(chatId, options = {}) {
      return this.client.sendChannelAdminInvite(chatId, this.id._serialized, options);
    }
    async acceptChannelAdminInvite() {
      return this.client.acceptChannelAdminInvite(this.id._serialized);
    }
    async revokeChannelAdminInvite(userId) {
      return this.client.revokeChannelAdminInvite(this.id._serialized, userId);
    }
    async demoteChannelAdmin(userId) {
      return this.client.demoteChannelAdmin(this.id._serialized, userId);
    }
    async transferChannelOwnership(newOwnerId, options = {}) {
      return this.client.transferChannelOwnership(this.id._serialized, newOwnerId, options);
    }
    async fetchMessages(searchOptions) {
      let messages = await this.client.pupPage.evaluate(async (channelId, searchOptions2) => {
        const msgFilter = (m2) => {
          if (m2.isNotification || m2.type === "newsletter_notification") {
            return false;
          }
          if (searchOptions2 && searchOptions2.fromMe !== undefined && m2.id.fromMe !== searchOptions2.fromMe) {
            return false;
          }
          return true;
        };
        const channel = await window.WWebJS.getChat(channelId, { getAsModel: false });
        let msgs = channel.msgs.getModelsArray().filter(msgFilter);
        if (searchOptions2 && searchOptions2.limit > 0) {
          while (msgs.length < searchOptions2.limit) {
            const loadedMessages = await window.Store.ConversationMsgs.loadEarlierMsgs(channel);
            if (!loadedMessages || !loadedMessages.length)
              break;
            msgs = [...loadedMessages.filter(msgFilter), ...msgs];
          }
          if (msgs.length > searchOptions2.limit) {
            msgs.sort((a, b) => a.t > b.t ? 1 : -1);
            msgs = msgs.splice(msgs.length - searchOptions2.limit);
          }
        }
        return msgs.map((m2) => window.WWebJS.getMessageModel(m2));
      }, this.id._serialized, searchOptions);
      return messages.map((msg) => new Message(this.client, msg));
    }
    async deleteChannel() {
      return this.client.deleteChannel(this.id._serialized);
    }
    async _setChannelMetadata(value, property) {
      return await this.client.pupPage.evaluate(async (channelId, value2, property2) => {
        const channel = await window.WWebJS.getChat(channelId, { getAsModel: false });
        if (!channel)
          return false;
        if (property2.editPicture) {
          value2.picture = value2.picture ? await window.WWebJS.cropAndResizeImage(value2.picture, {
            asDataUrl: true,
            mimetype: "image/jpeg",
            size: 640,
            quality: 1
          }) : null;
        }
        try {
          await window.Store.ChannelUtils.editNewsletterMetadataAction(channel, property2, value2);
          return true;
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return false;
          throw err;
        }
      }, this.id._serialized, value, property);
    }
    async _muteUnmuteChannel(action) {
      return await this.client.pupPage.evaluate(async (channelId, action2) => {
        try {
          action2 === "MUTE" ? await window.Store.ChannelUtils.muteNewsletter([channelId]) : await window.Store.ChannelUtils.unmuteNewsletter([channelId]);
          return true;
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return false;
          throw err;
        }
      }, this.id._serialized, action);
    }
  }
  module.exports = Channel;
});

// node_modules/whatsapp-web.js/src/factories/ChatFactory.js
var require_ChatFactory = __commonJS((exports, module) => {
  var PrivateChat = require_PrivateChat();
  var GroupChat = require_GroupChat();
  var Channel = require_Channel();

  class ChatFactory {
    static create(client, data) {
      if (data.isGroup) {
        return new GroupChat(client, data);
      }
      if (data.isChannel) {
        return new Channel(client, data);
      }
      return new PrivateChat(client, data);
    }
  }
  module.exports = ChatFactory;
});

// node_modules/whatsapp-web.js/src/structures/PrivateContact.js
var require_PrivateContact = __commonJS((exports, module) => {
  var Contact = require_Contact();

  class PrivateContact extends Contact {
  }
  module.exports = PrivateContact;
});

// node_modules/whatsapp-web.js/src/structures/BusinessContact.js
var require_BusinessContact = __commonJS((exports, module) => {
  var Contact = require_Contact();

  class BusinessContact extends Contact {
    _patch(data) {
      this.businessProfile = data.businessProfile;
      return super._patch(data);
    }
  }
  module.exports = BusinessContact;
});

// node_modules/whatsapp-web.js/src/factories/ContactFactory.js
var require_ContactFactory = __commonJS((exports, module) => {
  var PrivateContact = require_PrivateContact();
  var BusinessContact = require_BusinessContact();

  class ContactFactory {
    static create(client, data) {
      if (data.isBusiness) {
        return new BusinessContact(client, data);
      }
      return new PrivateContact(client, data);
    }
  }
  module.exports = ContactFactory;
});

// node_modules/whatsapp-web.js/src/webCache/WebCache.js
var require_WebCache = __commonJS((exports, module) => {
  class WebCache {
    async resolve() {
      return null;
    }
    async persist() {}
  }

  class VersionResolveError extends Error {
  }
  module.exports = {
    WebCache,
    VersionResolveError
  };
});

// node_modules/whatsapp-web.js/src/webCache/RemoteWebCache.js
var require_RemoteWebCache = __commonJS((exports, module) => {
  var fetch2 = require_lib3();
  var { WebCache, VersionResolveError } = require_WebCache();

  class RemoteWebCache extends WebCache {
    constructor(options = {}) {
      super();
      if (!options.remotePath)
        throw new Error("webVersionCache.remotePath is required when using the remote cache");
      this.remotePath = options.remotePath;
      this.strict = options.strict || false;
    }
    async resolve(version) {
      const remotePath = this.remotePath.replace("{version}", version);
      try {
        const cachedRes = await fetch2(remotePath);
        if (cachedRes.ok) {
          return cachedRes.text();
        }
      } catch (err) {
        console.error(`Error fetching version ${version} from remote`, err);
      }
      if (this.strict)
        throw new VersionResolveError(`Couldn't load version ${version} from the archive`);
      return null;
    }
    async persist() {}
  }
  module.exports = RemoteWebCache;
});

// node_modules/whatsapp-web.js/src/webCache/LocalWebCache.js
var require_LocalWebCache = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var { WebCache, VersionResolveError } = require_WebCache();

  class LocalWebCache extends WebCache {
    constructor(options = {}) {
      super();
      this.path = options.path || "./.wwebjs_cache/";
      this.strict = options.strict || false;
    }
    async resolve(version) {
      const filePath = path.join(this.path, `${version}.html`);
      try {
        return fs.readFileSync(filePath, "utf-8");
      } catch (err) {
        if (this.strict)
          throw new VersionResolveError(`Couldn't load version ${version} from the cache`);
        return null;
      }
    }
    async persist(indexHtml, version) {
      const filePath = path.join(this.path, `${version}.html`);
      fs.mkdirSync(this.path, { recursive: true });
      fs.writeFileSync(filePath, indexHtml);
    }
  }
  module.exports = LocalWebCache;
});

// node_modules/whatsapp-web.js/src/webCache/WebCacheFactory.js
var require_WebCacheFactory = __commonJS((exports, module) => {
  var RemoteWebCache = require_RemoteWebCache();
  var LocalWebCache = require_LocalWebCache();
  var { WebCache } = require_WebCache();
  var createWebCache = (type, options) => {
    switch (type) {
      case "remote":
        return new RemoteWebCache(options);
      case "local":
        return new LocalWebCache(options);
      case "none":
        return new WebCache;
      default:
        throw new Error(`Invalid WebCache type ${type}`);
    }
  };
  module.exports = {
    createWebCache
  };
});

// node_modules/whatsapp-web.js/src/structures/ClientInfo.js
var require_ClientInfo = __commonJS((exports, module) => {
  var Base = require_Base();

  class ClientInfo extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.pushname = data.pushname;
      this.wid = data.wid;
      this.me = data.wid;
      this.phone = data.phone;
      this.platform = data.platform;
      return super._patch(data);
    }
    async getBatteryStatus() {
      return await this.client.pupPage.evaluate(() => {
        const { battery, plugged } = window.Store.Conn;
        return { battery, plugged };
      });
    }
  }
  module.exports = ClientInfo;
});

// node_modules/whatsapp-web.js/src/structures/GroupNotification.js
var require_GroupNotification = __commonJS((exports, module) => {
  var Base = require_Base();

  class GroupNotification extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.body = data.body || "";
      this.type = data.subtype;
      this.timestamp = data.t;
      this.chatId = typeof data.id.remote === "object" ? data.id.remote._serialized : data.id.remote;
      this.author = typeof data.author === "object" ? data.author._serialized : data.author;
      this.recipientIds = [];
      if (data.recipients) {
        this.recipientIds = data.recipients;
      }
      return super._patch(data);
    }
    getChat() {
      return this.client.getChatById(this.chatId);
    }
    getContact() {
      return this.client.getContactById(this.author);
    }
    async getRecipients() {
      return await Promise.all(this.recipientIds.map(async (m2) => await this.client.getContactById(m2)));
    }
    async reply(content, options = {}) {
      return this.client.sendMessage(this.chatId, content, options);
    }
  }
  module.exports = GroupNotification;
});

// node_modules/whatsapp-web.js/src/structures/Label.js
var require_Label = __commonJS((exports, module) => {
  var Base = require_Base();
  var Chat = require_Chat();

  class Label extends Base {
    constructor(client, labelData) {
      super(client);
      if (labelData)
        this._patch(labelData);
    }
    _patch(labelData) {
      this.id = labelData.id;
      this.name = labelData.name;
      this.hexColor = labelData.hexColor;
    }
    async getChats() {
      return this.client.getChatsByLabelId(this.id);
    }
  }
  module.exports = Label;
});

// node_modules/whatsapp-web.js/src/structures/Call.js
var require_Call = __commonJS((exports, module) => {
  var Base = require_Base();

  class Call extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.from = data.peerJid;
      this.timestamp = data.offerTime;
      this.isVideo = data.isVideo;
      this.isGroup = data.isGroup;
      this.fromMe = data.outgoing;
      this.canHandleLocally = data.canHandleLocally;
      this.webClientShouldHandle = data.webClientShouldHandle;
      this.participants = data.participants;
      return super._patch(data);
    }
    async reject() {
      return this.client.pupPage.evaluate((peerJid, id) => {
        return window.WWebJS.rejectCall(peerJid, id);
      }, this.from, this.id);
    }
  }
  module.exports = Call;
});

// node_modules/whatsapp-web.js/src/structures/Buttons.js
var require_Buttons = __commonJS((exports, module) => {
  var MessageMedia = require_MessageMedia();
  var Util = require_Util();

  class Buttons {
    constructor(body, buttons, title, footer) {
      this.body = body;
      this.title = title;
      this.footer = footer;
      if (body instanceof MessageMedia) {
        this.type = "media";
        this.title = "";
      } else {
        this.type = "chat";
      }
      this.buttons = this._format(buttons);
      if (!this.buttons.length) {
        throw "[BT01] No buttons";
      }
    }
    _format(buttons) {
      buttons = buttons.slice(0, 3);
      return buttons.map((btn) => {
        return { buttonId: btn.id ? String(btn.id) : Util.generateHash(6), buttonText: { displayText: btn.body }, type: 1 };
      });
    }
  }
  module.exports = Buttons;
});

// node_modules/whatsapp-web.js/src/structures/List.js
var require_List = __commonJS((exports, module) => {
  var Util = require_Util();

  class List {
    constructor(body, buttonText, sections, title, footer) {
      this.description = body;
      this.buttonText = buttonText;
      this.title = title;
      this.footer = footer;
      this.sections = this._format(sections);
    }
    _format(sections) {
      if (!sections.length) {
        throw "[LT02] List without sections";
      }
      if (sections.length > 1 && sections.filter((s) => typeof s.title == "undefined").length > 1) {
        throw "[LT05] You can't have more than one empty title.";
      }
      return sections.map((section) => {
        if (!section.rows.length) {
          throw "[LT03] Section without rows";
        }
        return {
          title: section.title ? section.title : undefined,
          rows: section.rows.map((row) => {
            if (!row.title) {
              throw "[LT04] Row without title";
            }
            return {
              rowId: row.id ? row.id : Util.generateHash(6),
              title: row.title,
              description: row.description ? row.description : ""
            };
          })
        };
      });
    }
  }
  module.exports = List;
});

// node_modules/whatsapp-web.js/src/structures/Poll.js
var require_Poll = __commonJS((exports, module) => {
  class Poll {
    constructor(pollName, pollOptions, options = {}) {
      this.pollName = pollName.trim();
      this.pollOptions = pollOptions.map((option, index) => ({
        name: option.trim(),
        localId: index
      }));
      this.options = {
        allowMultipleAnswers: options.allowMultipleAnswers === true,
        messageSecret: options.messageSecret
      };
    }
  }
  module.exports = Poll;
});

// node_modules/whatsapp-web.js/src/structures/PollVote.js
var require_PollVote = __commonJS((exports, module) => {
  var Message = require_Message();
  var Base = require_Base();

  class PollVote extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.voter = data.sender;
      this.selectedOptions = data.selectedOptionLocalIds.length > 0 ? data.selectedOptionLocalIds.map((e) => ({
        name: data.parentMessage.pollOptions.find((x) => x.localId === e).name,
        localId: e
      })) : [];
      this.interractedAtTs = data.senderTimestampMs;
      this.parentMessage = new Message(this.client, data.parentMessage);
      return super._patch(data);
    }
  }
  module.exports = PollVote;
});

// node_modules/whatsapp-web.js/src/structures/Broadcast.js
var require_Broadcast = __commonJS((exports, module) => {
  var Base = require_Base();
  var Message = require_Message();

  class Broadcast extends Base {
    constructor(client, data) {
      super(client);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.timestamp = data.t;
      this.totalCount = data.totalCount;
      this.unreadCount = data.unreadCount;
      this.msgs = data.msgs?.map((msg) => new Message(this.client, msg));
      return super._patch(data);
    }
    getChat() {
      return this.client.getChatById(this.id._serialized);
    }
    getContact() {
      return this.client.getContactById(this.id._serialized);
    }
  }
  module.exports = Broadcast;
});

// node_modules/whatsapp-web.js/src/structures/index.js
var require_structures = __commonJS((exports, module) => {
  module.exports = {
    Base: require_Base(),
    BusinessContact: require_BusinessContact(),
    Chat: require_Chat(),
    ClientInfo: require_ClientInfo(),
    Contact: require_Contact(),
    GroupChat: require_GroupChat(),
    Channel: require_Channel(),
    Location: require_Location(),
    Message: require_Message(),
    MessageMedia: require_MessageMedia(),
    PrivateChat: require_PrivateChat(),
    PrivateContact: require_PrivateContact(),
    GroupNotification: require_GroupNotification(),
    Label: require_Label(),
    Order: require_Order(),
    Product: require_Product(),
    Call: require_Call(),
    Buttons: require_Buttons(),
    List: require_List(),
    Payment: require_Payment(),
    Reaction: require_Reaction(),
    Poll: require_Poll(),
    PollVote: require_PollVote(),
    Broadcast: require_Broadcast()
  };
});

// node_modules/whatsapp-web.js/src/authStrategies/BaseAuthStrategy.js
var require_BaseAuthStrategy = __commonJS((exports, module) => {
  class BaseAuthStrategy {
    constructor() {}
    setup(client) {
      this.client = client;
    }
    async beforeBrowserInitialized() {}
    async afterBrowserInitialized() {}
    async onAuthenticationNeeded() {
      return {
        failed: false,
        restart: false,
        failureEventPayload: undefined
      };
    }
    async getAuthEventPayload() {}
    async afterAuthReady() {}
    async disconnect() {}
    async destroy() {}
    async logout() {}
  }
  module.exports = BaseAuthStrategy;
});

// node_modules/whatsapp-web.js/src/authStrategies/NoAuth.js
var require_NoAuth = __commonJS((exports, module) => {
  var BaseAuthStrategy = require_BaseAuthStrategy();

  class NoAuth extends BaseAuthStrategy {
  }
  module.exports = NoAuth;
});

// node_modules/whatsapp-web.js/src/util/Puppeteer.js
var require_Puppeteer2 = __commonJS((exports, module) => {
  async function exposeFunctionIfAbsent(page, name, fn) {
    const exist = await page.evaluate((name2) => {
      return !!window[name2];
    }, name);
    if (exist) {
      return;
    }
    await page.exposeFunction(name, fn);
  }
  module.exports = { exposeFunctionIfAbsent };
});

// node_modules/whatsapp-web.js/src/Client.js
var require_Client = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var puppeteer = require_puppeteer();
  var moduleRaid2 = require_moduleraid();
  var Util = require_Util();
  var InterfaceController = require_InterfaceController();
  var { WhatsWebURL, DefaultOptions, Events, WAState } = require_Constants();
  var { ExposeAuthStore } = require_AuthStore();
  var { ExposeStore } = require_Store();
  var { ExposeLegacyAuthStore } = require_LegacyAuthStore();
  var { ExposeLegacyStore } = require_LegacyStore();
  var { LoadUtils } = require_Utils();
  var ChatFactory = require_ChatFactory();
  var ContactFactory = require_ContactFactory();
  var WebCacheFactory = require_WebCacheFactory();
  var { Broadcast, Buttons, Call, ClientInfo, Contact, GroupNotification, Label, List, Location, Message, MessageMedia, Poll, PollVote, Reaction } = require_structures();
  var NoAuth = require_NoAuth();
  var { exposeFunctionIfAbsent } = require_Puppeteer2();

  class Client extends EventEmitter {
    constructor(options = {}) {
      super();
      this.options = Util.mergeDefault(DefaultOptions, options);
      if (!this.options.authStrategy) {
        this.authStrategy = new NoAuth;
      } else {
        this.authStrategy = this.options.authStrategy;
      }
      this.authStrategy.setup(this);
      this.pupBrowser = null;
      this.pupPage = null;
      this.currentIndexHtml = null;
      this.lastLoggedOut = false;
      Util.setFfmpegPath(this.options.ffmpegPath);
    }
    async inject() {
      await this.pupPage.waitForFunction("window.Debug?.VERSION != undefined", { timeout: this.options.authTimeoutMs });
      const version = await this.getWWebVersion();
      const isCometOrAbove = parseInt(version.split(".")?.[1]) >= 3000;
      if (isCometOrAbove) {
        await this.pupPage.evaluate(ExposeAuthStore);
      } else {
        await this.pupPage.evaluate(ExposeLegacyAuthStore, moduleRaid2.toString());
      }
      const needAuthentication = await this.pupPage.evaluate(async () => {
        let state = window.AuthStore.AppState.state;
        if (state === "OPENING" || state === "UNLAUNCHED" || state === "PAIRING") {
          await new Promise((r) => {
            window.AuthStore.AppState.on("change:state", function waitTillInit(_AppState, state2) {
              if (state2 !== "OPENING" && state2 !== "UNLAUNCHED" && state2 !== "PAIRING") {
                window.AuthStore.AppState.off("change:state", waitTillInit);
                r();
              }
            });
          });
        }
        state = window.AuthStore.AppState.state;
        return state == "UNPAIRED" || state == "UNPAIRED_IDLE";
      });
      if (needAuthentication) {
        const { failed, failureEventPayload, restart } = await this.authStrategy.onAuthenticationNeeded();
        if (failed) {
          this.emit(Events.AUTHENTICATION_FAILURE, failureEventPayload);
          await this.destroy();
          if (restart) {
            return this.initialize();
          }
          return;
        }
        let qrRetries = 0;
        await exposeFunctionIfAbsent(this.pupPage, "onQRChangedEvent", async (qr) => {
          this.emit(Events.QR_RECEIVED, qr);
          if (this.options.qrMaxRetries > 0) {
            qrRetries++;
            if (qrRetries > this.options.qrMaxRetries) {
              this.emit(Events.DISCONNECTED, "Max qrcode retries reached");
              await this.destroy();
            }
          }
        });
        await this.pupPage.evaluate(async () => {
          const registrationInfo = await window.AuthStore.RegistrationUtils.waSignalStore.getRegistrationInfo();
          const noiseKeyPair = await window.AuthStore.RegistrationUtils.waNoiseInfo.get();
          const staticKeyB64 = window.AuthStore.Base64Tools.encodeB64(noiseKeyPair.staticKeyPair.pubKey);
          const identityKeyB64 = window.AuthStore.Base64Tools.encodeB64(registrationInfo.identityKeyPair.pubKey);
          const advSecretKey = await window.AuthStore.RegistrationUtils.getADVSecretKey();
          const platform = window.AuthStore.RegistrationUtils.DEVICE_PLATFORM;
          const getQR = (ref) => ref + "," + staticKeyB64 + "," + identityKeyB64 + "," + advSecretKey + "," + platform;
          window.onQRChangedEvent(getQR(window.AuthStore.Conn.ref));
          window.AuthStore.Conn.on("change:ref", (_2, ref) => {
            window.onQRChangedEvent(getQR(ref));
          });
        });
      }
      await exposeFunctionIfAbsent(this.pupPage, "onAuthAppStateChangedEvent", async (state) => {
        if (state == "UNPAIRED_IDLE") {
          window.Store.Cmd.refreshQR();
        }
      });
      await exposeFunctionIfAbsent(this.pupPage, "onAppStateHasSyncedEvent", async () => {
        const authEventPayload = await this.authStrategy.getAuthEventPayload();
        this.emit(Events.AUTHENTICATED, authEventPayload);
        const injected = await this.pupPage.evaluate(async () => {
          return typeof window.Store !== "undefined" && typeof window.WWebJS !== "undefined";
        });
        if (!injected) {
          if (this.options.webVersionCache.type === "local" && this.currentIndexHtml) {
            const { type: webCacheType, ...webCacheOptions } = this.options.webVersionCache;
            const webCache = WebCacheFactory.createWebCache(webCacheType, webCacheOptions);
            await webCache.persist(this.currentIndexHtml, version);
          }
          if (isCometOrAbove) {
            await this.pupPage.evaluate(ExposeStore);
          } else {
            await new Promise((r) => setTimeout(r, 2000));
            await this.pupPage.evaluate(ExposeLegacyStore);
          }
          await this.pupPage.waitForFunction("window.Store != undefined");
          this.info = new ClientInfo(this, await this.pupPage.evaluate(() => {
            return { ...window.Store.Conn.serialize(), wid: window.Store.User.getMeUser() };
          }));
          this.interface = new InterfaceController(this);
          await this.pupPage.evaluate(LoadUtils);
          await this.attachEventListeners();
        }
        this.emit(Events.READY);
        this.authStrategy.afterAuthReady();
      });
      let lastPercent = null;
      await exposeFunctionIfAbsent(this.pupPage, "onOfflineProgressUpdateEvent", async (percent) => {
        if (lastPercent !== percent) {
          lastPercent = percent;
          this.emit(Events.LOADING_SCREEN, percent, "WhatsApp");
        }
      });
      await exposeFunctionIfAbsent(this.pupPage, "onLogoutEvent", async () => {
        this.lastLoggedOut = true;
        await this.pupPage.waitForNavigation({ waitUntil: "load", timeout: 5000 }).catch((_2) => _2);
      });
      await this.pupPage.evaluate(() => {
        window.AuthStore.AppState.on("change:state", (_AppState, state) => {
          window.onAuthAppStateChangedEvent(state);
        });
        window.AuthStore.AppState.on("change:hasSynced", () => {
          window.onAppStateHasSyncedEvent();
        });
        window.AuthStore.Cmd.on("offline_progress_update", () => {
          window.onOfflineProgressUpdateEvent(window.AuthStore.OfflineMessageHandler.getOfflineDeliveryProgress());
        });
        window.AuthStore.Cmd.on("logout", async () => {
          await window.onLogoutEvent();
        });
      });
    }
    async initialize() {
      let browser, page;
      browser = null;
      page = null;
      await this.authStrategy.beforeBrowserInitialized();
      const puppeteerOpts = this.options.puppeteer;
      if (puppeteerOpts && (puppeteerOpts.browserWSEndpoint || puppeteerOpts.browserURL)) {
        browser = await puppeteer.connect(puppeteerOpts);
        page = await browser.newPage();
      } else {
        const browserArgs = [...puppeteerOpts.args || []];
        if (!browserArgs.find((arg) => arg.includes("--user-agent"))) {
          browserArgs.push(`--user-agent=${this.options.userAgent}`);
        }
        browserArgs.push("--disable-blink-features=AutomationControlled");
        browser = await puppeteer.launch({ ...puppeteerOpts, args: browserArgs });
        page = (await browser.pages())[0];
      }
      if (this.options.proxyAuthentication !== undefined) {
        await page.authenticate(this.options.proxyAuthentication);
      }
      await page.setUserAgent(this.options.userAgent);
      if (this.options.bypassCSP)
        await page.setBypassCSP(true);
      this.pupBrowser = browser;
      this.pupPage = page;
      await this.authStrategy.afterBrowserInitialized();
      await this.initWebVersionCache();
      await page.evaluateOnNewDocument(() => {
        const originalError = Error;
        window.originalError = originalError;
        Error = function(message) {
          const error = new originalError(message);
          const originalStack = error.stack;
          if (error.stack.includes("moduleRaid"))
            error.stack = originalStack + `
    at https://web.whatsapp.com/vendors~lazy_loaded_low_priority_components.05e98054dbd60f980427.js:2:44`;
          return error;
        };
      });
      await page.goto(WhatsWebURL, {
        waitUntil: "load",
        timeout: 0,
        referer: "https://whatsapp.com/"
      });
      await this.inject();
      this.pupPage.on("framenavigated", async (frame) => {
        if (frame.url().includes("post_logout=1") || this.lastLoggedOut) {
          this.emit(Events.DISCONNECTED, "LOGOUT");
          await this.authStrategy.logout();
          await this.authStrategy.beforeBrowserInitialized();
          await this.authStrategy.afterBrowserInitialized();
          this.lastLoggedOut = false;
        }
        await this.inject();
      });
    }
    async requestPairingCode(phoneNumber, showNotification = true) {
      return await this.pupPage.evaluate(async (phoneNumber2, showNotification2) => {
        window.AuthStore.PairingCodeLinkUtils.setPairingType("ALT_DEVICE_LINKING");
        await window.AuthStore.PairingCodeLinkUtils.initializeAltDeviceLinking();
        return window.AuthStore.PairingCodeLinkUtils.startAltLinkingFlow(phoneNumber2, showNotification2);
      }, phoneNumber, showNotification);
    }
    async attachEventListeners() {
      await exposeFunctionIfAbsent(this.pupPage, "onAddMessageEvent", (msg) => {
        if (msg.type === "gp2") {
          const notification = new GroupNotification(this, msg);
          if (["add", "invite", "linked_group_join"].includes(msg.subtype)) {
            this.emit(Events.GROUP_JOIN, notification);
          } else if (msg.subtype === "remove" || msg.subtype === "leave") {
            this.emit(Events.GROUP_LEAVE, notification);
          } else if (msg.subtype === "promote" || msg.subtype === "demote") {
            this.emit(Events.GROUP_ADMIN_CHANGED, notification);
          } else if (msg.subtype === "membership_approval_request") {
            this.emit(Events.GROUP_MEMBERSHIP_REQUEST, notification);
          } else {
            this.emit(Events.GROUP_UPDATE, notification);
          }
          return;
        }
        const message = new Message(this, msg);
        this.emit(Events.MESSAGE_CREATE, message);
        if (msg.id.fromMe)
          return;
        this.emit(Events.MESSAGE_RECEIVED, message);
      });
      let last_message;
      await exposeFunctionIfAbsent(this.pupPage, "onChangeMessageTypeEvent", (msg) => {
        if (msg.type === "revoked") {
          const message = new Message(this, msg);
          let revoked_msg;
          if (last_message && msg.id.id === last_message.id.id) {
            revoked_msg = new Message(this, last_message);
          }
          this.emit(Events.MESSAGE_REVOKED_EVERYONE, message, revoked_msg);
        }
      });
      await exposeFunctionIfAbsent(this.pupPage, "onChangeMessageEvent", (msg) => {
        if (msg.type !== "revoked") {
          last_message = msg;
        }
        const isParticipant = msg.type === "gp2" && msg.subtype === "modify";
        const isContact = msg.type === "notification_template" && msg.subtype === "change_number";
        if (isParticipant || isContact) {
          const message = new Message(this, msg);
          const newId = isParticipant ? msg.recipients[0] : msg.to;
          const oldId = isParticipant ? msg.author : msg.templateParams.find((id) => id !== newId);
          this.emit(Events.CONTACT_CHANGED, message, oldId, newId, isContact);
        }
      });
      await exposeFunctionIfAbsent(this.pupPage, "onRemoveMessageEvent", (msg) => {
        if (!msg.isNewMsg)
          return;
        const message = new Message(this, msg);
        this.emit(Events.MESSAGE_REVOKED_ME, message);
      });
      await exposeFunctionIfAbsent(this.pupPage, "onMessageAckEvent", (msg, ack) => {
        const message = new Message(this, msg);
        this.emit(Events.MESSAGE_ACK, message, ack);
      });
      await exposeFunctionIfAbsent(this.pupPage, "onChatUnreadCountEvent", async (data) => {
        const chat = await this.getChatById(data.id);
        this.emit(Events.UNREAD_COUNT, chat);
      });
      await exposeFunctionIfAbsent(this.pupPage, "onMessageMediaUploadedEvent", (msg) => {
        const message = new Message(this, msg);
        this.emit(Events.MEDIA_UPLOADED, message);
      });
      await exposeFunctionIfAbsent(this.pupPage, "onAppStateChangedEvent", async (state) => {
        this.emit(Events.STATE_CHANGED, state);
        const ACCEPTED_STATES = [WAState.CONNECTED, WAState.OPENING, WAState.PAIRING, WAState.TIMEOUT];
        if (this.options.takeoverOnConflict) {
          ACCEPTED_STATES.push(WAState.CONFLICT);
          if (state === WAState.CONFLICT) {
            setTimeout(() => {
              this.pupPage.evaluate(() => window.Store.AppState.takeover());
            }, this.options.takeoverTimeoutMs);
          }
        }
        if (!ACCEPTED_STATES.includes(state)) {
          await this.authStrategy.disconnect();
          this.emit(Events.DISCONNECTED, state);
          this.destroy();
        }
      });
      await exposeFunctionIfAbsent(this.pupPage, "onBatteryStateChangedEvent", (state) => {
        const { battery, plugged } = state;
        if (battery === undefined)
          return;
        this.emit(Events.BATTERY_CHANGED, { battery, plugged });
      });
      await exposeFunctionIfAbsent(this.pupPage, "onIncomingCall", (call) => {
        const cll = new Call(this, call);
        this.emit(Events.INCOMING_CALL, cll);
      });
      await exposeFunctionIfAbsent(this.pupPage, "onReaction", (reactions) => {
        for (const reaction of reactions) {
          this.emit(Events.MESSAGE_REACTION, new Reaction(this, reaction));
        }
      });
      await exposeFunctionIfAbsent(this.pupPage, "onRemoveChatEvent", async (chat) => {
        const _chat = await this.getChatById(chat.id);
        this.emit(Events.CHAT_REMOVED, _chat);
      });
      await exposeFunctionIfAbsent(this.pupPage, "onArchiveChatEvent", async (chat, currState, prevState) => {
        const _chat = await this.getChatById(chat.id);
        this.emit(Events.CHAT_ARCHIVED, _chat, currState, prevState);
      });
      await exposeFunctionIfAbsent(this.pupPage, "onEditMessageEvent", (msg, newBody, prevBody) => {
        if (msg.type === "revoked") {
          return;
        }
        this.emit(Events.MESSAGE_EDIT, new Message(this, msg), newBody, prevBody);
      });
      await exposeFunctionIfAbsent(this.pupPage, "onAddMessageCiphertextEvent", (msg) => {
        this.emit(Events.MESSAGE_CIPHERTEXT, new Message(this, msg));
      });
      await exposeFunctionIfAbsent(this.pupPage, "onPollVoteEvent", (vote) => {
        const _vote = new PollVote(this, vote);
        this.emit(Events.VOTE_UPDATE, _vote);
      });
      await this.pupPage.evaluate(() => {
        window.Store.Msg.on("change", (msg) => {
          window.onChangeMessageEvent(window.WWebJS.getMessageModel(msg));
        });
        window.Store.Msg.on("change:type", (msg) => {
          window.onChangeMessageTypeEvent(window.WWebJS.getMessageModel(msg));
        });
        window.Store.Msg.on("change:ack", (msg, ack) => {
          window.onMessageAckEvent(window.WWebJS.getMessageModel(msg), ack);
        });
        window.Store.Msg.on("change:isUnsentMedia", (msg, unsent) => {
          if (msg.id.fromMe && !unsent)
            window.onMessageMediaUploadedEvent(window.WWebJS.getMessageModel(msg));
        });
        window.Store.Msg.on("remove", (msg) => {
          if (msg.isNewMsg)
            window.onRemoveMessageEvent(window.WWebJS.getMessageModel(msg));
        });
        window.Store.Msg.on("change:body change:caption", (msg, newBody, prevBody) => {
          window.onEditMessageEvent(window.WWebJS.getMessageModel(msg), newBody, prevBody);
        });
        window.Store.AppState.on("change:state", (_AppState, state) => {
          window.onAppStateChangedEvent(state);
        });
        window.Store.Conn.on("change:battery", (state) => {
          window.onBatteryStateChangedEvent(state);
        });
        window.Store.Call.on("add", (call) => {
          window.onIncomingCall(call);
        });
        window.Store.Chat.on("remove", async (chat) => {
          window.onRemoveChatEvent(await window.WWebJS.getChatModel(chat));
        });
        window.Store.Chat.on("change:archive", async (chat, currState, prevState) => {
          window.onArchiveChatEvent(await window.WWebJS.getChatModel(chat), currState, prevState);
        });
        window.Store.Msg.on("add", (msg) => {
          if (msg.isNewMsg) {
            if (msg.type === "ciphertext") {
              msg.once("change:type", (_msg) => window.onAddMessageEvent(window.WWebJS.getMessageModel(_msg)));
              window.onAddMessageCiphertextEvent(window.WWebJS.getMessageModel(msg));
            } else {
              window.onAddMessageEvent(window.WWebJS.getMessageModel(msg));
            }
          }
        });
        window.Store.Chat.on("change:unreadCount", (chat) => {
          window.onChatUnreadCountEvent(chat);
        });
        window.Store.PollVote.on("add", async (vote) => {
          const pollVoteModel = await window.WWebJS.getPollVoteModel(vote);
          pollVoteModel && window.onPollVoteEvent(pollVoteModel);
        });
        if (window.compareWwebVersions(window.Debug.VERSION, ">=", "2.3000.1014111620")) {
          const module2 = window.Store.AddonReactionTable;
          const ogMethod = module2.bulkUpsert;
          module2.bulkUpsert = ((...args) => {
            window.onReaction(args[0].map((reaction) => {
              const msgKey = reaction.id;
              const parentMsgKey = reaction.reactionParentKey;
              const timestamp = reaction.reactionTimestamp / 1000;
              const sender = reaction.author ?? reaction.from;
              const senderUserJid = sender._serialized;
              return { ...reaction, msgKey, parentMsgKey, senderUserJid, timestamp };
            }));
            return ogMethod(...args);
          }).bind(module2);
        } else {
          const module2 = window.Store.createOrUpdateReactionsModule;
          const ogMethod = module2.createOrUpdateReactions;
          module2.createOrUpdateReactions = ((...args) => {
            window.onReaction(args[0].map((reaction) => {
              const msgKey = window.Store.MsgKey.fromString(reaction.msgKey);
              const parentMsgKey = window.Store.MsgKey.fromString(reaction.parentMsgKey);
              const timestamp = reaction.timestamp / 1000;
              return { ...reaction, msgKey, parentMsgKey, timestamp };
            }));
            return ogMethod(...args);
          }).bind(module2);
        }
      });
    }
    async initWebVersionCache() {
      const { type: webCacheType, ...webCacheOptions } = this.options.webVersionCache;
      const webCache = WebCacheFactory.createWebCache(webCacheType, webCacheOptions);
      const requestedVersion = this.options.webVersion;
      const versionContent = await webCache.resolve(requestedVersion);
      if (versionContent) {
        await this.pupPage.setRequestInterception(true);
        this.pupPage.on("request", async (req) => {
          if (req.url() === WhatsWebURL) {
            req.respond({
              status: 200,
              contentType: "text/html",
              body: versionContent
            });
          } else {
            req.continue();
          }
        });
      } else {
        this.pupPage.on("response", async (res) => {
          if (res.ok() && res.url() === WhatsWebURL) {
            const indexHtml = await res.text();
            this.currentIndexHtml = indexHtml;
          }
        });
      }
    }
    async destroy() {
      await this.pupBrowser.close();
      await this.authStrategy.destroy();
    }
    async logout() {
      await this.pupPage.evaluate(() => {
        if (window.Store && window.Store.AppState && typeof window.Store.AppState.logout === "function") {
          return window.Store.AppState.logout();
        }
      });
      await this.pupBrowser.close();
      let maxDelay = 0;
      while (this.pupBrowser.isConnected() && maxDelay < 10) {
        await new Promise((resolve) => setTimeout(resolve, 100));
        maxDelay++;
      }
      await this.authStrategy.logout();
    }
    async getWWebVersion() {
      return await this.pupPage.evaluate(() => {
        return window.Debug.VERSION;
      });
    }
    async sendSeen(chatId) {
      return await this.pupPage.evaluate(async (chatId2) => {
        return window.WWebJS.sendSeen(chatId2);
      }, chatId);
    }
    async sendMessage(chatId, content, options = {}) {
      const isChannel = /@\w*newsletter\b/.test(chatId);
      if (isChannel && [
        options.sendMediaAsDocument,
        options.quotedMessageId,
        options.parseVCards,
        options.isViewOnce,
        content instanceof Location,
        content instanceof Contact,
        content instanceof Buttons,
        content instanceof List,
        Array.isArray(content) && content.length > 0 && content[0] instanceof Contact
      ].includes(true)) {
        console.warn(`The message type is currently not supported for sending in channels,
the supported message types are: text, image, sticker, gif, video, voice and poll.`);
        return null;
      }
      if (options.mentions) {
        !Array.isArray(options.mentions) && (options.mentions = [options.mentions]);
        if (options.mentions.some((possiblyContact) => possiblyContact instanceof Contact)) {
          console.warn("Mentions with an array of Contact are now deprecated. See more at https://github.com/pedroslopez/whatsapp-web.js/pull/2166.");
          options.mentions = options.mentions.map((a) => a.id._serialized);
        }
      }
      options.groupMentions && !Array.isArray(options.groupMentions) && (options.groupMentions = [options.groupMentions]);
      let internalOptions = {
        linkPreview: options.linkPreview === false ? undefined : true,
        sendAudioAsVoice: options.sendAudioAsVoice,
        sendVideoAsGif: options.sendVideoAsGif,
        sendMediaAsSticker: options.sendMediaAsSticker,
        sendMediaAsDocument: options.sendMediaAsDocument,
        caption: options.caption,
        quotedMessageId: options.quotedMessageId,
        parseVCards: options.parseVCards !== false,
        mentionedJidList: options.mentions || [],
        groupMentions: options.groupMentions,
        invokedBotWid: options.invokedBotWid,
        ignoreQuoteErrors: options.ignoreQuoteErrors !== false,
        extraOptions: options.extra
      };
      const sendSeen = options.sendSeen !== false;
      if (content instanceof MessageMedia) {
        internalOptions.media = content;
        internalOptions.isViewOnce = options.isViewOnce, content = "";
      } else if (options.media instanceof MessageMedia) {
        internalOptions.media = options.media;
        internalOptions.caption = content;
        internalOptions.isViewOnce = options.isViewOnce, content = "";
      } else if (content instanceof Location) {
        internalOptions.location = content;
        content = "";
      } else if (content instanceof Poll) {
        internalOptions.poll = content;
        content = "";
      } else if (content instanceof Contact) {
        internalOptions.contactCard = content.id._serialized;
        content = "";
      } else if (Array.isArray(content) && content.length > 0 && content[0] instanceof Contact) {
        internalOptions.contactCardList = content.map((contact) => contact.id._serialized);
        content = "";
      } else if (content instanceof Buttons) {
        console.warn("Buttons are now deprecated. See more at https://www.youtube.com/watch?v=hv1R1rLeVVE.");
        if (content.type !== "chat") {
          internalOptions.attachment = content.body;
        }
        internalOptions.buttons = content;
        content = "";
      } else if (content instanceof List) {
        console.warn("Lists are now deprecated. See more at https://www.youtube.com/watch?v=hv1R1rLeVVE.");
        internalOptions.list = content;
        content = "";
      }
      if (internalOptions.sendMediaAsSticker && internalOptions.media) {
        internalOptions.media = await Util.formatToWebpSticker(internalOptions.media, {
          name: options.stickerName,
          author: options.stickerAuthor,
          categories: options.stickerCategories
        }, this.pupPage);
      }
      const sentMsg = await this.pupPage.evaluate(async (chatId2, content2, options2, sendSeen2) => {
        const chat = await window.WWebJS.getChat(chatId2, { getAsModel: false });
        if (!chat)
          return null;
        if (sendSeen2) {
          await window.WWebJS.sendSeen(chatId2);
        }
        const msg = await window.WWebJS.sendMessage(chat, content2, options2);
        return msg ? window.WWebJS.getMessageModel(msg) : undefined;
      }, chatId, content, internalOptions, sendSeen);
      return sentMsg ? new Message(this, sentMsg) : undefined;
    }
    async sendChannelAdminInvite(chatId, channelId, options = {}) {
      const response = await this.pupPage.evaluate(async (chatId2, channelId2, options2) => {
        const channelWid = window.Store.WidFactory.createWid(channelId2);
        const chatWid = window.Store.WidFactory.createWid(chatId2);
        const chat = window.Store.Chat.get(chatWid) || await window.Store.Chat.find(chatWid);
        if (!chatWid.isUser()) {
          return false;
        }
        return await window.Store.SendChannelMessage.sendNewsletterAdminInviteMessage(chat, {
          newsletterWid: channelWid,
          invitee: chatWid,
          inviteMessage: options2.comment,
          base64Thumb: await window.WWebJS.getProfilePicThumbToBase64(channelWid)
        });
      }, chatId, channelId, options);
      return response.messageSendResult === "OK";
    }
    async searchMessages(query, options = {}) {
      const messages = await this.pupPage.evaluate(async (query2, page, count, remote) => {
        const { messages: messages2 } = await window.Store.Msg.search(query2, page, count, remote);
        return messages2.map((msg) => window.WWebJS.getMessageModel(msg));
      }, query, options.page, options.limit, options.chatId);
      return messages.map((msg) => new Message(this, msg));
    }
    async getChats() {
      const chats = await this.pupPage.evaluate(async () => {
        return await window.WWebJS.getChats();
      });
      return chats.map((chat) => ChatFactory.create(this, chat));
    }
    async getChannels() {
      const channels = await this.pupPage.evaluate(async () => {
        return await window.WWebJS.getChannels();
      });
      return channels.map((channel) => ChatFactory.create(this, channel));
    }
    async getChatById(chatId) {
      const chat = await this.pupPage.evaluate(async (chatId2) => {
        return await window.WWebJS.getChat(chatId2);
      }, chatId);
      return chat ? ChatFactory.create(this, chat) : undefined;
    }
    async getChannelByInviteCode(inviteCode) {
      const channel = await this.pupPage.evaluate(async (inviteCode2) => {
        let channelMetadata;
        try {
          channelMetadata = await window.WWebJS.getChannelMetadata(inviteCode2);
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return null;
          throw err;
        }
        return await window.WWebJS.getChat(channelMetadata.id);
      }, inviteCode);
      return channel ? ChatFactory.create(this, channel) : undefined;
    }
    async getContacts() {
      let contacts = await this.pupPage.evaluate(() => {
        return window.WWebJS.getContacts();
      });
      return contacts.map((contact) => ContactFactory.create(this, contact));
    }
    async getContactById(contactId) {
      let contact = await this.pupPage.evaluate((contactId2) => {
        return window.WWebJS.getContact(contactId2);
      }, contactId);
      return ContactFactory.create(this, contact);
    }
    async getMessageById(messageId) {
      const msg = await this.pupPage.evaluate(async (messageId2) => {
        let msg2 = window.Store.Msg.get(messageId2);
        if (msg2)
          return window.WWebJS.getMessageModel(msg2);
        const params = messageId2.split("_");
        if (params.length !== 3 && params.length !== 4)
          throw new Error("Invalid serialized message id specified");
        let messagesObject = await window.Store.Msg.getMessagesById([messageId2]);
        if (messagesObject && messagesObject.messages.length)
          msg2 = messagesObject.messages[0];
        if (msg2)
          return window.WWebJS.getMessageModel(msg2);
      }, messageId);
      if (msg)
        return new Message(this, msg);
      return null;
    }
    async getInviteInfo(inviteCode) {
      return await this.pupPage.evaluate((inviteCode2) => {
        return window.Store.GroupInvite.queryGroupInvite(inviteCode2);
      }, inviteCode);
    }
    async acceptInvite(inviteCode) {
      const res = await this.pupPage.evaluate(async (inviteCode2) => {
        return await window.Store.GroupInvite.joinGroupViaInvite(inviteCode2);
      }, inviteCode);
      return res.gid._serialized;
    }
    async acceptChannelAdminInvite(channelId) {
      return await this.pupPage.evaluate(async (channelId2) => {
        try {
          await window.Store.ChannelUtils.acceptNewsletterAdminInvite(channelId2);
          return true;
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return false;
          throw err;
        }
      }, channelId);
    }
    async revokeChannelAdminInvite(channelId, userId) {
      return await this.pupPage.evaluate(async (channelId2, userId2) => {
        try {
          const userWid = window.Store.WidFactory.createWid(userId2);
          await window.Store.ChannelUtils.revokeNewsletterAdminInvite(channelId2, userWid);
          return true;
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return false;
          throw err;
        }
      }, channelId, userId);
    }
    async demoteChannelAdmin(channelId, userId) {
      return await this.pupPage.evaluate(async (channelId2, userId2) => {
        try {
          const userWid = window.Store.WidFactory.createWid(userId2);
          await window.Store.ChannelUtils.demoteNewsletterAdmin(channelId2, userWid);
          return true;
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return false;
          throw err;
        }
      }, channelId, userId);
    }
    async acceptGroupV4Invite(inviteInfo) {
      if (!inviteInfo.inviteCode)
        throw "Invalid invite code, try passing the message.inviteV4 object";
      if (inviteInfo.inviteCodeExp == 0)
        throw "Expired invite code";
      return this.pupPage.evaluate(async (inviteInfo2) => {
        let { groupId, fromId, inviteCode, inviteCodeExp } = inviteInfo2;
        let userWid = window.Store.WidFactory.createWid(fromId);
        return await window.Store.GroupInviteV4.joinGroupViaInviteV4(inviteCode, String(inviteCodeExp), groupId, userWid);
      }, inviteInfo);
    }
    async setStatus(status) {
      await this.pupPage.evaluate(async (status2) => {
        return await window.Store.StatusUtils.setMyStatus(status2);
      }, status);
    }
    async setDisplayName(displayName) {
      const couldSet = await this.pupPage.evaluate(async (displayName2) => {
        if (!window.Store.Conn.canSetMyPushname())
          return false;
        await window.Store.Settings.setPushname(displayName2);
        return true;
      }, displayName);
      return couldSet;
    }
    async getState() {
      return await this.pupPage.evaluate(() => {
        if (!window.Store)
          return null;
        return window.Store.AppState.state;
      });
    }
    async sendPresenceAvailable() {
      return await this.pupPage.evaluate(() => {
        return window.Store.PresenceUtils.sendPresenceAvailable();
      });
    }
    async sendPresenceUnavailable() {
      return await this.pupPage.evaluate(() => {
        return window.Store.PresenceUtils.sendPresenceUnavailable();
      });
    }
    async archiveChat(chatId) {
      return await this.pupPage.evaluate(async (chatId2) => {
        let chat = await window.WWebJS.getChat(chatId2, { getAsModel: false });
        await window.Store.Cmd.archiveChat(chat, true);
        return true;
      }, chatId);
    }
    async unarchiveChat(chatId) {
      return await this.pupPage.evaluate(async (chatId2) => {
        let chat = await window.WWebJS.getChat(chatId2, { getAsModel: false });
        await window.Store.Cmd.archiveChat(chat, false);
        return false;
      }, chatId);
    }
    async pinChat(chatId) {
      return this.pupPage.evaluate(async (chatId2) => {
        let chat = await window.WWebJS.getChat(chatId2, { getAsModel: false });
        if (chat.pin) {
          return true;
        }
        const MAX_PIN_COUNT = 3;
        const chatModels = window.Store.Chat.getModelsArray();
        if (chatModels.length > MAX_PIN_COUNT) {
          let maxPinned = chatModels[MAX_PIN_COUNT - 1].pin;
          if (maxPinned) {
            return false;
          }
        }
        await window.Store.Cmd.pinChat(chat, true);
        return true;
      }, chatId);
    }
    async unpinChat(chatId) {
      return this.pupPage.evaluate(async (chatId2) => {
        let chat = await window.WWebJS.getChat(chatId2, { getAsModel: false });
        if (!chat.pin) {
          return false;
        }
        await window.Store.Cmd.pinChat(chat, false);
        return false;
      }, chatId);
    }
    async muteChat(chatId, unmuteDate) {
      unmuteDate = unmuteDate ? Math.floor(unmuteDate.getTime() / 1000) : -1;
      return this._muteUnmuteChat(chatId, "MUTE", unmuteDate);
    }
    async unmuteChat(chatId) {
      return this._muteUnmuteChat(chatId, "UNMUTE");
    }
    async _muteUnmuteChat(chatId, action, unmuteDateTs) {
      return this.pupPage.evaluate(async (chatId2, action2, unmuteDateTs2) => {
        const chat = window.Store.Chat.get(chatId2) ?? await window.Store.Chat.find(chatId2);
        action2 === "MUTE" ? await chat.mute.mute({ expiration: unmuteDateTs2, sendDevice: true }) : await chat.mute.unmute({ sendDevice: true });
        return { isMuted: chat.mute.expiration !== 0, muteExpiration: chat.mute.expiration };
      }, chatId, action, unmuteDateTs || -1);
    }
    async markChatUnread(chatId) {
      await this.pupPage.evaluate(async (chatId2) => {
        let chat = await window.WWebJS.getChat(chatId2, { getAsModel: false });
        await window.Store.Cmd.markChatUnread(chat, true);
      }, chatId);
    }
    async getProfilePicUrl(contactId) {
      const profilePic = await this.pupPage.evaluate(async (contactId2) => {
        try {
          const chatWid = window.Store.WidFactory.createWid(contactId2);
          return window.compareWwebVersions(window.Debug.VERSION, "<", "2.3000.0") ? await window.Store.ProfilePic.profilePicFind(chatWid) : await window.Store.ProfilePic.requestProfilePicFromServer(chatWid);
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return;
          throw err;
        }
      }, contactId);
      return profilePic ? profilePic.eurl : undefined;
    }
    async getCommonGroups(contactId) {
      const commonGroups = await this.pupPage.evaluate(async (contactId2) => {
        let contact = window.Store.Contact.get(contactId2);
        if (!contact) {
          const wid = window.Store.WidFactory.createUserWid(contactId2);
          const chatConstructor = window.Store.Contact.getModelsArray().find((c) => !c.isGroup).constructor;
          contact = new chatConstructor({ id: wid });
        }
        if (contact.commonGroups) {
          return contact.commonGroups.serialize();
        }
        const status = await window.Store.findCommonGroups(contact);
        if (status) {
          return contact.commonGroups.serialize();
        }
        return [];
      }, contactId);
      const chats = [];
      for (const group of commonGroups) {
        chats.push(group.id);
      }
      return chats;
    }
    async resetState() {
      await this.pupPage.evaluate(() => {
        window.Store.AppState.reconnect();
      });
    }
    async isRegisteredUser(id) {
      return Boolean(await this.getNumberId(id));
    }
    async getNumberId(number) {
      if (!number.endsWith("@c.us")) {
        number += "@c.us";
      }
      return await this.pupPage.evaluate(async (number2) => {
        const wid = window.Store.WidFactory.createWid(number2);
        const result = await window.Store.QueryExist(wid);
        if (!result || result.wid === undefined)
          return null;
        return result.wid;
      }, number);
    }
    async getFormattedNumber(number) {
      if (!number.endsWith("@s.whatsapp.net"))
        number = number.replace("c.us", "s.whatsapp.net");
      if (!number.includes("@s.whatsapp.net"))
        number = `${number}@s.whatsapp.net`;
      return await this.pupPage.evaluate(async (numberId) => {
        return window.Store.NumberInfo.formattedPhoneNumber(numberId);
      }, number);
    }
    async getCountryCode(number) {
      number = number.replace(" ", "").replace("+", "").replace("@c.us", "");
      return await this.pupPage.evaluate(async (numberId) => {
        return window.Store.NumberInfo.findCC(numberId);
      }, number);
    }
    async createGroup(title, participants = [], options = {}) {
      !Array.isArray(participants) && (participants = [participants]);
      participants.map((p) => p instanceof Contact ? p.id._serialized : p);
      return await this.pupPage.evaluate(async (title2, participants2, options2) => {
        const { messageTimer = 0, parentGroupId, autoSendInviteV4 = true, comment = "" } = options2;
        const participantData = {}, participantWids = [], failedParticipants = [];
        let createGroupResult, parentGroupWid;
        const addParticipantResultCodes = {
          default: "An unknown error occupied while adding a participant",
          200: "The participant was added successfully",
          403: "The participant can be added by sending private invitation only",
          404: "The phone number is not registered on WhatsApp"
        };
        for (const participant of participants2) {
          const pWid = window.Store.WidFactory.createWid(participant);
          if ((await window.Store.QueryExist(pWid))?.wid)
            participantWids.push(pWid);
          else
            failedParticipants.push(participant);
        }
        parentGroupId && (parentGroupWid = window.Store.WidFactory.createWid(parentGroupId));
        try {
          createGroupResult = await window.Store.GroupUtils.createGroup({
            memberAddMode: options2.memberAddMode === undefined ? true : options2.memberAddMode,
            membershipApprovalMode: options2.membershipApprovalMode === undefined ? false : options2.membershipApprovalMode,
            announce: options2.announce === undefined ? true : options2.announce,
            ephemeralDuration: messageTimer,
            full: undefined,
            parentGroupId: parentGroupWid,
            restrict: options2.restrict === undefined ? true : options2.restrict,
            thumb: undefined,
            title: title2
          }, participantWids);
        } catch (err) {
          return "CreateGroupError: An unknown error occupied while creating a group";
        }
        for (const participant of createGroupResult.participants) {
          let isInviteV4Sent = false;
          const participantId = participant.wid._serialized;
          const statusCode = participant.error || 200;
          if (autoSendInviteV4 && statusCode === 403) {
            window.Store.Contact.gadd(participant.wid, { silent: true });
            const addParticipantResult = await window.Store.GroupInviteV4.sendGroupInviteMessage(await window.Store.Chat.find(participant.wid), createGroupResult.wid._serialized, createGroupResult.subject, participant.invite_code, participant.invite_code_exp, comment, await window.WWebJS.getProfilePicThumbToBase64(createGroupResult.wid));
            isInviteV4Sent = window.compareWwebVersions(window.Debug.VERSION, "<", "2.2335.6") ? addParticipantResult === "OK" : addParticipantResult.messageSendResult === "OK";
          }
          participantData[participantId] = {
            statusCode,
            message: addParticipantResultCodes[statusCode] || addParticipantResultCodes.default,
            isGroupCreator: participant.type === "superadmin",
            isInviteV4Sent
          };
        }
        for (const f of failedParticipants) {
          participantData[f] = {
            statusCode: 404,
            message: addParticipantResultCodes[404],
            isGroupCreator: false,
            isInviteV4Sent: false
          };
        }
        return { title: title2, gid: createGroupResult.wid, participants: participantData };
      }, title, participants, options);
    }
    async createChannel(title, options = {}) {
      return await this.pupPage.evaluate(async (title2, options2) => {
        let response, { description = null, picture = null } = options2;
        if (!window.Store.ChannelUtils.isNewsletterCreationEnabled()) {
          return "CreateChannelError: A channel creation is not enabled";
        }
        if (picture) {
          picture = await window.WWebJS.cropAndResizeImage(picture, {
            asDataUrl: true,
            mimetype: "image/jpeg",
            size: 640,
            quality: 1
          });
        }
        try {
          response = await window.Store.ChannelUtils.createNewsletterQuery({
            name: title2,
            description,
            picture
          });
        } catch (err) {
          if (err.name === "ServerStatusCodeError") {
            return "CreateChannelError: An error occupied while creating a channel";
          }
          throw err;
        }
        return {
          title: title2,
          nid: window.Store.JidToWid.newsletterJidToWid(response.idJid),
          inviteLink: `https://whatsapp.com/channel/${response.newsletterInviteLinkMetadataMixin.inviteCode}`,
          createdAtTs: response.newsletterCreationTimeMetadataMixin.creationTimeValue
        };
      }, title, options);
    }
    async subscribeToChannel(channelId) {
      return await this.pupPage.evaluate(async (channelId2) => {
        return await window.WWebJS.subscribeToUnsubscribeFromChannel(channelId2, "Subscribe");
      }, channelId);
    }
    async unsubscribeFromChannel(channelId, options) {
      return await this.pupPage.evaluate(async (channelId2, options2) => {
        return await window.WWebJS.subscribeToUnsubscribeFromChannel(channelId2, "Unsubscribe", options2);
      }, channelId, options);
    }
    async transferChannelOwnership(channelId, newOwnerId, options = {}) {
      return await this.pupPage.evaluate(async (channelId2, newOwnerId2, options2) => {
        const channel = await window.WWebJS.getChat(channelId2, { getAsModel: false });
        const newOwner = window.Store.Contact.get(newOwnerId2) || await window.Store.Contact.find(newOwnerId2);
        if (!channel.newsletterMetadata) {
          await window.Store.NewsletterMetadataCollection.update(channel.id);
        }
        try {
          await window.Store.ChannelUtils.changeNewsletterOwnerAction(channel, newOwner);
          if (options2.shouldDismissSelfAsAdmin) {
            const meContact = window.Store.ContactCollection.getMeContact();
            meContact && await window.Store.ChannelUtils.demoteNewsletterAdminAction(channel, meContact);
          }
        } catch (error) {
          return false;
        }
        return true;
      }, channelId, newOwnerId, options);
    }
    async searchChannels(searchOptions = {}) {
      return await this.pupPage.evaluate(async ({
        searchText = "",
        countryCodes = [window.Store.ChannelUtils.currentRegion],
        skipSubscribedNewsletters = false,
        view = 0,
        limit = 50
      }) => {
        searchText = searchText.trim();
        const currentRegion = window.Store.ChannelUtils.currentRegion;
        if (![0, 1, 2, 3].includes(view))
          view = 0;
        countryCodes = countryCodes.length === 1 && countryCodes[0] === currentRegion ? countryCodes : countryCodes.filter((code) => Object.keys(window.Store.ChannelUtils.countryCodesIso).includes(code));
        const viewTypeMapping = {
          0: "RECOMMENDED",
          1: "TRENDING",
          2: "POPULAR",
          3: "NEW"
        };
        searchOptions = {
          searchText,
          countryCodes,
          skipSubscribedNewsletters,
          view: viewTypeMapping[view],
          categories: [],
          cursorToken: ""
        };
        const originalFunction = window.Store.ChannelUtils.getNewsletterDirectoryPageSize;
        limit !== 50 && (window.Store.ChannelUtils.getNewsletterDirectoryPageSize = () => limit);
        const channels = (await window.Store.ChannelUtils.fetchNewsletterDirectories(searchOptions)).newsletters;
        limit !== 50 && (window.Store.ChannelUtils.getNewsletterDirectoryPageSize = originalFunction);
        return channels ? await Promise.all(channels.map((channel) => window.WWebJS.getChatModel(channel, { isChannel: true }))) : [];
      }, searchOptions);
    }
    async deleteChannel(channelId) {
      return await this.client.pupPage.evaluate(async (channelId2) => {
        const channel = await window.WWebJS.getChat(channelId2, { getAsModel: false });
        if (!channel)
          return false;
        try {
          await window.Store.ChannelUtils.deleteNewsletterAction(channel);
          return true;
        } catch (err) {
          if (err.name === "ServerStatusCodeError")
            return false;
          throw err;
        }
      }, channelId);
    }
    async getLabels() {
      const labels = await this.pupPage.evaluate(async () => {
        return window.WWebJS.getLabels();
      });
      return labels.map((data) => new Label(this, data));
    }
    async getBroadcasts() {
      const broadcasts = await this.pupPage.evaluate(async () => {
        return window.WWebJS.getAllStatuses();
      });
      return broadcasts.map((data) => new Broadcast(this, data));
    }
    async getLabelById(labelId) {
      const label = await this.pupPage.evaluate(async (labelId2) => {
        return window.WWebJS.getLabel(labelId2);
      }, labelId);
      return new Label(this, label);
    }
    async getChatLabels(chatId) {
      const labels = await this.pupPage.evaluate(async (chatId2) => {
        return window.WWebJS.getChatLabels(chatId2);
      }, chatId);
      return labels.map((data) => new Label(this, data));
    }
    async getChatsByLabelId(labelId) {
      const chatIds = await this.pupPage.evaluate(async (labelId2) => {
        const label = window.Store.Label.get(labelId2);
        const labelItems = label.labelItemCollection.getModelsArray();
        return labelItems.reduce((result, item) => {
          if (item.parentType === "Chat") {
            result.push(item.parentId);
          }
          return result;
        }, []);
      }, labelId);
      return Promise.all(chatIds.map((id) => this.getChatById(id)));
    }
    async getBlockedContacts() {
      const blockedContacts = await this.pupPage.evaluate(() => {
        let chatIds = window.Store.Blocklist.getModelsArray().map((a) => a.id._serialized);
        return Promise.all(chatIds.map((id) => window.WWebJS.getContact(id)));
      });
      return blockedContacts.map((contact) => ContactFactory.create(this.client, contact));
    }
    async setProfilePicture(media) {
      const success = await this.pupPage.evaluate((chatid, media2) => {
        return window.WWebJS.setPicture(chatid, media2);
      }, this.info.wid._serialized, media);
      return success;
    }
    async deleteProfilePicture() {
      const success = await this.pupPage.evaluate((chatid) => {
        return window.WWebJS.deletePicture(chatid);
      }, this.info.wid._serialized);
      return success;
    }
    async addOrRemoveLabels(labelIds, chatIds) {
      return this.pupPage.evaluate(async (labelIds2, chatIds2) => {
        if (["smba", "smbi"].indexOf(window.Store.Conn.platform) === -1) {
          throw "[LT01] Only Whatsapp business";
        }
        const labels = window.WWebJS.getLabels().filter((e) => labelIds2.find((l2) => l2 == e.id) !== undefined);
        const chats = window.Store.Chat.filter((e) => chatIds2.includes(e.id._serialized));
        let actions = labels.map((label) => ({ id: label.id, type: "add" }));
        chats.forEach((chat) => {
          (chat.labels || []).forEach((n) => {
            if (!actions.find((e) => e.id == n)) {
              actions.push({ id: n, type: "remove" });
            }
          });
        });
        return await window.Store.Label.addOrRemoveLabels(actions, chats);
      }, labelIds, chatIds);
    }
    async getGroupMembershipRequests(groupId) {
      return await this.pupPage.evaluate(async (groupId2) => {
        const groupWid = window.Store.WidFactory.createWid(groupId2);
        return await window.Store.MembershipRequestUtils.getMembershipApprovalRequests(groupWid);
      }, groupId);
    }
    async approveGroupMembershipRequests(groupId, options = {}) {
      return await this.pupPage.evaluate(async (groupId2, options2) => {
        const { requesterIds = null, sleep = [250, 500] } = options2;
        return await window.WWebJS.membershipRequestAction(groupId2, "Approve", requesterIds, sleep);
      }, groupId, options);
    }
    async rejectGroupMembershipRequests(groupId, options = {}) {
      return await this.pupPage.evaluate(async (groupId2, options2) => {
        const { requesterIds = null, sleep = [250, 500] } = options2;
        return await window.WWebJS.membershipRequestAction(groupId2, "Reject", requesterIds, sleep);
      }, groupId, options);
    }
    async setAutoDownloadAudio(flag) {
      await this.pupPage.evaluate(async (flag2) => {
        const autoDownload = window.Store.Settings.getAutoDownloadAudio();
        if (autoDownload === flag2) {
          return flag2;
        }
        await window.Store.Settings.setAutoDownloadAudio(flag2);
        return flag2;
      }, flag);
    }
    async setAutoDownloadDocuments(flag) {
      await this.pupPage.evaluate(async (flag2) => {
        const autoDownload = window.Store.Settings.getAutoDownloadDocuments();
        if (autoDownload === flag2) {
          return flag2;
        }
        await window.Store.Settings.setAutoDownloadDocuments(flag2);
        return flag2;
      }, flag);
    }
    async setAutoDownloadPhotos(flag) {
      await this.pupPage.evaluate(async (flag2) => {
        const autoDownload = window.Store.Settings.getAutoDownloadPhotos();
        if (autoDownload === flag2) {
          return flag2;
        }
        await window.Store.Settings.setAutoDownloadPhotos(flag2);
        return flag2;
      }, flag);
    }
    async setAutoDownloadVideos(flag) {
      await this.pupPage.evaluate(async (flag2) => {
        const autoDownload = window.Store.Settings.getAutoDownloadVideos();
        if (autoDownload === flag2) {
          return flag2;
        }
        await window.Store.Settings.setAutoDownloadVideos(flag2);
        return flag2;
      }, flag);
    }
    async setBackgroundSync(flag) {
      return await this.pupPage.evaluate(async (flag2) => {
        const backSync = window.Store.Settings.getGlobalOfflineNotifications();
        if (backSync === flag2) {
          return flag2;
        }
        await window.Store.Settings.setGlobalOfflineNotifications(flag2);
        return flag2;
      }, flag);
    }
    async getContactDeviceCount(userId) {
      return await this.pupPage.evaluate(async (userId2) => {
        const devices = await window.Store.DeviceList.getDeviceIds([window.Store.WidFactory.createWid(userId2)]);
        if (devices && devices.length && devices[0] != null && typeof devices[0].devices == "object") {
          return devices[0].devices.length;
        }
        return 0;
      }, userId);
    }
    async syncHistory(chatId) {
      return await this.pupPage.evaluate(async (chatId2) => {
        const chatWid = window.Store.WidFactory.createWid(chatId2);
        const chat = window.Store.Chat.get(chatWid) ?? await window.Store.Chat.find(chatWid);
        if (chat?.endOfHistoryTransferType === 0) {
          await window.Store.HistorySync.sendPeerDataOperationRequest(3, {
            chatId: chat.id
          });
          return true;
        }
        return false;
      }, chatId);
    }
    async saveOrEditAddressbookContact(phoneNumber, firstName, lastName, syncToAddressbook = false) {
      return await this.pupPage.evaluate(async (phoneNumber2, firstName2, lastName2, syncToAddressbook2) => {
        return await window.Store.AddressbookContactUtils.saveContactAction(phoneNumber2, null, firstName2, lastName2, syncToAddressbook2);
      }, phoneNumber, firstName, lastName, syncToAddressbook);
    }
    async deleteAddressbookContact(phoneNumber) {
      return await this.pupPage.evaluate(async (phoneNumber2) => {
        return await window.Store.AddressbookContactUtils.deleteContactAction(phoneNumber2);
      }, phoneNumber);
    }
  }
  module.exports = Client;
});

// node_modules/whatsapp-web.js/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "whatsapp-web.js",
    version: "1.30.0",
    description: "Library for interacting with the WhatsApp Web API ",
    main: "./index.js",
    typings: "./index.d.ts",
    scripts: {
      test: "mocha tests --recursive --timeout 5000",
      "test-single": "mocha",
      shell: "node --experimental-repl-await ./shell.js",
      "generate-docs": "npx jsdoc --configure .jsdoc.json --verbose"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/pedroslopez/whatsapp-web.js.git"
    },
    keywords: [
      "whatsapp",
      "whatsapp-web",
      "api",
      "bot",
      "client",
      "node"
    ],
    author: "Pedro Lopez",
    license: "Apache-2.0",
    bugs: {
      url: "https://github.com/pedroslopez/whatsapp-web.js/issues"
    },
    homepage: "https://wwebjs.dev/",
    dependencies: {
      "@pedroslopez/moduleraid": "^5.0.2",
      "fluent-ffmpeg": "2.1.2",
      mime: "^3.0.0",
      "node-fetch": "^2.6.9",
      "node-webpmux": "3.1.7",
      puppeteer: "^18.2.1"
    },
    devDependencies: {
      "@types/node-fetch": "^2.5.12",
      chai: "^4.3.4",
      "chai-as-promised": "^7.1.1",
      dotenv: "^16.0.0",
      eslint: "^8.4.1",
      "eslint-plugin-mocha": "^10.0.3",
      jsdoc: "^3.6.4",
      "jsdoc-baseline": "^0.1.5",
      mocha: "^9.0.2",
      sinon: "^13.0.1"
    },
    engines: {
      node: ">=18.0.0"
    },
    optionalDependencies: {
      archiver: "^5.3.1",
      "fs-extra": "^10.1.0",
      unzipper: "^0.10.11"
    }
  };
});

// node_modules/whatsapp-web.js/src/authStrategies/LocalAuth.js
var require_LocalAuth = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var BaseAuthStrategy = require_BaseAuthStrategy();

  class LocalAuth extends BaseAuthStrategy {
    constructor({ clientId, dataPath, rmMaxRetries } = {}) {
      super();
      const idRegex = /^[-_\w]+$/i;
      if (clientId && !idRegex.test(clientId)) {
        throw new Error("Invalid clientId. Only alphanumeric characters, underscores and hyphens are allowed.");
      }
      this.dataPath = path.resolve(dataPath || "./.wwebjs_auth/");
      this.clientId = clientId;
      this.rmMaxRetries = rmMaxRetries ?? 4;
    }
    async beforeBrowserInitialized() {
      const puppeteerOpts = this.client.options.puppeteer;
      const sessionDirName = this.clientId ? `session-${this.clientId}` : "session";
      const dirPath = path.join(this.dataPath, sessionDirName);
      if (puppeteerOpts.userDataDir && puppeteerOpts.userDataDir !== dirPath) {
        throw new Error("LocalAuth is not compatible with a user-supplied userDataDir.");
      }
      fs.mkdirSync(dirPath, { recursive: true });
      this.client.options.puppeteer = {
        ...puppeteerOpts,
        userDataDir: dirPath
      };
      this.userDataDir = dirPath;
    }
    async logout() {
      if (this.userDataDir) {
        await fs.promises.rm(this.userDataDir, { recursive: true, force: true, maxRetries: this.rmMaxRetries }).catch((e) => {
          throw new Error(e);
        });
      }
    }
  }
  module.exports = LocalAuth;
});

// node_modules/universalify/index.js
var require_universalify = __commonJS((exports) => {
  exports.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function")
        fn.apply(this, args);
      else {
        return new Promise((resolve, reject) => {
          args.push((err, res) => err != null ? reject(err) : resolve(res));
          fn.apply(this, args);
        });
      }
    }, "name", { value: fn.name });
  };
  exports.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, args);
      else {
        args.pop();
        fn.apply(this, args).then((r) => cb(null, r), cb);
      }
    }, "name", { value: fn.name });
  };
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports, module) => {
  var constants = __require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {}
  if (typeof process.chdir === "function") {
    chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module.exports = patch;
  function patch(fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs);
    }
    if (!fs.lutimes) {
      patchLutimes(fs);
    }
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    if (fs.chmod && !fs.lchmod) {
      fs.lchmod = function(path, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchmodSync = function() {};
    }
    if (fs.chown && !fs.lchown) {
      fs.lchown = function(path, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchownSync = function() {};
    }
    if (platform === "win32") {
      fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
              setTimeout(function() {
                fs.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs.rename);
    }
    fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _2, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs.readSync);
    function patchLchmod(fs2) {
      fs2.lchmod = function(path, mode, callback) {
        fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs2.fchmod(fd, mode, function(err2) {
            fs2.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs2.lchmodSync = function(path, mode) {
        var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs2.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs2.closeSync(fd);
            } catch (er) {}
          } else {
            fs2.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
        fs2.lutimes = function(path, at, mt, cb) {
          fs2.open(path, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs2.futimes(fd, at, mt, function(er2) {
              fs2.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs2.lutimesSync = function(path, at, mt) {
          var fd = fs2.openSync(path, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs2.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {}
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs2.futimes) {
        fs2.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lutimesSync = function() {};
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  module.exports = legacy;
  function legacy(fs) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path, options);
      Stream.call(this);
      var self2 = this;
      this.path = path;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key2 = keys[index];
        this[key2] = options[key2];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === undefined) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path, options);
      Stream.call(this);
      this.path = path;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key2 = keys[index];
        this[key2] = options[key2];
      }
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
        this.flush();
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports, module) => {
  module.exports = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj2) {
    return obj2.__proto__;
  };
  function clone(obj2) {
    if (obj2 === null || typeof obj2 !== "object")
      return obj2;
    if (obj2 instanceof Object)
      var copy = { __proto__: getPrototypeOf(obj2) };
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj2).forEach(function(key2) {
      Object.defineProperty(copy, key2, Object.getOwnPropertyDescriptor(obj2, key2));
    });
    return copy;
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports, module) => {
  var fs = __require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone = require_clone();
  var util = __require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {}
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug = noop;
  if (util.debuglog)
    debug = util.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m2 = util.format.apply(util, arguments);
      m2 = "GFS4: " + m2.split(/\n/).join(`
GFS4: `);
      console.error(m2);
    };
  if (!fs[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs, queue);
    fs.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs[gracefulQueue]);
        __require("assert").equal(fs[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs[gracefulQueue]);
  }
  module.exports = patch(clone(fs));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
  }
  function patch(fs2) {
    polyfills(fs2);
    fs2.gracefulify = patch;
    fs2.createReadStream = createReadStream;
    fs2.createWriteStream = createWriteStream;
    var fs$readFile = fs2.readFile;
    fs2.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path2, options2, cb2, startTime) {
        return fs$readFile(path2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs2.writeFile;
    fs2.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path2, data2, options2, cb2, startTime) {
        return fs$writeFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs2.appendFile;
    if (fs$appendFile)
      fs2.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path2, data2, options2, cb2, startTime) {
        return fs$appendFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs2.copyFile;
    if (fs$copyFile)
      fs2.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src, dest, flags, cb);
      function go$copyFile(src2, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src2, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs2.readdir;
    fs2.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
      } : function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path2, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path2, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs2);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs2.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs2.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs2, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs2, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs2, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs2, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path, options) {
      return new fs2.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
      return new fs2.WriteStream(path, options);
    }
    var fs$open = fs2.open;
    fs2.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path2, flags2, mode2, cb2, startTime) {
        return fs$open(path2, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs2;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
  }
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0;i < fs[gracefulQueue].length; ++i) {
      if (fs[gracefulQueue][i].length > 2) {
        fs[gracefulQueue][i][3] = now;
        fs[gracefulQueue][i][4] = now;
      }
    }
    retry();
  }
  function retry() {
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0)
      return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === undefined) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === undefined) {
      retryTimer = setTimeout(retry, 0);
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs2 = __commonJS((exports) => {
  var u = require_universalify().fromCallback;
  var fs = require_graceful_fs();
  var api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key2) => {
    return typeof fs[key2] === "function";
  });
  Object.assign(exports, fs);
  api.forEach((method) => {
    exports[method] = u(fs[method]);
  });
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs.exists(filename, callback);
    }
    return new Promise((resolve) => {
      return fs.exists(filename, resolve);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve, reject) => {
      fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs.write(fd, buffer, ...args);
    }
    return new Promise((resolve, reject) => {
      fs.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  if (typeof fs.writev === "function") {
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
  }
  if (typeof fs.realpath.native === "function") {
    exports.realpath.native = u(fs.realpath.native);
  } else {
    process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?", "Warning", "fs-extra-WARN0003");
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var path = __require("path");
  exports.checkPath = function checkPath(pth) {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS((exports, module) => {
  var fs = require_fs2();
  var { checkPath } = require_utils2();
  var getMode = (options) => {
    const defaults = { mode: 511 };
    if (typeof options === "number")
      return options;
    return { ...defaults, ...options }.mode;
  };
  exports.makeDir = async (dir, options) => {
    checkPath(dir);
    return fs.mkdir(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  exports.makeDirSync = (dir, options) => {
    checkPath(dir);
    return fs.mkdirSync(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var { makeDir: _makeDir, makeDirSync } = require_make_dir();
  var makeDir = u(_makeDir);
  module.exports = {
    mkdirs: makeDir,
    mkdirsSync: makeDirSync,
    mkdirp: makeDir,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir,
    ensureDirSync: makeDirSync
  };
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var fs = require_fs2();
  function pathExists(path) {
    return fs.access(path).then(() => true).catch(() => false);
  }
  module.exports = {
    pathExists: u(pathExists),
    pathExistsSync: fs.existsSync
  };
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  function utimesMillis(path, atime, mtime, callback) {
    fs.open(path, "r+", (err, fd) => {
      if (err)
        return callback(err);
      fs.futimes(fd, atime, mtime, (futimesErr) => {
        fs.close(fd, (closeErr) => {
          if (callback)
            callback(futimesErr || closeErr);
        });
      });
    });
  }
  function utimesMillisSync(path, atime, mtime) {
    const fd = fs.openSync(path, "r+");
    fs.futimesSync(fd, atime, mtime);
    return fs.closeSync(fd);
  }
  module.exports = {
    utimesMillis,
    utimesMillisSync
  };
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS((exports, module) => {
  var fs = require_fs2();
  var path = __require("path");
  var util = __require("util");
  function getStats(src, dest, opts) {
    const statFunc = opts.dereference ? (file) => fs.stat(file, { bigint: true }) : (file) => fs.lstat(file, { bigint: true });
    return Promise.all([
      statFunc(src),
      statFunc(dest).catch((err) => {
        if (err.code === "ENOENT")
          return null;
        throw err;
      })
    ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
  }
  function getStatsSync(src, dest, opts) {
    let destStat;
    const statFunc = opts.dereference ? (file) => fs.statSync(file, { bigint: true }) : (file) => fs.lstatSync(file, { bigint: true });
    const srcStat = statFunc(src);
    try {
      destStat = statFunc(dest);
    } catch (err) {
      if (err.code === "ENOENT")
        return { srcStat, destStat: null };
      throw err;
    }
    return { srcStat, destStat };
  }
  function checkPaths(src, dest, funcName, opts, cb) {
    util.callbackify(getStats)(src, dest, opts, (err, stats) => {
      if (err)
        return cb(err);
      const { srcStat, destStat } = stats;
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path.basename(src);
          const destBaseName = path.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return cb(null, { srcStat, destStat, isChangingCase: true });
          }
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        return cb(new Error(errMsg(src, dest, funcName)));
      }
      return cb(null, { srcStat, destStat });
    });
  }
  function checkPathsSync(src, dest, funcName, opts) {
    const { srcStat, destStat } = getStatsSync(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return { srcStat, destStat };
  }
  function checkParentPaths(src, srcStat, dest, funcName, cb) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root)
      return cb();
    fs.stat(destParent, { bigint: true }, (err, destStat) => {
      if (err) {
        if (err.code === "ENOENT")
          return cb();
        return cb(err);
      }
      if (areIdentical(srcStat, destStat)) {
        return cb(new Error(errMsg(src, dest, funcName)));
      }
      return checkParentPaths(src, srcStat, destParent, funcName, cb);
    });
  }
  function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = fs.statSync(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  }
  function areIdentical(srcStat, destStat) {
    return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
  }
  function isSrcSubdir(src, dest) {
    const srcArr = path.resolve(src).split(path.sep).filter((i) => i);
    const destArr = path.resolve(dest).split(path.sep).filter((i) => i);
    return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
  }
  function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  }
  module.exports = {
    checkPaths,
    checkPathsSync,
    checkParentPaths,
    checkParentPathsSync,
    isSrcSubdir,
    areIdentical
  };
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var mkdirs = require_mkdirs().mkdirs;
  var pathExists = require_path_exists().pathExists;
  var utimesMillis = require_utimes().utimesMillis;
  var stat = require_stat();
  function copy(src, dest, opts, cb) {
    if (typeof opts === "function" && !cb) {
      cb = opts;
      opts = {};
    } else if (typeof opts === "function") {
      opts = { filter: opts };
    }
    cb = cb || function() {};
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning(`Using the preserveTimestamps option in 32-bit node is not recommended;

` + "\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0001");
    }
    stat.checkPaths(src, dest, "copy", opts, (err, stats) => {
      if (err)
        return cb(err);
      const { srcStat, destStat } = stats;
      stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
        if (err2)
          return cb(err2);
        if (opts.filter)
          return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
        return checkParentDir(destStat, src, dest, opts, cb);
      });
    });
  }
  function checkParentDir(destStat, src, dest, opts, cb) {
    const destParent = path.dirname(dest);
    pathExists(destParent, (err, dirExists) => {
      if (err)
        return cb(err);
      if (dirExists)
        return getStats(destStat, src, dest, opts, cb);
      mkdirs(destParent, (err2) => {
        if (err2)
          return cb(err2);
        return getStats(destStat, src, dest, opts, cb);
      });
    });
  }
  function handleFilter(onInclude, destStat, src, dest, opts, cb) {
    Promise.resolve(opts.filter(src, dest)).then((include) => {
      if (include)
        return onInclude(destStat, src, dest, opts, cb);
      return cb();
    }, (error) => cb(error));
  }
  function startCopy(destStat, src, dest, opts, cb) {
    if (opts.filter)
      return handleFilter(getStats, destStat, src, dest, opts, cb);
    return getStats(destStat, src, dest, opts, cb);
  }
  function getStats(destStat, src, dest, opts, cb) {
    const stat2 = opts.dereference ? fs.stat : fs.lstat;
    stat2(src, (err, srcStat) => {
      if (err)
        return cb(err);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts, cb);
      else if (srcStat.isSocket())
        return cb(new Error(`Cannot copy a socket file: ${src}`));
      else if (srcStat.isFIFO())
        return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
      return cb(new Error(`Unknown file: ${src}`));
    });
  }
  function onFile(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts, cb);
    return mayCopyFile(srcStat, src, dest, opts, cb);
  }
  function mayCopyFile(srcStat, src, dest, opts, cb) {
    if (opts.overwrite) {
      fs.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return copyFile(srcStat, src, dest, opts, cb);
      });
    } else if (opts.errorOnExist) {
      return cb(new Error(`'${dest}' already exists`));
    } else
      return cb();
  }
  function copyFile(srcStat, src, dest, opts, cb) {
    fs.copyFile(src, dest, (err) => {
      if (err)
        return cb(err);
      if (opts.preserveTimestamps)
        return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
      return setDestMode(dest, srcStat.mode, cb);
    });
  }
  function handleTimestampsAndMode(srcMode, src, dest, cb) {
    if (fileIsNotWritable(srcMode)) {
      return makeFileWritable(dest, srcMode, (err) => {
        if (err)
          return cb(err);
        return setDestTimestampsAndMode(srcMode, src, dest, cb);
      });
    }
    return setDestTimestampsAndMode(srcMode, src, dest, cb);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode, cb) {
    return setDestMode(dest, srcMode | 128, cb);
  }
  function setDestTimestampsAndMode(srcMode, src, dest, cb) {
    setDestTimestamps(src, dest, (err) => {
      if (err)
        return cb(err);
      return setDestMode(dest, srcMode, cb);
    });
  }
  function setDestMode(dest, srcMode, cb) {
    return fs.chmod(dest, srcMode, cb);
  }
  function setDestTimestamps(src, dest, cb) {
    fs.stat(src, (err, updatedSrcStat) => {
      if (err)
        return cb(err);
      return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
    });
  }
  function onDir(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
    return copyDir(src, dest, opts, cb);
  }
  function mkDirAndCopy(srcMode, src, dest, opts, cb) {
    fs.mkdir(dest, (err) => {
      if (err)
        return cb(err);
      copyDir(src, dest, opts, (err2) => {
        if (err2)
          return cb(err2);
        return setDestMode(dest, srcMode, cb);
      });
    });
  }
  function copyDir(src, dest, opts, cb) {
    fs.readdir(src, (err, items) => {
      if (err)
        return cb(err);
      return copyDirItems(items, src, dest, opts, cb);
    });
  }
  function copyDirItems(items, src, dest, opts, cb) {
    const item = items.pop();
    if (!item)
      return cb();
    return copyDirItem(items, item, src, dest, opts, cb);
  }
  function copyDirItem(items, item, src, dest, opts, cb) {
    const srcItem = path.join(src, item);
    const destItem = path.join(dest, item);
    stat.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
      if (err)
        return cb(err);
      const { destStat } = stats;
      startCopy(destStat, srcItem, destItem, opts, (err2) => {
        if (err2)
          return cb(err2);
        return copyDirItems(items, src, dest, opts, cb);
      });
    });
  }
  function onLink(destStat, src, dest, opts, cb) {
    fs.readlink(src, (err, resolvedSrc) => {
      if (err)
        return cb(err);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs.symlink(resolvedSrc, dest, cb);
      } else {
        fs.readlink(dest, (err2, resolvedDest) => {
          if (err2) {
            if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
              return fs.symlink(resolvedSrc, dest, cb);
            return cb(err2);
          }
          if (opts.dereference) {
            resolvedDest = path.resolve(process.cwd(), resolvedDest);
          }
          if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
            return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
          }
          if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
            return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
          }
          return copyLink(resolvedSrc, dest, cb);
        });
      }
    });
  }
  function copyLink(resolvedSrc, dest, cb) {
    fs.unlink(dest, (err) => {
      if (err)
        return cb(err);
      return fs.symlink(resolvedSrc, dest, cb);
    });
  }
  module.exports = copy;
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var mkdirsSync = require_mkdirs().mkdirsSync;
  var utimesMillisSync = require_utimes().utimesMillisSync;
  var stat = require_stat();
  function copySync(src, dest, opts) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning(`Using the preserveTimestamps option in 32-bit node is not recommended;

` + "\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0002");
    }
    const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "copy");
    return handleFilterAndCopy(destStat, src, dest, opts);
  }
  function handleFilterAndCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest))
      return;
    const destParent = path.dirname(dest);
    if (!fs.existsSync(destParent))
      mkdirsSync(destParent);
    return getStats(destStat, src, dest, opts);
  }
  function startCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest))
      return;
    return getStats(destStat, src, dest, opts);
  }
  function getStats(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
    else if (srcStat.isSocket())
      throw new Error(`Cannot copy a socket file: ${src}`);
    else if (srcStat.isFIFO())
      throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
  }
  function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs.unlinkSync(dest);
      return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src, dest, opts) {
    fs.copyFileSync(src, dest);
    if (opts.preserveTimestamps)
      handleTimestamps(srcStat.mode, src, dest);
    return setDestMode(dest, srcStat.mode);
  }
  function handleTimestamps(srcMode, src, dest) {
    if (fileIsNotWritable(srcMode))
      makeFileWritable(dest, srcMode);
    return setDestTimestamps(src, dest);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return setDestMode(dest, srcMode | 128);
  }
  function setDestMode(dest, srcMode) {
    return fs.chmodSync(dest, srcMode);
  }
  function setDestTimestamps(src, dest) {
    const updatedSrcStat = fs.statSync(src);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts);
    return copyDir(src, dest, opts);
  }
  function mkDirAndCopy(srcMode, src, dest, opts) {
    fs.mkdirSync(dest);
    copyDir(src, dest, opts);
    return setDestMode(dest, srcMode);
  }
  function copyDir(src, dest, opts) {
    fs.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
  }
  function copyDirItem(item, src, dest, opts) {
    const srcItem = path.join(src, item);
    const destItem = path.join(dest, item);
    const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
    return startCopy(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src, dest, opts) {
    let resolvedSrc = fs.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN")
          return fs.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs.unlinkSync(dest);
    return fs.symlinkSync(resolvedSrc, dest);
  }
  module.exports = copySync;
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS((exports, module) => {
  var u = require_universalify().fromCallback;
  module.exports = {
    copy: u(require_copy()),
    copySync: require_copy_sync()
  };
});

// node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf2 = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var assert = __require("assert");
  var isWindows = process.platform === "win32";
  function defaults(options) {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m2) => {
      options[m2] = options[m2] || fs[m2];
      m2 = m2 + "Sync";
      options[m2] = options[m2] || fs[m2];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
  }
  function rimraf(p, options, cb) {
    let busyTries = 0;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    rimraf_(p, options, function CB(er) {
      if (er) {
        if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
          busyTries++;
          const time = busyTries * 100;
          return setTimeout(() => rimraf_(p, options, CB), time);
        }
        if (er.code === "ENOENT")
          er = null;
      }
      cb(er);
    });
  }
  function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT") {
        return cb(null);
      }
      if (er && er.code === "EPERM" && isWindows) {
        return fixWinEPERM(p, options, er, cb);
      }
      if (st && st.isDirectory()) {
        return rmdir(p, options, er, cb);
      }
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT") {
            return cb(null);
          }
          if (er2.code === "EPERM") {
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          }
          if (er2.code === "EISDIR") {
            return rmdir(p, options, er2, cb);
          }
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2) {
        cb(er2.code === "ENOENT" ? null : er);
      } else {
        options.stat(p, (er3, stats) => {
          if (er3) {
            cb(er3.code === "ENOENT" ? null : er);
          } else if (stats.isDirectory()) {
            rmdir(p, options, er, cb);
          } else {
            options.unlink(p, cb);
          }
        });
      }
    });
  }
  function fixWinEPERMSync(p, options, er) {
    let stats;
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    if (stats.isDirectory()) {
      rmdirSync(p, options, er);
    } else {
      options.unlinkSync(p);
    }
  }
  function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
        rmkids(p, options, cb);
      } else if (er && er.code === "ENOTDIR") {
        cb(originalEr);
      } else {
        cb(er);
      }
    });
  }
  function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      let errState;
      if (n === 0)
        return options.rmdir(p, cb);
      files.forEach((f) => {
        rimraf(path.join(p, f), options, (er2) => {
          if (errState) {
            return;
          }
          if (er2)
            return cb(errState = er2);
          if (--n === 0) {
            options.rmdir(p, cb);
          }
        });
      });
    });
  }
  function rimrafSync(p, options) {
    let st;
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    try {
      st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      }
      if (er.code === "EPERM" && isWindows) {
        fixWinEPERMSync(p, options, er);
      }
    }
    try {
      if (st && st.isDirectory()) {
        rmdirSync(p, options, null);
      } else {
        options.unlinkSync(p);
      }
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      } else if (er.code === "EPERM") {
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
      } else if (er.code !== "EISDIR") {
        throw er;
      }
      rmdirSync(p, options, er);
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOTDIR") {
        throw originalEr;
      } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
        rmkidsSync(p, options);
      } else if (er.code !== "ENOENT") {
        throw er;
      }
    }
  }
  function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
    if (isWindows) {
      const startTime = Date.now();
      do {
        try {
          const ret = options.rmdirSync(p, options);
          return ret;
        } catch {}
      } while (Date.now() - startTime < 500);
    } else {
      const ret = options.rmdirSync(p, options);
      return ret;
    }
  }
  module.exports = rimraf;
  rimraf.sync = rimrafSync;
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var u = require_universalify().fromCallback;
  var rimraf = require_rimraf2();
  function remove(path, callback) {
    if (fs.rm)
      return fs.rm(path, { recursive: true, force: true }, callback);
    rimraf(path, callback);
  }
  function removeSync(path) {
    if (fs.rmSync)
      return fs.rmSync(path, { recursive: true, force: true });
    rimraf.sync(path);
  }
  module.exports = {
    remove: u(remove),
    removeSync
  };
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var fs = require_fs2();
  var path = __require("path");
  var mkdir = require_mkdirs();
  var remove = require_remove();
  var emptyDir = u(async function emptyDir(dir) {
    let items;
    try {
      items = await fs.readdir(dir);
    } catch {
      return mkdir.mkdirs(dir);
    }
    return Promise.all(items.map((item) => remove.remove(path.join(dir, item))));
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs.readdirSync(dir);
    } catch {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path.join(dir, item);
      remove.removeSync(item);
    });
  }
  module.exports = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS((exports, module) => {
  var u = require_universalify().fromCallback;
  var path = __require("path");
  var fs = require_graceful_fs();
  var mkdir = require_mkdirs();
  function createFile(file, callback) {
    function makeFile() {
      fs.writeFile(file, "", (err) => {
        if (err)
          return callback(err);
        callback();
      });
    }
    fs.stat(file, (err, stats) => {
      if (!err && stats.isFile())
        return callback();
      const dir = path.dirname(file);
      fs.stat(dir, (err2, stats2) => {
        if (err2) {
          if (err2.code === "ENOENT") {
            return mkdir.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeFile();
            });
          }
          return callback(err2);
        }
        if (stats2.isDirectory())
          makeFile();
        else {
          fs.readdir(dir, (err3) => {
            if (err3)
              return callback(err3);
          });
        }
      });
    });
  }
  function createFileSync(file) {
    let stats;
    try {
      stats = fs.statSync(file);
    } catch {}
    if (stats && stats.isFile())
      return;
    const dir = path.dirname(file);
    try {
      if (!fs.statSync(dir).isDirectory()) {
        fs.readdirSync(dir);
      }
    } catch (err) {
      if (err && err.code === "ENOENT")
        mkdir.mkdirsSync(dir);
      else
        throw err;
    }
    fs.writeFileSync(file, "");
  }
  module.exports = {
    createFile: u(createFile),
    createFileSync
  };
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS((exports, module) => {
  var u = require_universalify().fromCallback;
  var path = __require("path");
  var fs = require_graceful_fs();
  var mkdir = require_mkdirs();
  var pathExists = require_path_exists().pathExists;
  var { areIdentical } = require_stat();
  function createLink(srcpath, dstpath, callback) {
    function makeLink(srcpath2, dstpath2) {
      fs.link(srcpath2, dstpath2, (err) => {
        if (err)
          return callback(err);
        callback(null);
      });
    }
    fs.lstat(dstpath, (_2, dstStat) => {
      fs.lstat(srcpath, (err, srcStat) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureLink");
          return callback(err);
        }
        if (dstStat && areIdentical(srcStat, dstStat))
          return callback(null);
        const dir = path.dirname(dstpath);
        pathExists(dir, (err2, dirExists) => {
          if (err2)
            return callback(err2);
          if (dirExists)
            return makeLink(srcpath, dstpath);
          mkdir.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeLink(srcpath, dstpath);
          });
        });
      });
    });
  }
  function createLinkSync(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = fs.lstatSync(dstpath);
    } catch {}
    try {
      const srcStat = fs.lstatSync(srcpath);
      if (dstStat && areIdentical(srcStat, dstStat))
        return;
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path.dirname(dstpath);
    const dirExists = fs.existsSync(dir);
    if (dirExists)
      return fs.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs.linkSync(srcpath, dstpath);
  }
  module.exports = {
    createLink: u(createLink),
    createLinkSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = require_graceful_fs();
  var pathExists = require_path_exists().pathExists;
  function symlinkPaths(srcpath, dstpath, callback) {
    if (path.isAbsolute(srcpath)) {
      return fs.lstat(srcpath, (err) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          return callback(err);
        }
        return callback(null, {
          toCwd: srcpath,
          toDst: srcpath
        });
      });
    } else {
      const dstdir = path.dirname(dstpath);
      const relativeToDst = path.join(dstdir, srcpath);
      return pathExists(relativeToDst, (err, exists) => {
        if (err)
          return callback(err);
        if (exists) {
          return callback(null, {
            toCwd: relativeToDst,
            toDst: srcpath
          });
        } else {
          return fs.lstat(srcpath, (err2) => {
            if (err2) {
              err2.message = err2.message.replace("lstat", "ensureSymlink");
              return callback(err2);
            }
            return callback(null, {
              toCwd: srcpath,
              toDst: path.relative(dstdir, srcpath)
            });
          });
        }
      });
    }
  }
  function symlinkPathsSync(srcpath, dstpath) {
    let exists;
    if (path.isAbsolute(srcpath)) {
      exists = fs.existsSync(srcpath);
      if (!exists)
        throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    } else {
      const dstdir = path.dirname(dstpath);
      const relativeToDst = path.join(dstdir, srcpath);
      exists = fs.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      } else {
        exists = fs.existsSync(srcpath);
        if (!exists)
          throw new Error("relative srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: path.relative(dstdir, srcpath)
        };
      }
    }
  }
  module.exports = {
    symlinkPaths,
    symlinkPathsSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  function symlinkType(srcpath, type, callback) {
    callback = typeof type === "function" ? type : callback;
    type = typeof type === "function" ? false : type;
    if (type)
      return callback(null, type);
    fs.lstat(srcpath, (err, stats) => {
      if (err)
        return callback(null, "file");
      type = stats && stats.isDirectory() ? "dir" : "file";
      callback(null, type);
    });
  }
  function symlinkTypeSync(srcpath, type) {
    let stats;
    if (type)
      return type;
    try {
      stats = fs.lstatSync(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  module.exports = {
    symlinkType,
    symlinkTypeSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS((exports, module) => {
  var u = require_universalify().fromCallback;
  var path = __require("path");
  var fs = require_fs2();
  var _mkdirs = require_mkdirs();
  var mkdirs = _mkdirs.mkdirs;
  var mkdirsSync = _mkdirs.mkdirsSync;
  var _symlinkPaths = require_symlink_paths();
  var symlinkPaths = _symlinkPaths.symlinkPaths;
  var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
  var _symlinkType = require_symlink_type();
  var symlinkType = _symlinkType.symlinkType;
  var symlinkTypeSync = _symlinkType.symlinkTypeSync;
  var pathExists = require_path_exists().pathExists;
  var { areIdentical } = require_stat();
  function createSymlink(srcpath, dstpath, type, callback) {
    callback = typeof type === "function" ? type : callback;
    type = typeof type === "function" ? false : type;
    fs.lstat(dstpath, (err, stats) => {
      if (!err && stats.isSymbolicLink()) {
        Promise.all([
          fs.stat(srcpath),
          fs.stat(dstpath)
        ]).then(([srcStat, dstStat]) => {
          if (areIdentical(srcStat, dstStat))
            return callback(null);
          _createSymlink(srcpath, dstpath, type, callback);
        });
      } else
        _createSymlink(srcpath, dstpath, type, callback);
    });
  }
  function _createSymlink(srcpath, dstpath, type, callback) {
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err)
        return callback(err);
      srcpath = relative.toDst;
      symlinkType(relative.toCwd, type, (err2, type2) => {
        if (err2)
          return callback(err2);
        const dir = path.dirname(dstpath);
        pathExists(dir, (err3, dirExists) => {
          if (err3)
            return callback(err3);
          if (dirExists)
            return fs.symlink(srcpath, dstpath, type2, callback);
          mkdirs(dir, (err4) => {
            if (err4)
              return callback(err4);
            fs.symlink(srcpath, dstpath, type2, callback);
          });
        });
      });
    });
  }
  function createSymlinkSync(srcpath, dstpath, type) {
    let stats;
    try {
      stats = fs.lstatSync(dstpath);
    } catch {}
    if (stats && stats.isSymbolicLink()) {
      const srcStat = fs.statSync(srcpath);
      const dstStat = fs.statSync(dstpath);
      if (areIdentical(srcStat, dstStat))
        return;
    }
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type = symlinkTypeSync(relative.toCwd, type);
    const dir = path.dirname(dstpath);
    const exists = fs.existsSync(dir);
    if (exists)
      return fs.symlinkSync(srcpath, dstpath, type);
    mkdirsSync(dir);
    return fs.symlinkSync(srcpath, dstpath, type);
  }
  module.exports = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS((exports, module) => {
  var { createFile, createFileSync } = require_file();
  var { createLink, createLinkSync } = require_link();
  var { createSymlink, createSymlinkSync } = require_symlink();
  module.exports = {
    createFile,
    createFileSync,
    ensureFile: createFile,
    ensureFileSync: createFileSync,
    createLink,
    createLinkSync,
    ensureLink: createLink,
    ensureLinkSync: createLinkSync,
    createSymlink,
    createSymlinkSync,
    ensureSymlink: createSymlink,
    ensureSymlinkSync: createSymlinkSync
  };
});

// node_modules/jsonfile/utils.js
var require_utils3 = __commonJS((exports, module) => {
  function stringify(obj2, { EOL = `
`, finalEOL = true, replacer = null, spaces } = {}) {
    const EOF = finalEOL ? EOL : "";
    const str = JSON.stringify(obj2, replacer, spaces);
    return str.replace(/\n/g, EOL) + EOF;
  }
  function stripBom(content) {
    if (Buffer.isBuffer(content))
      content = content.toString("utf8");
    return content.replace(/^\uFEFF/, "");
  }
  module.exports = { stringify, stripBom };
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS((exports, module) => {
  var _fs;
  try {
    _fs = require_graceful_fs();
  } catch (_2) {
    _fs = __require("fs");
  }
  var universalify = require_universalify();
  var { stringify, stripBom } = require_utils3();
  async function _readFile(file, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    let data = await universalify.fromCallback(fs.readFile)(file, options);
    data = stripBom(data);
    let obj2;
    try {
      obj2 = JSON.parse(data, options ? options.reviver : null);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
    return obj2;
  }
  var readFile = universalify.fromPromise(_readFile);
  function readFileSync(file, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    try {
      let content = fs.readFileSync(file, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  }
  async function _writeFile(file, obj2, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify(obj2, options);
    await universalify.fromCallback(fs.writeFile)(file, str, options);
  }
  var writeFile = universalify.fromPromise(_writeFile);
  function writeFileSync(file, obj2, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify(obj2, options);
    return fs.writeFileSync(file, str, options);
  }
  var jsonfile = {
    readFile,
    readFileSync,
    writeFile,
    writeFileSync
  };
  module.exports = jsonfile;
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS((exports, module) => {
  var jsonFile = require_jsonfile();
  module.exports = {
    readJson: jsonFile.readFile,
    readJsonSync: jsonFile.readFileSync,
    writeJson: jsonFile.writeFile,
    writeJsonSync: jsonFile.writeFileSync
  };
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS((exports, module) => {
  var u = require_universalify().fromCallback;
  var fs = require_graceful_fs();
  var path = __require("path");
  var mkdir = require_mkdirs();
  var pathExists = require_path_exists().pathExists;
  function outputFile(file, data, encoding, callback) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = "utf8";
    }
    const dir = path.dirname(file);
    pathExists(dir, (err, itDoes) => {
      if (err)
        return callback(err);
      if (itDoes)
        return fs.writeFile(file, data, encoding, callback);
      mkdir.mkdirs(dir, (err2) => {
        if (err2)
          return callback(err2);
        fs.writeFile(file, data, encoding, callback);
      });
    });
  }
  function outputFileSync(file, ...args) {
    const dir = path.dirname(file);
    if (fs.existsSync(dir)) {
      return fs.writeFileSync(file, ...args);
    }
    mkdir.mkdirsSync(dir);
    fs.writeFileSync(file, ...args);
  }
  module.exports = {
    outputFile: u(outputFile),
    outputFileSync
  };
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS((exports, module) => {
  var { stringify } = require_utils3();
  var { outputFile } = require_output_file();
  async function outputJson(file, data, options = {}) {
    const str = stringify(data, options);
    await outputFile(file, str, options);
  }
  module.exports = outputJson;
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS((exports, module) => {
  var { stringify } = require_utils3();
  var { outputFileSync } = require_output_file();
  function outputJsonSync(file, data, options) {
    const str = stringify(data, options);
    outputFileSync(file, str, options);
  }
  module.exports = outputJsonSync;
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var jsonFile = require_jsonfile2();
  jsonFile.outputJson = u(require_output_json());
  jsonFile.outputJsonSync = require_output_json_sync();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  module.exports = jsonFile;
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var copy = require_copy2().copy;
  var remove = require_remove().remove;
  var mkdirp = require_mkdirs().mkdirp;
  var pathExists = require_path_exists().pathExists;
  var stat = require_stat();
  function move(src, dest, opts, cb) {
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    stat.checkPaths(src, dest, "move", opts, (err, stats) => {
      if (err)
        return cb(err);
      const { srcStat, isChangingCase = false } = stats;
      stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
        if (err2)
          return cb(err2);
        if (isParentRoot(dest))
          return doRename(src, dest, overwrite, isChangingCase, cb);
        mkdirp(path.dirname(dest), (err3) => {
          if (err3)
            return cb(err3);
          return doRename(src, dest, overwrite, isChangingCase, cb);
        });
      });
    });
  }
  function isParentRoot(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src, dest, overwrite, isChangingCase, cb) {
    if (isChangingCase)
      return rename(src, dest, overwrite, cb);
    if (overwrite) {
      return remove(dest, (err) => {
        if (err)
          return cb(err);
        return rename(src, dest, overwrite, cb);
      });
    }
    pathExists(dest, (err, destExists) => {
      if (err)
        return cb(err);
      if (destExists)
        return cb(new Error("dest already exists."));
      return rename(src, dest, overwrite, cb);
    });
  }
  function rename(src, dest, overwrite, cb) {
    fs.rename(src, dest, (err) => {
      if (!err)
        return cb();
      if (err.code !== "EXDEV")
        return cb(err);
      return moveAcrossDevice(src, dest, overwrite, cb);
    });
  }
  function moveAcrossDevice(src, dest, overwrite, cb) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copy(src, dest, opts, (err) => {
      if (err)
        return cb(err);
      return remove(src, cb);
    });
  }
  module.exports = move;
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var copySync = require_copy2().copySync;
  var removeSync = require_remove().removeSync;
  var mkdirpSync = require_mkdirs().mkdirpSync;
  var stat = require_stat();
  function moveSync(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "move");
    if (!isParentRoot(dest))
      mkdirpSync(path.dirname(dest));
    return doRename(src, dest, overwrite, isChangingCase);
  }
  function isParentRoot(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src, dest, overwrite, isChangingCase) {
    if (isChangingCase)
      return rename(src, dest, overwrite);
    if (overwrite) {
      removeSync(dest);
      return rename(src, dest, overwrite);
    }
    if (fs.existsSync(dest))
      throw new Error("dest already exists.");
    return rename(src, dest, overwrite);
  }
  function rename(src, dest, overwrite) {
    try {
      fs.renameSync(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV")
        throw err;
      return moveAcrossDevice(src, dest, overwrite);
    }
  }
  function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copySync(src, dest, opts);
    return removeSync(src);
  }
  module.exports = moveSync;
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS((exports, module) => {
  var u = require_universalify().fromCallback;
  module.exports = {
    move: u(require_move()),
    moveSync: require_move_sync()
  };
});

// node_modules/fs-extra/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  module.exports = {
    ...require_fs2(),
    ...require_copy2(),
    ...require_empty(),
    ...require_ensure(),
    ...require_json(),
    ...require_mkdirs(),
    ...require_move2(),
    ...require_output_file(),
    ...require_path_exists(),
    ...require_remove()
  };
});

// node_modules/listenercount/index.js
var require_listenercount = __commonJS((exports, module) => {
  var listenerCount = __require("events").listenerCount;
  listenerCount = listenerCount || function(ee, event) {
    var listeners = ee && ee._events && ee._events[event];
    if (Array.isArray(listeners)) {
      return listeners.length;
    } else if (typeof listeners === "function") {
      return 1;
    } else {
      return 0;
    }
  };
  module.exports = listenerCount;
});

// node_modules/buffer-indexof-polyfill/init-buffer.js
var require_init_buffer = __commonJS((exports, module) => {
  module.exports = function initBuffer(val) {
    var nodeVersion = process && process.version ? process.version : "v5.0.0";
    var major = nodeVersion.split(".")[0].replace("v", "");
    return major < 6 ? new Buffer(val) : Buffer.from(val);
  };
});

// node_modules/buffer-indexof-polyfill/index.js
var require_buffer_indexof_polyfill = __commonJS(() => {
  var initBuffer = require_init_buffer();
  if (!Buffer.prototype.indexOf) {
    Buffer.prototype.indexOf = function(value, offset) {
      offset = offset || 0;
      if (typeof value === "string" || value instanceof String) {
        value = initBuffer(value);
      } else if (typeof value === "number" || value instanceof Number) {
        value = initBuffer([value]);
      }
      var len = value.length;
      for (var i = offset;i <= this.length - len; i++) {
        var mismatch = false;
        for (var j = 0;j < len; j++) {
          if (this[i + j] != value[j]) {
            mismatch = true;
            break;
          }
        }
        if (!mismatch) {
          return i;
        }
      }
      return -1;
    };
  }
  function bufferLastIndexOf(value, offset) {
    if (typeof value === "string" || value instanceof String) {
      value = initBuffer(value);
    } else if (typeof value === "number" || value instanceof Number) {
      value = initBuffer([value]);
    }
    var len = value.length;
    offset = offset || this.length - len;
    for (var i = offset;i >= 0; i--) {
      var mismatch = false;
      for (var j = 0;j < len; j++) {
        if (this[i + j] != value[j]) {
          mismatch = true;
          break;
        }
      }
      if (!mismatch) {
        return i;
      }
    }
    return -1;
  }
  if (Buffer.prototype.lastIndexOf) {
    if (initBuffer("ABC").lastIndexOf("ABC") === -1)
      Buffer.prototype.lastIndexOf = bufferLastIndexOf;
  } else {
    Buffer.prototype.lastIndexOf = bufferLastIndexOf;
  }
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  (function(global2, undefined2) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined2, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel;
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
});

// node_modules/traverse/index.js
var require_traverse = __commonJS((exports, module) => {
  module.exports = Traverse;
  function Traverse(obj2) {
    if (!(this instanceof Traverse))
      return new Traverse(obj2);
    this.value = obj2;
  }
  Traverse.prototype.get = function(ps) {
    var node = this.value;
    for (var i = 0;i < ps.length; i++) {
      var key2 = ps[i];
      if (!Object.hasOwnProperty.call(node, key2)) {
        node = undefined;
        break;
      }
      node = node[key2];
    }
    return node;
  };
  Traverse.prototype.set = function(ps, value) {
    var node = this.value;
    for (var i = 0;i < ps.length - 1; i++) {
      var key2 = ps[i];
      if (!Object.hasOwnProperty.call(node, key2))
        node[key2] = {};
      node = node[key2];
    }
    node[ps[i]] = value;
    return value;
  };
  Traverse.prototype.map = function(cb) {
    return walk(this.value, cb, true);
  };
  Traverse.prototype.forEach = function(cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
  };
  Traverse.prototype.reduce = function(cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function(x) {
      if (!this.isRoot || !skip) {
        acc = cb.call(this, acc, x);
      }
    });
    return acc;
  };
  Traverse.prototype.deepEqual = function(obj2) {
    if (arguments.length !== 1) {
      throw new Error("deepEqual requires exactly one object to compare against");
    }
    var equal = true;
    var node = obj2;
    this.forEach(function(y) {
      var notEqual = function() {
        equal = false;
        return;
      }.bind(this);
      if (!this.isRoot) {
        if (typeof node !== "object")
          return notEqual();
        node = node[this.key];
      }
      var x = node;
      this.post(function() {
        node = x;
      });
      var toS = function(o) {
        return Object.prototype.toString.call(o);
      };
      if (this.circular) {
        if (Traverse(obj2).get(this.circular.path) !== x)
          notEqual();
      } else if (typeof x !== typeof y) {
        notEqual();
      } else if (x === null || y === null || x === undefined || y === undefined) {
        if (x !== y)
          notEqual();
      } else if (x.__proto__ !== y.__proto__) {
        notEqual();
      } else if (x === y) {} else if (typeof x === "function") {
        if (x instanceof RegExp) {
          if (x.toString() != y.toString())
            notEqual();
        } else if (x !== y)
          notEqual();
      } else if (typeof x === "object") {
        if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
          if (toS(x) !== toS(y)) {
            notEqual();
          }
        } else if (x instanceof Date || y instanceof Date) {
          if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
            notEqual();
          }
        } else {
          var kx = Object.keys(x);
          var ky = Object.keys(y);
          if (kx.length !== ky.length)
            return notEqual();
          for (var i = 0;i < kx.length; i++) {
            var k = kx[i];
            if (!Object.hasOwnProperty.call(y, k)) {
              notEqual();
            }
          }
        }
      }
    });
    return equal;
  };
  Traverse.prototype.paths = function() {
    var acc = [];
    this.forEach(function(x) {
      acc.push(this.path);
    });
    return acc;
  };
  Traverse.prototype.nodes = function() {
    var acc = [];
    this.forEach(function(x) {
      acc.push(this.node);
    });
    return acc;
  };
  Traverse.prototype.clone = function() {
    var parents = [], nodes = [];
    return function clone(src) {
      for (var i = 0;i < parents.length; i++) {
        if (parents[i] === src) {
          return nodes[i];
        }
      }
      if (typeof src === "object" && src !== null) {
        var dst = copy(src);
        parents.push(src);
        nodes.push(dst);
        Object.keys(src).forEach(function(key2) {
          dst[key2] = clone(src[key2]);
        });
        parents.pop();
        nodes.pop();
        return dst;
      } else {
        return src;
      }
    }(this.value);
  };
  function walk(root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    return function walker(node_) {
      var node = immutable ? copy(node_) : node_;
      var modifiers = {};
      var state = {
        node,
        node_,
        path: [].concat(path),
        parent: parents.slice(-1)[0],
        key: path.slice(-1)[0],
        isRoot: path.length === 0,
        level: path.length,
        circular: null,
        update: function(x) {
          if (!state.isRoot) {
            state.parent.node[state.key] = x;
          }
          state.node = x;
        },
        delete: function() {
          delete state.parent.node[state.key];
        },
        remove: function() {
          if (Array.isArray(state.parent.node)) {
            state.parent.node.splice(state.key, 1);
          } else {
            delete state.parent.node[state.key];
          }
        },
        before: function(f) {
          modifiers.before = f;
        },
        after: function(f) {
          modifiers.after = f;
        },
        pre: function(f) {
          modifiers.pre = f;
        },
        post: function(f) {
          modifiers.post = f;
        },
        stop: function() {
          alive = false;
        }
      };
      if (!alive)
        return state;
      if (typeof node === "object" && node !== null) {
        state.isLeaf = Object.keys(node).length == 0;
        for (var i = 0;i < parents.length; i++) {
          if (parents[i].node_ === node_) {
            state.circular = parents[i];
            break;
          }
        }
      } else {
        state.isLeaf = true;
      }
      state.notLeaf = !state.isLeaf;
      state.notRoot = !state.isRoot;
      var ret = cb.call(state, state.node);
      if (ret !== undefined && state.update)
        state.update(ret);
      if (modifiers.before)
        modifiers.before.call(state, state.node);
      if (typeof state.node == "object" && state.node !== null && !state.circular) {
        parents.push(state);
        var keys = Object.keys(state.node);
        keys.forEach(function(key2, i2) {
          path.push(key2);
          if (modifiers.pre)
            modifiers.pre.call(state, state.node[key2], key2);
          var child = walker(state.node[key2]);
          if (immutable && Object.hasOwnProperty.call(state.node, key2)) {
            state.node[key2] = child.node;
          }
          child.isLast = i2 == keys.length - 1;
          child.isFirst = i2 == 0;
          if (modifiers.post)
            modifiers.post.call(state, child);
          path.pop();
        });
        parents.pop();
      }
      if (modifiers.after)
        modifiers.after.call(state, state.node);
      return state;
    }(root).node;
  }
  Object.keys(Traverse.prototype).forEach(function(key2) {
    Traverse[key2] = function(obj2) {
      var args = [].slice.call(arguments, 1);
      var t = Traverse(obj2);
      return t[key2].apply(t, args);
    };
  });
  function copy(src) {
    if (typeof src === "object" && src !== null) {
      var dst;
      if (Array.isArray(src)) {
        dst = [];
      } else if (src instanceof Date) {
        dst = new Date(src);
      } else if (src instanceof Boolean) {
        dst = new Boolean(src);
      } else if (src instanceof Number) {
        dst = new Number(src);
      } else if (src instanceof String) {
        dst = new String(src);
      } else {
        dst = Object.create(Object.getPrototypeOf(src));
      }
      Object.keys(src).forEach(function(key2) {
        dst[key2] = src[key2];
      });
      return dst;
    } else
      return src;
  }
});

// node_modules/chainsaw/index.js
var require_chainsaw = __commonJS((exports, module) => {
  var Traverse = require_traverse();
  var EventEmitter = __require("events").EventEmitter;
  module.exports = Chainsaw;
  function Chainsaw(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined)
      saw.handlers = r;
    saw.record();
    return saw.chain();
  }
  Chainsaw.light = function ChainsawLight(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined)
      saw.handlers = r;
    return saw.chain();
  };
  Chainsaw.saw = function(builder, handlers) {
    var saw = new EventEmitter;
    saw.handlers = handlers;
    saw.actions = [];
    saw.chain = function() {
      var ch = Traverse(saw.handlers).map(function(node) {
        if (this.isRoot)
          return node;
        var ps = this.path;
        if (typeof node === "function") {
          this.update(function() {
            saw.actions.push({
              path: ps,
              args: [].slice.call(arguments)
            });
            return ch;
          });
        }
      });
      process.nextTick(function() {
        saw.emit("begin");
        saw.next();
      });
      return ch;
    };
    saw.pop = function() {
      return saw.actions.shift();
    };
    saw.next = function() {
      var action = saw.pop();
      if (!action) {
        saw.emit("end");
      } else if (!action.trap) {
        var node = saw.handlers;
        action.path.forEach(function(key2) {
          node = node[key2];
        });
        node.apply(saw.handlers, action.args);
      }
    };
    saw.nest = function(cb) {
      var args = [].slice.call(arguments, 1);
      var autonext = true;
      if (typeof cb === "boolean") {
        var autonext = cb;
        cb = args.shift();
      }
      var s = Chainsaw.saw(builder, {});
      var r = builder.call(s.handlers, s);
      if (r !== undefined)
        s.handlers = r;
      if (typeof saw.step !== "undefined") {
        s.record();
      }
      cb.apply(s.chain(), args);
      if (autonext !== false)
        s.on("end", saw.next);
    };
    saw.record = function() {
      upgradeChainsaw(saw);
    };
    ["trap", "down", "jump"].forEach(function(method) {
      saw[method] = function() {
        throw new Error("To use the trap, down and jump features, please " + "call record() first to start recording actions.");
      };
    });
    return saw;
  };
  function upgradeChainsaw(saw) {
    saw.step = 0;
    saw.pop = function() {
      return saw.actions[saw.step++];
    };
    saw.trap = function(name, cb) {
      var ps = Array.isArray(name) ? name : [name];
      saw.actions.push({
        path: ps,
        step: saw.step,
        cb,
        trap: true
      });
    };
    saw.down = function(name) {
      var ps = (Array.isArray(name) ? name : [name]).join("/");
      var i = saw.actions.slice(saw.step).map(function(x) {
        if (x.trap && x.step <= saw.step)
          return false;
        return x.path.join("/") == ps;
      }).indexOf(true);
      if (i >= 0)
        saw.step += i;
      else
        saw.step = saw.actions.length;
      var act = saw.actions[saw.step - 1];
      if (act && act.trap) {
        saw.step = act.step;
        act.cb();
      } else
        saw.next();
    };
    saw.jump = function(step) {
      saw.step = step;
      saw.next();
    };
  }
});

// node_modules/buffers/index.js
var require_buffers = __commonJS((exports, module) => {
  module.exports = Buffers;
  function Buffers(bufs) {
    if (!(this instanceof Buffers))
      return new Buffers(bufs);
    this.buffers = bufs || [];
    this.length = this.buffers.reduce(function(size, buf) {
      return size + buf.length;
    }, 0);
  }
  Buffers.prototype.push = function() {
    for (var i = 0;i < arguments.length; i++) {
      if (!Buffer.isBuffer(arguments[i])) {
        throw new TypeError("Tried to push a non-buffer");
      }
    }
    for (var i = 0;i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.push(buf);
      this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.unshift = function() {
    for (var i = 0;i < arguments.length; i++) {
      if (!Buffer.isBuffer(arguments[i])) {
        throw new TypeError("Tried to unshift a non-buffer");
      }
    }
    for (var i = 0;i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.unshift(buf);
      this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.copy = function(dst, dStart, start, end) {
    return this.slice(start, end).copy(dst, dStart, 0, end - start);
  };
  Buffers.prototype.splice = function(i, howMany) {
    var buffers = this.buffers;
    var index = i >= 0 ? i : this.length - i;
    var reps = [].slice.call(arguments, 2);
    if (howMany === undefined) {
      howMany = this.length - index;
    } else if (howMany > this.length - index) {
      howMany = this.length - index;
    }
    for (var i = 0;i < reps.length; i++) {
      this.length += reps[i].length;
    }
    var removed = new Buffers;
    var bytes = 0;
    var startBytes = 0;
    for (var ii = 0;ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
      startBytes += buffers[ii].length;
    }
    if (index - startBytes > 0) {
      var start = index - startBytes;
      if (start + howMany < buffers[ii].length) {
        removed.push(buffers[ii].slice(start, start + howMany));
        var orig = buffers[ii];
        var buf0 = new Buffer(start);
        for (var i = 0;i < start; i++) {
          buf0[i] = orig[i];
        }
        var buf1 = new Buffer(orig.length - start - howMany);
        for (var i = start + howMany;i < orig.length; i++) {
          buf1[i - howMany - start] = orig[i];
        }
        if (reps.length > 0) {
          var reps_ = reps.slice();
          reps_.unshift(buf0);
          reps_.push(buf1);
          buffers.splice.apply(buffers, [ii, 1].concat(reps_));
          ii += reps_.length;
          reps = [];
        } else {
          buffers.splice(ii, 1, buf0, buf1);
          ii += 2;
        }
      } else {
        removed.push(buffers[ii].slice(start));
        buffers[ii] = buffers[ii].slice(0, start);
        ii++;
      }
    }
    if (reps.length > 0) {
      buffers.splice.apply(buffers, [ii, 0].concat(reps));
      ii += reps.length;
    }
    while (removed.length < howMany) {
      var buf = buffers[ii];
      var len = buf.length;
      var take = Math.min(len, howMany - removed.length);
      if (take === len) {
        removed.push(buf);
        buffers.splice(ii, 1);
      } else {
        removed.push(buf.slice(0, take));
        buffers[ii] = buffers[ii].slice(take);
      }
    }
    this.length -= removed.length;
    return removed;
  };
  Buffers.prototype.slice = function(i, j) {
    var buffers = this.buffers;
    if (j === undefined)
      j = this.length;
    if (i === undefined)
      i = 0;
    if (j > this.length)
      j = this.length;
    var startBytes = 0;
    for (var si = 0;si < buffers.length && startBytes + buffers[si].length <= i; si++) {
      startBytes += buffers[si].length;
    }
    var target = new Buffer(j - i);
    var ti = 0;
    for (var ii = si;ti < j - i && ii < buffers.length; ii++) {
      var len = buffers[ii].length;
      var start = ti === 0 ? i - startBytes : 0;
      var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
      buffers[ii].copy(target, ti, start, end);
      ti += end - start;
    }
    return target;
  };
  Buffers.prototype.pos = function(i) {
    if (i < 0 || i >= this.length)
      throw new Error("oob");
    var l2 = i, bi = 0, bu = null;
    for (;; ) {
      bu = this.buffers[bi];
      if (l2 < bu.length) {
        return { buf: bi, offset: l2 };
      } else {
        l2 -= bu.length;
      }
      bi++;
    }
  };
  Buffers.prototype.get = function get(i) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].get(pos.offset);
  };
  Buffers.prototype.set = function set(i, b) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].set(pos.offset, b);
  };
  Buffers.prototype.indexOf = function(needle, offset) {
    if (typeof needle === "string") {
      needle = new Buffer(needle);
    } else if (needle instanceof Buffer) {} else {
      throw new Error("Invalid type for a search string");
    }
    if (!needle.length) {
      return 0;
    }
    if (!this.length) {
      return -1;
    }
    var i = 0, j = 0, match = 0, mstart, pos = 0;
    if (offset) {
      var p = this.pos(offset);
      i = p.buf;
      j = p.offset;
      pos = offset;
    }
    for (;; ) {
      while (j >= this.buffers[i].length) {
        j = 0;
        i++;
        if (i >= this.buffers.length) {
          return -1;
        }
      }
      var char = this.buffers[i][j];
      if (char == needle[match]) {
        if (match == 0) {
          mstart = {
            i,
            j,
            pos
          };
        }
        match++;
        if (match == needle.length) {
          return mstart.pos;
        }
      } else if (match != 0) {
        i = mstart.i;
        j = mstart.j;
        pos = mstart.pos;
        match = 0;
      }
      j++;
      pos++;
    }
  };
  Buffers.prototype.toBuffer = function() {
    return this.slice();
  };
  Buffers.prototype.toString = function(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
});

// node_modules/binary/lib/vars.js
var require_vars = __commonJS((exports, module) => {
  module.exports = function(store) {
    function getset(name, value) {
      var node = vars.store;
      var keys = name.split(".");
      keys.slice(0, -1).forEach(function(k) {
        if (node[k] === undefined)
          node[k] = {};
        node = node[k];
      });
      var key2 = keys[keys.length - 1];
      if (arguments.length == 1) {
        return node[key2];
      } else {
        return node[key2] = value;
      }
    }
    var vars = {
      get: function(name) {
        return getset(name);
      },
      set: function(name, value) {
        return getset(name, value);
      },
      store: store || {}
    };
    return vars;
  };
});

// node_modules/binary/index.js
var require_binary = __commonJS((exports, module) => {
  var Chainsaw = require_chainsaw();
  var EventEmitter = __require("events").EventEmitter;
  var Buffers = require_buffers();
  var Vars = require_vars();
  var Stream = __require("stream").Stream;
  exports = module.exports = function(bufOrEm, eventName) {
    if (Buffer.isBuffer(bufOrEm)) {
      return exports.parse(bufOrEm);
    }
    var s = exports.stream();
    if (bufOrEm && bufOrEm.pipe) {
      bufOrEm.pipe(s);
    } else if (bufOrEm) {
      bufOrEm.on(eventName || "data", function(buf) {
        s.write(buf);
      });
      bufOrEm.on("end", function() {
        s.end();
      });
    }
    return s;
  };
  exports.stream = function(input) {
    if (input)
      return exports.apply(null, arguments);
    var pending = null;
    function getBytes(bytes, cb, skip) {
      pending = {
        bytes,
        skip,
        cb: function(buf) {
          pending = null;
          cb(buf);
        }
      };
      dispatch();
    }
    var offset = null;
    function dispatch() {
      if (!pending) {
        if (caughtEnd)
          done = true;
        return;
      }
      if (typeof pending === "function") {
        pending();
      } else {
        var bytes = offset + pending.bytes;
        if (buffers.length >= bytes) {
          var buf;
          if (offset == null) {
            buf = buffers.splice(0, bytes);
            if (!pending.skip) {
              buf = buf.slice();
            }
          } else {
            if (!pending.skip) {
              buf = buffers.slice(offset, bytes);
            }
            offset = bytes;
          }
          if (pending.skip) {
            pending.cb();
          } else {
            pending.cb(buf);
          }
        }
      }
    }
    function builder(saw) {
      function next() {
        if (!done)
          saw.next();
      }
      var self2 = words(function(bytes, cb) {
        return function(name) {
          getBytes(bytes, function(buf) {
            vars.set(name, cb(buf));
            next();
          });
        };
      });
      self2.tap = function(cb) {
        saw.nest(cb, vars.store);
      };
      self2.into = function(key2, cb) {
        if (!vars.get(key2))
          vars.set(key2, {});
        var parent = vars;
        vars = Vars(parent.get(key2));
        saw.nest(function() {
          cb.apply(this, arguments);
          this.tap(function() {
            vars = parent;
          });
        }, vars.store);
      };
      self2.flush = function() {
        vars.store = {};
        next();
      };
      self2.loop = function(cb) {
        var end = false;
        saw.nest(false, function loop() {
          this.vars = vars.store;
          cb.call(this, function() {
            end = true;
            next();
          }, vars.store);
          this.tap(function() {
            if (end)
              saw.next();
            else
              loop.call(this);
          }.bind(this));
        }, vars.store);
      };
      self2.buffer = function(name, bytes) {
        if (typeof bytes === "string") {
          bytes = vars.get(bytes);
        }
        getBytes(bytes, function(buf) {
          vars.set(name, buf);
          next();
        });
      };
      self2.skip = function(bytes) {
        if (typeof bytes === "string") {
          bytes = vars.get(bytes);
        }
        getBytes(bytes, function() {
          next();
        });
      };
      self2.scan = function find(name, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        var taken = 0;
        pending = function() {
          var pos = buffers.indexOf(search, offset + taken);
          var i = pos - offset - taken;
          if (pos !== -1) {
            pending = null;
            if (offset != null) {
              vars.set(name, buffers.slice(offset, offset + taken + i));
              offset += taken + i + search.length;
            } else {
              vars.set(name, buffers.slice(0, taken + i));
              buffers.splice(0, taken + i + search.length);
            }
            next();
            dispatch();
          } else {
            i = Math.max(buffers.length - search.length - offset - taken, 0);
          }
          taken += i;
        };
        dispatch();
      };
      self2.peek = function(cb) {
        offset = 0;
        saw.nest(function() {
          cb.call(this, vars.store);
          this.tap(function() {
            offset = null;
          });
        });
      };
      return self2;
    }
    var stream = Chainsaw.light(builder);
    stream.writable = true;
    var buffers = Buffers();
    stream.write = function(buf) {
      buffers.push(buf);
      dispatch();
    };
    var vars = Vars();
    var done = false, caughtEnd = false;
    stream.end = function() {
      caughtEnd = true;
    };
    stream.pipe = Stream.prototype.pipe;
    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function(name) {
      stream[name] = EventEmitter.prototype[name];
    });
    return stream;
  };
  exports.parse = function parse(buffer) {
    var self2 = words(function(bytes, cb) {
      return function(name) {
        if (offset + bytes <= buffer.length) {
          var buf = buffer.slice(offset, offset + bytes);
          offset += bytes;
          vars.set(name, cb(buf));
        } else {
          vars.set(name, null);
        }
        return self2;
      };
    });
    var offset = 0;
    var vars = Vars();
    self2.vars = vars.store;
    self2.tap = function(cb) {
      cb.call(self2, vars.store);
      return self2;
    };
    self2.into = function(key2, cb) {
      if (!vars.get(key2)) {
        vars.set(key2, {});
      }
      var parent = vars;
      vars = Vars(parent.get(key2));
      cb.call(self2, vars.store);
      vars = parent;
      return self2;
    };
    self2.loop = function(cb) {
      var end = false;
      var ender = function() {
        end = true;
      };
      while (end === false) {
        cb.call(self2, ender, vars.store);
      }
      return self2;
    };
    self2.buffer = function(name, size) {
      if (typeof size === "string") {
        size = vars.get(size);
      }
      var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
      offset += size;
      vars.set(name, buf);
      return self2;
    };
    self2.skip = function(bytes) {
      if (typeof bytes === "string") {
        bytes = vars.get(bytes);
      }
      offset += bytes;
      return self2;
    };
    self2.scan = function(name, search) {
      if (typeof search === "string") {
        search = new Buffer(search);
      } else if (!Buffer.isBuffer(search)) {
        throw new Error("search must be a Buffer or a string");
      }
      vars.set(name, null);
      for (var i = 0;i + offset <= buffer.length - search.length + 1; i++) {
        for (var j = 0;j < search.length && buffer[offset + i + j] === search[j]; j++)
          ;
        if (j === search.length)
          break;
      }
      vars.set(name, buffer.slice(offset, offset + i));
      offset += i + search.length;
      return self2;
    };
    self2.peek = function(cb) {
      var was = offset;
      cb.call(self2, vars.store);
      offset = was;
      return self2;
    };
    self2.flush = function() {
      vars.store = {};
      return self2;
    };
    self2.eof = function() {
      return offset >= buffer.length;
    };
    return self2;
  };
  function decodeLEu(bytes) {
    var acc = 0;
    for (var i = 0;i < bytes.length; i++) {
      acc += Math.pow(256, i) * bytes[i];
    }
    return acc;
  }
  function decodeBEu(bytes) {
    var acc = 0;
    for (var i = 0;i < bytes.length; i++) {
      acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
    }
    return acc;
  }
  function decodeBEs(bytes) {
    var val = decodeBEu(bytes);
    if ((bytes[0] & 128) == 128) {
      val -= Math.pow(256, bytes.length);
    }
    return val;
  }
  function decodeLEs(bytes) {
    var val = decodeLEu(bytes);
    if ((bytes[bytes.length - 1] & 128) == 128) {
      val -= Math.pow(256, bytes.length);
    }
    return val;
  }
  function words(decode) {
    var self2 = {};
    [1, 2, 4, 8].forEach(function(bytes) {
      var bits = bytes * 8;
      self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes, decodeLEu);
      self2["word" + bits + "ls"] = decode(bytes, decodeLEs);
      self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes, decodeBEu);
      self2["word" + bits + "bs"] = decode(bytes, decodeBEs);
    });
    self2.word8 = self2.word8u = self2.word8be;
    self2.word8s = self2.word8bs;
    return self2;
  }
});

// node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS((exports, module) => {
  var isES5 = function() {
    return this === undefined;
  }();
  if (isES5) {
    module.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5,
      propertyIsWritable: function(obj2, prop) {
        var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
        return !!(!descriptor || descriptor.writable || descriptor.set);
      }
    };
  } else {
    has = {}.hasOwnProperty;
    str = {}.toString;
    proto = {}.constructor.prototype;
    ObjectKeys = function(o) {
      var ret = [];
      for (var key2 in o) {
        if (has.call(o, key2)) {
          ret.push(key2);
        }
      }
      return ret;
    };
    ObjectGetDescriptor = function(o, key2) {
      return { value: o[key2] };
    };
    ObjectDefineProperty = function(o, key2, desc) {
      o[key2] = desc.value;
      return o;
    };
    ObjectFreeze = function(obj2) {
      return obj2;
    };
    ObjectGetPrototypeOf = function(obj2) {
      try {
        return Object(obj2).constructor.prototype;
      } catch (e) {
        return proto;
      }
    };
    ArrayIsArray = function(obj2) {
      try {
        return str.call(obj2) === "[object Array]";
      } catch (e) {
        return false;
      }
    };
    module.exports = {
      isArray: ArrayIsArray,
      keys: ObjectKeys,
      names: ObjectKeys,
      defineProperty: ObjectDefineProperty,
      getDescriptor: ObjectGetDescriptor,
      freeze: ObjectFreeze,
      getPrototypeOf: ObjectGetPrototypeOf,
      isES5,
      propertyIsWritable: function() {
        return true;
      }
    };
  }
  var has;
  var str;
  var proto;
  var ObjectKeys;
  var ObjectGetDescriptor;
  var ObjectDefineProperty;
  var ObjectFreeze;
  var ObjectGetPrototypeOf;
  var ArrayIsArray;
});

// node_modules/bluebird/js/release/util.js
var require_util3 = __commonJS((exports, module) => {
  var es5 = require_es5();
  var canEvaluate = typeof navigator == "undefined";
  var errorObj = { e: {} };
  var tryCatchTarget;
  var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== undefined ? exports : null;
  function tryCatcher() {
    try {
      var target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      errorObj.e = e;
      return errorObj;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
      this.constructor = Child;
      this.constructor$ = Parent;
      for (var propertyName in Parent.prototype) {
        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
          this[propertyName + "$"] = Parent.prototype[propertyName];
        }
      }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T;
    return Child.prototype;
  };
  function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
  }
  function isObject(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
  }
  function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError))
      return maybeError;
    return new Error(safeToString(maybeError));
  }
  function withAppended(target, appendee) {
    var len = target.length;
    var ret2 = new Array(len + 1);
    var i;
    for (i = 0;i < len; ++i) {
      ret2[i] = target[i];
    }
    ret2[i] = appendee;
    return ret2;
  }
  function getDataPropertyOrDefault(obj2, key2, defaultValue) {
    if (es5.isES5) {
      var desc = Object.getOwnPropertyDescriptor(obj2, key2);
      if (desc != null) {
        return desc.get == null && desc.set == null ? desc.value : defaultValue;
      }
    } else {
      return {}.hasOwnProperty.call(obj2, key2) ? obj2[key2] : undefined;
    }
  }
  function notEnumerableProp(obj2, name, value) {
    if (isPrimitive(obj2))
      return obj2;
    var descriptor = {
      value,
      configurable: true,
      enumerable: false,
      writable: true
    };
    es5.defineProperty(obj2, name, descriptor);
    return obj2;
  }
  function thrower(r) {
    throw r;
  }
  var inheritedDataKeys = function() {
    var excludedPrototypes = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ];
    var isExcludedProto = function(val) {
      for (var i = 0;i < excludedPrototypes.length; ++i) {
        if (excludedPrototypes[i] === val) {
          return true;
        }
      }
      return false;
    };
    if (es5.isES5) {
      var getKeys = Object.getOwnPropertyNames;
      return function(obj2) {
        var ret2 = [];
        var visitedKeys = Object.create(null);
        while (obj2 != null && !isExcludedProto(obj2)) {
          var keys;
          try {
            keys = getKeys(obj2);
          } catch (e) {
            return ret2;
          }
          for (var i = 0;i < keys.length; ++i) {
            var key2 = keys[i];
            if (visitedKeys[key2])
              continue;
            visitedKeys[key2] = true;
            var desc = Object.getOwnPropertyDescriptor(obj2, key2);
            if (desc != null && desc.get == null && desc.set == null) {
              ret2.push(key2);
            }
          }
          obj2 = es5.getPrototypeOf(obj2);
        }
        return ret2;
      };
    } else {
      var hasProp = {}.hasOwnProperty;
      return function(obj2) {
        if (isExcludedProto(obj2))
          return [];
        var ret2 = [];
        enumeration:
          for (var key2 in obj2) {
            if (hasProp.call(obj2, key2)) {
              ret2.push(key2);
            } else {
              for (var i = 0;i < excludedPrototypes.length; ++i) {
                if (hasProp.call(excludedPrototypes[i], key2)) {
                  continue enumeration;
                }
              }
              ret2.push(key2);
            }
          }
        return ret2;
      };
    }
  }();
  var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
  function isClass(fn) {
    try {
      if (typeof fn === "function") {
        var keys = es5.names(fn.prototype);
        var hasMethods = es5.isES5 && keys.length > 1;
        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function toFastProperties(obj) {
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--)
      new FakeConstructor;
    return obj;
    eval(obj);
  }
  var rident = /^[a-z$_][a-z$_0-9]*$/i;
  function isIdentifier(str) {
    return rident.test(str);
  }
  function filledRange(count, prefix, suffix) {
    var ret2 = new Array(count);
    for (var i = 0;i < count; ++i) {
      ret2[i] = prefix + i + suffix;
    }
    return ret2;
  }
  function safeToString(obj2) {
    try {
      return obj2 + "";
    } catch (e) {
      return "[no string representation]";
    }
  }
  function isError(obj2) {
    return obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
  }
  function markAsOriginatingFromRejection(e) {
    try {
      notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {}
  }
  function originatesFromRejection(e) {
    if (e == null)
      return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
  }
  function canAttachTrace(obj2) {
    return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
  }
  var ensureErrorObject = function() {
    if (!("stack" in new Error)) {
      return function(value) {
        if (canAttachTrace(value))
          return value;
        try {
          throw new Error(safeToString(value));
        } catch (err) {
          return err;
        }
      };
    } else {
      return function(value) {
        if (canAttachTrace(value))
          return value;
        return new Error(safeToString(value));
      };
    }
  }();
  function classString(obj2) {
    return {}.toString.call(obj2);
  }
  function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0;i < keys.length; ++i) {
      var key2 = keys[i];
      if (filter(key2)) {
        try {
          es5.defineProperty(to, key2, es5.getDescriptor(from, key2));
        } catch (ignore) {}
      }
    }
  }
  var asArray = function(v) {
    if (es5.isArray(v)) {
      return v;
    }
    return null;
  };
  if (typeof Symbol !== "undefined" && Symbol.iterator) {
    ArrayFrom = typeof Array.from === "function" ? function(v) {
      return Array.from(v);
    } : function(v) {
      var ret2 = [];
      var it = v[Symbol.iterator]();
      var itResult;
      while (!(itResult = it.next()).done) {
        ret2.push(itResult.value);
      }
      return ret2;
    };
    asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      } else if (v != null && typeof v[Symbol.iterator] === "function") {
        return ArrayFrom(v);
      }
      return null;
    };
  }
  var ArrayFrom;
  var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
  var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
  function env(key2) {
    return hasEnvVariables ? process.env[key2] : undefined;
  }
  function getNativePromise() {
    if (typeof Promise === "function") {
      try {
        var promise = new Promise(function() {});
        if ({}.toString.call(promise) === "[object Promise]") {
          return Promise;
        }
      } catch (e) {}
    }
  }
  function domainBind(self2, cb) {
    return self2.bind(cb);
  }
  var ret = {
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es5.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject,
    isError,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode,
    hasEnvVariables,
    env,
    global: globalObject,
    getNativePromise,
    domainBind
  };
  ret.isRecentNode = ret.isNode && function() {
    var version = process.versions.node.split(".").map(Number);
    return version[0] === 0 && version[1] > 10 || version[0] > 0;
  }();
  if (ret.isNode)
    ret.toFastProperties(process);
  try {
    throw new Error;
  } catch (e) {
    ret.lastLineError = e;
  }
  module.exports = ret;
});

// node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS((exports, module) => {
  var util = require_util3();
  var schedule;
  var noAsyncScheduler = function() {
    throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
  };
  var NativePromise = util.getNativePromise();
  if (util.isNode && typeof MutationObserver === "undefined") {
    GlobalSetImmediate = global.setImmediate;
    ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode ? function(fn) {
      GlobalSetImmediate.call(global, fn);
    } : function(fn) {
      ProcessNextTick.call(process, fn);
    };
  } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    nativePromise = NativePromise.resolve();
    schedule = function(fn) {
      nativePromise.then(fn);
    };
  } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
    schedule = function() {
      var div = document.createElement("div");
      var opts = { attributes: true };
      var toggleScheduled = false;
      var div2 = document.createElement("div");
      var o2 = new MutationObserver(function() {
        div.classList.toggle("foo");
        toggleScheduled = false;
      });
      o2.observe(div2, opts);
      var scheduleToggle = function() {
        if (toggleScheduled)
          return;
        toggleScheduled = true;
        div2.classList.toggle("foo");
      };
      return function schedule(fn) {
        var o = new MutationObserver(function() {
          o.disconnect();
          fn();
        });
        o.observe(div, opts);
        scheduleToggle();
      };
    }();
  } else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
      setImmediate(fn);
    };
  } else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
      setTimeout(fn, 0);
    };
  } else {
    schedule = noAsyncScheduler;
  }
  var GlobalSetImmediate;
  var ProcessNextTick;
  var nativePromise;
  module.exports = schedule;
});

// node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS((exports, module) => {
  function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0;j < len; ++j) {
      dst[j + dstIndex] = src[j + srcIndex];
      src[j + srcIndex] = undefined;
    }
  }
  function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
  }
  Queue.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
  };
  Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
  };
  Queue.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
      this._pushOne(fn);
      this._pushOne(receiver);
      this._pushOne(arg);
      return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
  };
  Queue.prototype.shift = function() {
    var front = this._front, ret = this[front];
    this[front] = undefined;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
  };
  Queue.prototype.length = function() {
    return this._length;
  };
  Queue.prototype._checkCapacity = function(size) {
    if (this._capacity < size) {
      this._resizeTo(this._capacity << 1);
    }
  };
  Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
  };
  module.exports = Queue;
});

// node_modules/bluebird/js/release/async.js
var require_async = __commonJS((exports, module) => {
  var firstLineError;
  try {
    throw new Error;
  } catch (e) {
    firstLineError = e;
  }
  var schedule = require_schedule();
  var Queue = require_queue();
  var util = require_util3();
  function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self2 = this;
    this.drainQueues = function() {
      self2._drainQueues();
    };
    this._schedule = schedule;
  }
  Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
  };
  Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  };
  Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
  };
  Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
      this._trampolineEnabled = false;
    }
  };
  Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  };
  Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
      process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + `
`);
      process.exit(2);
    } else {
      this.throwLater(e);
    }
  };
  Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
      arg = fn;
      fn = function() {
        throw arg;
      };
    }
    if (typeof setTimeout !== "undefined") {
      setTimeout(function() {
        fn(arg);
      }, 0);
    } else
      try {
        this._schedule(function() {
          fn(arg);
        });
      } catch (e) {
        throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
      }
  };
  function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
  }
  if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
  } else {
    Async.prototype.invokeLater = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvokeLater.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          setTimeout(function() {
            fn.call(receiver, arg);
          }, 100);
        });
      }
    };
    Async.prototype.invoke = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvoke.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          fn.call(receiver, arg);
        });
      }
    };
    Async.prototype.settlePromises = function(promise) {
      if (this._trampolineEnabled) {
        AsyncSettlePromises.call(this, promise);
      } else {
        this._schedule(function() {
          promise._settlePromises();
        });
      }
    };
  }
  Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
      var fn = queue.shift();
      if (typeof fn !== "function") {
        fn._settlePromises();
        continue;
      }
      var receiver = queue.shift();
      var arg = queue.shift();
      fn.call(receiver, arg);
    }
  };
  Async.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
  };
  Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
      this._isTickUsed = true;
      this._schedule(this.drainQueues);
    }
  };
  Async.prototype._reset = function() {
    this._isTickUsed = false;
  };
  module.exports = Async;
  module.exports.firstLineError = firstLineError;
});

// node_modules/bluebird/js/release/errors.js
var require_errors2 = __commonJS((exports, module) => {
  var es5 = require_es5();
  var Objectfreeze = es5.freeze;
  var util = require_util3();
  var inherits = util.inherits;
  var notEnumerableProp = util.notEnumerableProp;
  function subError(nameProperty, defaultMessage) {
    function SubError(message) {
      if (!(this instanceof SubError))
        return new SubError(message);
      notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
      notEnumerableProp(this, "name", nameProperty);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        Error.call(this);
      }
    }
    inherits(SubError, Error);
    return SubError;
  }
  var _TypeError;
  var _RangeError;
  var Warning = subError("Warning", "warning");
  var CancellationError = subError("CancellationError", "cancellation error");
  var TimeoutError = subError("TimeoutError", "timeout error");
  var AggregateError = subError("AggregateError", "aggregate error");
  try {
    _TypeError = TypeError;
    _RangeError = RangeError;
  } catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
  }
  var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
  for (i = 0;i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
      AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
  }
  var i;
  es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
  });
  AggregateError.prototype["isOperational"] = true;
  var level = 0;
  AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = `
` + indent + "AggregateError of:" + `
`;
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i2 = 0;i2 < this.length; ++i2) {
      var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
      var lines = str.split(`
`);
      for (var j = 0;j < lines.length; ++j) {
        lines[j] = indent + lines[j];
      }
      str = lines.join(`
`);
      ret += str + `
`;
    }
    level--;
    return ret;
  };
  function OperationalError(message) {
    if (!(this instanceof OperationalError))
      return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;
    if (message instanceof Error) {
      notEnumerableProp(this, "message", message.message);
      notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  inherits(OperationalError, Error);
  var errorTypes = Error["__BluebirdErrorTypes__"];
  if (!errorTypes) {
    errorTypes = Objectfreeze({
      CancellationError,
      TimeoutError,
      OperationalError,
      RejectionError: OperationalError,
      AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
      value: errorTypes,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  module.exports = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
  };
});

// node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var util = require_util3();
    var errorObj = util.errorObj;
    var isObject = util.isObject;
    function tryConvertToPromise(obj2, context) {
      if (isObject(obj2)) {
        if (obj2 instanceof Promise2)
          return obj2;
        var then = getThen(obj2);
        if (then === errorObj) {
          if (context)
            context._pushContext();
          var ret = Promise2.reject(then.e);
          if (context)
            context._popContext();
          return ret;
        } else if (typeof then === "function") {
          if (isAnyBluebirdPromise(obj2)) {
            var ret = new Promise2(INTERNAL);
            obj2._then(ret._fulfill, ret._reject, undefined, ret, null);
            return ret;
          }
          return doThenable(obj2, then, context);
        }
      }
      return obj2;
    }
    function doGetThen(obj2) {
      return obj2.then;
    }
    function getThen(obj2) {
      try {
        return doGetThen(obj2);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj2) {
      try {
        return hasProp.call(obj2, "_promise0");
      } catch (e) {
        return false;
      }
    }
    function doThenable(x, then, context) {
      var promise = new Promise2(INTERNAL);
      var ret = promise;
      if (context)
        context._pushContext();
      promise._captureStackTrace();
      if (context)
        context._popContext();
      var synchronous = true;
      var result = util.tryCatch(then).call(x, resolve, reject);
      synchronous = false;
      if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
      }
      function resolve(value) {
        if (!promise)
          return;
        promise._resolveCallback(value);
        promise = null;
      }
      function reject(reason) {
        if (!promise)
          return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
      }
      return ret;
    }
    return tryConvertToPromise;
  };
});

// node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util = require_util3();
    var isArray = util.isArray;
    function toResolutionValue(val) {
      switch (val) {
        case -2:
          return [];
        case -3:
          return {};
      }
    }
    function PromiseArray(values) {
      var promise = this._promise = new Promise2(INTERNAL);
      if (values instanceof Promise2) {
        promise._propagateFrom(values, 3);
      }
      promise._setOnCancel(this);
      this._values = values;
      this._length = 0;
      this._totalResolved = 0;
      this._init(undefined, -2);
    }
    util.inherits(PromiseArray, Proxyable);
    PromiseArray.prototype.length = function() {
      return this._length;
    };
    PromiseArray.prototype.promise = function() {
      return this._promise;
    };
    PromiseArray.prototype._init = function init(_2, resolveValueIfEmpty) {
      var values = tryConvertToPromise(this._values, this._promise);
      if (values instanceof Promise2) {
        values = values._target();
        var bitField = values._bitField;
        this._values = values;
        if ((bitField & 50397184) === 0) {
          this._promise._setAsyncGuaranteed();
          return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
        } else if ((bitField & 33554432) !== 0) {
          values = values._value();
        } else if ((bitField & 16777216) !== 0) {
          return this._reject(values._reason());
        } else {
          return this._cancel();
        }
      }
      values = util.asArray(values);
      if (values === null) {
        var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
        this._promise._rejectCallback(err, false);
        return;
      }
      if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
          this._resolveEmptyArray();
        } else {
          this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
      }
      this._iterate(values);
    };
    PromiseArray.prototype._iterate = function(values) {
      var len = this.getActualLength(values.length);
      this._length = len;
      this._values = this.shouldCopyValues() ? new Array(len) : this._values;
      var result = this._promise;
      var isResolved = false;
      var bitField = null;
      for (var i = 0;i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          bitField = maybePromise._bitField;
        } else {
          bitField = null;
        }
        if (isResolved) {
          if (bitField !== null) {
            maybePromise.suppressUnhandledRejections();
          }
        } else if (bitField !== null) {
          if ((bitField & 50397184) === 0) {
            maybePromise._proxy(this, i);
            this._values[i] = maybePromise;
          } else if ((bitField & 33554432) !== 0) {
            isResolved = this._promiseFulfilled(maybePromise._value(), i);
          } else if ((bitField & 16777216) !== 0) {
            isResolved = this._promiseRejected(maybePromise._reason(), i);
          } else {
            isResolved = this._promiseCancelled(i);
          }
        } else {
          isResolved = this._promiseFulfilled(maybePromise, i);
        }
      }
      if (!isResolved)
        result._setAsyncGuaranteed();
    };
    PromiseArray.prototype._isResolved = function() {
      return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
      this._values = null;
      this._promise._fulfill(value);
    };
    PromiseArray.prototype._cancel = function() {
      if (this._isResolved() || !this._promise._isCancellable())
        return;
      this._values = null;
      this._promise._cancel();
    };
    PromiseArray.prototype._reject = function(reason) {
      this._values = null;
      this._promise._rejectCallback(reason, false);
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    PromiseArray.prototype._promiseCancelled = function() {
      this._cancel();
      return true;
    };
    PromiseArray.prototype._promiseRejected = function(reason) {
      this._totalResolved++;
      this._reject(reason);
      return true;
    };
    PromiseArray.prototype._resultCancelled = function() {
      if (this._isResolved())
        return;
      var values = this._values;
      this._cancel();
      if (values instanceof Promise2) {
        values.cancel();
      } else {
        for (var i = 0;i < values.length; ++i) {
          if (values[i] instanceof Promise2) {
            values[i].cancel();
          }
        }
      }
    };
    PromiseArray.prototype.shouldCopyValues = function() {
      return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
      return len;
    };
    return PromiseArray;
  };
});

// node_modules/bluebird/js/release/context.js
var require_context = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    var longStackTraces = false;
    var contextStack = [];
    Promise2.prototype._promiseCreated = function() {};
    Promise2.prototype._pushContext = function() {};
    Promise2.prototype._popContext = function() {
      return null;
    };
    Promise2._peekContext = Promise2.prototype._peekContext = function() {};
    function Context() {
      this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function() {
      if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
      }
    };
    Context.prototype._popContext = function() {
      if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
      }
      return null;
    };
    function createContext() {
      if (longStackTraces)
        return new Context;
    }
    function peekContext() {
      var lastIndex = contextStack.length - 1;
      if (lastIndex >= 0) {
        return contextStack[lastIndex];
      }
      return;
    }
    Context.CapturedTrace = null;
    Context.create = createContext;
    Context.deactivateLongStackTraces = function() {};
    Context.activateLongStackTraces = function() {
      var Promise_pushContext = Promise2.prototype._pushContext;
      var Promise_popContext = Promise2.prototype._popContext;
      var Promise_PeekContext = Promise2._peekContext;
      var Promise_peekContext = Promise2.prototype._peekContext;
      var Promise_promiseCreated = Promise2.prototype._promiseCreated;
      Context.deactivateLongStackTraces = function() {
        Promise2.prototype._pushContext = Promise_pushContext;
        Promise2.prototype._popContext = Promise_popContext;
        Promise2._peekContext = Promise_PeekContext;
        Promise2.prototype._peekContext = Promise_peekContext;
        Promise2.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
      };
      longStackTraces = true;
      Promise2.prototype._pushContext = Context.prototype._pushContext;
      Promise2.prototype._popContext = Context.prototype._popContext;
      Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
      Promise2.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null)
          ctx._promiseCreated = this;
      };
    };
    return Context;
  };
});

// node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS((exports, module) => {
  module.exports = function(Promise2, Context) {
    var getDomain = Promise2._getDomain;
    var async = Promise2._async;
    var Warning = require_errors2().Warning;
    var util = require_util3();
    var canAttachTrace = util.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
    var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
    var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
    var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    Promise2.prototype.suppressUnhandledRejections = function() {
      var target = this._target();
      target._bitField = target._bitField & ~1048576 | 524288;
    };
    Promise2.prototype._ensurePossibleRejectionHandled = function() {
      if ((this._bitField & 524288) !== 0)
        return;
      this._setRejectionIsUnhandled();
      async.invokeLater(this._notifyUnhandledRejection, this, undefined);
    };
    Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
      fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
    };
    Promise2.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    };
    Promise2.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    };
    Promise2.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
      }
    };
    Promise2.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    };
    Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & ~262144;
    };
    Promise2.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    };
    Promise2.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    };
    Promise2.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & ~1048576;
      if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
      }
    };
    Promise2.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    };
    Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
      return warn(message, shouldUseOwnTrace, promise || this);
    };
    Promise2.onPossiblyUnhandledRejection = function(fn) {
      var domain = getDomain();
      possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
    };
    Promise2.onUnhandledRejectionHandled = function(fn) {
      var domain = getDomain();
      unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
    };
    var disableLongStackTraces = function() {};
    Promise2.longStackTraces = function() {
      if (async.haveItemsQueued() && !config.longStackTraces) {
        throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
      }
      if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
          if (async.haveItemsQueued() && !config.longStackTraces) {
            throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
          }
          Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
          Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
          Context.deactivateLongStackTraces();
          async.enableTrampoline();
          config.longStackTraces = false;
        };
        Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async.disableTrampolineIfNecessary();
      }
    };
    Promise2.hasLongStackTraces = function() {
      return config.longStackTraces && longStackTracesIsSupported();
    };
    var fireDomEvent = function() {
      try {
        if (typeof CustomEvent === "function") {
          var event = new CustomEvent("CustomEvent");
          util.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = new CustomEvent(name.toLowerCase(), {
              detail: event2,
              cancelable: true
            });
            return !util.global.dispatchEvent(domEvent);
          };
        } else if (typeof Event === "function") {
          var event = new Event("CustomEvent");
          util.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = new Event(name.toLowerCase(), {
              cancelable: true
            });
            domEvent.detail = event2;
            return !util.global.dispatchEvent(domEvent);
          };
        } else {
          var event = document.createEvent("CustomEvent");
          event.initCustomEvent("testingtheevent", false, true, {});
          util.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = document.createEvent("CustomEvent");
            domEvent.initCustomEvent(name.toLowerCase(), false, true, event2);
            return !util.global.dispatchEvent(domEvent);
          };
        }
      } catch (e) {}
      return function() {
        return false;
      };
    }();
    var fireGlobalEvent = function() {
      if (util.isNode) {
        return function() {
          return process.emit.apply(process, arguments);
        };
      } else {
        if (!util.global) {
          return function() {
            return false;
          };
        }
        return function(name) {
          var methodName = "on" + name.toLowerCase();
          var method = util.global[methodName];
          if (!method)
            return false;
          method.apply(util.global, [].slice.call(arguments, 1));
          return true;
        };
      }
    }();
    function generatePromiseLifecycleEventObject(name, promise) {
      return { promise };
    }
    var eventToObjectGenerator = {
      promiseCreated: generatePromiseLifecycleEventObject,
      promiseFulfilled: generatePromiseLifecycleEventObject,
      promiseRejected: generatePromiseLifecycleEventObject,
      promiseResolved: generatePromiseLifecycleEventObject,
      promiseCancelled: generatePromiseLifecycleEventObject,
      promiseChained: function(name, promise, child) {
        return { promise, child };
      },
      warning: function(name, warning) {
        return { warning };
      },
      unhandledRejection: function(name, reason, promise) {
        return { reason, promise };
      },
      rejectionHandled: generatePromiseLifecycleEventObject
    };
    var activeFireEvent = function(name) {
      var globalEventFired = false;
      try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
      } catch (e) {
        async.throwLater(e);
        globalEventFired = true;
      }
      var domEventFired = false;
      try {
        domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
      } catch (e) {
        async.throwLater(e);
        domEventFired = true;
      }
      return domEventFired || globalEventFired;
    };
    Promise2.config = function(opts) {
      opts = Object(opts);
      if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
          Promise2.longStackTraces();
        } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
          disableLongStackTraces();
        }
      }
      if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;
        if (util.isObject(warningsOption)) {
          if ("wForgottenReturn" in warningsOption) {
            wForgottenReturn = !!warningsOption.wForgottenReturn;
          }
        }
      }
      if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async.haveItemsQueued()) {
          throw new Error("cannot enable cancellation after promises are in use");
        }
        Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
        Promise2.prototype._propagateFrom = cancellationPropagateFrom;
        Promise2.prototype._onCancel = cancellationOnCancel;
        Promise2.prototype._setOnCancel = cancellationSetOnCancel;
        Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
        Promise2.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
      }
      if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
          config.monitoring = true;
          Promise2.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
          config.monitoring = false;
          Promise2.prototype._fireEvent = defaultFireEvent;
        }
      }
      return Promise2;
    };
    function defaultFireEvent() {
      return false;
    }
    Promise2.prototype._fireEvent = defaultFireEvent;
    Promise2.prototype._execute = function(executor, resolve, reject) {
      try {
        executor(resolve, reject);
      } catch (e) {
        return e;
      }
    };
    Promise2.prototype._onCancel = function() {};
    Promise2.prototype._setOnCancel = function(handler) {};
    Promise2.prototype._attachCancellationCallback = function(onCancel) {};
    Promise2.prototype._captureStackTrace = function() {};
    Promise2.prototype._attachExtraTrace = function() {};
    Promise2.prototype._clearCancellationData = function() {};
    Promise2.prototype._propagateFrom = function(parent, flags) {};
    function cancellationExecute(executor, resolve, reject) {
      var promise = this;
      try {
        executor(resolve, reject, function(onCancel) {
          if (typeof onCancel !== "function") {
            throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
          }
          promise._attachCancellationCallback(onCancel);
        });
      } catch (e) {
        return e;
      }
    }
    function cancellationAttachCancellationCallback(onCancel) {
      if (!this._isCancellable())
        return this;
      var previousOnCancel = this._onCancel();
      if (previousOnCancel !== undefined) {
        if (util.isArray(previousOnCancel)) {
          previousOnCancel.push(onCancel);
        } else {
          this._setOnCancel([previousOnCancel, onCancel]);
        }
      } else {
        this._setOnCancel(onCancel);
      }
    }
    function cancellationOnCancel() {
      return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
      this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
      this._cancellationParent = undefined;
      this._onCancelField = undefined;
    }
    function cancellationPropagateFrom(parent, flags) {
      if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
          branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
      }
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    function bindingPropagateFrom(parent, flags) {
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    var propagateFromFunction = bindingPropagateFrom;
    function boundValueFunction() {
      var ret = this._boundTo;
      if (ret !== undefined) {
        if (ret instanceof Promise2) {
          if (ret.isFulfilled()) {
            return ret.value();
          } else {
            return;
          }
        }
      }
      return ret;
    }
    function longStackTracesCaptureStackTrace() {
      this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
      if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
          if (ignoreSelf)
            trace = trace._parent;
        }
        if (trace !== undefined) {
          trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
          var parsed = parseStackAndMessage(error);
          util.notEnumerableProp(error, "stack", parsed.message + `
` + parsed.stack.join(`
`));
          util.notEnumerableProp(error, "__stackCleaned__", true);
        }
      }
    }
    function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
      if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
        if (parent !== undefined && parent._returnedNonUndefined())
          return;
        if ((promise._bitField & 65535) === 0)
          return;
        if (name)
          name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
          var traceLines = promiseCreated._trace.stack.split(`
`);
          var stack = cleanStack(traceLines);
          for (var i = stack.length - 1;i >= 0; --i) {
            var line = stack[i];
            if (!nodeFramePattern.test(line)) {
              var lineMatches = line.match(parseLinePattern);
              if (lineMatches) {
                handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
              }
              break;
            }
          }
          if (stack.length > 0) {
            var firstUserLine = stack[0];
            for (var i = 0;i < traceLines.length; ++i) {
              if (traceLines[i] === firstUserLine) {
                if (i > 0) {
                  creatorLine = `
` + traceLines[i - 1];
                }
                break;
              }
            }
          }
        }
        var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, " + "see http://goo.gl/rRqMUw" + creatorLine;
        promise._warn(msg, true, promiseCreated);
      }
    }
    function deprecated(name, replacement) {
      var message = name + " is deprecated and will be removed in a future version.";
      if (replacement)
        message += " Use " + replacement + " instead.";
      return warn(message);
    }
    function warn(message, shouldUseOwnTrace, promise) {
      if (!config.warnings)
        return;
      var warning = new Warning(message);
      var ctx;
      if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
      } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
        ctx.attachExtraTrace(warning);
      } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + `
` + parsed.stack.join(`
`);
      }
      if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
      }
    }
    function reconstructStack(message, stacks) {
      for (var i = 0;i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join(`
`);
      }
      if (i < stacks.length) {
        stacks[i] = stacks[i].join(`
`);
      }
      return message + `
` + stacks.join(`
`);
    }
    function removeDuplicateOrEmptyJumps(stacks) {
      for (var i = 0;i < stacks.length; ++i) {
        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
          stacks.splice(i, 1);
          i--;
        }
      }
    }
    function removeCommonRoots(stacks) {
      var current = stacks[0];
      for (var i = 1;i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;
        for (var j = prev.length - 1;j >= 0; --j) {
          if (prev[j] === currentLastLine) {
            commonRootMeetPoint = j;
            break;
          }
        }
        for (var j = commonRootMeetPoint;j >= 0; --j) {
          var line = prev[j];
          if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
          } else {
            break;
          }
        }
        current = prev;
      }
    }
    function cleanStack(stack) {
      var ret = [];
      for (var i = 0;i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = line === "    (No stack trace)" || stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
          if (indentStackFrames && line.charAt(0) !== " ") {
            line = "    " + line;
          }
          ret.push(line);
        }
      }
      return ret;
    }
    function stackFramesAsArray(error) {
      var stack = error.stack.replace(/\s+$/g, "").split(`
`);
      for (var i = 0;i < stack.length; ++i) {
        var line = stack[i];
        if (line === "    (No stack trace)" || stackFramePattern.test(line)) {
          break;
        }
      }
      if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
      }
      return stack;
    }
    function parseStackAndMessage(error) {
      var stack = error.stack;
      var message = error.toString();
      stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
      return {
        message,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
      };
    }
    function formatAndLogError(error, title, isSoft) {
      if (typeof console !== "undefined") {
        var message;
        if (util.isObject(error)) {
          var stack = error.stack;
          message = title + formatStack(stack, error);
        } else {
          message = title + String(error);
        }
        if (typeof printWarning === "function") {
          printWarning(message, isSoft);
        } else if (typeof console.log === "function" || typeof console.log === "object") {
          console.log(message);
        }
      }
    }
    function fireRejectionEvent(name, localHandler, reason, promise) {
      var localEventFired = false;
      try {
        if (typeof localHandler === "function") {
          localEventFired = true;
          if (name === "rejectionHandled") {
            localHandler(promise);
          } else {
            localHandler(reason, promise);
          }
        }
      } catch (e) {
        async.throwLater(e);
      }
      if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
          formatAndLogError(reason, "Unhandled rejection ");
        }
      } else {
        activeFireEvent(name, promise);
      }
    }
    function formatNonError(obj2) {
      var str;
      if (typeof obj2 === "function") {
        str = "[function " + (obj2.name || "anonymous") + "]";
      } else {
        str = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util.toString(obj2);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
          try {
            var newStr = JSON.stringify(obj2);
            str = newStr;
          } catch (e) {}
        }
        if (str.length === 0) {
          str = "(empty array)";
        }
      }
      return "(<" + snip(str) + ">, no stack trace)";
    }
    function snip(str) {
      var maxChars = 41;
      if (str.length < maxChars) {
        return str;
      }
      return str.substr(0, maxChars - 3) + "...";
    }
    function longStackTracesIsSupported() {
      return typeof captureStackTrace === "function";
    }
    var shouldIgnore = function() {
      return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
      var matches = line.match(parseLineInfoRegex);
      if (matches) {
        return {
          fileName: matches[1],
          line: parseInt(matches[2], 10)
        };
      }
    }
    function setBounds(firstLineError, lastLineError) {
      if (!longStackTracesIsSupported())
        return;
      var firstStackLines = firstLineError.stack.split(`
`);
      var lastStackLines = lastLineError.stack.split(`
`);
      var firstIndex = -1;
      var lastIndex = -1;
      var firstFileName;
      var lastFileName;
      for (var i = 0;i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
          firstFileName = result.fileName;
          firstIndex = result.line;
          break;
        }
      }
      for (var i = 0;i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
          lastFileName = result.fileName;
          lastIndex = result.line;
          break;
        }
      }
      if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
      }
      shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line))
          return true;
        var info = parseLineInfo(line);
        if (info) {
          if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
            return true;
          }
        }
        return false;
      };
    }
    function CapturedTrace(parent) {
      this._parent = parent;
      this._promisesCreated = 0;
      var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
      captureStackTrace(this, CapturedTrace);
      if (length > 32)
        this.uncycle();
    }
    util.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;
    CapturedTrace.prototype.uncycle = function() {
      var length = this._length;
      if (length < 2)
        return;
      var nodes = [];
      var stackToIndex = {};
      for (var i = 0, node = this;node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
      }
      length = this._length = i;
      for (var i = length - 1;i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
          stackToIndex[stack] = i;
        }
      }
      for (var i = 0;i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
          if (index > 0) {
            nodes[index - 1]._parent = undefined;
            nodes[index - 1]._length = 1;
          }
          nodes[i]._parent = undefined;
          nodes[i]._length = 1;
          var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
          if (index < length - 1) {
            cycleEdgeNode._parent = nodes[index + 1];
            cycleEdgeNode._parent.uncycle();
            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
          } else {
            cycleEdgeNode._parent = undefined;
            cycleEdgeNode._length = 1;
          }
          var currentChildLength = cycleEdgeNode._length + 1;
          for (var j = i - 2;j >= 0; --j) {
            nodes[j]._length = currentChildLength;
            currentChildLength++;
          }
          return;
        }
      }
    };
    CapturedTrace.prototype.attachExtraTrace = function(error) {
      if (error.__stackCleaned__)
        return;
      this.uncycle();
      var parsed = parseStackAndMessage(error);
      var message = parsed.message;
      var stacks = [parsed.stack];
      var trace = this;
      while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split(`
`)));
        trace = trace._parent;
      }
      removeCommonRoots(stacks);
      removeDuplicateOrEmptyJumps(stacks);
      util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
      util.notEnumerableProp(error, "__stackCleaned__", true);
    };
    var captureStackTrace = function stackDetection() {
      var v8stackFramePattern = /^\s*at\s*/;
      var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string")
          return stack;
        if (error.name !== undefined && error.message !== undefined) {
          return error.toString();
        }
        return formatNonError(error);
      };
      if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace2 = Error.captureStackTrace;
        shouldIgnore = function(line) {
          return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
          Error.stackTraceLimit += 6;
          captureStackTrace2(receiver, ignoreUntil);
          Error.stackTraceLimit -= 6;
        };
      }
      var err = new Error;
      if (typeof err.stack === "string" && err.stack.split(`
`)[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
          o.stack = new Error().stack;
        };
      }
      var hasStackAfterThrow;
      try {
        throw new Error;
      } catch (e) {
        hasStackAfterThrow = "stack" in e;
      }
      if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
          Error.stackTraceLimit += 6;
          try {
            throw new Error;
          } catch (e) {
            o.stack = e.stack;
          }
          Error.stackTraceLimit -= 6;
        };
      }
      formatStack = function(stack, error) {
        if (typeof stack === "string")
          return stack;
        if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
          return error.toString();
        }
        return formatNonError(error);
      };
      return null;
    }([]);
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
      printWarning = function(message) {
        console.warn(message);
      };
      if (util.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
          var color = isSoft ? "\x1B[33m" : "\x1B[31m";
          console.warn(color + message + `\x1B[0m
`);
        };
      } else if (!util.isNode && typeof new Error().stack === "string") {
        printWarning = function(message, isSoft) {
          console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
        };
      }
    }
    var config = {
      warnings,
      longStackTraces: false,
      cancellation: false,
      monitoring: false
    };
    if (longStackTraces)
      Promise2.longStackTraces();
    return {
      longStackTraces: function() {
        return config.longStackTraces;
      },
      warnings: function() {
        return config.warnings;
      },
      cancellation: function() {
        return config.cancellation;
      },
      monitoring: function() {
        return config.monitoring;
      },
      propagateFromFunction: function() {
        return propagateFromFunction;
      },
      boundValueFunction: function() {
        return boundValueFunction;
      },
      checkForgottenReturns,
      setBounds,
      warn,
      deprecated,
      CapturedTrace,
      fireDomEvent,
      fireGlobalEvent
    };
  };
});

// node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS((exports, module) => {
  module.exports = function(Promise2, tryConvertToPromise) {
    var util = require_util3();
    var CancellationError = Promise2.CancellationError;
    var errorObj = util.errorObj;
    function PassThroughHandlerContext(promise, type, handler) {
      this.promise = promise;
      this.type = type;
      this.handler = handler;
      this.called = false;
      this.cancelPromise = null;
    }
    PassThroughHandlerContext.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function FinallyHandlerCancelReaction(finallyHandler2) {
      this.finallyHandler = finallyHandler2;
    }
    FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
      checkCancel(this.finallyHandler);
    };
    function checkCancel(ctx, reason) {
      if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
          ctx.cancelPromise._reject(reason);
        } else {
          ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
      }
      return false;
    }
    function succeed() {
      return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
      if (checkCancel(this, reason))
        return;
      errorObj.e = reason;
      return errorObj;
    }
    function finallyHandler(reasonOrValue) {
      var promise = this.promise;
      var handler = this.handler;
      if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
        if (ret !== undefined) {
          promise._setReturnedNonUndefined();
          var maybePromise = tryConvertToPromise(ret, promise);
          if (maybePromise instanceof Promise2) {
            if (this.cancelPromise != null) {
              if (maybePromise._isCancelled()) {
                var reason = new CancellationError("late cancellation observer");
                promise._attachExtraTrace(reason);
                errorObj.e = reason;
                return errorObj;
              } else if (maybePromise.isPending()) {
                maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
              }
            }
            return maybePromise._then(succeed, fail, undefined, this, undefined);
          }
        }
      }
      if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
      } else {
        checkCancel(this);
        return reasonOrValue;
      }
    }
    Promise2.prototype._passThrough = function(handler, type, success, fail2) {
      if (typeof handler !== "function")
        return this.then();
      return this._then(success, fail2, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
    };
    Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
      return this._passThrough(handler, 0, finallyHandler, finallyHandler);
    };
    Promise2.prototype.tap = function(handler) {
      return this._passThrough(handler, 1, finallyHandler);
    };
    return PassThroughHandlerContext;
  };
});

// node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS((exports, module) => {
  module.exports = function(NEXT_FILTER) {
    var util = require_util3();
    var getKeys = require_es5().keys;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    function catchFilter(instances, cb, promise) {
      return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop:
          for (var i = 0;i < instances.length; ++i) {
            var item = instances[i];
            if (item === Error || item != null && item.prototype instanceof Error) {
              if (e instanceof item) {
                return tryCatch(cb).call(boundTo, e);
              }
            } else if (typeof item === "function") {
              var matchesPredicate = tryCatch(item).call(boundTo, e);
              if (matchesPredicate === errorObj) {
                return matchesPredicate;
              } else if (matchesPredicate) {
                return tryCatch(cb).call(boundTo, e);
              }
            } else if (util.isObject(e)) {
              var keys = getKeys(item);
              for (var j = 0;j < keys.length; ++j) {
                var key2 = keys[j];
                if (item[key2] != e[key2]) {
                  continue predicateLoop;
                }
              }
              return tryCatch(cb).call(boundTo, e);
            }
          }
        return NEXT_FILTER;
      };
    }
    return catchFilter;
  };
});

// node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS((exports, module) => {
  var util = require_util3();
  var maybeWrapAsError = util.maybeWrapAsError;
  var errors = require_errors2();
  var OperationalError = errors.OperationalError;
  var es5 = require_es5();
  function isUntypedError(obj2) {
    return obj2 instanceof Error && es5.getPrototypeOf(obj2) === Error.prototype;
  }
  var rErrorKey = /^(?:name|message|stack|cause)$/;
  function wrapAsOperationalError(obj2) {
    var ret;
    if (isUntypedError(obj2)) {
      ret = new OperationalError(obj2);
      ret.name = obj2.name;
      ret.message = obj2.message;
      ret.stack = obj2.stack;
      var keys = es5.keys(obj2);
      for (var i = 0;i < keys.length; ++i) {
        var key2 = keys[i];
        if (!rErrorKey.test(key2)) {
          ret[key2] = obj2[key2];
        }
      }
      return ret;
    }
    util.markAsOriginatingFromRejection(obj2);
    return obj2;
  }
  function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
      if (promise === null)
        return;
      if (err) {
        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
        promise._attachExtraTrace(wrapped);
        promise._reject(wrapped);
      } else if (!multiArgs) {
        promise._fulfill(value);
      } else {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1;$_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        promise._fulfill(args);
      }
      promise = null;
    };
  }
  module.exports = nodebackForPromise;
});

// node_modules/bluebird/js/release/method.js
var require_method = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util = require_util3();
    var tryCatch = util.tryCatch;
    Promise2.method = function(fn) {
      if (typeof fn !== "function") {
        throw new Promise2.TypeError("expecting a function but got " + util.classString(fn));
      }
      return function() {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
      };
    };
    Promise2.attempt = Promise2["try"] = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
      }
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._pushContext();
      var value;
      if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
      } else {
        value = tryCatch(fn)();
      }
      var promiseCreated = ret._popContext();
      debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);
      ret._resolveFromSyncValue(value);
      return ret;
    };
    Promise2.prototype._resolveFromSyncValue = function(value) {
      if (value === util.errorObj) {
        this._rejectCallback(value.e, false);
      } else {
        this._resolveCallback(value, true);
      }
    };
  };
});

// node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function(_2, e) {
      this._reject(e);
    };
    var targetRejected = function(e, context) {
      context.promiseRejectionQueued = true;
      context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context) {
      if ((this._bitField & 50397184) === 0) {
        this._resolveCallback(context.target);
      }
    };
    var bindingRejected = function(e, context) {
      if (!context.promiseRejectionQueued)
        this._reject(e);
    };
    Promise2.prototype.bind = function(thisArg) {
      if (!calledBind) {
        calledBind = true;
        Promise2.prototype._propagateFrom = debug.propagateFromFunction();
        Promise2.prototype._boundValue = debug.boundValueFunction();
      }
      var maybePromise = tryConvertToPromise(thisArg);
      var ret = new Promise2(INTERNAL);
      ret._propagateFrom(this, 1);
      var target = this._target();
      ret._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        var context = {
          promiseRejectionQueued: false,
          promise: ret,
          target,
          bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context);
        maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);
        ret._setOnCancel(maybePromise);
      } else {
        ret._resolveCallback(target);
      }
      return ret;
    };
    Promise2.prototype._setBoundTo = function(obj2) {
      if (obj2 !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj2;
      } else {
        this._bitField = this._bitField & ~2097152;
      }
    };
    Promise2.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    };
    Promise2.bind = function(thisArg, value) {
      return Promise2.resolve(value).bind(thisArg);
    };
  };
});

// node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection, debug) {
    var util = require_util3();
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise2._async;
    Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
      if (!debug.cancellation())
        return this._warn("cancellation is disabled");
      var promise = this;
      var child = promise;
      while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
          if (child._isFollowing()) {
            child._followee().cancel();
          } else {
            child._cancelBranched();
          }
          break;
        }
        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
          if (promise._isFollowing()) {
            promise._followee().cancel();
          } else {
            promise._cancelBranched();
          }
          break;
        } else {
          if (promise._isFollowing())
            promise._followee().cancel();
          promise._setWillBeCancelled();
          child = promise;
          promise = parent;
        }
      }
    };
    Promise2.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    };
    Promise2.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
    };
    Promise2.prototype._cancelBy = function(canceller) {
      if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
      } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
          this._invokeOnCancel();
          return true;
        }
      }
      return false;
    };
    Promise2.prototype._cancelBranched = function() {
      if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
      }
    };
    Promise2.prototype._cancel = function() {
      if (!this._isCancellable())
        return;
      this._setCancelled();
      async.invoke(this._cancelPromises, this, undefined);
    };
    Promise2.prototype._cancelPromises = function() {
      if (this._length() > 0)
        this._settlePromises();
    };
    Promise2.prototype._unsetOnCancel = function() {
      this._onCancelField = undefined;
    };
    Promise2.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    };
    Promise2.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    };
    Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
      if (util.isArray(onCancelCallback)) {
        for (var i = 0;i < onCancelCallback.length; ++i) {
          this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
      } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === "function") {
          if (!internalOnly) {
            var e = tryCatch(onCancelCallback).call(this._boundValue());
            if (e === errorObj) {
              this._attachExtraTrace(e.e);
              async.throwLater(e.e);
            }
          }
        } else {
          onCancelCallback._resultCancelled(this);
        }
      }
    };
    Promise2.prototype._invokeOnCancel = function() {
      var onCancelCallback = this._onCancel();
      this._unsetOnCancel();
      async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };
    Promise2.prototype._invokeInternalOnCancel = function() {
      if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
      }
    };
    Promise2.prototype._resultCancelled = function() {
      this.cancel();
    };
  };
});

// node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    function returner() {
      return this.value;
    }
    function thrower() {
      throw this.reason;
    }
    Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
      if (value instanceof Promise2)
        value.suppressUnhandledRejections();
      return this._then(returner, undefined, undefined, { value }, undefined);
    };
    Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
      return this._then(thrower, undefined, undefined, { reason }, undefined);
    };
    Promise2.prototype.catchThrow = function(reason) {
      if (arguments.length <= 1) {
        return this._then(undefined, thrower, undefined, { reason }, undefined);
      } else {
        var _reason = arguments[1];
        var handler = function() {
          throw _reason;
        };
        return this.caught(reason, handler);
      }
    };
    Promise2.prototype.catchReturn = function(value) {
      if (arguments.length <= 1) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(undefined, returner, undefined, { value }, undefined);
      } else {
        var _value = arguments[1];
        if (_value instanceof Promise2)
          _value.suppressUnhandledRejections();
        var handler = function() {
          return _value;
        };
        return this.caught(value, handler);
      }
    };
  };
});

// node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    function PromiseInspection(promise) {
      if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
      } else {
        this._bitField = 0;
        this._settledValueField = undefined;
      }
    }
    PromiseInspection.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
      if (!this.isFulfilled()) {
        throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
      }
      return this._settledValue();
    };
    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
      if (!this.isRejected()) {
        throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
      }
      return this._settledValue();
    };
    var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    };
    var isRejected = PromiseInspection.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    };
    var isPending = PromiseInspection.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    };
    var isResolved = PromiseInspection.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    PromiseInspection.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    };
    Promise2.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    };
    Promise2.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    };
    Promise2.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    };
    Promise2.prototype.isPending = function() {
      return isPending.call(this._target());
    };
    Promise2.prototype.isRejected = function() {
      return isRejected.call(this._target());
    };
    Promise2.prototype.isFulfilled = function() {
      return isFulfilled.call(this._target());
    };
    Promise2.prototype.isResolved = function() {
      return isResolved.call(this._target());
    };
    Promise2.prototype.value = function() {
      return value.call(this._target());
    };
    Promise2.prototype.reason = function() {
      var target = this._target();
      target._unsetRejectionIsUnhandled();
      return reason.call(target);
    };
    Promise2.prototype._value = function() {
      return this._settledValue();
    };
    Promise2.prototype._reason = function() {
      this._unsetRejectionIsUnhandled();
      return this._settledValue();
    };
    Promise2.PromiseInspection = PromiseInspection;
  };
});

// node_modules/bluebird/js/release/join.js
var require_join = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
    var util = require_util3();
    var canEvaluate = util.canEvaluate;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var reject;
    if (true) {
      if (canEvaluate) {
        var thenCallback = function(i2) {
          return new Function("value", "holder", `                             
            'use strict';                                                    
            holder.pIndex = value;                                           
            holder.checkFulfillment(this);                                   
            `.replace(/Index/g, i2));
        };
        var promiseSetter = function(i2) {
          return new Function("promise", "holder", `                           
            'use strict';                                                    
            holder.pIndex = promise;                                         
            `.replace(/Index/g, i2));
        };
        var generateHolderClass = function(total) {
          var props = new Array(total);
          for (var i2 = 0;i2 < props.length; ++i2) {
            props[i2] = "this.p" + (i2 + 1);
          }
          var assignment = props.join(" = ") + " = null;";
          var cancellationCode = `var promise;
` + props.map(function(prop) {
            return `                                                         
                promise = ` + prop + `;                                      
                if (promise instanceof Promise) {                            
                    promise.cancel();                                        
                }                                                            
            `;
          }).join(`
`);
          var passedArguments = props.join(", ");
          var name = "Holder$" + total;
          var code = `return function(tryCatch, errorObj, Promise, async) {    
            'use strict';                                                    
            function [TheName](fn) {                                         
                [TheProperties]                                              
                this.fn = fn;                                                
                this.asyncNeeded = true;                                     
                this.now = 0;                                                
            }                                                                
                                                                             
            [TheName].prototype._callFunction = function(promise) {          
                promise._pushContext();                                      
                var ret = tryCatch(this.fn)([ThePassedArguments]);           
                promise._popContext();                                       
                if (ret === errorObj) {                                      
                    promise._rejectCallback(ret.e, false);                   
                } else {                                                     
                    promise._resolveCallback(ret);                           
                }                                                            
            };                                                               
                                                                             
            [TheName].prototype.checkFulfillment = function(promise) {       
                var now = ++this.now;                                        
                if (now === [TheTotal]) {                                    
                    if (this.asyncNeeded) {                                  
                        async.invoke(this._callFunction, this, promise);     
                    } else {                                                 
                        this._callFunction(promise);                         
                    }                                                        
                                                                             
                }                                                            
            };                                                               
                                                                             
            [TheName].prototype._resultCancelled = function() {              
                [CancellationCode]                                           
            };                                                               
                                                                             
            return [TheName];                                                
        }(tryCatch, errorObj, Promise, async);                               
        `;
          code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
          return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise2, async);
        };
        var holderClasses = [];
        var thenCallbacks = [];
        var promiseSetters = [];
        for (var i = 0;i < 8; ++i) {
          holderClasses.push(generateHolderClass(i + 1));
          thenCallbacks.push(thenCallback(i + 1));
          promiseSetters.push(promiseSetter(i + 1));
        }
        reject = function(reason) {
          this._reject(reason);
        };
      }
    }
    Promise2.join = function() {
      var last = arguments.length - 1;
      var fn;
      if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (true) {
          if (last <= 8 && canEvaluate) {
            var ret = new Promise2(INTERNAL);
            ret._captureStackTrace();
            var HolderClass = holderClasses[last - 1];
            var holder = new HolderClass(fn);
            var callbacks = thenCallbacks;
            for (var i2 = 0;i2 < last; ++i2) {
              var maybePromise = tryConvertToPromise(arguments[i2], ret);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                if ((bitField & 50397184) === 0) {
                  maybePromise._then(callbacks[i2], reject, undefined, ret, holder);
                  promiseSetters[i2](maybePromise, holder);
                  holder.asyncNeeded = false;
                } else if ((bitField & 33554432) !== 0) {
                  callbacks[i2].call(ret, maybePromise._value(), holder);
                } else if ((bitField & 16777216) !== 0) {
                  ret._reject(maybePromise._reason());
                } else {
                  ret._cancel();
                }
              } else {
                callbacks[i2].call(ret, maybePromise, holder);
              }
            }
            if (!ret._isFateSealed()) {
              if (holder.asyncNeeded) {
                var domain = getDomain();
                if (domain !== null) {
                  holder.fn = util.domainBind(domain, holder.fn);
                }
              }
              ret._setAsyncGuaranteed();
              ret._setOnCancel(holder);
            }
            return ret;
          }
        }
      }
      var $_len = arguments.length;
      var args = new Array($_len);
      for (var $_i = 0;$_i < $_len; ++$_i) {
        args[$_i] = arguments[$_i];
      }
      if (fn)
        args.pop();
      var ret = new PromiseArray(args).promise();
      return fn !== undefined ? ret.spread(fn) : ret;
    };
  };
});

// node_modules/bluebird/js/release/map.js
var require_map = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise2._getDomain;
    var util = require_util3();
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise2._async;
    function MappingPromiseArray(promises, fn, limit, _filter) {
      this.constructor$(promises);
      this._promise._captureStackTrace();
      var domain = getDomain();
      this._callback = domain === null ? fn : util.domainBind(domain, fn);
      this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
      this._limit = limit;
      this._inFlight = 0;
      this._queue = [];
      async.invoke(this._asyncInit, this, undefined);
    }
    util.inherits(MappingPromiseArray, PromiseArray);
    MappingPromiseArray.prototype._asyncInit = function() {
      this._init$(undefined, -2);
    };
    MappingPromiseArray.prototype._init = function() {};
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var values = this._values;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var limit = this._limit;
      if (index < 0) {
        index = index * -1 - 1;
        values[index] = value;
        if (limit >= 1) {
          this._inFlight--;
          this._drainQueue();
          if (this._isResolved())
            return true;
        }
      } else {
        if (limit >= 1 && this._inFlight >= limit) {
          values[index] = value;
          this._queue.push(index);
          return false;
        }
        if (preservedValues !== null)
          preservedValues[index] = value;
        var promise = this._promise;
        var callback = this._callback;
        var receiver = promise._boundValue();
        promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
        if (ret === errorObj) {
          this._reject(ret.e);
          return true;
        }
        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          if ((bitField & 50397184) === 0) {
            if (limit >= 1)
              this._inFlight++;
            values[index] = maybePromise;
            maybePromise._proxy(this, (index + 1) * -1);
            return false;
          } else if ((bitField & 33554432) !== 0) {
            ret = maybePromise._value();
          } else if ((bitField & 16777216) !== 0) {
            this._reject(maybePromise._reason());
            return true;
          } else {
            this._cancel();
            return true;
          }
        }
        values[index] = ret;
      }
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= length) {
        if (preservedValues !== null) {
          this._filter(values, preservedValues);
        } else {
          this._resolve(values);
        }
        return true;
      }
      return false;
    };
    MappingPromiseArray.prototype._drainQueue = function() {
      var queue = this._queue;
      var limit = this._limit;
      var values = this._values;
      while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved())
          return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
      }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values) {
      var len = values.length;
      var ret = new Array(len);
      var j = 0;
      for (var i = 0;i < len; ++i) {
        if (booleans[i])
          ret[j++] = values[i];
      }
      ret.length = j;
      this._resolve(ret);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function map(promises, fn, options, _filter) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
      }
      var limit = 0;
      if (options !== undefined) {
        if (typeof options === "object" && options !== null) {
          if (typeof options.concurrency !== "number") {
            return Promise2.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
          }
          limit = options.concurrency;
        } else {
          return Promise2.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
        }
      }
      limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
      return new MappingPromiseArray(promises, fn, limit, _filter).promise();
    }
    Promise2.prototype.map = function(fn, options) {
      return map(this, fn, options, null);
    };
    Promise2.map = function(promises, fn, options, _filter) {
      return map(promises, fn, options, _filter);
    };
  };
});

// node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS((exports, module) => {
  var cr = Object.create;
  if (cr) {
    callerCache = cr(null);
    getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
  }
  var callerCache;
  var getterCache;
  module.exports = function(Promise2) {
    var util = require_util3();
    var canEvaluate = util.canEvaluate;
    var isIdentifier = util.isIdentifier;
    var getMethodCaller;
    var getGetter;
    if (true) {
      var makeMethodCaller = function(methodName) {
        return new Function("ensureMethod", `                                    
        return function(obj) {                                               
            'use strict'                                                     
            var len = this.length;                                           
            ensureMethod(obj, 'methodName');                                 
            switch(len) {                                                    
                case 1: return obj.methodName(this[0]);                      
                case 2: return obj.methodName(this[0], this[1]);             
                case 3: return obj.methodName(this[0], this[1], this[2]);    
                case 0: return obj.methodName();                             
                default:                                                     
                    return obj.methodName.apply(obj, this);                  
            }                                                                
        };                                                                   
        `.replace(/methodName/g, methodName))(ensureMethod);
      };
      var makeGetter = function(propertyName) {
        return new Function("obj", `                                             
        'use strict';                                                        
        return obj.propertyName;                                             
        `.replace("propertyName", propertyName));
      };
      var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
          if (!isIdentifier(name)) {
            return null;
          }
          ret = compiler(name);
          cache[name] = ret;
          cache[" size"]++;
          if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0;i < 256; ++i)
              delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
          }
        }
        return ret;
      };
      getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
      };
      getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
      };
    }
    function ensureMethod(obj2, methodName) {
      var fn;
      if (obj2 != null)
        fn = obj2[methodName];
      if (typeof fn !== "function") {
        var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
        throw new Promise2.TypeError(message);
      }
      return fn;
    }
    function caller(obj2) {
      var methodName = this.pop();
      var fn = ensureMethod(obj2, methodName);
      return fn.apply(obj2, this);
    }
    Promise2.prototype.call = function(methodName) {
      var $_len = arguments.length;
      var args = new Array(Math.max($_len - 1, 0));
      for (var $_i = 1;$_i < $_len; ++$_i) {
        args[$_i - 1] = arguments[$_i];
      }
      if (true) {
        if (canEvaluate) {
          var maybeCaller = getMethodCaller(methodName);
          if (maybeCaller !== null) {
            return this._then(maybeCaller, undefined, undefined, args, undefined);
          }
        }
      }
      args.push(methodName);
      return this._then(caller, undefined, undefined, args, undefined);
    };
    function namedGetter(obj2) {
      return obj2[this];
    }
    function indexedGetter(obj2) {
      var index = +this;
      if (index < 0)
        index = Math.max(0, index + obj2.length);
      return obj2[index];
    }
    Promise2.prototype.get = function(propertyName) {
      var isIndex = typeof propertyName === "number";
      var getter;
      if (!isIndex) {
        if (canEvaluate) {
          var maybeGetter = getGetter(propertyName);
          getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
          getter = namedGetter;
        }
      } else {
        getter = indexedGetter;
      }
      return this._then(getter, undefined, undefined, propertyName, undefined);
    };
  };
});

// node_modules/bluebird/js/release/using.js
var require_using = __commonJS((exports, module) => {
  module.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util = require_util3();
    var TypeError2 = require_errors2().TypeError;
    var inherits = require_util3().inherits;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var NULL = {};
    function thrower(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function castPreservingDisposable(thenable) {
      var maybePromise = tryConvertToPromise(thenable);
      if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
        maybePromise._setDisposable(thenable._getDisposer());
      }
      return maybePromise;
    }
    function dispose(resources, inspection) {
      var i = 0;
      var len = resources.length;
      var ret = new Promise2(INTERNAL);
      function iterator() {
        if (i >= len)
          return ret._fulfill();
        var maybePromise = castPreservingDisposable(resources[i++]);
        if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
          try {
            maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
          } catch (e) {
            return thrower(e);
          }
          if (maybePromise instanceof Promise2) {
            return maybePromise._then(iterator, thrower, null, null, null);
          }
        }
        iterator();
      }
      iterator();
      return ret;
    }
    function Disposer(data, promise, context) {
      this._data = data;
      this._promise = promise;
      this._context = context;
    }
    Disposer.prototype.data = function() {
      return this._data;
    };
    Disposer.prototype.promise = function() {
      return this._promise;
    };
    Disposer.prototype.resource = function() {
      if (this.promise().isFulfilled()) {
        return this.promise().value();
      }
      return NULL;
    };
    Disposer.prototype.tryDispose = function(inspection) {
      var resource = this.resource();
      var context = this._context;
      if (context !== undefined)
        context._pushContext();
      var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
      if (context !== undefined)
        context._popContext();
      this._promise._unsetDisposable();
      this._data = null;
      return ret;
    };
    Disposer.isDisposer = function(d) {
      return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise, context) {
      this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
      var fn = this.data();
      return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
      if (Disposer.isDisposer(value)) {
        this.resources[this.index]._setDisposable(value);
        return value.promise();
      }
      return value;
    }
    function ResourceList(length) {
      this.length = length;
      this.promise = null;
      this[length - 1] = null;
    }
    ResourceList.prototype._resultCancelled = function() {
      var len = this.length;
      for (var i = 0;i < len; ++i) {
        var item = this[i];
        if (item instanceof Promise2) {
          item.cancel();
        }
      }
    };
    Promise2.using = function() {
      var len = arguments.length;
      if (len < 2)
        return apiRejection("you must pass at least 2 arguments to Promise.using");
      var fn = arguments[len - 1];
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
      }
      var input;
      var spreadArgs = true;
      if (len === 2 && Array.isArray(arguments[0])) {
        input = arguments[0];
        len = input.length;
        spreadArgs = false;
      } else {
        input = arguments;
        len--;
      }
      var resources = new ResourceList(len);
      for (var i = 0;i < len; ++i) {
        var resource = input[i];
        if (Disposer.isDisposer(resource)) {
          var disposer = resource;
          resource = resource.promise();
          resource._setDisposable(disposer);
        } else {
          var maybePromise = tryConvertToPromise(resource);
          if (maybePromise instanceof Promise2) {
            resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
              resources,
              index: i
            }, undefined);
          }
        }
        resources[i] = resource;
      }
      var reflectedResources = new Array(resources.length);
      for (var i = 0;i < reflectedResources.length; ++i) {
        reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
      }
      var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
        for (var i2 = 0;i2 < inspections.length; ++i2) {
          var inspection = inspections[i2];
          if (inspection.isRejected()) {
            errorObj.e = inspection.error();
            return errorObj;
          } else if (!inspection.isFulfilled()) {
            resultPromise.cancel();
            return;
          }
          inspections[i2] = inspection.value();
        }
        promise._pushContext();
        fn = tryCatch(fn);
        var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
        return ret;
      });
      var promise = resultPromise.lastly(function() {
        var inspection = new Promise2.PromiseInspection(resultPromise);
        return dispose(resources, inspection);
      });
      resources.promise = promise;
      promise._setOnCancel(resources);
      return promise;
    };
    Promise2.prototype._setDisposable = function(disposer) {
      this._bitField = this._bitField | 131072;
      this._disposer = disposer;
    };
    Promise2.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    };
    Promise2.prototype._getDisposer = function() {
      return this._disposer;
    };
    Promise2.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & ~131072;
      this._disposer = undefined;
    };
    Promise2.prototype.disposer = function(fn) {
      if (typeof fn === "function") {
        return new FunctionDisposer(fn, this, createContext());
      }
      throw new TypeError2;
    };
  };
});

// node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, debug) {
    var util = require_util3();
    var TimeoutError = Promise2.TimeoutError;
    function HandleWrapper(handle) {
      this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var afterValue = function(value) {
      return delay(+this).thenReturn(value);
    };
    var delay = Promise2.delay = function(ms, value) {
      var ret;
      var handle;
      if (value !== undefined) {
        ret = Promise2.resolve(value)._then(afterValue, null, null, ms, undefined);
        if (debug.cancellation() && value instanceof Promise2) {
          ret._setOnCancel(value);
        }
      } else {
        ret = new Promise2(INTERNAL);
        handle = setTimeout(function() {
          ret._fulfill();
        }, +ms);
        if (debug.cancellation()) {
          ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
      }
      ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.prototype.delay = function(ms) {
      return delay(ms, this);
    };
    var afterTimeout = function(promise, message, parent) {
      var err;
      if (typeof message !== "string") {
        if (message instanceof Error) {
          err = message;
        } else {
          err = new TimeoutError("operation timed out");
        }
      } else {
        err = new TimeoutError(message);
      }
      util.markAsOriginatingFromRejection(err);
      promise._attachExtraTrace(err);
      promise._reject(err);
      if (parent != null) {
        parent.cancel();
      }
    };
    function successClear(value) {
      clearTimeout(this.handle);
      return value;
    }
    function failureClear(reason) {
      clearTimeout(this.handle);
      throw reason;
    }
    Promise2.prototype.timeout = function(ms, message) {
      ms = +ms;
      var ret, parent;
      var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
          afterTimeout(ret, message, parent);
        }
      }, ms));
      if (debug.cancellation()) {
        parent = this.then();
        ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);
        ret._setOnCancel(handleWrapper);
      } else {
        ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
      }
      return ret;
    };
  };
});

// node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS((exports, module) => {
  module.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var errors = require_errors2();
    var TypeError2 = errors.TypeError;
    var util = require_util3();
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
      for (var i = 0;i < yieldHandlers2.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers2[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
          traceParent._pushContext();
          var ret = Promise2.reject(errorObj.e);
          traceParent._popContext();
          return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise2)
          return maybePromise;
      }
      return null;
    }
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
      if (debug.cancellation()) {
        var internal = new Promise2(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
        this._promise = internal.lastly(function() {
          return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
      } else {
        var promise = this._promise = new Promise2(INTERNAL);
        promise._captureStackTrace();
      }
      this._stack = stack;
      this._generatorFunction = generatorFunction;
      this._receiver = receiver;
      this._generator = undefined;
      this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
      this._yieldedPromise = null;
      this._cancellationPhase = false;
    }
    util.inherits(PromiseSpawn, Proxyable);
    PromiseSpawn.prototype._isResolved = function() {
      return this._promise === null;
    };
    PromiseSpawn.prototype._cleanup = function() {
      this._promise = this._generator = null;
      if (debug.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
      }
    };
    PromiseSpawn.prototype._promiseCancelled = function() {
      if (this._isResolved())
        return;
      var implementsReturn = typeof this._generator["return"] !== "undefined";
      var result;
      if (!implementsReturn) {
        var reason = new Promise2.CancellationError("generator .return() sentinel");
        Promise2.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
      } else {
        this._promise._pushContext();
        result = tryCatch(this._generator["return"]).call(this._generator, undefined);
        this._promise._popContext();
      }
      this._cancellationPhase = true;
      this._yieldedPromise = null;
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseFulfilled = function(value) {
      this._yieldedPromise = null;
      this._promise._pushContext();
      var result = tryCatch(this._generator.next).call(this._generator, value);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseRejected = function(reason) {
      this._yieldedPromise = null;
      this._promise._attachExtraTrace(reason);
      this._promise._pushContext();
      var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof Promise2) {
        var promise = this._yieldedPromise;
        this._yieldedPromise = null;
        promise.cancel();
      }
    };
    PromiseSpawn.prototype.promise = function() {
      return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver);
      this._receiver = this._generatorFunction = undefined;
      this._promiseFulfilled(undefined);
    };
    PromiseSpawn.prototype._continue = function(result) {
      var promise = this._promise;
      if (result === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise.cancel();
        } else {
          return promise._rejectCallback(result.e, false);
        }
      }
      var value = result.value;
      if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise.cancel();
        } else {
          return promise._resolveCallback(value);
        }
      } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise2)) {
          maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
          if (maybePromise === null) {
            this._promiseRejected(new TypeError2(`A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", value) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)));
            return;
          }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        if ((bitField & 50397184) === 0) {
          this._yieldedPromise = maybePromise;
          maybePromise._proxy(this, null);
        } else if ((bitField & 33554432) !== 0) {
          Promise2._async.invoke(this._promiseFulfilled, this, maybePromise._value());
        } else if ((bitField & 16777216) !== 0) {
          Promise2._async.invoke(this._promiseRejected, this, maybePromise._reason());
        } else {
          this._promiseCancelled();
        }
      }
    };
    Promise2.coroutine = function(generatorFunction, options) {
      if (typeof generatorFunction !== "function") {
        throw new TypeError2(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      }
      var yieldHandler = Object(options).yieldHandler;
      var PromiseSpawn$ = PromiseSpawn;
      var stack = new Error().stack;
      return function() {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(undefined);
        return ret;
      };
    };
    Promise2.coroutine.addYieldHandler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util.classString(fn));
      }
      yieldHandlers.push(fn);
    };
    Promise2.spawn = function(generatorFunction) {
      debug.deprecated("Promise.spawn()", "Promise.coroutine()");
      if (typeof generatorFunction !== "function") {
        return apiRejection(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      }
      var spawn = new PromiseSpawn(generatorFunction, this);
      var ret = spawn.promise();
      spawn._run(Promise2.spawn);
      return ret;
    };
  };
});

// node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    var util = require_util3();
    var async = Promise2._async;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    function spreadAdapter(val, nodeback) {
      var promise = this;
      if (!util.isArray(val))
        return successAdapter.call(promise, val, nodeback);
      var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    function successAdapter(val, nodeback) {
      var promise = this;
      var receiver = promise._boundValue();
      var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    function errorAdapter(reason, nodeback) {
      var promise = this;
      if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
      }
      var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
      if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
          adapter = spreadAdapter;
        }
        this._then(adapter, errorAdapter, undefined, this, nodeback);
      }
      return this;
    };
  };
});

// node_modules/bluebird/js/release/promisify.js
var require_promisify2 = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var THIS = {};
    var util = require_util3();
    var nodebackForPromise = require_nodeback();
    var withAppended = util.withAppended;
    var maybeWrapAsError = util.maybeWrapAsError;
    var canEvaluate = util.canEvaluate;
    var TypeError2 = require_errors2().TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name) {
      return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };
    function propsFilter(key2) {
      return !noCopyPropsPattern.test(key2);
    }
    function isPromisified(fn) {
      try {
        return fn.__isPromisified__ === true;
      } catch (e) {
        return false;
      }
    }
    function hasPromisified(obj2, key2, suffix) {
      var val = util.getDataPropertyOrDefault(obj2, key2 + suffix, defaultPromisified);
      return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
      for (var i = 0;i < ret.length; i += 2) {
        var key2 = ret[i];
        if (suffixRegexp.test(key2)) {
          var keyWithoutAsyncSuffix = key2.replace(suffixRegexp, "");
          for (var j = 0;j < ret.length; j += 2) {
            if (ret[j] === keyWithoutAsyncSuffix) {
              throw new TypeError2(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", suffix));
            }
          }
        }
      }
    }
    function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
      var keys = util.inheritedDataKeys(obj2);
      var ret = [];
      for (var i = 0;i < keys.length; ++i) {
        var key2 = keys[i];
        var value = obj2[key2];
        var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key2, value, obj2);
        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key2, suffix) && filter(key2, value, obj2, passesDefaultFilter)) {
          ret.push(key2, value);
        }
      }
      checkValid(ret, suffix, suffixRegexp);
      return ret;
    }
    var escapeIdentRegex = function(str) {
      return str.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    if (true) {
      var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min = Math.max(0, likelyArgumentCount - 1 - 3);
        for (var i = likelyArgumentCount - 1;i >= min; --i) {
          ret.push(i);
        }
        for (var i = likelyArgumentCount + 1;i <= 3; ++i) {
          ret.push(i);
        }
        return ret;
      };
      var argumentSequence = function(argumentCount) {
        return util.filledRange(argumentCount, "_arg", "");
      };
      var parameterDeclaration = function(parameterCount2) {
        return util.filledRange(Math.max(parameterCount2, 3), "_arg", "");
      };
      var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
          return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
      };
      makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _2, multiArgs) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
        function generateCallForArgumentCount(count) {
          var args = argumentSequence(count).join(", ");
          var comma = count > 0 ? ", " : "";
          var ret;
          if (shouldProxyThis) {
            ret = `ret = callback.call(this, {{args}}, nodeback); break;
`;
          } else {
            ret = receiver === undefined ? `ret = callback({{args}}, nodeback); break;
` : `ret = callback.call(receiver, {{args}}, nodeback); break;
`;
          }
          return ret.replace("{{args}}", args).replace(", ", comma);
        }
        function generateArgumentSwitchCase() {
          var ret = "";
          for (var i = 0;i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
          }
          ret += `                                                             
        default:                                                             
            var args = new Array(len + 1);                                   
            var i = 0;                                                       
            for (var i = 0; i < len; ++i) {                                  
               args[i] = arguments[i];                                       
            }                                                                
            args[i] = nodeback;                                              
            [CodeForCall]                                                    
            break;                                                           
        `.replace("[CodeForCall]", shouldProxyThis ? `ret = callback.apply(this, args);
` : `ret = callback.apply(receiver, args);
`);
          return ret;
        }
        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
        var body = `'use strict';                                                
        var ret = function (Parameters) {                                    
            'use strict';                                                    
            var len = arguments.length;                                      
            var promise = new Promise(INTERNAL);                             
            promise._captureStackTrace();                                    
            var nodeback = nodebackForPromise(promise, ` + multiArgs + `);   
            var ret;                                                         
            var callback = tryCatch([GetFunctionCode]);                      
            switch(len) {                                                    
                [CodeForSwitchCase]                                          
            }                                                                
            if (ret === errorObj) {                                          
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
            }                                                                
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     
            return promise;                                                  
        };                                                                   
        notEnumerableProp(ret, '__isPromisified__', true);                   
        return ret;                                                          
    `.replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
        body = body.replace("Parameters", parameterDeclaration(newParameterCount));
        return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise2, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
      };
    }
    function makeNodePromisifiedClosure(callback, receiver, _2, fn, __, multiArgs) {
      var defaultThis = function() {
        return this;
      }();
      var method = callback;
      if (typeof method === "string") {
        callback = fn;
      }
      function promisified() {
        var _receiver = receiver;
        if (receiver === THIS)
          _receiver = this;
        var promise = new Promise2(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
        var fn2 = nodebackForPromise(promise, multiArgs);
        try {
          cb.apply(_receiver, withAppended(arguments, fn2));
        } catch (e) {
          promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise._isFateSealed())
          promise._setAsyncGuaranteed();
        return promise;
      }
      util.notEnumerableProp(promisified, "__isPromisified__", true);
      return promisified;
    }
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj2, suffix, filter, promisifier, multiArgs) {
      var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
      var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
      for (var i = 0, len = methods.length;i < len; i += 2) {
        var key2 = methods[i];
        var fn = methods[i + 1];
        var promisifiedKey = key2 + suffix;
        if (promisifier === makeNodePromisified) {
          obj2[promisifiedKey] = makeNodePromisified(key2, THIS, key2, fn, suffix, multiArgs);
        } else {
          var promisified = promisifier(fn, function() {
            return makeNodePromisified(key2, THIS, key2, fn, suffix, multiArgs);
          });
          util.notEnumerableProp(promisified, "__isPromisified__", true);
          obj2[promisifiedKey] = promisified;
        }
      }
      util.toFastProperties(obj2);
      return obj2;
    }
    function promisify(callback, receiver, multiArgs) {
      return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);
    }
    Promise2.promisify = function(fn, options) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util.classString(fn));
      }
      if (isPromisified(fn)) {
        return fn;
      }
      options = Object(options);
      var receiver = options.context === undefined ? THIS : options.context;
      var multiArgs = !!options.multiArgs;
      var ret = promisify(fn, receiver, multiArgs);
      util.copyDescriptors(fn, ret, propsFilter);
      return ret;
    };
    Promise2.promisifyAll = function(target, options) {
      if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError2(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
      }
      options = Object(options);
      var multiArgs = !!options.multiArgs;
      var suffix = options.suffix;
      if (typeof suffix !== "string")
        suffix = defaultSuffix;
      var filter = options.filter;
      if (typeof filter !== "function")
        filter = defaultFilter;
      var promisifier = options.promisifier;
      if (typeof promisifier !== "function")
        promisifier = makeNodePromisified;
      if (!util.isIdentifier(suffix)) {
        throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
      }
      var keys = util.inheritedDataKeys(target);
      for (var i = 0;i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" && util.isClass(value)) {
          promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
          promisifyAll(value, suffix, filter, promisifier, multiArgs);
        }
      }
      return promisifyAll(target, suffix, filter, promisifier, multiArgs);
    };
  };
});

// node_modules/bluebird/js/release/props.js
var require_props = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
    var util = require_util3();
    var isObject = util.isObject;
    var es5 = require_es5();
    var Es6Map;
    if (typeof Map === "function")
      Es6Map = Map;
    var mapToEntries = function() {
      var index = 0;
      var size = 0;
      function extractEntry(value, key2) {
        this[index] = value;
        this[index + size] = key2;
        index++;
      }
      return function mapToEntries(map) {
        size = map.size;
        index = 0;
        var ret = new Array(map.size * 2);
        map.forEach(extractEntry, ret);
        return ret;
      };
    }();
    var entriesToMap = function(entries) {
      var ret = new Es6Map;
      var length = entries.length / 2 | 0;
      for (var i = 0;i < length; ++i) {
        var key2 = entries[length + i];
        var value = entries[i];
        ret.set(key2, value);
      }
      return ret;
    };
    function PropertiesPromiseArray(obj2) {
      var isMap = false;
      var entries;
      if (Es6Map !== undefined && obj2 instanceof Es6Map) {
        entries = mapToEntries(obj2);
        isMap = true;
      } else {
        var keys = es5.keys(obj2);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0;i < len; ++i) {
          var key2 = keys[i];
          entries[i] = obj2[key2];
          entries[i + len] = key2;
        }
      }
      this.constructor$(entries);
      this._isMap = isMap;
      this._init$(undefined, -3);
    }
    util.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {};
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
          val = entriesToMap(this._values);
        } else {
          val = {};
          var keyOffset = this.length();
          for (var i = 0, len = this.length();i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
          }
        }
        this._resolve(val);
        return true;
      }
      return false;
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
      return len >> 1;
    };
    function props(promises) {
      var ret;
      var castValue = tryConvertToPromise(promises);
      if (!isObject(castValue)) {
        return apiRejection(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
      } else if (castValue instanceof Promise2) {
        ret = castValue._then(Promise2.props, undefined, undefined, undefined, undefined);
      } else {
        ret = new PropertiesPromiseArray(castValue).promise();
      }
      if (castValue instanceof Promise2) {
        ret._propagateFrom(castValue, 2);
      }
      return ret;
    }
    Promise2.prototype.props = function() {
      return props(this);
    };
    Promise2.props = function(promises) {
      return props(promises);
    };
  };
});

// node_modules/bluebird/js/release/race.js
var require_race = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var util = require_util3();
    var raceLater = function(promise) {
      return promise.then(function(array) {
        return race(array, promise);
      });
    };
    function race(promises, parent) {
      var maybePromise = tryConvertToPromise(promises);
      if (maybePromise instanceof Promise2) {
        return raceLater(maybePromise);
      } else {
        promises = util.asArray(promises);
        if (promises === null)
          return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
      }
      var ret = new Promise2(INTERNAL);
      if (parent !== undefined) {
        ret._propagateFrom(parent, 3);
      }
      var fulfill = ret._fulfill;
      var reject = ret._reject;
      for (var i = 0, len = promises.length;i < len; ++i) {
        var val = promises[i];
        if (val === undefined && !(i in promises)) {
          continue;
        }
        Promise2.cast(val)._then(fulfill, reject, undefined, ret, null);
      }
      return ret;
    }
    Promise2.race = function(promises) {
      return race(promises, undefined);
    };
    Promise2.prototype.race = function() {
      return race(this, undefined);
    };
  };
});

// node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise2._getDomain;
    var util = require_util3();
    var tryCatch = util.tryCatch;
    function ReductionPromiseArray(promises, fn, initialValue, _each) {
      this.constructor$(promises);
      var domain = getDomain();
      this._fn = domain === null ? fn : util.domainBind(domain, fn);
      if (initialValue !== undefined) {
        initialValue = Promise2.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
      }
      this._initialValue = initialValue;
      this._currentCancellable = null;
      if (_each === INTERNAL) {
        this._eachValues = Array(this._length);
      } else if (_each === 0) {
        this._eachValues = null;
      } else {
        this._eachValues = undefined;
      }
      this._promise._captureStackTrace();
      this._init$(undefined, -5);
    }
    util.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._gotAccum = function(accum) {
      if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {
        this._eachValues.push(accum);
      }
    };
    ReductionPromiseArray.prototype._eachComplete = function(value) {
      if (this._eachValues !== null) {
        this._eachValues.push(value);
      }
      return this._eachValues;
    };
    ReductionPromiseArray.prototype._init = function() {};
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
    };
    ReductionPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    ReductionPromiseArray.prototype._resolve = function(value) {
      this._promise._resolveCallback(value);
      this._values = null;
    };
    ReductionPromiseArray.prototype._resultCancelled = function(sender) {
      if (sender === this._initialValue)
        return this._cancel();
      if (this._isResolved())
        return;
      this._resultCancelled$();
      if (this._currentCancellable instanceof Promise2) {
        this._currentCancellable.cancel();
      }
      if (this._initialValue instanceof Promise2) {
        this._initialValue.cancel();
      }
    };
    ReductionPromiseArray.prototype._iterate = function(values) {
      this._values = values;
      var value;
      var i;
      var length = values.length;
      if (this._initialValue !== undefined) {
        value = this._initialValue;
        i = 0;
      } else {
        value = Promise2.resolve(values[0]);
        i = 1;
      }
      this._currentCancellable = value;
      if (!value.isRejected()) {
        for (;i < length; ++i) {
          var ctx = {
            accum: null,
            value: values[i],
            index: i,
            length,
            array: this
          };
          value = value._then(gotAccum, undefined, undefined, ctx, undefined);
        }
      }
      if (this._eachValues !== undefined) {
        value = value._then(this._eachComplete, undefined, undefined, this, undefined);
      }
      value._then(completed, completed, undefined, value, this);
    };
    Promise2.prototype.reduce = function(fn, initialValue) {
      return reduce(this, fn, initialValue, null);
    };
    Promise2.reduce = function(promises, fn, initialValue, _each) {
      return reduce(promises, fn, initialValue, _each);
    };
    function completed(valueOrReason, array) {
      if (this.isFulfilled()) {
        array._resolve(valueOrReason);
      } else {
        array._reject(valueOrReason);
      }
    }
    function reduce(promises, fn, initialValue, _each) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
      }
      var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
      return array.promise();
    }
    function gotAccum(accum) {
      this.accum = accum;
      this.array._gotAccum(accum);
      var value = tryConvertToPromise(this.value, this.array._promise);
      if (value instanceof Promise2) {
        this.array._currentCancellable = value;
        return value._then(gotValue, undefined, undefined, this, undefined);
      } else {
        return gotValue.call(this, value);
      }
    }
    function gotValue(value) {
      var array = this.array;
      var promise = array._promise;
      var fn = tryCatch(array._fn);
      promise._pushContext();
      var ret;
      if (array._eachValues !== undefined) {
        ret = fn.call(promise._boundValue(), value, this.index, this.length);
      } else {
        ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
      }
      if (ret instanceof Promise2) {
        array._currentCancellable = ret;
      }
      var promiseCreated = promise._popContext();
      debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
      return ret;
    }
  };
});

// node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, debug) {
    var PromiseInspection = Promise2.PromiseInspection;
    var util = require_util3();
    function SettledPromiseArray(values) {
      this.constructor$(values);
    }
    util.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
      this._values[index] = inspection;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var ret = new PromiseInspection;
      ret._bitField = 33554432;
      ret._settledValueField = value;
      return this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
      var ret = new PromiseInspection;
      ret._bitField = 16777216;
      ret._settledValueField = reason;
      return this._promiseResolved(index, ret);
    };
    Promise2.settle = function(promises) {
      debug.deprecated(".settle()", ".reflect()");
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.prototype.settle = function() {
      return Promise2.settle(this);
    };
  };
});

// node_modules/bluebird/js/release/some.js
var require_some = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection) {
    var util = require_util3();
    var RangeError2 = require_errors2().RangeError;
    var AggregateError = require_errors2().AggregateError;
    var isArray = util.isArray;
    var CANCELLATION = {};
    function SomePromiseArray(values) {
      this.constructor$(values);
      this._howMany = 0;
      this._unwrap = false;
      this._initialized = false;
    }
    util.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
      if (!this._initialized) {
        return;
      }
      if (this._howMany === 0) {
        this._resolve([]);
        return;
      }
      this._init$(undefined, -5);
      var isArrayResolved = isArray(this._values);
      if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
      }
    };
    SomePromiseArray.prototype.init = function() {
      this._initialized = true;
      this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
      this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
      return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
      this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
      this._addFulfilled(value);
      if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
          this._resolve(this._values[0]);
        } else {
          this._resolve(this._values);
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
      this._addRejected(reason);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._promiseCancelled = function() {
      if (this._values instanceof Promise2 || this._values == null) {
        return this._cancel();
      }
      this._addRejected(CANCELLATION);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError;
        for (var i = this.length();i < this._values.length; ++i) {
          if (this._values[i] !== CANCELLATION) {
            e.push(this._values[i]);
          }
        }
        if (e.length > 0) {
          this._reject(e);
        } else {
          this._cancel();
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._fulfilled = function() {
      return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
      return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
      this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
      this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
      var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
      return new RangeError2(message);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function some(promises, howMany) {
      if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
      }
      var ret = new SomePromiseArray(promises);
      var promise = ret.promise();
      ret.setHowMany(howMany);
      ret.init();
      return promise;
    }
    Promise2.some = function(promises, howMany) {
      return some(promises, howMany);
    };
    Promise2.prototype.some = function(howMany) {
      return some(this, howMany);
    };
    Promise2._SomePromiseArray = SomePromiseArray;
  };
});

// node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var PromiseMap = Promise2.map;
    Promise2.prototype.filter = function(fn, options) {
      return PromiseMap(this, fn, options, INTERNAL);
    };
    Promise2.filter = function(promises, fn, options) {
      return PromiseMap(promises, fn, options, INTERNAL);
    };
  };
});

// node_modules/bluebird/js/release/each.js
var require_each = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var PromiseReduce = Promise2.reduce;
    var PromiseAll = Promise2.all;
    function promiseAllThis() {
      return PromiseAll(this);
    }
    function PromiseMapSeries(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }
    Promise2.prototype.each = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);
    };
    Promise2.prototype.mapSeries = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };
    Promise2.each = function(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);
    };
    Promise2.mapSeries = PromiseMapSeries;
  };
});

// node_modules/bluebird/js/release/any.js
var require_any = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    var SomePromiseArray = Promise2._SomePromiseArray;
    function any(promises) {
      var ret = new SomePromiseArray(promises);
      var promise = ret.promise();
      ret.setHowMany(1);
      ret.setUnwrap();
      ret.init();
      return promise;
    }
    Promise2.any = function(promises) {
      return any(promises);
    };
    Promise2.prototype.any = function() {
      return any(this);
    };
  };
});

// node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS((exports, module) => {
  module.exports = function() {
    var makeSelfResolutionError = function() {
      return new TypeError2(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
    };
    var reflectHandler = function() {
      return new Promise2.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
      return Promise2.reject(new TypeError2(msg));
    };
    function Proxyable() {}
    var UNDEFINED_BINDING = {};
    var util = require_util3();
    var getDomain;
    if (util.isNode) {
      getDomain = function() {
        var ret = process.domain;
        if (ret === undefined)
          ret = null;
        return ret;
      };
    } else {
      getDomain = function() {
        return null;
      };
    }
    util.notEnumerableProp(Promise2, "_getDomain", getDomain);
    var es5 = require_es5();
    var Async = require_async();
    var async = new Async;
    es5.defineProperty(Promise2, "_async", { value: async });
    var errors = require_errors2();
    var TypeError2 = Promise2.TypeError = errors.TypeError;
    Promise2.RangeError = errors.RangeError;
    var CancellationError = Promise2.CancellationError = errors.CancellationError;
    Promise2.TimeoutError = errors.TimeoutError;
    Promise2.OperationalError = errors.OperationalError;
    Promise2.RejectionError = errors.OperationalError;
    Promise2.AggregateError = errors.AggregateError;
    var INTERNAL = function() {};
    var APPLY = {};
    var NEXT_FILTER = {};
    var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
    var PromiseArray = require_promise_array()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
    var Context = require_context()(Promise2);
    var createContext = Context.create;
    var debug = require_debuggability()(Promise2, Context);
    var CapturedTrace = debug.CapturedTrace;
    var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise);
    var catchFilter = require_catch_filter()(NEXT_FILTER);
    var nodebackForPromise = require_nodeback();
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    function check(self2, executor) {
      if (typeof executor !== "function") {
        throw new TypeError2("expecting a function but got " + util.classString(executor));
      }
      if (self2.constructor !== Promise2) {
        throw new TypeError2(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
      }
    }
    function Promise2(executor) {
      this._bitField = 0;
      this._fulfillmentHandler0 = undefined;
      this._rejectionHandler0 = undefined;
      this._promise0 = undefined;
      this._receiver0 = undefined;
      if (executor !== INTERNAL) {
        check(this, executor);
        this._resolveFromExecutor(executor);
      }
      this._promiseCreated();
      this._fireEvent("promiseCreated", this);
    }
    Promise2.prototype.toString = function() {
      return "[object Promise]";
    };
    Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
      var len = arguments.length;
      if (len > 1) {
        var catchInstances = new Array(len - 1), j = 0, i;
        for (i = 0;i < len - 1; ++i) {
          var item = arguments[i];
          if (util.isObject(item)) {
            catchInstances[j++] = item;
          } else {
            return apiRejection("expecting an object but got " + "A catch statement predicate " + util.classString(item));
          }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(undefined, catchFilter(catchInstances, fn, this));
      }
      return this.then(undefined, fn);
    };
    Promise2.prototype.reflect = function() {
      return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
    };
    Promise2.prototype.then = function(didFulfill, didReject) {
      if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
        if (arguments.length > 1) {
          msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
      }
      return this._then(didFulfill, didReject, undefined, undefined, undefined);
    };
    Promise2.prototype.done = function(didFulfill, didReject) {
      var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);
      promise._setIsFinal();
    };
    Promise2.prototype.spread = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
      }
      return this.all()._then(fn, undefined, undefined, APPLY, undefined);
    };
    Promise2.prototype.toJSON = function() {
      var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
      };
      if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
      } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
      }
      return ret;
    };
    Promise2.prototype.all = function() {
      if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
      }
      return new PromiseArray(this).promise();
    };
    Promise2.prototype.error = function(fn) {
      return this.caught(util.originatesFromRejection, fn);
    };
    Promise2.getNewLibraryCopy = module.exports;
    Promise2.is = function(val) {
      return val instanceof Promise2;
    };
    Promise2.fromNode = Promise2.fromCallback = function(fn) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
      var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
      if (result === errorObj) {
        ret._rejectCallback(result.e, true);
      }
      if (!ret._isFateSealed())
        ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.all = function(promises) {
      return new PromiseArray(promises).promise();
    };
    Promise2.cast = function(obj2) {
      var ret = tryConvertToPromise(obj2);
      if (!(ret instanceof Promise2)) {
        ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj2;
      }
      return ret;
    };
    Promise2.resolve = Promise2.fulfilled = Promise2.cast;
    Promise2.reject = Promise2.rejected = function(reason) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._rejectCallback(reason, true);
      return ret;
    };
    Promise2.setScheduler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util.classString(fn));
      }
      return async.setScheduler(fn);
    };
    Promise2.prototype._then = function(didFulfill, didReject, _2, receiver, internalData) {
      var haveInternalData = internalData !== undefined;
      var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
      var target = this._target();
      var bitField = target._bitField;
      if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === undefined && (this._bitField & 2097152) !== 0) {
          if (!((bitField & 50397184) === 0)) {
            receiver = this._boundValue();
          } else {
            receiver = target === this ? undefined : this._boundTo;
          }
        }
        this._fireEvent("promiseChained", this, promise);
      }
      var domain = getDomain();
      if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if ((bitField & 33554432) !== 0) {
          value = target._rejectionHandler0;
          handler = didFulfill;
        } else if ((bitField & 16777216) !== 0) {
          value = target._fulfillmentHandler0;
          handler = didReject;
          target._unsetRejectionIsUnhandled();
        } else {
          settler = target._settlePromiseLateCancellationObserver;
          value = new CancellationError("late cancellation observer");
          target._attachExtraTrace(value);
          handler = didReject;
        }
        async.invoke(settler, target, {
          handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
          promise,
          receiver,
          value
        });
      } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
      }
      return promise;
    };
    Promise2.prototype._length = function() {
      return this._bitField & 65535;
    };
    Promise2.prototype._isFateSealed = function() {
      return (this._bitField & 117506048) !== 0;
    };
    Promise2.prototype._isFollowing = function() {
      return (this._bitField & 67108864) === 67108864;
    };
    Promise2.prototype._setLength = function(len) {
      this._bitField = this._bitField & -65536 | len & 65535;
    };
    Promise2.prototype._setFulfilled = function() {
      this._bitField = this._bitField | 33554432;
      this._fireEvent("promiseFulfilled", this);
    };
    Promise2.prototype._setRejected = function() {
      this._bitField = this._bitField | 16777216;
      this._fireEvent("promiseRejected", this);
    };
    Promise2.prototype._setFollowing = function() {
      this._bitField = this._bitField | 67108864;
      this._fireEvent("promiseResolved", this);
    };
    Promise2.prototype._setIsFinal = function() {
      this._bitField = this._bitField | 4194304;
    };
    Promise2.prototype._isFinal = function() {
      return (this._bitField & 4194304) > 0;
    };
    Promise2.prototype._unsetCancelled = function() {
      this._bitField = this._bitField & ~65536;
    };
    Promise2.prototype._setCancelled = function() {
      this._bitField = this._bitField | 65536;
      this._fireEvent("promiseCancelled", this);
    };
    Promise2.prototype._setWillBeCancelled = function() {
      this._bitField = this._bitField | 8388608;
    };
    Promise2.prototype._setAsyncGuaranteed = function() {
      if (async.hasCustomScheduler())
        return;
      this._bitField = this._bitField | 134217728;
    };
    Promise2.prototype._receiverAt = function(index) {
      var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
      if (ret === UNDEFINED_BINDING) {
        return;
      } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
      }
      return ret;
    };
    Promise2.prototype._promiseAt = function(index) {
      return this[index * 4 - 4 + 2];
    };
    Promise2.prototype._fulfillmentHandlerAt = function(index) {
      return this[index * 4 - 4 + 0];
    };
    Promise2.prototype._rejectionHandlerAt = function(index) {
      return this[index * 4 - 4 + 1];
    };
    Promise2.prototype._boundValue = function() {};
    Promise2.prototype._migrateCallback0 = function(follower) {
      var bitField = follower._bitField;
      var fulfill = follower._fulfillmentHandler0;
      var reject = follower._rejectionHandler0;
      var promise = follower._promise0;
      var receiver = follower._receiverAt(0);
      if (receiver === undefined)
        receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, promise, receiver, null);
    };
    Promise2.prototype._migrateCallbackAt = function(follower, index) {
      var fulfill = follower._fulfillmentHandlerAt(index);
      var reject = follower._rejectionHandlerAt(index);
      var promise = follower._promiseAt(index);
      var receiver = follower._receiverAt(index);
      if (receiver === undefined)
        receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, promise, receiver, null);
    };
    Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain) {
      var index = this._length();
      if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
      }
      if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
          this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
          this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
        }
      } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
          this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
          this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
        }
      }
      this._setLength(index + 1);
      return index;
    };
    Promise2.prototype._proxy = function(proxyable, arg) {
      this._addCallbacks(undefined, undefined, arg, proxyable, null);
    };
    Promise2.prototype._resolveCallback = function(value, shouldBind) {
      if ((this._bitField & 117506048) !== 0)
        return;
      if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
      var maybePromise = tryConvertToPromise(value, this);
      if (!(maybePromise instanceof Promise2))
        return this._fulfill(value);
      if (shouldBind)
        this._propagateFrom(maybePromise, 2);
      var promise = maybePromise._target();
      if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
      }
      var bitField = promise._bitField;
      if ((bitField & 50397184) === 0) {
        var len = this._length();
        if (len > 0)
          promise._migrateCallback0(this);
        for (var i = 1;i < len; ++i) {
          promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
      } else if ((bitField & 33554432) !== 0) {
        this._fulfill(promise._value());
      } else if ((bitField & 16777216) !== 0) {
        this._reject(promise._reason());
      } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
      }
    };
    Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
      var trace = util.ensureErrorObject(reason);
      var hasStack = trace === reason;
      if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message = "a promise was rejected with a non-error: " + util.classString(reason);
        this._warn(message, true);
      }
      this._attachExtraTrace(trace, synchronous ? hasStack : false);
      this._reject(reason);
    };
    Promise2.prototype._resolveFromExecutor = function(executor) {
      var promise = this;
      this._captureStackTrace();
      this._pushContext();
      var synchronous = true;
      var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
      }, function(reason) {
        promise._rejectCallback(reason, synchronous);
      });
      synchronous = false;
      this._popContext();
      if (r !== undefined) {
        promise._rejectCallback(r, true);
      }
    };
    Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
      var bitField = promise._bitField;
      if ((bitField & 65536) !== 0)
        return;
      promise._pushContext();
      var x;
      if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
          x = errorObj;
          x.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
        } else {
          x = tryCatch(handler).apply(this._boundValue(), value);
        }
      } else {
        x = tryCatch(handler).call(receiver, value);
      }
      var promiseCreated = promise._popContext();
      bitField = promise._bitField;
      if ((bitField & 65536) !== 0)
        return;
      if (x === NEXT_FILTER) {
        promise._reject(value);
      } else if (x === errorObj) {
        promise._rejectCallback(x.e, false);
      } else {
        debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
        promise._resolveCallback(x);
      }
    };
    Promise2.prototype._target = function() {
      var ret = this;
      while (ret._isFollowing())
        ret = ret._followee();
      return ret;
    };
    Promise2.prototype._followee = function() {
      return this._rejectionHandler0;
    };
    Promise2.prototype._setFollowee = function(promise) {
      this._rejectionHandler0 = promise;
    };
    Promise2.prototype._settlePromise = function(promise, handler, receiver, value) {
      var isPromise = promise instanceof Promise2;
      var bitField = this._bitField;
      var asyncGuaranteed = (bitField & 134217728) !== 0;
      if ((bitField & 65536) !== 0) {
        if (isPromise)
          promise._invokeInternalOnCancel();
        if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
          receiver.cancelPromise = promise;
          if (tryCatch(handler).call(receiver, value) === errorObj) {
            promise._reject(errorObj.e);
          }
        } else if (handler === reflectHandler) {
          promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
          receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
          promise._cancel();
        } else {
          receiver.cancel();
        }
      } else if (typeof handler === "function") {
        if (!isPromise) {
          handler.call(receiver, value, promise);
        } else {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
      } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
          if ((bitField & 33554432) !== 0) {
            receiver._promiseFulfilled(value, promise);
          } else {
            receiver._promiseRejected(value, promise);
          }
        }
      } else if (isPromise) {
        if (asyncGuaranteed)
          promise._setAsyncGuaranteed();
        if ((bitField & 33554432) !== 0) {
          promise._fulfill(value);
        } else {
          promise._reject(value);
        }
      }
    };
    Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
      var handler = ctx.handler;
      var promise = ctx.promise;
      var receiver = ctx.receiver;
      var value = ctx.value;
      if (typeof handler === "function") {
        if (!(promise instanceof Promise2)) {
          handler.call(receiver, value, promise);
        } else {
          this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
      } else if (promise instanceof Promise2) {
        promise._reject(value);
      }
    };
    Promise2.prototype._settlePromiseCtx = function(ctx) {
      this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    };
    Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
      var promise = this._promise0;
      var receiver = this._receiverAt(0);
      this._promise0 = undefined;
      this._receiver0 = undefined;
      this._settlePromise(promise, handler, receiver, value);
    };
    Promise2.prototype._clearCallbackDataAtIndex = function(index) {
      var base = index * 4 - 4;
      this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
    };
    Promise2.prototype._fulfill = function(value) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16)
        return;
      if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
      }
      this._setFulfilled();
      this._rejectionHandler0 = value;
      if ((bitField & 65535) > 0) {
        if ((bitField & 134217728) !== 0) {
          this._settlePromises();
        } else {
          async.settlePromises(this);
        }
      }
    };
    Promise2.prototype._reject = function(reason) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16)
        return;
      this._setRejected();
      this._fulfillmentHandler0 = reason;
      if (this._isFinal()) {
        return async.fatalError(reason, util.isNode);
      }
      if ((bitField & 65535) > 0) {
        async.settlePromises(this);
      } else {
        this._ensurePossibleRejectionHandled();
      }
    };
    Promise2.prototype._fulfillPromises = function(len, value) {
      for (var i = 1;i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, value);
      }
    };
    Promise2.prototype._rejectPromises = function(len, reason) {
      for (var i = 1;i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, reason);
      }
    };
    Promise2.prototype._settlePromises = function() {
      var bitField = this._bitField;
      var len = bitField & 65535;
      if (len > 0) {
        if ((bitField & 16842752) !== 0) {
          var reason = this._fulfillmentHandler0;
          this._settlePromise0(this._rejectionHandler0, reason, bitField);
          this._rejectPromises(len, reason);
        } else {
          var value = this._rejectionHandler0;
          this._settlePromise0(this._fulfillmentHandler0, value, bitField);
          this._fulfillPromises(len, value);
        }
        this._setLength(0);
      }
      this._clearCancellationData();
    };
    Promise2.prototype._settledValue = function() {
      var bitField = this._bitField;
      if ((bitField & 33554432) !== 0) {
        return this._rejectionHandler0;
      } else if ((bitField & 16777216) !== 0) {
        return this._fulfillmentHandler0;
      }
    };
    function deferResolve(v) {
      this.promise._resolveCallback(v);
    }
    function deferReject(v) {
      this.promise._rejectCallback(v, false);
    }
    Promise2.defer = Promise2.pending = function() {
      debug.deprecated("Promise.defer", "new Promise");
      var promise = new Promise2(INTERNAL);
      return {
        promise,
        resolve: deferResolve,
        reject: deferReject
      };
    };
    util.notEnumerableProp(Promise2, "_makeSelfResolutionError", makeSelfResolutionError);
    require_method()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug);
    require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug);
    require_cancel()(Promise2, PromiseArray, apiRejection, debug);
    require_direct_resolve()(Promise2);
    require_synchronous_inspection()(Promise2);
    require_join()(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
    Promise2.Promise = Promise2;
    Promise2.version = "3.4.7";
    require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    require_call_get()(Promise2);
    require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
    require_timers()(Promise2, INTERNAL, debug);
    require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
    require_nodeify()(Promise2);
    require_promisify2()(Promise2, INTERNAL);
    require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
    require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
    require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    require_settle()(Promise2, PromiseArray, debug);
    require_some()(Promise2, PromiseArray, apiRejection);
    require_filter()(Promise2, INTERNAL);
    require_each()(Promise2, INTERNAL);
    require_any()(Promise2);
    util.toFastProperties(Promise2);
    util.toFastProperties(Promise2.prototype);
    function fillTypes(value) {
      var p = new Promise2(INTERNAL);
      p._fulfillmentHandler0 = value;
      p._rejectionHandler0 = value;
      p._promise0 = value;
      p._receiver0 = value;
    }
    fillTypes({ a: 1 });
    fillTypes({ b: 2 });
    fillTypes({ c: 3 });
    fillTypes(1);
    fillTypes(function() {});
    fillTypes(undefined);
    fillTypes(false);
    fillTypes(new Promise2(INTERNAL));
    debug.setBounds(Async.firstLineError, util.lastLineError);
    return Promise2;
  };
});

// node_modules/bluebird/js/release/bluebird.js
var require_bluebird = __commonJS((exports, module) => {
  var old;
  if (typeof Promise !== "undefined")
    old = Promise;
  function noConflict() {
    try {
      if (Promise === bluebird)
        Promise = old;
    } catch (e) {}
    return bluebird;
  }
  var bluebird = require_promise()();
  bluebird.noConflict = noConflict;
  module.exports = bluebird;
});

// node_modules/unzipper/lib/Buffer.js
var require_Buffer = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  if (Buffer2.from === undefined) {
    Buffer2.from = function(a, b, c) {
      return new Buffer2(a, b, c);
    };
    Buffer2.alloc = Buffer2.from;
  }
  module.exports = Buffer2;
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports, module) => {
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module.exports = { nextTick };
  } else {
    module.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports, module) => {
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// node_modules/core-util-is/lib/util.js
var require_util4 = __commonJS((exports) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === undefined;
  }
  exports.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = __require("buffer").Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/unzipper/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList2 = __commonJS((exports, module) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util = __require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
      var obj2 = util.inspect({ length: this.length });
      return this.constructor.name + " " + obj2;
    };
  }
});

// node_modules/unzipper/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy
  };
});

// node_modules/unzipper/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable2 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node3()
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy2();
  util.inherits(Writable, Stream);
  function nop() {}
  function WritableState(options, stream) {
    Duplex = Duplex || require__stream_duplex2();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_2) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex2();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l2 = state.bufferedRequestCount;
      var buffer = new Array(l2);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/unzipper/node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex2 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj2) {
    var keys2 = [];
    for (var key2 in obj2) {
      keys2.push(key2);
    }
    return keys2;
  };
  module.exports = Duplex;
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var Readable = require__stream_readable2();
  var Writable = require__stream_writable2();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/unzipper/node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable2 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var debugUtil = __require("util");
  var debug = undefined;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {};
  }
  var BufferList = require_BufferList2();
  var destroyImpl = require_destroy2();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require__stream_duplex2();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex2();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l2 = xs.length;i < l2; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/unzipper/node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform2 = __commonJS((exports, module) => {
  module.exports = Transform;
  var Duplex = require__stream_duplex2();
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/unzipper/node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough2 = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform2();
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/unzipper/node_modules/readable-stream/readable.js
var require_readable2 = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable2();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable2();
    exports.Duplex = require__stream_duplex2();
    exports.Transform = require__stream_transform2();
    exports.PassThrough = require__stream_passthrough2();
  }
});

// node_modules/unzipper/lib/PullStream.js
var require_PullStream = __commonJS((exports, module) => {
  var Stream = __require("stream");
  var Promise2 = require_bluebird();
  var util = __require("util");
  var Buffer2 = require_Buffer();
  var strFunction = "function";
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable2();
  function PullStream() {
    if (!(this instanceof PullStream))
      return new PullStream;
    Stream.Duplex.call(this, { decodeStrings: false, objectMode: true });
    this.buffer = Buffer2.from("");
    var self2 = this;
    self2.on("finish", function() {
      self2.finished = true;
      self2.emit("chunk", false);
    });
  }
  util.inherits(PullStream, Stream.Duplex);
  PullStream.prototype._write = function(chunk, e, cb) {
    this.buffer = Buffer2.concat([this.buffer, chunk]);
    this.cb = cb;
    this.emit("chunk");
  };
  PullStream.prototype.stream = function(eof, includeEof) {
    var p = Stream.PassThrough();
    var done, self2 = this;
    function cb() {
      if (typeof self2.cb === strFunction) {
        var callback = self2.cb;
        self2.cb = undefined;
        return callback();
      }
    }
    function pull() {
      var packet;
      if (self2.buffer && self2.buffer.length) {
        if (typeof eof === "number") {
          packet = self2.buffer.slice(0, eof);
          self2.buffer = self2.buffer.slice(eof);
          eof -= packet.length;
          done = !eof;
        } else {
          var match = self2.buffer.indexOf(eof);
          if (match !== -1) {
            self2.match = match;
            if (includeEof)
              match = match + eof.length;
            packet = self2.buffer.slice(0, match);
            self2.buffer = self2.buffer.slice(match);
            done = true;
          } else {
            var len = self2.buffer.length - eof.length;
            if (len <= 0) {
              cb();
            } else {
              packet = self2.buffer.slice(0, len);
              self2.buffer = self2.buffer.slice(len);
            }
          }
        }
        if (packet)
          p.write(packet, function() {
            if (self2.buffer.length === 0 || eof.length && self2.buffer.length <= eof.length)
              cb();
          });
      }
      if (!done) {
        if (self2.finished) {
          self2.removeListener("chunk", pull);
          self2.emit("error", new Error("FILE_ENDED"));
          return;
        }
      } else {
        self2.removeListener("chunk", pull);
        p.end();
      }
    }
    self2.on("chunk", pull);
    pull();
    return p;
  };
  PullStream.prototype.pull = function(eof, includeEof) {
    if (eof === 0)
      return Promise2.resolve("");
    if (!isNaN(eof) && this.buffer.length > eof) {
      var data = this.buffer.slice(0, eof);
      this.buffer = this.buffer.slice(eof);
      return Promise2.resolve(data);
    }
    var buffer = Buffer2.from(""), self2 = this;
    var concatStream = Stream.Transform();
    concatStream._transform = function(d, e, cb) {
      buffer = Buffer2.concat([buffer, d]);
      cb();
    };
    var rejectHandler;
    var pullStreamRejectHandler;
    return new Promise2(function(resolve, reject) {
      rejectHandler = reject;
      pullStreamRejectHandler = function(e) {
        self2.__emittedError = e;
        reject(e);
      };
      if (self2.finished)
        return reject(new Error("FILE_ENDED"));
      self2.once("error", pullStreamRejectHandler);
      self2.stream(eof, includeEof).on("error", reject).pipe(concatStream).on("finish", function() {
        resolve(buffer);
      }).on("error", reject);
    }).finally(function() {
      self2.removeListener("error", rejectHandler);
      self2.removeListener("error", pullStreamRejectHandler);
    });
  };
  PullStream.prototype._read = function() {};
  module.exports = PullStream;
});

// node_modules/unzipper/lib/NoopStream.js
var require_NoopStream = __commonJS((exports, module) => {
  var Stream = __require("stream");
  var util = __require("util");
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable2();
  function NoopStream() {
    if (!(this instanceof NoopStream)) {
      return new NoopStream;
    }
    Stream.Transform.call(this);
  }
  util.inherits(NoopStream, Stream.Transform);
  NoopStream.prototype._transform = function(d, e, cb) {
    cb();
  };
  module.exports = NoopStream;
});

// node_modules/unzipper/lib/BufferStream.js
var require_BufferStream = __commonJS((exports, module) => {
  var Promise2 = require_bluebird();
  var Stream = __require("stream");
  var Buffer2 = require_Buffer();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable2();
  module.exports = function(entry) {
    return new Promise2(function(resolve, reject) {
      var chunks = [];
      var bufferStream = Stream.Transform().on("finish", function() {
        resolve(Buffer2.concat(chunks));
      }).on("error", reject);
      bufferStream._transform = function(d, e, cb) {
        chunks.push(d);
        cb();
      };
      entry.on("error", reject).pipe(bufferStream);
    });
  };
});

// node_modules/unzipper/lib/parseExtraField.js
var require_parseExtraField = __commonJS((exports, module) => {
  var binary = require_binary();
  module.exports = function(extraField, vars) {
    var extra;
    while (!extra && extraField && extraField.length) {
      var candidateExtra = binary.parse(extraField).word16lu("signature").word16lu("partsize").word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offset").word64lu("disknum").vars;
      if (candidateExtra.signature === 1) {
        extra = candidateExtra;
      } else {
        extraField = extraField.slice(candidateExtra.partsize + 4);
      }
    }
    extra = extra || {};
    if (vars.compressedSize === 4294967295)
      vars.compressedSize = extra.compressedSize;
    if (vars.uncompressedSize === 4294967295)
      vars.uncompressedSize = extra.uncompressedSize;
    if (vars.offsetToLocalFileHeader === 4294967295)
      vars.offsetToLocalFileHeader = extra.offset;
    return extra;
  };
});

// node_modules/unzipper/lib/parseDateTime.js
var require_parseDateTime = __commonJS((exports, module) => {
  module.exports = function parseDateTime(date, time) {
    const day = date & 31;
    const month = date >> 5 & 15;
    const year = (date >> 9 & 127) + 1980;
    const seconds = time ? (time & 31) * 2 : 0;
    const minutes = time ? time >> 5 & 63 : 0;
    const hours = time ? time >> 11 : 0;
    return new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds));
  };
});

// node_modules/unzipper/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var util = __require("util");
  var zlib = __require("zlib");
  var Stream = __require("stream");
  var binary = require_binary();
  var Promise2 = require_bluebird();
  var PullStream = require_PullStream();
  var NoopStream = require_NoopStream();
  var BufferStream = require_BufferStream();
  var parseExtraField = require_parseExtraField();
  var Buffer2 = require_Buffer();
  var parseDateTime = require_parseDateTime();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable2();
  var endDirectorySignature = Buffer2.alloc(4);
  endDirectorySignature.writeUInt32LE(101010256, 0);
  function Parse(opts) {
    if (!(this instanceof Parse)) {
      return new Parse(opts);
    }
    var self2 = this;
    self2._opts = opts || { verbose: false };
    PullStream.call(self2, self2._opts);
    self2.on("finish", function() {
      self2.emit("end");
      self2.emit("close");
    });
    self2._readRecord().catch(function(e) {
      if (!self2.__emittedError || self2.__emittedError !== e)
        self2.emit("error", e);
    });
  }
  util.inherits(Parse, PullStream);
  Parse.prototype._readRecord = function() {
    var self2 = this;
    return self2.pull(4).then(function(data) {
      if (data.length === 0)
        return;
      var signature = data.readUInt32LE(0);
      if (signature === 875721283) {
        return self2._readCrxHeader();
      }
      if (signature === 67324752) {
        return self2._readFile();
      } else if (signature === 33639248) {
        self2.reachedCD = true;
        return self2._readCentralDirectoryFileHeader();
      } else if (signature === 101010256) {
        return self2._readEndOfCentralDirectoryRecord();
      } else if (self2.reachedCD) {
        var includeEof = true;
        return self2.pull(endDirectorySignature, includeEof).then(function() {
          return self2._readEndOfCentralDirectoryRecord();
        });
      } else
        self2.emit("error", new Error("invalid signature: 0x" + signature.toString(16)));
    });
  };
  Parse.prototype._readCrxHeader = function() {
    var self2 = this;
    return self2.pull(12).then(function(data) {
      self2.crxHeader = binary.parse(data).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
      return self2.pull(self2.crxHeader.pubKeyLength + self2.crxHeader.signatureLength);
    }).then(function(data) {
      self2.crxHeader.publicKey = data.slice(0, self2.crxHeader.pubKeyLength);
      self2.crxHeader.signature = data.slice(self2.crxHeader.pubKeyLength);
      self2.emit("crx-header", self2.crxHeader);
      return self2._readRecord();
    });
  };
  Parse.prototype._readFile = function() {
    var self2 = this;
    return self2.pull(26).then(function(data) {
      var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);
      if (self2.crxHeader)
        vars.crxHeader = self2.crxHeader;
      return self2.pull(vars.fileNameLength).then(function(fileNameBuffer) {
        var fileName = fileNameBuffer.toString("utf8");
        var entry = Stream.PassThrough();
        var __autodraining = false;
        entry.autodrain = function() {
          __autodraining = true;
          var draining = entry.pipe(NoopStream());
          draining.promise = function() {
            return new Promise2(function(resolve, reject) {
              draining.on("finish", resolve);
              draining.on("error", reject);
            });
          };
          return draining;
        };
        entry.buffer = function() {
          return BufferStream(entry);
        };
        entry.path = fileName;
        entry.props = {};
        entry.props.path = fileName;
        entry.props.pathBuffer = fileNameBuffer;
        entry.props.flags = {
          isUnicode: (vars.flags & 2048) != 0
        };
        entry.type = vars.uncompressedSize === 0 && /[\/\\]$/.test(fileName) ? "Directory" : "File";
        if (self2._opts.verbose) {
          if (entry.type === "Directory") {
            console.log("   creating:", fileName);
          } else if (entry.type === "File") {
            if (vars.compressionMethod === 0) {
              console.log(" extracting:", fileName);
            } else {
              console.log("  inflating:", fileName);
            }
          }
        }
        return self2.pull(vars.extraFieldLength).then(function(extraField) {
          var extra = parseExtraField(extraField, vars);
          entry.vars = vars;
          entry.extra = extra;
          if (self2._opts.forceStream) {
            self2.push(entry);
          } else {
            self2.emit("entry", entry);
            if (self2._readableState.pipesCount || self2._readableState.pipes && self2._readableState.pipes.length)
              self2.push(entry);
          }
          if (self2._opts.verbose)
            console.log({
              filename: fileName,
              vars,
              extra
            });
          var fileSizeKnown = !(vars.flags & 8) || vars.compressedSize > 0, eof;
          entry.__autodraining = __autodraining;
          var inflater = vars.compressionMethod && !__autodraining ? zlib.createInflateRaw() : Stream.PassThrough();
          if (fileSizeKnown) {
            entry.size = vars.uncompressedSize;
            eof = vars.compressedSize;
          } else {
            eof = Buffer2.alloc(4);
            eof.writeUInt32LE(134695760, 0);
          }
          return new Promise2(function(resolve, reject) {
            self2.stream(eof).pipe(inflater).on("error", function(err) {
              self2.emit("error", err);
            }).pipe(entry).on("finish", function() {
              return fileSizeKnown ? self2._readRecord().then(resolve).catch(reject) : self2._processDataDescriptor(entry).then(resolve).catch(reject);
            });
          });
        });
      });
    });
  };
  Parse.prototype._processDataDescriptor = function(entry) {
    var self2 = this;
    return self2.pull(16).then(function(data) {
      var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
      entry.size = vars.uncompressedSize;
      return self2._readRecord();
    });
  };
  Parse.prototype._readCentralDirectoryFileHeader = function() {
    var self2 = this;
    return self2.pull(42).then(function(data) {
      var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
      return self2.pull(vars.fileNameLength).then(function(fileName) {
        vars.fileName = fileName.toString("utf8");
        return self2.pull(vars.extraFieldLength);
      }).then(function(extraField) {
        return self2.pull(vars.fileCommentLength);
      }).then(function(fileComment) {
        return self2._readRecord();
      });
    });
  };
  Parse.prototype._readEndOfCentralDirectoryRecord = function() {
    var self2 = this;
    return self2.pull(18).then(function(data) {
      var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      return self2.pull(vars.commentLength).then(function(comment) {
        comment = comment.toString("utf8");
        self2.end();
        self2.push(null);
      });
    });
  };
  Parse.prototype.promise = function() {
    var self2 = this;
    return new Promise2(function(resolve, reject) {
      self2.on("finish", resolve);
      self2.on("error", reject);
    });
  };
  module.exports = Parse;
});

// node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList3 = __commonJS((exports, module) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util = __require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
      var obj2 = util.inspect({ length: this.length });
      return this.constructor.name + " " + obj2;
    };
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy3 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy
  };
});

// node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable3 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node3()
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy3();
  util.inherits(Writable, Stream);
  function nop() {}
  function WritableState(options, stream) {
    Duplex = Duplex || require__stream_duplex3();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_2) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex3();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l2 = state.bufferedRequestCount;
      var buffer = new Array(l2);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/duplexer2/node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex3 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj2) {
    var keys2 = [];
    for (var key2 in obj2) {
      keys2.push(key2);
    }
    return keys2;
  };
  module.exports = Duplex;
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var Readable = require__stream_readable3();
  var Writable = require__stream_writable3();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/duplexer2/node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable3 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var debugUtil = __require("util");
  var debug = undefined;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {};
  }
  var BufferList = require_BufferList3();
  var destroyImpl = require_destroy3();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require__stream_duplex3();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex3();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l2 = xs.length;i < l2; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform3 = __commonJS((exports, module) => {
  module.exports = Transform;
  var Duplex = require__stream_duplex3();
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/duplexer2/node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough3 = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform3();
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/duplexer2/node_modules/readable-stream/readable.js
var require_readable3 = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable3();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable3();
    exports.Duplex = require__stream_duplex3();
    exports.Transform = require__stream_transform3();
    exports.PassThrough = require__stream_passthrough3();
  }
});

// node_modules/duplexer2/index.js
var require_duplexer2 = __commonJS((exports, module) => {
  var stream = require_readable3();
  function DuplexWrapper(options, writable, readable) {
    if (typeof readable === "undefined") {
      readable = writable;
      writable = options;
      options = null;
    }
    stream.Duplex.call(this, options);
    if (typeof readable.read !== "function") {
      readable = new stream.Readable(options).wrap(readable);
    }
    this._writable = writable;
    this._readable = readable;
    this._waiting = false;
    var self2 = this;
    writable.once("finish", function() {
      self2.end();
    });
    this.once("finish", function() {
      writable.end();
    });
    readable.on("readable", function() {
      if (self2._waiting) {
        self2._waiting = false;
        self2._read();
      }
    });
    readable.once("end", function() {
      self2.push(null);
    });
    if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
      writable.on("error", function(err) {
        self2.emit("error", err);
      });
      readable.on("error", function(err) {
        self2.emit("error", err);
      });
    }
  }
  DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, { constructor: { value: DuplexWrapper } });
  DuplexWrapper.prototype._write = function _write(input, encoding, done) {
    this._writable.write(input, encoding, done);
  };
  DuplexWrapper.prototype._read = function _read() {
    var buf;
    var reads = 0;
    while ((buf = this._readable.read()) !== null) {
      this.push(buf);
      reads++;
    }
    if (reads === 0) {
      this._waiting = true;
    }
  };
  module.exports = function duplex2(options, writable, readable) {
    return new DuplexWrapper(options, writable, readable);
  };
  module.exports.DuplexWrapper = DuplexWrapper;
});

// node_modules/unzipper/lib/parseOne.js
var require_parseOne = __commonJS((exports, module) => {
  var Stream = __require("stream");
  var Parse = require_parse();
  var duplexer2 = require_duplexer2();
  var BufferStream = require_BufferStream();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable2();
  function parseOne(match, opts) {
    var inStream = Stream.PassThrough({ objectMode: true });
    var outStream = Stream.PassThrough();
    var transform = Stream.Transform({ objectMode: true });
    var re = match instanceof RegExp ? match : match && new RegExp(match);
    var found;
    transform._transform = function(entry, e, cb) {
      if (found || re && !re.exec(entry.path)) {
        entry.autodrain();
        return cb();
      } else {
        found = true;
        out.emit("entry", entry);
        entry.on("error", function(e2) {
          outStream.emit("error", e2);
        });
        entry.pipe(outStream).on("error", function(err) {
          cb(err);
        }).on("finish", function(d) {
          cb(null, d);
        });
      }
    };
    inStream.pipe(Parse(opts)).on("error", function(err) {
      outStream.emit("error", err);
    }).pipe(transform).on("error", Object).on("finish", function() {
      if (!found)
        outStream.emit("error", new Error("PATTERN_NOT_FOUND"));
      else
        outStream.end();
    });
    var out = duplexer2(inStream, outStream);
    out.buffer = function() {
      return BufferStream(outStream);
    };
    return out;
  }
  module.exports = parseOne;
});

// node_modules/fstream/lib/abstract.js
var require_abstract = __commonJS((exports, module) => {
  module.exports = Abstract;
  var Stream = __require("stream").Stream;
  var inherits = require_inherits();
  function Abstract() {
    Stream.call(this);
  }
  inherits(Abstract, Stream);
  Abstract.prototype.on = function(ev, fn) {
    if (ev === "ready" && this.ready) {
      process.nextTick(fn.bind(this));
    } else {
      Stream.prototype.on.call(this, ev, fn);
    }
    return this;
  };
  Abstract.prototype.abort = function() {
    this._aborted = true;
    this.emit("abort");
  };
  Abstract.prototype.destroy = function() {};
  Abstract.prototype.warn = function(msg, code) {
    var self2 = this;
    var er = decorate(msg, code, self2);
    if (!self2.listeners("warn")) {
      console.error(`%s %s
` + `path = %s
` + `syscall = %s
` + `fstream_type = %s
` + `fstream_path = %s
` + `fstream_unc_path = %s
` + `fstream_class = %s
` + `fstream_stack =
%s
`, code || "UNKNOWN", er.stack, er.path, er.syscall, er.fstream_type, er.fstream_path, er.fstream_unc_path, er.fstream_class, er.fstream_stack.join(`
`));
    } else {
      self2.emit("warn", er);
    }
  };
  Abstract.prototype.info = function(msg, code) {
    this.emit("info", msg, code);
  };
  Abstract.prototype.error = function(msg, code, th) {
    var er = decorate(msg, code, this);
    if (th)
      throw er;
    else
      this.emit("error", er);
  };
  function decorate(er, code, self2) {
    if (!(er instanceof Error))
      er = new Error(er);
    er.code = er.code || code;
    er.path = er.path || self2.path;
    er.fstream_type = er.fstream_type || self2.type;
    er.fstream_path = er.fstream_path || self2.path;
    if (self2._path !== self2.path) {
      er.fstream_unc_path = er.fstream_unc_path || self2._path;
    }
    if (self2.linkpath) {
      er.fstream_linkpath = er.fstream_linkpath || self2.linkpath;
    }
    er.fstream_class = er.fstream_class || self2.constructor.name;
    er.fstream_stack = er.fstream_stack || new Error().stack.split(/\n/).slice(3).map(function(s) {
      return s.replace(/^ {4}at /, "");
    });
    return er;
  }
});

// node_modules/fstream/lib/get-type.js
var require_get_type = __commonJS((exports, module) => {
  module.exports = getType;
  function getType(st) {
    var types = [
      "Directory",
      "File",
      "SymbolicLink",
      "Link",
      "BlockDevice",
      "CharacterDevice",
      "FIFO",
      "Socket"
    ];
    var type;
    if (st.type && types.indexOf(st.type) !== -1) {
      st[st.type] = true;
      return st.type;
    }
    for (var i = 0, l2 = types.length;i < l2; i++) {
      type = types[i];
      var is = st[type] || st["is" + type];
      if (typeof is === "function")
        is = is.call(st);
      if (is) {
        st[type] = true;
        st.type = type;
        return type;
      }
    }
    return null;
  }
});

// node_modules/fstream/lib/link-reader.js
var require_link_reader = __commonJS((exports, module) => {
  module.exports = LinkReader;
  var fs = require_graceful_fs();
  var inherits = require_inherits();
  var Reader = require_reader();
  inherits(LinkReader, Reader);
  function LinkReader(props) {
    var self2 = this;
    if (!(self2 instanceof LinkReader)) {
      throw new Error("LinkReader must be called as constructor.");
    }
    if (!(props.type === "Link" && props.Link || props.type === "SymbolicLink" && props.SymbolicLink)) {
      throw new Error("Non-link type " + props.type);
    }
    Reader.call(self2, props);
  }
  LinkReader.prototype._stat = function(currentStat) {
    var self2 = this;
    fs.readlink(self2._path, function(er, linkpath) {
      if (er)
        return self2.error(er);
      self2.linkpath = self2.props.linkpath = linkpath;
      self2.emit("linkpath", linkpath);
      Reader.prototype._stat.call(self2, currentStat);
    });
  };
  LinkReader.prototype._read = function() {
    var self2 = this;
    if (self2._paused)
      return;
    if (!self2._ended) {
      self2.emit("end");
      self2.emit("close");
      self2._ended = true;
    }
  };
});

// node_modules/fstream/lib/dir-reader.js
var require_dir_reader = __commonJS((exports, module) => {
  module.exports = DirReader;
  var fs = require_graceful_fs();
  var inherits = require_inherits();
  var path = __require("path");
  var Reader = require_reader();
  var assert = __require("assert").ok;
  inherits(DirReader, Reader);
  function DirReader(props) {
    var self2 = this;
    if (!(self2 instanceof DirReader)) {
      throw new Error("DirReader must be called as constructor.");
    }
    if (props.type !== "Directory" || !props.Directory) {
      throw new Error("Non-directory type " + props.type);
    }
    self2.entries = null;
    self2._index = -1;
    self2._paused = false;
    self2._length = -1;
    if (props.sort) {
      this.sort = props.sort;
    }
    Reader.call(this, props);
  }
  DirReader.prototype._getEntries = function() {
    var self2 = this;
    if (self2._gotEntries)
      return;
    self2._gotEntries = true;
    fs.readdir(self2._path, function(er, entries) {
      if (er)
        return self2.error(er);
      self2.entries = entries;
      self2.emit("entries", entries);
      if (self2._paused)
        self2.once("resume", processEntries);
      else
        processEntries();
      function processEntries() {
        self2._length = self2.entries.length;
        if (typeof self2.sort === "function") {
          self2.entries = self2.entries.sort(self2.sort.bind(self2));
        }
        self2._read();
      }
    });
  };
  DirReader.prototype._read = function() {
    var self2 = this;
    if (!self2.entries)
      return self2._getEntries();
    if (self2._paused || self2._currentEntry || self2._aborted) {
      return;
    }
    self2._index++;
    if (self2._index >= self2.entries.length) {
      if (!self2._ended) {
        self2._ended = true;
        self2.emit("end");
        self2.emit("close");
      }
      return;
    }
    var p = path.resolve(self2._path, self2.entries[self2._index]);
    assert(p !== self2._path);
    assert(self2.entries[self2._index]);
    self2._currentEntry = p;
    fs[self2.props.follow ? "stat" : "lstat"](p, function(er, stat) {
      if (er)
        return self2.error(er);
      var who = self2._proxy || self2;
      stat.path = p;
      stat.basename = path.basename(p);
      stat.dirname = path.dirname(p);
      var childProps = self2.getChildProps.call(who, stat);
      childProps.path = p;
      childProps.basename = path.basename(p);
      childProps.dirname = path.dirname(p);
      var entry = Reader(childProps, stat);
      self2._currentEntry = entry;
      entry.on("pause", function(who2) {
        if (!self2._paused && !entry._disowned) {
          self2.pause(who2);
        }
      });
      entry.on("resume", function(who2) {
        if (self2._paused && !entry._disowned) {
          self2.resume(who2);
        }
      });
      entry.on("stat", function(props) {
        self2.emit("_entryStat", entry, props);
        if (entry._aborted)
          return;
        if (entry._paused) {
          entry.once("resume", function() {
            self2.emit("entryStat", entry, props);
          });
        } else
          self2.emit("entryStat", entry, props);
      });
      entry.on("ready", function EMITCHILD() {
        if (self2._paused) {
          entry.pause(self2);
          return self2.once("resume", EMITCHILD);
        }
        if (entry.type === "Socket") {
          self2.emit("socket", entry);
        } else {
          self2.emitEntry(entry);
        }
      });
      var ended = false;
      entry.on("close", onend);
      entry.on("disown", onend);
      function onend() {
        if (ended)
          return;
        ended = true;
        self2.emit("childEnd", entry);
        self2.emit("entryEnd", entry);
        self2._currentEntry = null;
        if (!self2._paused) {
          self2._read();
        }
      }
      entry.on("error", function(er2) {
        if (entry._swallowErrors) {
          self2.warn(er2);
          entry.emit("end");
          entry.emit("close");
        } else {
          self2.emit("error", er2);
        }
      });
      [
        "child",
        "childEnd",
        "warn"
      ].forEach(function(ev) {
        entry.on(ev, self2.emit.bind(self2, ev));
      });
    });
  };
  DirReader.prototype.disown = function(entry) {
    entry.emit("beforeDisown");
    entry._disowned = true;
    entry.parent = entry.root = null;
    if (entry === this._currentEntry) {
      this._currentEntry = null;
    }
    entry.emit("disown");
  };
  DirReader.prototype.getChildProps = function() {
    return {
      depth: this.depth + 1,
      root: this.root || this,
      parent: this,
      follow: this.follow,
      filter: this.filter,
      sort: this.props.sort,
      hardlinks: this.props.hardlinks
    };
  };
  DirReader.prototype.pause = function(who) {
    var self2 = this;
    if (self2._paused)
      return;
    who = who || self2;
    self2._paused = true;
    if (self2._currentEntry && self2._currentEntry.pause) {
      self2._currentEntry.pause(who);
    }
    self2.emit("pause", who);
  };
  DirReader.prototype.resume = function(who) {
    var self2 = this;
    if (!self2._paused)
      return;
    who = who || self2;
    self2._paused = false;
    self2.emit("resume", who);
    if (self2._paused) {
      return;
    }
    if (self2._currentEntry) {
      if (self2._currentEntry.resume)
        self2._currentEntry.resume(who);
    } else
      self2._read();
  };
  DirReader.prototype.emitEntry = function(entry) {
    this.emit("entry", entry);
    this.emit("child", entry);
  };
});

// node_modules/fstream/lib/file-reader.js
var require_file_reader = __commonJS((exports, module) => {
  module.exports = FileReader2;
  var fs = require_graceful_fs();
  var inherits = require_inherits();
  var Reader = require_reader();
  var EOF = { EOF: true };
  var CLOSE = { CLOSE: true };
  inherits(FileReader2, Reader);
  function FileReader2(props) {
    var self2 = this;
    if (!(self2 instanceof FileReader2)) {
      throw new Error("FileReader must be called as constructor.");
    }
    if (!(props.type === "Link" && props.Link || props.type === "File" && props.File)) {
      throw new Error("Non-file type " + props.type);
    }
    self2._buffer = [];
    self2._bytesEmitted = 0;
    Reader.call(self2, props);
  }
  FileReader2.prototype._getStream = function() {
    var self2 = this;
    var stream = self2._stream = fs.createReadStream(self2._path, self2.props);
    if (self2.props.blksize) {
      stream.bufferSize = self2.props.blksize;
    }
    stream.on("open", self2.emit.bind(self2, "open"));
    stream.on("data", function(c) {
      self2._bytesEmitted += c.length;
      if (!c.length) {
        return;
      } else if (self2._paused || self2._buffer.length) {
        self2._buffer.push(c);
        self2._read();
      } else
        self2.emit("data", c);
    });
    stream.on("end", function() {
      if (self2._paused || self2._buffer.length) {
        self2._buffer.push(EOF);
        self2._read();
      } else {
        self2.emit("end");
      }
      if (self2._bytesEmitted !== self2.props.size) {
        self2.error(`Didn't get expected byte count
` + "expect: " + self2.props.size + `
` + "actual: " + self2._bytesEmitted);
      }
    });
    stream.on("close", function() {
      if (self2._paused || self2._buffer.length) {
        self2._buffer.push(CLOSE);
        self2._read();
      } else {
        self2.emit("close");
      }
    });
    stream.on("error", function(e) {
      self2.emit("error", e);
    });
    self2._read();
  };
  FileReader2.prototype._read = function() {
    var self2 = this;
    if (self2._paused) {
      return;
    }
    if (!self2._stream) {
      return self2._getStream();
    }
    if (self2._buffer.length) {
      var buf = self2._buffer;
      for (var i = 0, l2 = buf.length;i < l2; i++) {
        var c = buf[i];
        if (c === EOF) {
          self2.emit("end");
        } else if (c === CLOSE) {
          self2.emit("close");
        } else {
          self2.emit("data", c);
        }
        if (self2._paused) {
          self2._buffer = buf.slice(i);
          return;
        }
      }
      self2._buffer.length = 0;
    }
  };
  FileReader2.prototype.pause = function(who) {
    var self2 = this;
    if (self2._paused)
      return;
    who = who || self2;
    self2._paused = true;
    if (self2._stream)
      self2._stream.pause();
    self2.emit("pause", who);
  };
  FileReader2.prototype.resume = function(who) {
    var self2 = this;
    if (!self2._paused)
      return;
    who = who || self2;
    self2.emit("resume", who);
    self2._paused = false;
    if (self2._stream)
      self2._stream.resume();
    self2._read();
  };
});

// node_modules/fstream/lib/socket-reader.js
var require_socket_reader = __commonJS((exports, module) => {
  module.exports = SocketReader;
  var inherits = require_inherits();
  var Reader = require_reader();
  inherits(SocketReader, Reader);
  function SocketReader(props) {
    var self2 = this;
    if (!(self2 instanceof SocketReader)) {
      throw new Error("SocketReader must be called as constructor.");
    }
    if (!(props.type === "Socket" && props.Socket)) {
      throw new Error("Non-socket type " + props.type);
    }
    Reader.call(self2, props);
  }
  SocketReader.prototype._read = function() {
    var self2 = this;
    if (self2._paused)
      return;
    if (!self2._ended) {
      self2.emit("end");
      self2.emit("close");
      self2._ended = true;
    }
  };
});

// node_modules/fstream/lib/proxy-reader.js
var require_proxy_reader = __commonJS((exports, module) => {
  module.exports = ProxyReader;
  var Reader = require_reader();
  var getType = require_get_type();
  var inherits = require_inherits();
  var fs = require_graceful_fs();
  inherits(ProxyReader, Reader);
  function ProxyReader(props) {
    var self2 = this;
    if (!(self2 instanceof ProxyReader)) {
      throw new Error("ProxyReader must be called as constructor.");
    }
    self2.props = props;
    self2._buffer = [];
    self2.ready = false;
    Reader.call(self2, props);
  }
  ProxyReader.prototype._stat = function() {
    var self2 = this;
    var props = self2.props;
    var stat = props.follow ? "stat" : "lstat";
    fs[stat](props.path, function(er, current) {
      var type;
      if (er || !current) {
        type = "File";
      } else {
        type = getType(current);
      }
      props[type] = true;
      props.type = self2.type = type;
      self2._old = current;
      self2._addProxy(Reader(props, current));
    });
  };
  ProxyReader.prototype._addProxy = function(proxy) {
    var self2 = this;
    if (self2._proxyTarget) {
      return self2.error("proxy already set");
    }
    self2._proxyTarget = proxy;
    proxy._proxy = self2;
    [
      "error",
      "data",
      "end",
      "close",
      "linkpath",
      "entry",
      "entryEnd",
      "child",
      "childEnd",
      "warn",
      "stat"
    ].forEach(function(ev) {
      proxy.on(ev, self2.emit.bind(self2, ev));
    });
    self2.emit("proxy", proxy);
    proxy.on("ready", function() {
      self2.ready = true;
      self2.emit("ready");
    });
    var calls = self2._buffer;
    self2._buffer.length = 0;
    calls.forEach(function(c) {
      proxy[c[0]].apply(proxy, c[1]);
    });
  };
  ProxyReader.prototype.pause = function() {
    return this._proxyTarget ? this._proxyTarget.pause() : false;
  };
  ProxyReader.prototype.resume = function() {
    return this._proxyTarget ? this._proxyTarget.resume() : false;
  };
});

// node_modules/fstream/lib/reader.js
var require_reader = __commonJS((exports, module) => {
  module.exports = Reader;
  var fs = require_graceful_fs();
  var Stream = __require("stream").Stream;
  var inherits = require_inherits();
  var path = __require("path");
  var getType = require_get_type();
  var hardLinks = Reader.hardLinks = {};
  var Abstract = require_abstract();
  inherits(Reader, Abstract);
  var LinkReader = require_link_reader();
  function Reader(props, currentStat) {
    var self2 = this;
    if (!(self2 instanceof Reader))
      return new Reader(props, currentStat);
    if (typeof props === "string") {
      props = { path: props };
    }
    var type;
    var ClassType;
    if (props.type && typeof props.type === "function") {
      type = props.type;
      ClassType = type;
    } else {
      type = getType(props);
      ClassType = Reader;
    }
    if (currentStat && !type) {
      type = getType(currentStat);
      props[type] = true;
      props.type = type;
    }
    switch (type) {
      case "Directory":
        ClassType = require_dir_reader();
        break;
      case "Link":
      case "File":
        ClassType = require_file_reader();
        break;
      case "SymbolicLink":
        ClassType = LinkReader;
        break;
      case "Socket":
        ClassType = require_socket_reader();
        break;
      case null:
        ClassType = require_proxy_reader();
        break;
    }
    if (!(self2 instanceof ClassType)) {
      return new ClassType(props);
    }
    Abstract.call(self2);
    if (!props.path) {
      self2.error("Must provide a path", null, true);
    }
    self2.readable = true;
    self2.writable = false;
    self2.type = type;
    self2.props = props;
    self2.depth = props.depth = props.depth || 0;
    self2.parent = props.parent || null;
    self2.root = props.root || props.parent && props.parent.root || self2;
    self2._path = self2.path = path.resolve(props.path);
    if (process.platform === "win32") {
      self2.path = self2._path = self2.path.replace(/\?/g, "_");
      if (self2._path.length >= 260) {
        self2._swallowErrors = true;
        self2._path = "\\\\?\\" + self2.path.replace(/\//g, "\\");
      }
    }
    self2.basename = props.basename = path.basename(self2.path);
    self2.dirname = props.dirname = path.dirname(self2.path);
    props.parent = props.root = null;
    self2.size = props.size;
    self2.filter = typeof props.filter === "function" ? props.filter : null;
    if (props.sort === "alpha")
      props.sort = alphasort;
    self2._stat(currentStat);
  }
  function alphasort(a, b) {
    return a === b ? 0 : a.toLowerCase() > b.toLowerCase() ? 1 : a.toLowerCase() < b.toLowerCase() ? -1 : a > b ? 1 : -1;
  }
  Reader.prototype._stat = function(currentStat) {
    var self2 = this;
    var props = self2.props;
    var stat = props.follow ? "stat" : "lstat";
    if (currentStat)
      process.nextTick(statCb.bind(null, null, currentStat));
    else
      fs[stat](self2._path, statCb);
    function statCb(er, props_) {
      if (er)
        return self2.error(er);
      Object.keys(props_).forEach(function(k2) {
        props[k2] = props_[k2];
      });
      if (self2.size !== undefined && props.size !== self2.size) {
        return self2.error("incorrect size");
      }
      self2.size = props.size;
      var type = getType(props);
      var handleHardlinks = props.hardlinks !== false;
      if (handleHardlinks && type !== "Directory" && props.nlink && props.nlink > 1) {
        var k = props.dev + ":" + props.ino;
        if (hardLinks[k] === self2._path || !hardLinks[k]) {
          hardLinks[k] = self2._path;
        } else {
          type = self2.type = self2.props.type = "Link";
          self2.Link = self2.props.Link = true;
          self2.linkpath = self2.props.linkpath = hardLinks[k];
          self2._stat = self2._read = LinkReader.prototype._read;
        }
      }
      if (self2.type && self2.type !== type) {
        self2.error("Unexpected type: " + type);
      }
      if (self2.filter) {
        var who = self2._proxy || self2;
        if (!self2.filter.call(who, who, props)) {
          if (!self2._disowned) {
            self2.abort();
            self2.emit("end");
            self2.emit("close");
          }
          return;
        }
      }
      var events = ["_stat", "stat", "ready"];
      var e = 0;
      (function go() {
        if (self2._aborted) {
          self2.emit("end");
          self2.emit("close");
          return;
        }
        if (self2._paused && self2.type !== "Directory") {
          self2.once("resume", go);
          return;
        }
        var ev = events[e++];
        if (!ev) {
          return self2._read();
        }
        self2.emit(ev, props);
        go();
      })();
    }
  };
  Reader.prototype.pipe = function(dest) {
    var self2 = this;
    if (typeof dest.add === "function") {
      self2.on("entry", function(entry) {
        var ret = dest.add(entry);
        if (ret === false) {
          self2.pause();
        }
      });
    }
    return Stream.prototype.pipe.apply(this, arguments);
  };
  Reader.prototype.pause = function(who) {
    this._paused = true;
    who = who || this;
    this.emit("pause", who);
    if (this._stream)
      this._stream.pause(who);
  };
  Reader.prototype.resume = function(who) {
    this._paused = false;
    who = who || this;
    this.emit("resume", who);
    if (this._stream)
      this._stream.resume(who);
    this._read();
  };
  Reader.prototype._read = function() {
    this.error("Cannot read unknown type: " + this.type);
  };
});

// node_modules/rimraf/rimraf.js
var require_rimraf3 = __commonJS((exports, module) => {
  module.exports = rimraf;
  rimraf.sync = rimrafSync;
  var assert = __require("assert");
  var path = __require("path");
  var fs = __require("fs");
  var glob = undefined;
  try {
    glob = require_glob();
  } catch (_err) {}
  var _0666 = parseInt("666", 8);
  var defaultGlobOpts = {
    nosort: true,
    silent: true
  };
  var timeout = 0;
  var isWindows = process.platform === "win32";
  function defaults(options) {
    var methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach(function(m2) {
      options[m2] = options[m2] || fs[m2];
      m2 = m2 + "Sync";
      options[m2] = options[m2] || fs[m2];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1000;
    if (options.glob === false) {
      options.disableGlob = true;
    }
    if (options.disableGlob !== true && glob === undefined) {
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    }
    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
  }
  function rimraf(p, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert.equal(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    var busyTries = 0;
    var errState = null;
    var n = 0;
    if (options.disableGlob || !glob.hasMagic(p))
      return afterGlob(null, [p]);
    options.lstat(p, function(er, stat) {
      if (!er)
        return afterGlob(null, [p]);
      glob(p, options.glob, afterGlob);
    });
    function next(er) {
      errState = errState || er;
      if (--n === 0)
        cb(errState);
    }
    function afterGlob(er, results2) {
      if (er)
        return cb(er);
      n = results2.length;
      if (n === 0)
        return cb();
      results2.forEach(function(p2) {
        rimraf_(p2, options, function CB(er2) {
          if (er2) {
            if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
              busyTries++;
              var time = busyTries * 100;
              return setTimeout(function() {
                rimraf_(p2, options, CB);
              }, time);
            }
            if (er2.code === "EMFILE" && timeout < options.emfileWait) {
              return setTimeout(function() {
                rimraf_(p2, options, CB);
              }, timeout++);
            }
            if (er2.code === "ENOENT")
              er2 = null;
          }
          timeout = 0;
          next(er2);
        });
      });
    }
  }
  function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, function(er, st) {
      if (er && er.code === "ENOENT")
        return cb(null);
      if (er && er.code === "EPERM" && isWindows)
        fixWinEPERM(p, options, er, cb);
      if (st && st.isDirectory())
        return rmdir(p, options, er, cb);
      options.unlink(p, function(er2) {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb(null);
          if (er2.code === "EPERM")
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          if (er2.code === "EISDIR")
            return rmdir(p, options, er2, cb);
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    if (er)
      assert(er instanceof Error);
    options.chmod(p, _0666, function(er2) {
      if (er2)
        cb(er2.code === "ENOENT" ? null : er);
      else
        options.stat(p, function(er3, stats) {
          if (er3)
            cb(er3.code === "ENOENT" ? null : er);
          else if (stats.isDirectory())
            rmdir(p, options, er, cb);
          else
            options.unlink(p, cb);
        });
    });
  }
  function fixWinEPERMSync(p, options, er) {
    assert(p);
    assert(options);
    if (er)
      assert(er instanceof Error);
    try {
      options.chmodSync(p, _0666);
    } catch (er2) {
      if (er2.code === "ENOENT")
        return;
      else
        throw er;
    }
    try {
      var stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT")
        return;
      else
        throw er;
    }
    if (stats.isDirectory())
      rmdirSync(p, options, er);
    else
      options.unlinkSync(p);
  }
  function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    if (originalEr)
      assert(originalEr instanceof Error);
    assert(typeof cb === "function");
    options.rmdir(p, function(er) {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
        rmkids(p, options, cb);
      else if (er && er.code === "ENOTDIR")
        cb(originalEr);
      else
        cb(er);
    });
  }
  function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, function(er, files) {
      if (er)
        return cb(er);
      var n = files.length;
      if (n === 0)
        return options.rmdir(p, cb);
      var errState;
      files.forEach(function(f) {
        rimraf(path.join(p, f), options, function(er2) {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--n === 0)
            options.rmdir(p, cb);
        });
      });
    });
  }
  function rimrafSync(p, options) {
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    var results2;
    if (options.disableGlob || !glob.hasMagic(p)) {
      results2 = [p];
    } else {
      try {
        options.lstatSync(p);
        results2 = [p];
      } catch (er) {
        results2 = glob.sync(p, options.glob);
      }
    }
    if (!results2.length)
      return;
    for (var i = 0;i < results2.length; i++) {
      var p = results2[i];
      try {
        var st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM" && isWindows)
          fixWinEPERMSync(p, options, er);
      }
      try {
        if (st && st.isDirectory())
          rmdirSync(p, options, null);
        else
          options.unlinkSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p, options, er);
      }
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    if (originalEr)
      assert(originalEr instanceof Error);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR")
        throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
        rmkidsSync(p, options);
    }
  }
  function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach(function(f) {
      rimrafSync(path.join(p, f), options);
    });
    var retries = isWindows ? 100 : 1;
    var i = 0;
    do {
      var threw = true;
      try {
        var ret = options.rmdirSync(p, options);
        threw = false;
        return ret;
      } finally {
        if (++i < retries && threw)
          continue;
      }
    } while (true);
  }
});

// node_modules/mkdirp/dist/cjs/src/opts-arg.js
var require_opts_arg = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.optsArg = undefined;
  var fs_1 = __require("fs");
  var optsArg = (opts) => {
    if (!opts) {
      opts = { mode: 511 };
    } else if (typeof opts === "object") {
      opts = { mode: 511, ...opts };
    } else if (typeof opts === "number") {
      opts = { mode: opts };
    } else if (typeof opts === "string") {
      opts = { mode: parseInt(opts, 8) };
    } else {
      throw new TypeError("invalid options argument");
    }
    const resolved = opts;
    const optsFs = opts.fs || {};
    opts.mkdir = opts.mkdir || optsFs.mkdir || fs_1.mkdir;
    opts.mkdirAsync = opts.mkdirAsync ? opts.mkdirAsync : async (path, options) => {
      return new Promise((res, rej) => resolved.mkdir(path, options, (er, made) => er ? rej(er) : res(made)));
    };
    opts.stat = opts.stat || optsFs.stat || fs_1.stat;
    opts.statAsync = opts.statAsync ? opts.statAsync : async (path) => new Promise((res, rej) => resolved.stat(path, (err, stats) => err ? rej(err) : res(stats)));
    opts.statSync = opts.statSync || optsFs.statSync || fs_1.statSync;
    opts.mkdirSync = opts.mkdirSync || optsFs.mkdirSync || fs_1.mkdirSync;
    return resolved;
  };
  exports.optsArg = optsArg;
});

// node_modules/mkdirp/dist/cjs/src/mkdirp-manual.js
var require_mkdirp_manual = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mkdirpManual = exports.mkdirpManualSync = undefined;
  var path_1 = __require("path");
  var opts_arg_js_1 = require_opts_arg();
  var mkdirpManualSync = (path, options, made) => {
    const parent = (0, path_1.dirname)(path);
    const opts = { ...(0, opts_arg_js_1.optsArg)(options), recursive: false };
    if (parent === path) {
      try {
        return opts.mkdirSync(path, opts);
      } catch (er) {
        const fer = er;
        if (fer && fer.code !== "EISDIR") {
          throw er;
        }
        return;
      }
    }
    try {
      opts.mkdirSync(path, opts);
      return made || path;
    } catch (er) {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return (0, exports.mkdirpManualSync)(path, opts, (0, exports.mkdirpManualSync)(parent, opts, made));
      }
      if (fer && fer.code !== "EEXIST" && fer && fer.code !== "EROFS") {
        throw er;
      }
      try {
        if (!opts.statSync(path).isDirectory())
          throw er;
      } catch (_2) {
        throw er;
      }
    }
  };
  exports.mkdirpManualSync = mkdirpManualSync;
  exports.mkdirpManual = Object.assign(async (path, options, made) => {
    const opts = (0, opts_arg_js_1.optsArg)(options);
    opts.recursive = false;
    const parent = (0, path_1.dirname)(path);
    if (parent === path) {
      return opts.mkdirAsync(path, opts).catch((er) => {
        const fer = er;
        if (fer && fer.code !== "EISDIR") {
          throw er;
        }
      });
    }
    return opts.mkdirAsync(path, opts).then(() => made || path, async (er) => {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return (0, exports.mkdirpManual)(parent, opts).then((made2) => (0, exports.mkdirpManual)(path, opts, made2));
      }
      if (fer && fer.code !== "EEXIST" && fer.code !== "EROFS") {
        throw er;
      }
      return opts.statAsync(path).then((st) => {
        if (st.isDirectory()) {
          return made;
        } else {
          throw er;
        }
      }, () => {
        throw er;
      });
    });
  }, { sync: exports.mkdirpManualSync });
});

// node_modules/mkdirp/dist/cjs/src/find-made.js
var require_find_made = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findMadeSync = exports.findMade = undefined;
  var path_1 = __require("path");
  var findMade = async (opts, parent, path) => {
    if (path === parent) {
      return;
    }
    return opts.statAsync(parent).then((st) => st.isDirectory() ? path : undefined, (er) => {
      const fer = er;
      return fer && fer.code === "ENOENT" ? (0, exports.findMade)(opts, (0, path_1.dirname)(parent), parent) : undefined;
    });
  };
  exports.findMade = findMade;
  var findMadeSync = (opts, parent, path) => {
    if (path === parent) {
      return;
    }
    try {
      return opts.statSync(parent).isDirectory() ? path : undefined;
    } catch (er) {
      const fer = er;
      return fer && fer.code === "ENOENT" ? (0, exports.findMadeSync)(opts, (0, path_1.dirname)(parent), parent) : undefined;
    }
  };
  exports.findMadeSync = findMadeSync;
});

// node_modules/mkdirp/dist/cjs/src/mkdirp-native.js
var require_mkdirp_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mkdirpNative = exports.mkdirpNativeSync = undefined;
  var path_1 = __require("path");
  var find_made_js_1 = require_find_made();
  var mkdirp_manual_js_1 = require_mkdirp_manual();
  var opts_arg_js_1 = require_opts_arg();
  var mkdirpNativeSync = (path, options) => {
    const opts = (0, opts_arg_js_1.optsArg)(options);
    opts.recursive = true;
    const parent = (0, path_1.dirname)(path);
    if (parent === path) {
      return opts.mkdirSync(path, opts);
    }
    const made = (0, find_made_js_1.findMadeSync)(opts, path);
    try {
      opts.mkdirSync(path, opts);
      return made;
    } catch (er) {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return (0, mkdirp_manual_js_1.mkdirpManualSync)(path, opts);
      } else {
        throw er;
      }
    }
  };
  exports.mkdirpNativeSync = mkdirpNativeSync;
  exports.mkdirpNative = Object.assign(async (path, options) => {
    const opts = { ...(0, opts_arg_js_1.optsArg)(options), recursive: true };
    const parent = (0, path_1.dirname)(path);
    if (parent === path) {
      return await opts.mkdirAsync(path, opts);
    }
    return (0, find_made_js_1.findMade)(opts, path).then((made) => opts.mkdirAsync(path, opts).then((m2) => made || m2).catch((er) => {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return (0, mkdirp_manual_js_1.mkdirpManual)(path, opts);
      } else {
        throw er;
      }
    }));
  }, { sync: exports.mkdirpNativeSync });
});

// node_modules/mkdirp/dist/cjs/src/path-arg.js
var require_path_arg = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pathArg = undefined;
  var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
  var path_1 = __require("path");
  var pathArg = (path) => {
    if (/\0/.test(path)) {
      throw Object.assign(new TypeError("path must be a string without null bytes"), {
        path,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path = (0, path_1.resolve)(path);
    if (platform === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const { root } = (0, path_1.parse)(path);
      if (badWinChars.test(path.substring(root.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path,
          code: "EINVAL"
        });
      }
    }
    return path;
  };
  exports.pathArg = pathArg;
});

// node_modules/mkdirp/dist/cjs/src/use-native.js
var require_use_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.useNative = exports.useNativeSync = undefined;
  var fs_1 = __require("fs");
  var opts_arg_js_1 = require_opts_arg();
  var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  var versArr = version.replace(/^v/, "").split(".");
  var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  exports.useNativeSync = !hasNative ? () => false : (opts) => (0, opts_arg_js_1.optsArg)(opts).mkdirSync === fs_1.mkdirSync;
  exports.useNative = Object.assign(!hasNative ? () => false : (opts) => (0, opts_arg_js_1.optsArg)(opts).mkdir === fs_1.mkdir, {
    sync: exports.useNativeSync
  });
});

// node_modules/mkdirp/dist/cjs/src/index.js
var require_src4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mkdirp = exports.nativeSync = exports.native = exports.manualSync = exports.manual = exports.sync = exports.mkdirpSync = exports.useNativeSync = exports.useNative = exports.mkdirpNativeSync = exports.mkdirpNative = exports.mkdirpManualSync = exports.mkdirpManual = undefined;
  var mkdirp_manual_js_1 = require_mkdirp_manual();
  var mkdirp_native_js_1 = require_mkdirp_native();
  var opts_arg_js_1 = require_opts_arg();
  var path_arg_js_1 = require_path_arg();
  var use_native_js_1 = require_use_native();
  var mkdirp_manual_js_2 = require_mkdirp_manual();
  Object.defineProperty(exports, "mkdirpManual", { enumerable: true, get: function() {
    return mkdirp_manual_js_2.mkdirpManual;
  } });
  Object.defineProperty(exports, "mkdirpManualSync", { enumerable: true, get: function() {
    return mkdirp_manual_js_2.mkdirpManualSync;
  } });
  var mkdirp_native_js_2 = require_mkdirp_native();
  Object.defineProperty(exports, "mkdirpNative", { enumerable: true, get: function() {
    return mkdirp_native_js_2.mkdirpNative;
  } });
  Object.defineProperty(exports, "mkdirpNativeSync", { enumerable: true, get: function() {
    return mkdirp_native_js_2.mkdirpNativeSync;
  } });
  var use_native_js_2 = require_use_native();
  Object.defineProperty(exports, "useNative", { enumerable: true, get: function() {
    return use_native_js_2.useNative;
  } });
  Object.defineProperty(exports, "useNativeSync", { enumerable: true, get: function() {
    return use_native_js_2.useNativeSync;
  } });
  var mkdirpSync = (path, opts) => {
    path = (0, path_arg_js_1.pathArg)(path);
    const resolved = (0, opts_arg_js_1.optsArg)(opts);
    return (0, use_native_js_1.useNativeSync)(resolved) ? (0, mkdirp_native_js_1.mkdirpNativeSync)(path, resolved) : (0, mkdirp_manual_js_1.mkdirpManualSync)(path, resolved);
  };
  exports.mkdirpSync = mkdirpSync;
  exports.sync = exports.mkdirpSync;
  exports.manual = mkdirp_manual_js_1.mkdirpManual;
  exports.manualSync = mkdirp_manual_js_1.mkdirpManualSync;
  exports.native = mkdirp_native_js_1.mkdirpNative;
  exports.nativeSync = mkdirp_native_js_1.mkdirpNativeSync;
  exports.mkdirp = Object.assign(async (path, opts) => {
    path = (0, path_arg_js_1.pathArg)(path);
    const resolved = (0, opts_arg_js_1.optsArg)(opts);
    return (0, use_native_js_1.useNative)(resolved) ? (0, mkdirp_native_js_1.mkdirpNative)(path, resolved) : (0, mkdirp_manual_js_1.mkdirpManual)(path, resolved);
  }, {
    mkdirpSync: exports.mkdirpSync,
    mkdirpNative: mkdirp_native_js_1.mkdirpNative,
    mkdirpNativeSync: mkdirp_native_js_1.mkdirpNativeSync,
    mkdirpManual: mkdirp_manual_js_1.mkdirpManual,
    mkdirpManualSync: mkdirp_manual_js_1.mkdirpManualSync,
    sync: exports.mkdirpSync,
    native: mkdirp_native_js_1.mkdirpNative,
    nativeSync: mkdirp_native_js_1.mkdirpNativeSync,
    manual: mkdirp_manual_js_1.mkdirpManual,
    manualSync: mkdirp_manual_js_1.mkdirpManualSync,
    useNative: use_native_js_1.useNative,
    useNativeSync: use_native_js_1.useNativeSync
  });
});

// node_modules/fstream/lib/collect.js
var require_collect = __commonJS((exports, module) => {
  module.exports = collect;
  function collect(stream) {
    if (stream._collected)
      return;
    if (stream._paused)
      return stream.on("resume", collect.bind(null, stream));
    stream._collected = true;
    stream.pause();
    stream.on("data", save);
    stream.on("end", save);
    var buf = [];
    function save(b) {
      if (typeof b === "string")
        b = new Buffer(b);
      if (Buffer.isBuffer(b) && !b.length)
        return;
      buf.push(b);
    }
    stream.on("entry", saveEntry);
    var entryBuffer = [];
    function saveEntry(e) {
      collect(e);
      entryBuffer.push(e);
    }
    stream.on("proxy", proxyPause);
    function proxyPause(p) {
      p.pause();
    }
    stream.pipe = function(orig) {
      return function(dest) {
        var e = 0;
        (function unblockEntry() {
          var entry = entryBuffer[e++];
          if (!entry)
            return resume();
          entry.on("end", unblockEntry);
          if (dest)
            dest.add(entry);
          else
            stream.emit("entry", entry);
        })();
        function resume() {
          stream.removeListener("entry", saveEntry);
          stream.removeListener("data", save);
          stream.removeListener("end", save);
          stream.pipe = orig;
          if (dest)
            stream.pipe(dest);
          buf.forEach(function(b) {
            if (b)
              stream.emit("data", b);
            else
              stream.emit("end");
          });
          stream.resume();
        }
        return dest;
      };
    }(stream.pipe);
  }
});

// node_modules/fstream/lib/dir-writer.js
var require_dir_writer = __commonJS((exports, module) => {
  module.exports = DirWriter;
  var Writer = require_writer();
  var inherits = require_inherits();
  var mkdir = require_src4();
  var path = __require("path");
  var collect = require_collect();
  inherits(DirWriter, Writer);
  function DirWriter(props) {
    var self2 = this;
    if (!(self2 instanceof DirWriter)) {
      self2.error("DirWriter must be called as constructor.", null, true);
    }
    if (props.type !== "Directory" || !props.Directory) {
      self2.error("Non-directory type " + props.type + " " + JSON.stringify(props), null, true);
    }
    Writer.call(this, props);
  }
  DirWriter.prototype._create = function() {
    var self2 = this;
    mkdir(self2._path, Writer.dirmode, function(er) {
      if (er)
        return self2.error(er);
      self2.ready = true;
      self2.emit("ready");
      self2._process();
    });
  };
  DirWriter.prototype.write = function() {
    return true;
  };
  DirWriter.prototype.end = function() {
    this._ended = true;
    this._process();
  };
  DirWriter.prototype.add = function(entry) {
    var self2 = this;
    collect(entry);
    if (!self2.ready || self2._currentEntry) {
      self2._buffer.push(entry);
      return false;
    }
    if (self2._ended) {
      return self2.error("add after end");
    }
    self2._buffer.push(entry);
    self2._process();
    return this._buffer.length === 0;
  };
  DirWriter.prototype._process = function() {
    var self2 = this;
    if (self2._processing)
      return;
    var entry = self2._buffer.shift();
    if (!entry) {
      self2.emit("drain");
      if (self2._ended)
        self2._finish();
      return;
    }
    self2._processing = true;
    self2.emit("entry", entry);
    var p = entry;
    var pp;
    do {
      pp = p._path || p.path;
      if (pp === self2.root._path || pp === self2._path || pp && pp.indexOf(self2._path) === 0) {
        self2._processing = false;
        if (entry._collected)
          entry.pipe();
        return self2._process();
      }
      p = p.parent;
    } while (p);
    var props = {
      parent: self2,
      root: self2.root || self2,
      type: entry.type,
      depth: self2.depth + 1
    };
    pp = entry._path || entry.path || entry.props.path;
    if (entry.parent) {
      pp = pp.substr(entry.parent._path.length + 1);
    }
    props.path = path.join(self2.path, path.join("/", pp));
    props.filter = self2.filter;
    Object.keys(entry.props).forEach(function(k) {
      if (!props.hasOwnProperty(k)) {
        props[k] = entry.props[k];
      }
    });
    var child = self2._currentChild = new Writer(props);
    child.on("ready", function() {
      entry.pipe(child);
      entry.resume();
    });
    child.on("error", function(er) {
      if (child._swallowErrors) {
        self2.warn(er);
        child.emit("end");
        child.emit("close");
      } else {
        self2.emit("error", er);
      }
    });
    child.on("close", onend);
    var ended = false;
    function onend() {
      if (ended)
        return;
      ended = true;
      self2._currentChild = null;
      self2._processing = false;
      self2._process();
    }
  };
});

// node_modules/fstream/lib/link-writer.js
var require_link_writer = __commonJS((exports, module) => {
  module.exports = LinkWriter;
  var fs = require_graceful_fs();
  var Writer = require_writer();
  var inherits = require_inherits();
  var path = __require("path");
  var rimraf = require_rimraf3();
  inherits(LinkWriter, Writer);
  function LinkWriter(props) {
    var self2 = this;
    if (!(self2 instanceof LinkWriter)) {
      throw new Error("LinkWriter must be called as constructor.");
    }
    if (!(props.type === "Link" && props.Link || props.type === "SymbolicLink" && props.SymbolicLink)) {
      throw new Error("Non-link type " + props.type);
    }
    if (props.linkpath === "")
      props.linkpath = ".";
    if (!props.linkpath) {
      self2.error("Need linkpath property to create " + props.type);
    }
    Writer.call(this, props);
  }
  LinkWriter.prototype._create = function() {
    var self2 = this;
    var hard = self2.type === "Link" || process.platform === "win32";
    var link = hard ? "link" : "symlink";
    var lp = hard ? path.resolve(self2.dirname, self2.linkpath) : self2.linkpath;
    if (hard)
      return clobber(self2, lp, link);
    fs.readlink(self2._path, function(er, p) {
      if (p && p === lp)
        return finish(self2);
      clobber(self2, lp, link);
    });
  };
  function clobber(self2, lp, link) {
    rimraf(self2._path, function(er) {
      if (er)
        return self2.error(er);
      create(self2, lp, link);
    });
  }
  function create(self2, lp, link) {
    fs[link](lp, self2._path, function(er) {
      if (er) {
        if ((er.code === "ENOENT" || er.code === "EACCES" || er.code === "EPERM") && process.platform === "win32") {
          self2.ready = true;
          self2.emit("ready");
          self2.emit("end");
          self2.emit("close");
          self2.end = self2._finish = function() {};
        } else
          return self2.error(er);
      }
      finish(self2);
    });
  }
  function finish(self2) {
    self2.ready = true;
    self2.emit("ready");
    if (self2._ended && !self2._finished)
      self2._finish();
  }
  LinkWriter.prototype.end = function() {
    this._ended = true;
    if (this.ready) {
      this._finished = true;
      this._finish();
    }
  };
});

// node_modules/fstream/lib/file-writer.js
var require_file_writer = __commonJS((exports, module) => {
  module.exports = FileWriter;
  var fs = require_graceful_fs();
  var Writer = require_writer();
  var inherits = require_inherits();
  var EOF = {};
  inherits(FileWriter, Writer);
  function FileWriter(props) {
    var self2 = this;
    if (!(self2 instanceof FileWriter)) {
      throw new Error("FileWriter must be called as constructor.");
    }
    if (props.type !== "File" || !props.File) {
      throw new Error("Non-file type " + props.type);
    }
    self2._buffer = [];
    self2._bytesWritten = 0;
    Writer.call(this, props);
  }
  FileWriter.prototype._create = function() {
    var self2 = this;
    if (self2._stream)
      return;
    var so = {};
    if (self2.props.flags)
      so.flags = self2.props.flags;
    so.mode = Writer.filemode;
    if (self2._old && self2._old.blksize)
      so.bufferSize = self2._old.blksize;
    self2._stream = fs.createWriteStream(self2._path, so);
    self2._stream.on("open", function() {
      self2.ready = true;
      self2._buffer.forEach(function(c) {
        if (c === EOF)
          self2._stream.end();
        else
          self2._stream.write(c);
      });
      self2.emit("ready");
      self2.emit("drain");
    });
    self2._stream.on("error", function(er) {
      self2.emit("error", er);
    });
    self2._stream.on("drain", function() {
      self2.emit("drain");
    });
    self2._stream.on("close", function() {
      self2._finish();
    });
  };
  FileWriter.prototype.write = function(c) {
    var self2 = this;
    self2._bytesWritten += c.length;
    if (!self2.ready) {
      if (!Buffer.isBuffer(c) && typeof c !== "string") {
        throw new Error("invalid write data");
      }
      self2._buffer.push(c);
      return false;
    }
    var ret = self2._stream.write(c);
    if (ret === false && self2._stream._queue) {
      return self2._stream._queue.length <= 2;
    } else {
      return ret;
    }
  };
  FileWriter.prototype.end = function(c) {
    var self2 = this;
    if (c)
      self2.write(c);
    if (!self2.ready) {
      self2._buffer.push(EOF);
      return false;
    }
    return self2._stream.end();
  };
  FileWriter.prototype._finish = function() {
    var self2 = this;
    if (typeof self2.size === "number" && self2._bytesWritten !== self2.size) {
      self2.error(`Did not get expected byte count.
` + "expect: " + self2.size + `
` + "actual: " + self2._bytesWritten);
    }
    Writer.prototype._finish.call(self2);
  };
});

// node_modules/fstream/lib/proxy-writer.js
var require_proxy_writer = __commonJS((exports, module) => {
  module.exports = ProxyWriter;
  var Writer = require_writer();
  var getType = require_get_type();
  var inherits = require_inherits();
  var collect = require_collect();
  var fs = __require("fs");
  inherits(ProxyWriter, Writer);
  function ProxyWriter(props) {
    var self2 = this;
    if (!(self2 instanceof ProxyWriter)) {
      throw new Error("ProxyWriter must be called as constructor.");
    }
    self2.props = props;
    self2._needDrain = false;
    Writer.call(self2, props);
  }
  ProxyWriter.prototype._stat = function() {
    var self2 = this;
    var props = self2.props;
    var stat = props.follow ? "stat" : "lstat";
    fs[stat](props.path, function(er, current) {
      var type;
      if (er || !current) {
        type = "File";
      } else {
        type = getType(current);
      }
      props[type] = true;
      props.type = self2.type = type;
      self2._old = current;
      self2._addProxy(Writer(props, current));
    });
  };
  ProxyWriter.prototype._addProxy = function(proxy) {
    var self2 = this;
    if (self2._proxy) {
      return self2.error("proxy already set");
    }
    self2._proxy = proxy;
    [
      "ready",
      "error",
      "close",
      "pipe",
      "drain",
      "warn"
    ].forEach(function(ev) {
      proxy.on(ev, self2.emit.bind(self2, ev));
    });
    self2.emit("proxy", proxy);
    var calls = self2._buffer;
    calls.forEach(function(c) {
      proxy[c[0]].apply(proxy, c[1]);
    });
    self2._buffer.length = 0;
    if (self2._needsDrain)
      self2.emit("drain");
  };
  ProxyWriter.prototype.add = function(entry) {
    collect(entry);
    if (!this._proxy) {
      this._buffer.push(["add", [entry]]);
      this._needDrain = true;
      return false;
    }
    return this._proxy.add(entry);
  };
  ProxyWriter.prototype.write = function(c) {
    if (!this._proxy) {
      this._buffer.push(["write", [c]]);
      this._needDrain = true;
      return false;
    }
    return this._proxy.write(c);
  };
  ProxyWriter.prototype.end = function(c) {
    if (!this._proxy) {
      this._buffer.push(["end", [c]]);
      return false;
    }
    return this._proxy.end(c);
  };
});

// node_modules/fstream/lib/writer.js
var require_writer = __commonJS((exports, module) => {
  module.exports = Writer;
  var fs = require_graceful_fs();
  var inherits = require_inherits();
  var rimraf = require_rimraf3();
  var mkdir = require_src4();
  var path = __require("path");
  var umask = process.platform === "win32" ? 0 : process.umask();
  var getType = require_get_type();
  var Abstract = require_abstract();
  inherits(Writer, Abstract);
  Writer.dirmode = parseInt("0777", 8) & ~umask;
  Writer.filemode = parseInt("0666", 8) & ~umask;
  var DirWriter = require_dir_writer();
  var LinkWriter = require_link_writer();
  var FileWriter = require_file_writer();
  var ProxyWriter = require_proxy_writer();
  function Writer(props, current) {
    var self2 = this;
    if (typeof props === "string") {
      props = { path: props };
    }
    var type = getType(props);
    var ClassType = Writer;
    switch (type) {
      case "Directory":
        ClassType = DirWriter;
        break;
      case "File":
        ClassType = FileWriter;
        break;
      case "Link":
      case "SymbolicLink":
        ClassType = LinkWriter;
        break;
      case null:
      default:
        ClassType = ProxyWriter;
        break;
    }
    if (!(self2 instanceof ClassType))
      return new ClassType(props);
    Abstract.call(self2);
    if (!props.path)
      self2.error("Must provide a path", null, true);
    self2.type = props.type;
    self2.props = props;
    self2.depth = props.depth || 0;
    self2.clobber = props.clobber === false ? props.clobber : true;
    self2.parent = props.parent || null;
    self2.root = props.root || props.parent && props.parent.root || self2;
    self2._path = self2.path = path.resolve(props.path);
    if (process.platform === "win32") {
      self2.path = self2._path = self2.path.replace(/\?/g, "_");
      if (self2._path.length >= 260) {
        self2._swallowErrors = true;
        self2._path = "\\\\?\\" + self2.path.replace(/\//g, "\\");
      }
    }
    self2.basename = path.basename(props.path);
    self2.dirname = path.dirname(props.path);
    self2.linkpath = props.linkpath || null;
    props.parent = props.root = null;
    self2.size = props.size;
    if (typeof props.mode === "string") {
      props.mode = parseInt(props.mode, 8);
    }
    self2.readable = false;
    self2.writable = true;
    self2._buffer = [];
    self2.ready = false;
    self2.filter = typeof props.filter === "function" ? props.filter : null;
    self2._stat(current);
  }
  Writer.prototype._create = function() {
    var self2 = this;
    fs[self2.props.follow ? "stat" : "lstat"](self2._path, function(er) {
      if (er) {
        return self2.warn("Cannot create " + self2._path + `
` + "Unsupported type: " + self2.type, "ENOTSUP");
      }
      self2._finish();
    });
  };
  Writer.prototype._stat = function(current) {
    var self2 = this;
    var props = self2.props;
    var stat = props.follow ? "stat" : "lstat";
    var who = self2._proxy || self2;
    if (current)
      statCb(null, current);
    else
      fs[stat](self2._path, statCb);
    function statCb(er, current2) {
      if (self2.filter && !self2.filter.call(who, who, current2)) {
        self2._aborted = true;
        self2.emit("end");
        self2.emit("close");
        return;
      }
      if (er || !current2) {
        return create(self2);
      }
      self2._old = current2;
      var currentType = getType(current2);
      if (currentType !== self2.type || self2.type === "File" && current2.nlink > 1) {
        return rimraf(self2._path, function(er2) {
          if (er2)
            return self2.error(er2);
          self2._old = null;
          create(self2);
        });
      }
      create(self2);
    }
  };
  function create(self2) {
    mkdir(path.dirname(self2._path), Writer.dirmode, function(er, made) {
      if (er)
        return self2.error(er);
      self2._madeDir = made;
      return self2._create();
    });
  }
  function endChmod(self2, want, current, path2, cb) {
    var wantMode = want.mode;
    var chmod = want.follow || self2.type !== "SymbolicLink" ? "chmod" : "lchmod";
    if (!fs[chmod])
      return cb();
    if (typeof wantMode !== "number")
      return cb();
    var curMode = current.mode & parseInt("0777", 8);
    wantMode = wantMode & parseInt("0777", 8);
    if (wantMode === curMode)
      return cb();
    fs[chmod](path2, wantMode, cb);
  }
  function endChown(self2, want, current, path2, cb) {
    if (process.platform === "win32")
      return cb();
    if (!process.getuid || process.getuid() !== 0)
      return cb();
    if (typeof want.uid !== "number" && typeof want.gid !== "number")
      return cb();
    if (current.uid === want.uid && current.gid === want.gid)
      return cb();
    var chown = self2.props.follow || self2.type !== "SymbolicLink" ? "chown" : "lchown";
    if (!fs[chown])
      return cb();
    if (typeof want.uid !== "number")
      want.uid = current.uid;
    if (typeof want.gid !== "number")
      want.gid = current.gid;
    fs[chown](path2, want.uid, want.gid, cb);
  }
  function endUtimes(self2, want, current, path2, cb) {
    if (!fs.utimes || process.platform === "win32")
      return cb();
    var utimes = want.follow || self2.type !== "SymbolicLink" ? "utimes" : "lutimes";
    if (utimes === "lutimes" && !fs[utimes]) {
      utimes = "utimes";
    }
    if (!fs[utimes])
      return cb();
    var curA = current.atime;
    var curM = current.mtime;
    var meA = want.atime;
    var meM = want.mtime;
    if (meA === undefined)
      meA = curA;
    if (meM === undefined)
      meM = curM;
    if (!isDate(meA))
      meA = new Date(meA);
    if (!isDate(meM))
      meA = new Date(meM);
    if (meA.getTime() === curA.getTime() && meM.getTime() === curM.getTime())
      return cb();
    fs[utimes](path2, meA, meM, cb);
  }
  Writer.prototype._finish = function() {
    var self2 = this;
    if (self2._finishing)
      return;
    self2._finishing = true;
    var todo = 0;
    var errState = null;
    var done = false;
    if (self2._old) {
      self2._old.atime = new Date(0);
      self2._old.mtime = new Date(0);
      setProps(self2._old);
    } else {
      var stat = self2.props.follow ? "stat" : "lstat";
      fs[stat](self2._path, function(er, current) {
        if (er) {
          if (er.code === "ENOENT" && (self2.type === "Link" || self2.type === "SymbolicLink") && process.platform === "win32") {
            self2.ready = true;
            self2.emit("ready");
            self2.emit("end");
            self2.emit("close");
            self2.end = self2._finish = function() {};
            return;
          } else
            return self2.error(er);
        }
        setProps(self2._old = current);
      });
    }
    return;
    function setProps(current) {
      todo += 3;
      endChmod(self2, self2.props, current, self2._path, next("chmod"));
      endChown(self2, self2.props, current, self2._path, next("chown"));
      endUtimes(self2, self2.props, current, self2._path, next("utimes"));
    }
    function next(what) {
      return function(er) {
        if (errState)
          return;
        if (er) {
          er.fstream_finish_call = what;
          return self2.error(errState = er);
        }
        if (--todo > 0)
          return;
        if (done)
          return;
        done = true;
        if (!self2._madeDir)
          return end();
        else
          endMadeDir(self2, self2._path, end);
        function end(er2) {
          if (er2) {
            er2.fstream_finish_call = "setupMadeDir";
            return self2.error(er2);
          }
          self2.emit("end");
          self2.emit("close");
        }
      };
    }
  };
  function endMadeDir(self2, p, cb) {
    var made = self2._madeDir;
    var d = path.dirname(p);
    endMadeDir_(self2, d, function(er) {
      if (er)
        return cb(er);
      if (d === made) {
        return cb();
      }
      endMadeDir(self2, d, cb);
    });
  }
  function endMadeDir_(self2, p, cb) {
    var dirProps = {};
    Object.keys(self2.props).forEach(function(k) {
      dirProps[k] = self2.props[k];
      if (k === "mode" && self2.type !== "Directory") {
        dirProps[k] = dirProps[k] | parseInt("0111", 8);
      }
    });
    var todo = 3;
    var errState = null;
    fs.stat(p, function(er, current) {
      if (er)
        return cb(errState = er);
      endChmod(self2, dirProps, current, p, next);
      endChown(self2, dirProps, current, p, next);
      endUtimes(self2, dirProps, current, p, next);
    });
    function next(er) {
      if (errState)
        return;
      if (er)
        return cb(errState = er);
      if (--todo === 0)
        return cb();
    }
  }
  Writer.prototype.pipe = function() {
    this.error("Can't pipe from writable stream");
  };
  Writer.prototype.add = function() {
    this.error("Can't add to non-Directory type");
  };
  Writer.prototype.write = function() {
    return true;
  };
  function objectToString(d) {
    return Object.prototype.toString.call(d);
  }
  function isDate(d) {
    return typeof d === "object" && objectToString(d) === "[object Date]";
  }
});

// node_modules/fstream/fstream.js
var require_fstream = __commonJS((exports) => {
  exports.Abstract = require_abstract();
  exports.Reader = require_reader();
  exports.Writer = require_writer();
  exports.File = {
    Reader: require_file_reader(),
    Writer: require_file_writer()
  };
  exports.Dir = {
    Reader: require_dir_reader(),
    Writer: require_dir_writer()
  };
  exports.Link = {
    Reader: require_link_reader(),
    Writer: require_link_writer()
  };
  exports.Proxy = {
    Reader: require_proxy_reader(),
    Writer: require_proxy_writer()
  };
  exports.Reader.Dir = exports.DirReader = exports.Dir.Reader;
  exports.Reader.File = exports.FileReader = exports.File.Reader;
  exports.Reader.Link = exports.LinkReader = exports.Link.Reader;
  exports.Reader.Proxy = exports.ProxyReader = exports.Proxy.Reader;
  exports.Writer.Dir = exports.DirWriter = exports.Dir.Writer;
  exports.Writer.File = exports.FileWriter = exports.File.Writer;
  exports.Writer.Link = exports.LinkWriter = exports.Link.Writer;
  exports.Writer.Proxy = exports.ProxyWriter = exports.Proxy.Writer;
  exports.collect = require_collect();
});

// node_modules/unzipper/lib/extract.js
var require_extract2 = __commonJS((exports, module) => {
  module.exports = Extract;
  var Parse = require_parse();
  var Writer = require_fstream().Writer;
  var path = __require("path");
  var stream = __require("stream");
  var duplexer2 = require_duplexer2();
  var Promise2 = require_bluebird();
  function Extract(opts) {
    opts.path = path.resolve(path.normalize(opts.path));
    var parser = new Parse(opts);
    var outStream = new stream.Writable({ objectMode: true });
    outStream._write = function(entry, encoding, cb) {
      if (entry.type == "Directory")
        return cb();
      var extractPath = path.join(opts.path, entry.path);
      if (extractPath.indexOf(opts.path) != 0) {
        return cb();
      }
      const writer = opts.getWriter ? opts.getWriter({ path: extractPath }) : Writer({ path: extractPath });
      entry.pipe(writer).on("error", cb).on("close", cb);
    };
    var extract = duplexer2(parser, outStream);
    parser.once("crx-header", function(crxHeader) {
      extract.crxHeader = crxHeader;
    });
    parser.pipe(outStream).on("finish", function() {
      extract.emit("close");
    });
    extract.promise = function() {
      return new Promise2(function(resolve, reject) {
        extract.on("close", resolve);
        extract.on("error", reject);
      });
    };
    return extract;
  }
});

// node_modules/big-integer/BigInteger.js
var require_BigInteger = __commonJS((exports, module) => {
  var bigInt = function(undefined2) {
    var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
    var supportsNativeBigInt = typeof BigInt === "function";
    function Integer(v, radix, alphabet, caseSensitive) {
      if (typeof v === "undefined")
        return Integer[0];
      if (typeof radix !== "undefined")
        return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
      return parseValue(v);
    }
    function BigInteger(value, sign) {
      this.value = value;
      this.sign = sign;
      this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);
    function SmallInteger(value) {
      this.value = value;
      this.sign = value < 0;
      this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);
    function NativeBigInt(value) {
      this.value = value;
    }
    NativeBigInt.prototype = Object.create(Integer.prototype);
    function isPrecise(n) {
      return -MAX_INT < n && n < MAX_INT;
    }
    function smallToArray(n) {
      if (n < 1e7)
        return [n];
      if (n < 100000000000000)
        return [n % 1e7, Math.floor(n / 1e7)];
      return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 100000000000000)];
    }
    function arrayToSmall(arr) {
      trim(arr);
      var length = arr.length;
      if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
        switch (length) {
          case 0:
            return 0;
          case 1:
            return arr[0];
          case 2:
            return arr[0] + arr[1] * BASE;
          default:
            return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
        }
      }
      return arr;
    }
    function trim(v) {
      var i2 = v.length;
      while (v[--i2] === 0)
        ;
      v.length = i2 + 1;
    }
    function createArray(length) {
      var x = new Array(length);
      var i2 = -1;
      while (++i2 < length) {
        x[i2] = 0;
      }
      return x;
    }
    function truncate(n) {
      if (n > 0)
        return Math.floor(n);
      return Math.ceil(n);
    }
    function add(a, b) {
      var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i2;
      for (i2 = 0;i2 < l_b; i2++) {
        sum = a[i2] + b[i2] + carry;
        carry = sum >= base ? 1 : 0;
        r[i2] = sum - carry * base;
      }
      while (i2 < l_a) {
        sum = a[i2] + carry;
        carry = sum === base ? 1 : 0;
        r[i2++] = sum - carry * base;
      }
      if (carry > 0)
        r.push(carry);
      return r;
    }
    function addAny(a, b) {
      if (a.length >= b.length)
        return add(a, b);
      return add(b, a);
    }
    function addSmall(a, carry) {
      var l2 = a.length, r = new Array(l2), base = BASE, sum, i2;
      for (i2 = 0;i2 < l2; i2++) {
        sum = a[i2] - base + carry;
        carry = Math.floor(sum / base);
        r[i2] = sum - carry * base;
        carry += 1;
      }
      while (carry > 0) {
        r[i2++] = carry % base;
        carry = Math.floor(carry / base);
      }
      return r;
    }
    BigInteger.prototype.add = function(v) {
      var n = parseValue(v);
      if (this.sign !== n.sign) {
        return this.subtract(n.negate());
      }
      var a = this.value, b = n.value;
      if (n.isSmall) {
        return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
      }
      return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;
    SmallInteger.prototype.add = function(v) {
      var n = parseValue(v);
      var a = this.value;
      if (a < 0 !== n.sign) {
        return this.subtract(n.negate());
      }
      var b = n.value;
      if (n.isSmall) {
        if (isPrecise(a + b))
          return new SmallInteger(a + b);
        b = smallToArray(Math.abs(b));
      }
      return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;
    NativeBigInt.prototype.add = function(v) {
      return new NativeBigInt(this.value + parseValue(v).value);
    };
    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
    function subtract(a, b) {
      var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i2, difference;
      for (i2 = 0;i2 < b_l; i2++) {
        difference = a[i2] - borrow - b[i2];
        if (difference < 0) {
          difference += base;
          borrow = 1;
        } else
          borrow = 0;
        r[i2] = difference;
      }
      for (i2 = b_l;i2 < a_l; i2++) {
        difference = a[i2] - borrow;
        if (difference < 0)
          difference += base;
        else {
          r[i2++] = difference;
          break;
        }
        r[i2] = difference;
      }
      for (;i2 < a_l; i2++) {
        r[i2] = a[i2];
      }
      trim(r);
      return r;
    }
    function subtractAny(a, b, sign) {
      var value;
      if (compareAbs(a, b) >= 0) {
        value = subtract(a, b);
      } else {
        value = subtract(b, a);
        sign = !sign;
      }
      value = arrayToSmall(value);
      if (typeof value === "number") {
        if (sign)
          value = -value;
        return new SmallInteger(value);
      }
      return new BigInteger(value, sign);
    }
    function subtractSmall(a, b, sign) {
      var l2 = a.length, r = new Array(l2), carry = -b, base = BASE, i2, difference;
      for (i2 = 0;i2 < l2; i2++) {
        difference = a[i2] + carry;
        carry = Math.floor(difference / base);
        difference %= base;
        r[i2] = difference < 0 ? difference + base : difference;
      }
      r = arrayToSmall(r);
      if (typeof r === "number") {
        if (sign)
          r = -r;
        return new SmallInteger(r);
      }
      return new BigInteger(r, sign);
    }
    BigInteger.prototype.subtract = function(v) {
      var n = parseValue(v);
      if (this.sign !== n.sign) {
        return this.add(n.negate());
      }
      var a = this.value, b = n.value;
      if (n.isSmall)
        return subtractSmall(a, Math.abs(b), this.sign);
      return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;
    SmallInteger.prototype.subtract = function(v) {
      var n = parseValue(v);
      var a = this.value;
      if (a < 0 !== n.sign) {
        return this.add(n.negate());
      }
      var b = n.value;
      if (n.isSmall) {
        return new SmallInteger(a - b);
      }
      return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
    NativeBigInt.prototype.subtract = function(v) {
      return new NativeBigInt(this.value - parseValue(v).value);
    };
    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
    BigInteger.prototype.negate = function() {
      return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function() {
      var sign = this.sign;
      var small = new SmallInteger(-this.value);
      small.sign = !sign;
      return small;
    };
    NativeBigInt.prototype.negate = function() {
      return new NativeBigInt(-this.value);
    };
    BigInteger.prototype.abs = function() {
      return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function() {
      return new SmallInteger(Math.abs(this.value));
    };
    NativeBigInt.prototype.abs = function() {
      return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    };
    function multiplyLong(a, b) {
      var a_l = a.length, b_l = b.length, l2 = a_l + b_l, r = createArray(l2), base = BASE, product, carry, i2, a_i, b_j;
      for (i2 = 0;i2 < a_l; ++i2) {
        a_i = a[i2];
        for (var j = 0;j < b_l; ++j) {
          b_j = b[j];
          product = a_i * b_j + r[i2 + j];
          carry = Math.floor(product / base);
          r[i2 + j] = product - carry * base;
          r[i2 + j + 1] += carry;
        }
      }
      trim(r);
      return r;
    }
    function multiplySmall(a, b) {
      var l2 = a.length, r = new Array(l2), base = BASE, carry = 0, product, i2;
      for (i2 = 0;i2 < l2; i2++) {
        product = a[i2] * b + carry;
        carry = Math.floor(product / base);
        r[i2] = product - carry * base;
      }
      while (carry > 0) {
        r[i2++] = carry % base;
        carry = Math.floor(carry / base);
      }
      return r;
    }
    function shiftLeft(x, n) {
      var r = [];
      while (n-- > 0)
        r.push(0);
      return r.concat(x);
    }
    function multiplyKaratsuba(x, y) {
      var n = Math.max(x.length, y.length);
      if (n <= 30)
        return multiplyLong(x, y);
      n = Math.ceil(n / 2);
      var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
      var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
      var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
      trim(product);
      return product;
    }
    function useKaratsuba(l1, l2) {
      return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }
    BigInteger.prototype.multiply = function(v) {
      var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;
      if (n.isSmall) {
        if (b === 0)
          return Integer[0];
        if (b === 1)
          return this;
        if (b === -1)
          return this.negate();
        abs = Math.abs(b);
        if (abs < BASE) {
          return new BigInteger(multiplySmall(a, abs), sign);
        }
        b = smallToArray(abs);
      }
      if (useKaratsuba(a.length, b.length))
        return new BigInteger(multiplyKaratsuba(a, b), sign);
      return new BigInteger(multiplyLong(a, b), sign);
    };
    BigInteger.prototype.times = BigInteger.prototype.multiply;
    function multiplySmallAndArray(a, b, sign) {
      if (a < BASE) {
        return new BigInteger(multiplySmall(b, a), sign);
      }
      return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function(a) {
      if (isPrecise(a.value * this.value)) {
        return new SmallInteger(a.value * this.value);
      }
      return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function(a) {
      if (a.value === 0)
        return Integer[0];
      if (a.value === 1)
        return this;
      if (a.value === -1)
        return this.negate();
      return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function(v) {
      return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;
    NativeBigInt.prototype.multiply = function(v) {
      return new NativeBigInt(this.value * parseValue(v).value);
    };
    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
    function square(a) {
      var l2 = a.length, r = createArray(l2 + l2), base = BASE, product, carry, i2, a_i, a_j;
      for (i2 = 0;i2 < l2; i2++) {
        a_i = a[i2];
        carry = 0 - a_i * a_i;
        for (var j = i2;j < l2; j++) {
          a_j = a[j];
          product = 2 * (a_i * a_j) + r[i2 + j] + carry;
          carry = Math.floor(product / base);
          r[i2 + j] = product - carry * base;
        }
        r[i2 + l2] = carry;
      }
      trim(r);
      return r;
    }
    BigInteger.prototype.square = function() {
      return new BigInteger(square(this.value), false);
    };
    SmallInteger.prototype.square = function() {
      var value = this.value * this.value;
      if (isPrecise(value))
        return new SmallInteger(value);
      return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };
    NativeBigInt.prototype.square = function(v) {
      return new NativeBigInt(this.value * this.value);
    };
    function divMod1(a, b) {
      var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l2, q;
      if (remainder.length <= a_l)
        remainder.push(0);
      divisor.push(0);
      divisorMostSignificantDigit = divisor[b_l - 1];
      for (shift = a_l - b_l;shift >= 0; shift--) {
        quotientDigit = base - 1;
        if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
          quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
        }
        carry = 0;
        borrow = 0;
        l2 = divisor.length;
        for (i2 = 0;i2 < l2; i2++) {
          carry += quotientDigit * divisor[i2];
          q = Math.floor(carry / base);
          borrow += remainder[shift + i2] - (carry - q * base);
          carry = q;
          if (borrow < 0) {
            remainder[shift + i2] = borrow + base;
            borrow = -1;
          } else {
            remainder[shift + i2] = borrow;
            borrow = 0;
          }
        }
        while (borrow !== 0) {
          quotientDigit -= 1;
          carry = 0;
          for (i2 = 0;i2 < l2; i2++) {
            carry += remainder[shift + i2] - base + divisor[i2];
            if (carry < 0) {
              remainder[shift + i2] = carry + base;
              carry = 0;
            } else {
              remainder[shift + i2] = carry;
              carry = 1;
            }
          }
          borrow += carry;
        }
        result[shift] = quotientDigit;
      }
      remainder = divModSmall(remainder, lambda)[0];
      return [arrayToSmall(result), arrayToSmall(remainder)];
    }
    function divMod2(a, b) {
      var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;
      while (a_l) {
        part.unshift(a[--a_l]);
        trim(part);
        if (compareAbs(part, b) < 0) {
          result.push(0);
          continue;
        }
        xlen = part.length;
        highx = part[xlen - 1] * base + part[xlen - 2];
        highy = b[b_l - 1] * base + b[b_l - 2];
        if (xlen > b_l) {
          highx = (highx + 1) * base;
        }
        guess = Math.ceil(highx / highy);
        do {
          check = multiplySmall(b, guess);
          if (compareAbs(check, part) <= 0)
            break;
          guess--;
        } while (guess);
        result.push(guess);
        part = subtract(part, check);
      }
      result.reverse();
      return [arrayToSmall(result), arrayToSmall(part)];
    }
    function divModSmall(value, lambda) {
      var length = value.length, quotient = createArray(length), base = BASE, i2, q, remainder, divisor;
      remainder = 0;
      for (i2 = length - 1;i2 >= 0; --i2) {
        divisor = remainder * base + value[i2];
        q = truncate(divisor / lambda);
        remainder = divisor - q * lambda;
        quotient[i2] = q | 0;
      }
      return [quotient, remainder | 0];
    }
    function divModAny(self2, v) {
      var value, n = parseValue(v);
      if (supportsNativeBigInt) {
        return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];
      }
      var a = self2.value, b = n.value;
      var quotient;
      if (b === 0)
        throw new Error("Cannot divide by zero");
      if (self2.isSmall) {
        if (n.isSmall) {
          return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
        }
        return [Integer[0], self2];
      }
      if (n.isSmall) {
        if (b === 1)
          return [self2, Integer[0]];
        if (b == -1)
          return [self2.negate(), Integer[0]];
        var abs = Math.abs(b);
        if (abs < BASE) {
          value = divModSmall(a, abs);
          quotient = arrayToSmall(value[0]);
          var remainder = value[1];
          if (self2.sign)
            remainder = -remainder;
          if (typeof quotient === "number") {
            if (self2.sign !== n.sign)
              quotient = -quotient;
            return [new SmallInteger(quotient), new SmallInteger(remainder)];
          }
          return [new BigInteger(quotient, self2.sign !== n.sign), new SmallInteger(remainder)];
        }
        b = smallToArray(abs);
      }
      var comparison = compareAbs(a, b);
      if (comparison === -1)
        return [Integer[0], self2];
      if (comparison === 0)
        return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];
      if (a.length + b.length <= 200)
        value = divMod1(a, b);
      else
        value = divMod2(a, b);
      quotient = value[0];
      var qSign = self2.sign !== n.sign, mod2 = value[1], mSign = self2.sign;
      if (typeof quotient === "number") {
        if (qSign)
          quotient = -quotient;
        quotient = new SmallInteger(quotient);
      } else
        quotient = new BigInteger(quotient, qSign);
      if (typeof mod2 === "number") {
        if (mSign)
          mod2 = -mod2;
        mod2 = new SmallInteger(mod2);
      } else
        mod2 = new BigInteger(mod2, mSign);
      return [quotient, mod2];
    }
    BigInteger.prototype.divmod = function(v) {
      var result = divModAny(this, v);
      return {
        quotient: result[0],
        remainder: result[1]
      };
    };
    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
    BigInteger.prototype.divide = function(v) {
      return divModAny(this, v)[0];
    };
    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
      return new NativeBigInt(this.value / parseValue(v).value);
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
    BigInteger.prototype.mod = function(v) {
      return divModAny(this, v)[1];
    };
    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
      return new NativeBigInt(this.value % parseValue(v).value);
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
    BigInteger.prototype.pow = function(v) {
      var n = parseValue(v), a = this.value, b = n.value, value, x, y;
      if (b === 0)
        return Integer[1];
      if (a === 0)
        return Integer[0];
      if (a === 1)
        return Integer[1];
      if (a === -1)
        return n.isEven() ? Integer[1] : Integer[-1];
      if (n.sign) {
        return Integer[0];
      }
      if (!n.isSmall)
        throw new Error("The exponent " + n.toString() + " is too large.");
      if (this.isSmall) {
        if (isPrecise(value = Math.pow(a, b)))
          return new SmallInteger(truncate(value));
      }
      x = this;
      y = Integer[1];
      while (true) {
        if (b & true) {
          y = y.times(x);
          --b;
        }
        if (b === 0)
          break;
        b /= 2;
        x = x.square();
      }
      return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;
    NativeBigInt.prototype.pow = function(v) {
      var n = parseValue(v);
      var a = this.value, b = n.value;
      var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
      if (b === _0)
        return Integer[1];
      if (a === _0)
        return Integer[0];
      if (a === _1)
        return Integer[1];
      if (a === BigInt(-1))
        return n.isEven() ? Integer[1] : Integer[-1];
      if (n.isNegative())
        return new NativeBigInt(_0);
      var x = this;
      var y = Integer[1];
      while (true) {
        if ((b & _1) === _1) {
          y = y.times(x);
          --b;
        }
        if (b === _0)
          break;
        b /= _2;
        x = x.square();
      }
      return y;
    };
    BigInteger.prototype.modPow = function(exp, mod2) {
      exp = parseValue(exp);
      mod2 = parseValue(mod2);
      if (mod2.isZero())
        throw new Error("Cannot take modPow with modulus 0");
      var r = Integer[1], base = this.mod(mod2);
      if (exp.isNegative()) {
        exp = exp.multiply(Integer[-1]);
        base = base.modInv(mod2);
      }
      while (exp.isPositive()) {
        if (base.isZero())
          return Integer[0];
        if (exp.isOdd())
          r = r.multiply(base).mod(mod2);
        exp = exp.divide(2);
        base = base.square().mod(mod2);
      }
      return r;
    };
    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
    function compareAbs(a, b) {
      if (a.length !== b.length) {
        return a.length > b.length ? 1 : -1;
      }
      for (var i2 = a.length - 1;i2 >= 0; i2--) {
        if (a[i2] !== b[i2])
          return a[i2] > b[i2] ? 1 : -1;
      }
      return 0;
    }
    BigInteger.prototype.compareAbs = function(v) {
      var n = parseValue(v), a = this.value, b = n.value;
      if (n.isSmall)
        return 1;
      return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function(v) {
      var n = parseValue(v), a = Math.abs(this.value), b = n.value;
      if (n.isSmall) {
        b = Math.abs(b);
        return a === b ? 0 : a > b ? 1 : -1;
      }
      return -1;
    };
    NativeBigInt.prototype.compareAbs = function(v) {
      var a = this.value;
      var b = parseValue(v).value;
      a = a >= 0 ? a : -a;
      b = b >= 0 ? b : -b;
      return a === b ? 0 : a > b ? 1 : -1;
    };
    BigInteger.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var n = parseValue(v), a = this.value, b = n.value;
      if (this.sign !== n.sign) {
        return n.sign ? 1 : -1;
      }
      if (n.isSmall) {
        return this.sign ? -1 : 1;
      }
      return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;
    SmallInteger.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var n = parseValue(v), a = this.value, b = n.value;
      if (n.isSmall) {
        return a == b ? 0 : a > b ? 1 : -1;
      }
      if (a < 0 !== n.sign) {
        return a < 0 ? -1 : 1;
      }
      return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
    NativeBigInt.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var a = this.value;
      var b = parseValue(v).value;
      return a === b ? 0 : a > b ? 1 : -1;
    };
    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
    BigInteger.prototype.equals = function(v) {
      return this.compare(v) === 0;
    };
    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
    BigInteger.prototype.notEquals = function(v) {
      return this.compare(v) !== 0;
    };
    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
    BigInteger.prototype.greater = function(v) {
      return this.compare(v) > 0;
    };
    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
    BigInteger.prototype.lesser = function(v) {
      return this.compare(v) < 0;
    };
    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
    BigInteger.prototype.greaterOrEquals = function(v) {
      return this.compare(v) >= 0;
    };
    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
    BigInteger.prototype.lesserOrEquals = function(v) {
      return this.compare(v) <= 0;
    };
    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
    BigInteger.prototype.isEven = function() {
      return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function() {
      return (this.value & 1) === 0;
    };
    NativeBigInt.prototype.isEven = function() {
      return (this.value & BigInt(1)) === BigInt(0);
    };
    BigInteger.prototype.isOdd = function() {
      return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function() {
      return (this.value & 1) === 1;
    };
    NativeBigInt.prototype.isOdd = function() {
      return (this.value & BigInt(1)) === BigInt(1);
    };
    BigInteger.prototype.isPositive = function() {
      return !this.sign;
    };
    SmallInteger.prototype.isPositive = function() {
      return this.value > 0;
    };
    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
    BigInteger.prototype.isNegative = function() {
      return this.sign;
    };
    SmallInteger.prototype.isNegative = function() {
      return this.value < 0;
    };
    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
    BigInteger.prototype.isUnit = function() {
      return false;
    };
    SmallInteger.prototype.isUnit = function() {
      return Math.abs(this.value) === 1;
    };
    NativeBigInt.prototype.isUnit = function() {
      return this.abs().value === BigInt(1);
    };
    BigInteger.prototype.isZero = function() {
      return false;
    };
    SmallInteger.prototype.isZero = function() {
      return this.value === 0;
    };
    NativeBigInt.prototype.isZero = function() {
      return this.value === BigInt(0);
    };
    BigInteger.prototype.isDivisibleBy = function(v) {
      var n = parseValue(v);
      if (n.isZero())
        return false;
      if (n.isUnit())
        return true;
      if (n.compareAbs(2) === 0)
        return this.isEven();
      return this.mod(n).isZero();
    };
    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
    function isBasicPrime(v) {
      var n = v.abs();
      if (n.isUnit())
        return false;
      if (n.equals(2) || n.equals(3) || n.equals(5))
        return true;
      if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5))
        return false;
      if (n.lesser(49))
        return true;
    }
    function millerRabinTest(n, a) {
      var nPrev = n.prev(), b = nPrev, r = 0, d, t, i2, x;
      while (b.isEven())
        b = b.divide(2), r++;
      next:
        for (i2 = 0;i2 < a.length; i2++) {
          if (n.lesser(a[i2]))
            continue;
          x = bigInt(a[i2]).modPow(b, n);
          if (x.isUnit() || x.equals(nPrev))
            continue;
          for (d = r - 1;d != 0; d--) {
            x = x.square().mod(n);
            if (x.isUnit())
              return false;
            if (x.equals(nPrev))
              continue next;
          }
          return false;
        }
      return true;
    }
    BigInteger.prototype.isPrime = function(strict) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined2)
        return isPrime;
      var n = this.abs();
      var bits = n.bitLength();
      if (bits <= 64)
        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
      var logN = Math.log(2) * bits.toJSNumber();
      var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
      for (var a = [], i2 = 0;i2 < t; i2++) {
        a.push(bigInt(i2 + 2));
      }
      return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
    BigInteger.prototype.isProbablePrime = function(iterations, rng) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined2)
        return isPrime;
      var n = this.abs();
      var t = iterations === undefined2 ? 5 : iterations;
      for (var a = [], i2 = 0;i2 < t; i2++) {
        a.push(bigInt.randBetween(2, n.minus(2), rng));
      }
      return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
    BigInteger.prototype.modInv = function(n) {
      var { zero: t, one: newT } = bigInt, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
      while (!newR.isZero()) {
        q = r.divide(newR);
        lastT = t;
        lastR = r;
        t = newT;
        r = newR;
        newT = lastT.subtract(q.multiply(newT));
        newR = lastR.subtract(q.multiply(newR));
      }
      if (!r.isUnit())
        throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
      if (t.compare(0) === -1) {
        t = t.add(n);
      }
      if (this.isNegative()) {
        return t.negate();
      }
      return t;
    };
    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
    BigInteger.prototype.next = function() {
      var value = this.value;
      if (this.sign) {
        return subtractSmall(value, 1, this.sign);
      }
      return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function() {
      var value = this.value;
      if (value + 1 < MAX_INT)
        return new SmallInteger(value + 1);
      return new BigInteger(MAX_INT_ARR, false);
    };
    NativeBigInt.prototype.next = function() {
      return new NativeBigInt(this.value + BigInt(1));
    };
    BigInteger.prototype.prev = function() {
      var value = this.value;
      if (this.sign) {
        return new BigInteger(addSmall(value, 1), true);
      }
      return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function() {
      var value = this.value;
      if (value - 1 > -MAX_INT)
        return new SmallInteger(value - 1);
      return new BigInteger(MAX_INT_ARR, true);
    };
    NativeBigInt.prototype.prev = function() {
      return new NativeBigInt(this.value - BigInt(1));
    };
    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)
      powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
    function shift_isSmall(n) {
      return Math.abs(n) <= BASE;
    }
    BigInteger.prototype.shiftLeft = function(v) {
      var n = parseValue(v).toJSNumber();
      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }
      if (n < 0)
        return this.shiftRight(-n);
      var result = this;
      if (result.isZero())
        return result;
      while (n >= powers2Length) {
        result = result.multiply(highestPower2);
        n -= powers2Length - 1;
      }
      return result.multiply(powersOfTwo[n]);
    };
    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
    BigInteger.prototype.shiftRight = function(v) {
      var remQuo;
      var n = parseValue(v).toJSNumber();
      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }
      if (n < 0)
        return this.shiftLeft(-n);
      var result = this;
      while (n >= powers2Length) {
        if (result.isZero() || result.isNegative() && result.isUnit())
          return result;
        remQuo = divModAny(result, highestPower2);
        result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        n -= powers2Length - 1;
      }
      remQuo = divModAny(result, powersOfTwo[n]);
      return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
    function bitwise(x, y, fn) {
      y = parseValue(y);
      var xSign = x.isNegative(), ySign = y.isNegative();
      var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
      var xDigit = 0, yDigit = 0;
      var xDivMod = null, yDivMod = null;
      var result = [];
      while (!xRem.isZero() || !yRem.isZero()) {
        xDivMod = divModAny(xRem, highestPower2);
        xDigit = xDivMod[1].toJSNumber();
        if (xSign) {
          xDigit = highestPower2 - 1 - xDigit;
        }
        yDivMod = divModAny(yRem, highestPower2);
        yDigit = yDivMod[1].toJSNumber();
        if (ySign) {
          yDigit = highestPower2 - 1 - yDigit;
        }
        xRem = xDivMod[0];
        yRem = yDivMod[0];
        result.push(fn(xDigit, yDigit));
      }
      var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
      for (var i2 = result.length - 1;i2 >= 0; i2 -= 1) {
        sum = sum.multiply(highestPower2).add(bigInt(result[i2]));
      }
      return sum;
    }
    BigInteger.prototype.not = function() {
      return this.negate().prev();
    };
    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
    BigInteger.prototype.and = function(n) {
      return bitwise(this, n, function(a, b) {
        return a & b;
      });
    };
    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
    BigInteger.prototype.or = function(n) {
      return bitwise(this, n, function(a, b) {
        return a | b;
      });
    };
    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
    BigInteger.prototype.xor = function(n) {
      return bitwise(this, n, function(a, b) {
        return a ^ b;
      });
    };
    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) {
      var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
      return x & -x;
    }
    function integerLogarithm(value, base) {
      if (base.compareTo(value) <= 0) {
        var tmp = integerLogarithm(value, base.square(base));
        var p = tmp.p;
        var e = tmp.e;
        var t = p.multiply(base);
        return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };
      }
      return { p: bigInt(1), e: 0 };
    }
    BigInteger.prototype.bitLength = function() {
      var n = this;
      if (n.compareTo(bigInt(0)) < 0) {
        n = n.negate().subtract(bigInt(1));
      }
      if (n.compareTo(bigInt(0)) === 0) {
        return bigInt(0);
      }
      return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
    };
    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
    function max(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.greater(b) ? a : b;
    }
    function min(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      if (a.equals(b))
        return a;
      if (a.isZero())
        return b;
      if (b.isZero())
        return a;
      var c = Integer[1], d, t;
      while (a.isEven() && b.isEven()) {
        d = min(roughLOB(a), roughLOB(b));
        a = a.divide(d);
        b = b.divide(d);
        c = c.multiply(d);
      }
      while (a.isEven()) {
        a = a.divide(roughLOB(a));
      }
      do {
        while (b.isEven()) {
          b = b.divide(roughLOB(b));
        }
        if (a.greater(b)) {
          t = b;
          b = a;
          a = t;
        }
        b = b.subtract(a);
      } while (!b.isZero());
      return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b, rng) {
      a = parseValue(a);
      b = parseValue(b);
      var usedRNG = rng || Math.random;
      var low = min(a, b), high = max(a, b);
      var range = high.subtract(low).add(1);
      if (range.isSmall)
        return low.add(Math.floor(usedRNG() * range));
      var digits = toBase(range, BASE).value;
      var result = [], restricted = true;
      for (var i2 = 0;i2 < digits.length; i2++) {
        var top = restricted ? digits[i2] + (i2 + 1 < digits.length ? digits[i2 + 1] / BASE : 0) : BASE;
        var digit = truncate(usedRNG() * top);
        result.push(digit);
        if (digit < digits[i2])
          restricted = false;
      }
      return low.add(Integer.fromArray(result, BASE, false));
    }
    var parseBase = function(text, base, alphabet, caseSensitive) {
      alphabet = alphabet || DEFAULT_ALPHABET;
      text = String(text);
      if (!caseSensitive) {
        text = text.toLowerCase();
        alphabet = alphabet.toLowerCase();
      }
      var length = text.length;
      var i2;
      var absBase = Math.abs(base);
      var alphabetValues = {};
      for (i2 = 0;i2 < alphabet.length; i2++) {
        alphabetValues[alphabet[i2]] = i2;
      }
      for (i2 = 0;i2 < length; i2++) {
        var c = text[i2];
        if (c === "-")
          continue;
        if (c in alphabetValues) {
          if (alphabetValues[c] >= absBase) {
            if (c === "1" && absBase === 1)
              continue;
            throw new Error(c + " is not a valid digit in base " + base + ".");
          }
        }
      }
      base = parseValue(base);
      var digits = [];
      var isNegative = text[0] === "-";
      for (i2 = isNegative ? 1 : 0;i2 < text.length; i2++) {
        var c = text[i2];
        if (c in alphabetValues)
          digits.push(parseValue(alphabetValues[c]));
        else if (c === "<") {
          var start = i2;
          do {
            i2++;
          } while (text[i2] !== ">" && i2 < text.length);
          digits.push(parseValue(text.slice(start + 1, i2)));
        } else
          throw new Error(c + " is not a valid character");
      }
      return parseBaseFromArray(digits, base, isNegative);
    };
    function parseBaseFromArray(digits, base, isNegative) {
      var val = Integer[0], pow = Integer[1], i2;
      for (i2 = digits.length - 1;i2 >= 0; i2--) {
        val = val.add(digits[i2].times(pow));
        pow = pow.times(base);
      }
      return isNegative ? val.negate() : val;
    }
    function stringify(digit, alphabet) {
      alphabet = alphabet || DEFAULT_ALPHABET;
      if (digit < alphabet.length) {
        return alphabet[digit];
      }
      return "<" + digit + ">";
    }
    function toBase(n, base) {
      base = bigInt(base);
      if (base.isZero()) {
        if (n.isZero())
          return { value: [0], isNegative: false };
        throw new Error("Cannot convert nonzero numbers to base 0.");
      }
      if (base.equals(-1)) {
        if (n.isZero())
          return { value: [0], isNegative: false };
        if (n.isNegative())
          return {
            value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])),
            isNegative: false
          };
        var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
        arr.unshift([1]);
        return {
          value: [].concat.apply([], arr),
          isNegative: false
        };
      }
      var neg = false;
      if (n.isNegative() && base.isPositive()) {
        neg = true;
        n = n.abs();
      }
      if (base.isUnit()) {
        if (n.isZero())
          return { value: [0], isNegative: false };
        return {
          value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
          isNegative: neg
        };
      }
      var out = [];
      var left = n, divmod;
      while (left.isNegative() || left.compareAbs(base) >= 0) {
        divmod = left.divmod(base);
        left = divmod.quotient;
        var digit = divmod.remainder;
        if (digit.isNegative()) {
          digit = base.minus(digit).abs();
          left = left.next();
        }
        out.push(digit.toJSNumber());
      }
      out.push(left.toJSNumber());
      return { value: out.reverse(), isNegative: neg };
    }
    function toBaseString(n, base, alphabet) {
      var arr = toBase(n, base);
      return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
        return stringify(x, alphabet);
      }).join("");
    }
    BigInteger.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    SmallInteger.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    NativeBigInt.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    BigInteger.prototype.toString = function(radix, alphabet) {
      if (radix === undefined2)
        radix = 10;
      if (radix !== 10 || alphabet)
        return toBaseString(this, radix, alphabet);
      var v = this.value, l2 = v.length, str = String(v[--l2]), zeros = "0000000", digit;
      while (--l2 >= 0) {
        digit = String(v[l2]);
        str += zeros.slice(digit.length) + digit;
      }
      var sign = this.sign ? "-" : "";
      return sign + str;
    };
    SmallInteger.prototype.toString = function(radix, alphabet) {
      if (radix === undefined2)
        radix = 10;
      if (radix != 10 || alphabet)
        return toBaseString(this, radix, alphabet);
      return String(this.value);
    };
    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
      return this.toString();
    };
    BigInteger.prototype.valueOf = function() {
      return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
    SmallInteger.prototype.valueOf = function() {
      return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
      return parseInt(this.toString(), 10);
    };
    function parseStringValue(v) {
      if (isPrecise(+v)) {
        var x = +v;
        if (x === truncate(x))
          return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
        throw new Error("Invalid integer: " + v);
      }
      var sign = v[0] === "-";
      if (sign)
        v = v.slice(1);
      var split = v.split(/e/i);
      if (split.length > 2)
        throw new Error("Invalid integer: " + split.join("e"));
      if (split.length === 2) {
        var exp = split[1];
        if (exp[0] === "+")
          exp = exp.slice(1);
        exp = +exp;
        if (exp !== truncate(exp) || !isPrecise(exp))
          throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
        var text = split[0];
        var decimalPlace = text.indexOf(".");
        if (decimalPlace >= 0) {
          exp -= text.length - decimalPlace - 1;
          text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
        }
        if (exp < 0)
          throw new Error("Cannot include negative exponent part for integers");
        text += new Array(exp + 1).join("0");
        v = text;
      }
      var isValid = /^([0-9][0-9]*)$/.test(v);
      if (!isValid)
        throw new Error("Invalid integer: " + v);
      if (supportsNativeBigInt) {
        return new NativeBigInt(BigInt(sign ? "-" + v : v));
      }
      var r = [], max2 = v.length, l2 = LOG_BASE, min2 = max2 - l2;
      while (max2 > 0) {
        r.push(+v.slice(min2, max2));
        min2 -= l2;
        if (min2 < 0)
          min2 = 0;
        max2 -= l2;
      }
      trim(r);
      return new BigInteger(r, sign);
    }
    function parseNumberValue(v) {
      if (supportsNativeBigInt) {
        return new NativeBigInt(BigInt(v));
      }
      if (isPrecise(v)) {
        if (v !== truncate(v))
          throw new Error(v + " is not an integer.");
        return new SmallInteger(v);
      }
      return parseStringValue(v.toString());
    }
    function parseValue(v) {
      if (typeof v === "number") {
        return parseNumberValue(v);
      }
      if (typeof v === "string") {
        return parseStringValue(v);
      }
      if (typeof v === "bigint") {
        return new NativeBigInt(v);
      }
      return v;
    }
    for (var i = 0;i < 1000; i++) {
      Integer[i] = parseValue(i);
      if (i > 0)
        Integer[-i] = parseValue(-i);
    }
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function(x) {
      return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
    };
    Integer.randBetween = randBetween;
    Integer.fromArray = function(digits, base, isNegative) {
      return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };
    return Integer;
  }();
  if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
    module.exports = bigInt;
  }
  if (typeof define === "function" && define.amd) {
    define(function() {
      return bigInt;
    });
  }
});

// node_modules/unzipper/lib/Decrypt.js
var require_Decrypt = __commonJS((exports, module) => {
  var bigInt = require_BigInteger();
  var Stream = __require("stream");
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable2();
  var table;
  function generateTable() {
    var poly = 3988292384, c, n, k;
    table = [];
    for (n = 0;n < 256; n++) {
      c = n;
      for (k = 0;k < 8; k++)
        c = c & 1 ? poly ^ c >>> 1 : c = c >>> 1;
      table[n] = c >>> 0;
    }
  }
  function crc(ch, crc2) {
    if (!table)
      generateTable();
    if (ch.charCodeAt)
      ch = ch.charCodeAt(0);
    return bigInt(crc2).shiftRight(8).and(16777215).xor(table[bigInt(crc2).xor(ch).and(255)]).value;
  }
  function Decrypt() {
    if (!(this instanceof Decrypt))
      return new Decrypt;
    this.key0 = 305419896;
    this.key1 = 591751049;
    this.key2 = 878082192;
  }
  Decrypt.prototype.update = function(h) {
    this.key0 = crc(h, this.key0);
    this.key1 = bigInt(this.key0).and(255).and(4294967295).add(this.key1);
    this.key1 = bigInt(this.key1).multiply(134775813).add(1).and(4294967295).value;
    this.key2 = crc(bigInt(this.key1).shiftRight(24).and(255), this.key2);
  };
  Decrypt.prototype.decryptByte = function(c) {
    var k = bigInt(this.key2).or(2);
    c = c ^ bigInt(k).multiply(bigInt(k ^ 1)).shiftRight(8).and(255);
    this.update(c);
    return c;
  };
  Decrypt.prototype.stream = function() {
    var stream = Stream.Transform(), self2 = this;
    stream._transform = function(d, e, cb) {
      for (var i = 0;i < d.length; i++) {
        d[i] = self2.decryptByte(d[i]);
      }
      this.push(d);
      cb();
    };
    return stream;
  };
  module.exports = Decrypt;
});

// node_modules/unzipper/lib/Open/unzip.js
var require_unzip = __commonJS((exports, module) => {
  var Promise2 = require_bluebird();
  var Decrypt = require_Decrypt();
  var PullStream = require_PullStream();
  var Stream = __require("stream");
  var binary = require_binary();
  var zlib = __require("zlib");
  var parseExtraField = require_parseExtraField();
  var Buffer2 = require_Buffer();
  var parseDateTime = require_parseDateTime();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable2();
  module.exports = function unzip(source, offset, _password, directoryVars) {
    var file = PullStream(), entry = Stream.PassThrough();
    var req = source.stream(offset);
    req.pipe(file).on("error", function(e) {
      entry.emit("error", e);
    });
    entry.vars = file.pull(30).then(function(data) {
      var vars = binary.parse(data).word32lu("signature").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);
      return file.pull(vars.fileNameLength).then(function(fileName) {
        vars.fileName = fileName.toString("utf8");
        return file.pull(vars.extraFieldLength);
      }).then(function(extraField) {
        var checkEncryption;
        vars.extra = parseExtraField(extraField, vars);
        if (directoryVars && directoryVars.compressedSize)
          vars = directoryVars;
        if (vars.flags & 1)
          checkEncryption = file.pull(12).then(function(header) {
            if (!_password)
              throw new Error("MISSING_PASSWORD");
            var decrypt = Decrypt();
            String(_password).split("").forEach(function(d) {
              decrypt.update(d);
            });
            for (var i = 0;i < header.length; i++)
              header[i] = decrypt.decryptByte(header[i]);
            vars.decrypt = decrypt;
            vars.compressedSize -= 12;
            var check = vars.flags & 8 ? vars.lastModifiedTime >> 8 & 255 : vars.crc32 >> 24 & 255;
            if (header[11] !== check)
              throw new Error("BAD_PASSWORD");
            return vars;
          });
        return Promise2.resolve(checkEncryption).then(function() {
          entry.emit("vars", vars);
          return vars;
        });
      });
    });
    entry.vars.then(function(vars) {
      var fileSizeKnown = !(vars.flags & 8) || vars.compressedSize > 0, eof;
      var inflater = vars.compressionMethod ? zlib.createInflateRaw() : Stream.PassThrough();
      if (fileSizeKnown) {
        entry.size = vars.uncompressedSize;
        eof = vars.compressedSize;
      } else {
        eof = Buffer2.alloc(4);
        eof.writeUInt32LE(134695760, 0);
      }
      var stream = file.stream(eof);
      if (vars.decrypt)
        stream = stream.pipe(vars.decrypt.stream());
      stream.pipe(inflater).on("error", function(err) {
        entry.emit("error", err);
      }).pipe(entry).on("finish", function() {
        if (req.destroy)
          req.destroy();
        else if (req.abort)
          req.abort();
        else if (req.close)
          req.close();
        else if (req.push)
          req.push();
        else
          console.log("warning - unable to close stream");
      });
    }).catch(function(e) {
      entry.emit("error", e);
    });
    return entry;
  };
});

// node_modules/unzipper/lib/Open/directory.js
var require_directory = __commonJS((exports, module) => {
  var binary = require_binary();
  var PullStream = require_PullStream();
  var unzip = require_unzip();
  var Promise2 = require_bluebird();
  var BufferStream = require_BufferStream();
  var parseExtraField = require_parseExtraField();
  var Buffer2 = require_Buffer();
  var path = __require("path");
  var Writer = require_fstream().Writer;
  var parseDateTime = require_parseDateTime();
  var signature = Buffer2.alloc(4);
  signature.writeUInt32LE(101010256, 0);
  function getCrxHeader(source) {
    var sourceStream = source.stream(0).pipe(PullStream());
    return sourceStream.pull(4).then(function(data) {
      var signature2 = data.readUInt32LE(0);
      if (signature2 === 875721283) {
        var crxHeader;
        return sourceStream.pull(12).then(function(data2) {
          crxHeader = binary.parse(data2).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
        }).then(function() {
          return sourceStream.pull(crxHeader.pubKeyLength + crxHeader.signatureLength);
        }).then(function(data2) {
          crxHeader.publicKey = data2.slice(0, crxHeader.pubKeyLength);
          crxHeader.signature = data2.slice(crxHeader.pubKeyLength);
          crxHeader.size = 16 + crxHeader.pubKeyLength + crxHeader.signatureLength;
          return crxHeader;
        });
      }
    });
  }
  function getZip64CentralDirectory(source, zip64CDL) {
    var d64loc = binary.parse(zip64CDL).word32lu("signature").word32lu("diskNumber").word64lu("offsetToStartOfCentralDirectory").word32lu("numberOfDisks").vars;
    if (d64loc.signature != 117853008) {
      throw new Error("invalid zip64 end of central dir locator signature (0x07064b50): 0x" + d64loc.signature.toString(16));
    }
    var dir64 = PullStream();
    source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);
    return dir64.pull(56);
  }
  function parseZip64DirRecord(dir64record) {
    var vars = binary.parse(dir64record).word32lu("signature").word64lu("sizeOfCentralDirectory").word16lu("version").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskStart").word64lu("numberOfRecordsOnDisk").word64lu("numberOfRecords").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
    if (vars.signature != 101075792) {
      throw new Error("invalid zip64 end of central dir locator signature (0x06064b50): 0x0" + vars.signature.toString(16));
    }
    return vars;
  }
  module.exports = function centralDirectory(source, options) {
    var endDir = PullStream(), records = PullStream(), tailSize = options && options.tailSize || 80, sourceSize, crxHeader, startOffset, vars;
    if (options && options.crx)
      crxHeader = getCrxHeader(source);
    return source.size().then(function(size) {
      sourceSize = size;
      source.stream(Math.max(0, size - tailSize)).on("error", function(error) {
        endDir.emit("error", error);
      }).pipe(endDir);
      return endDir.pull(signature);
    }).then(function() {
      return Promise2.props({ directory: endDir.pull(22), crxHeader });
    }).then(function(d) {
      var data = d.directory;
      startOffset = d.crxHeader && d.crxHeader.size || 0;
      vars = binary.parse(data).word32lu("signature").word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      if (vars.numberOfRecords == 65535 || vars.numberOfRecords == 65535 || vars.offsetToStartOfCentralDirectory == 4294967295) {
        const zip64CDLSize = 20;
        const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize);
        const zip64CDLStream = PullStream();
        source.stream(zip64CDLOffset).pipe(zip64CDLStream);
        return zip64CDLStream.pull(zip64CDLSize).then(function(d2) {
          return getZip64CentralDirectory(source, d2);
        }).then(function(dir64record) {
          vars = parseZip64DirRecord(dir64record);
        });
      } else {
        vars.offsetToStartOfCentralDirectory += startOffset;
      }
    }).then(function() {
      if (vars.commentLength)
        return endDir.pull(vars.commentLength).then(function(comment) {
          vars.comment = comment.toString("utf8");
        });
    }).then(function() {
      source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);
      vars.extract = function(opts) {
        if (!opts || !opts.path)
          throw new Error("PATH_MISSING");
        opts.path = path.resolve(path.normalize(opts.path));
        return vars.files.then(function(files) {
          return Promise2.map(files, function(entry) {
            if (entry.type == "Directory")
              return;
            var extractPath = path.join(opts.path, entry.path);
            if (extractPath.indexOf(opts.path) != 0) {
              return;
            }
            var writer = opts.getWriter ? opts.getWriter({ path: extractPath }) : Writer({ path: extractPath });
            return new Promise2(function(resolve, reject) {
              entry.stream(opts.password).on("error", reject).pipe(writer).on("close", resolve).on("error", reject);
            });
          }, { concurrency: opts.concurrency > 1 ? opts.concurrency : 1 });
        });
      };
      vars.files = Promise2.mapSeries(Array(vars.numberOfRecords), function() {
        return records.pull(46).then(function(data) {
          var vars2 = binary.parse(data).word32lu("signature").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
          vars2.offsetToLocalFileHeader += startOffset;
          vars2.lastModifiedDateTime = parseDateTime(vars2.lastModifiedDate, vars2.lastModifiedTime);
          return records.pull(vars2.fileNameLength).then(function(fileNameBuffer) {
            vars2.pathBuffer = fileNameBuffer;
            vars2.path = fileNameBuffer.toString("utf8");
            vars2.isUnicode = (vars2.flags & 2048) != 0;
            return records.pull(vars2.extraFieldLength);
          }).then(function(extraField) {
            vars2.extra = parseExtraField(extraField, vars2);
            return records.pull(vars2.fileCommentLength);
          }).then(function(comment) {
            vars2.comment = comment;
            vars2.type = vars2.uncompressedSize === 0 && /[\/\\]$/.test(vars2.path) ? "Directory" : "File";
            vars2.stream = function(_password) {
              return unzip(source, vars2.offsetToLocalFileHeader, _password, vars2);
            };
            vars2.buffer = function(_password) {
              return BufferStream(vars2.stream(_password));
            };
            return vars2;
          });
        });
      });
      return Promise2.props(vars);
    });
  };
});

// node_modules/unzipper/lib/Open/index.js
var require_Open = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var Promise2 = require_bluebird();
  var directory = require_directory();
  var Stream = __require("stream");
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable2();
  module.exports = {
    buffer: function(buffer, options) {
      var source = {
        stream: function(offset, length) {
          var stream = Stream.PassThrough();
          stream.end(buffer.slice(offset, length));
          return stream;
        },
        size: function() {
          return Promise2.resolve(buffer.length);
        }
      };
      return directory(source, options);
    },
    file: function(filename, options) {
      var source = {
        stream: function(offset, length) {
          return fs.createReadStream(filename, { start: offset, end: length && offset + length });
        },
        size: function() {
          return new Promise2(function(resolve, reject) {
            fs.stat(filename, function(err, d) {
              if (err)
                reject(err);
              else
                resolve(d.size);
            });
          });
        }
      };
      return directory(source, options);
    },
    url: function(request, params, options) {
      if (typeof params === "string")
        params = { url: params };
      if (!params.url)
        throw "URL missing";
      params.headers = params.headers || {};
      var source = {
        stream: function(offset, length) {
          var options2 = Object.create(params);
          options2.headers = Object.create(params.headers);
          options2.headers.range = "bytes=" + offset + "-" + (length ? length : "");
          return request(options2);
        },
        size: function() {
          return new Promise2(function(resolve, reject) {
            var req = request(params);
            req.on("response", function(d) {
              req.abort();
              if (!d.headers["content-length"])
                reject(new Error("Missing content length header"));
              else
                resolve(d.headers["content-length"]);
            }).on("error", reject);
          });
        }
      };
      return directory(source, options);
    },
    s3: function(client, params, options) {
      var source = {
        size: function() {
          return new Promise2(function(resolve, reject) {
            client.headObject(params, function(err, d) {
              if (err)
                reject(err);
              else
                resolve(d.ContentLength);
            });
          });
        },
        stream: function(offset, length) {
          var d = {};
          for (var key2 in params)
            d[key2] = params[key2];
          d.Range = "bytes=" + offset + "-" + (length ? length : "");
          return client.getObject(d).createReadStream();
        }
      };
      return directory(source, options);
    },
    custom: function(source, options) {
      return directory(source, options);
    }
  };
});

// node_modules/unzipper/unzip.js
var require_unzip2 = __commonJS((exports) => {
  require_listenercount();
  require_buffer_indexof_polyfill();
  require_setImmediate();
  exports.Parse = require_parse();
  exports.ParseOne = require_parseOne();
  exports.Extract = require_extract2();
  exports.Open = require_Open();
});

// node_modules/minimatch/lib/path.js
var require_path = __commonJS((exports, module) => {
  var isWindows = typeof process === "object" && process && process.platform === "win32";
  module.exports = isWindows ? { sep: "\\" } : { sep: "/" };
});

// node_modules/brace-expansion/index.js
var require_brace_expansion2 = __commonJS((exports, module) => {
  var balanced = require_balanced_match();
  module.exports = expandTop;
  var escSlash = "\x00SLASH" + Math.random() + "\x00";
  var escOpen = "\x00OPEN" + Math.random() + "\x00";
  var escClose = "\x00CLOSE" + Math.random() + "\x00";
  var escComma = "\x00COMMA" + Math.random() + "\x00";
  var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m2 = balanced("{", "}", str);
    if (!m2)
      return str.split(",");
    var pre = m2.pre;
    var body = m2.body;
    var post = m2.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m2 = balanced("{", "}", str);
    if (!m2)
      return [str];
    var pre = m2.pre;
    var post = m2.post.length ? expand(m2.post, false) : [""];
    if (/\$$/.test(m2.pre)) {
      for (var k = 0;k < post.length; k++) {
        var expansion = pre + "{" + m2.body + "}" + post[k];
        expansions.push(expansion);
      }
    } else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m2.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m2.post.match(/,(?!,).*\}/)) {
          str = m2.pre + "{" + m2.body + escClose + m2.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m2.body.split(/\.\./);
      } else {
        n = parseCommaParts(m2.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            return post.map(function(p) {
              return m2.pre + n[0] + p;
            });
          }
        }
      }
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width2 = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x;test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width2 - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = [];
        for (var j = 0;j < n.length; j++) {
          N.push.apply(N, expand(n[j], false));
        }
      }
      for (var j = 0;j < N.length; j++) {
        for (var k = 0;k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    }
    return expansions;
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch2 = __commonJS((exports, module) => {
  var minimatch = module.exports = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  module.exports = minimatch;
  var path = require_path();
  minimatch.sep = path.sep;
  var GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  var expand = require_brace_expansion2();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var charSet = (s) => s.split("").reduce((set, c) => {
    set[c] = true;
    return set;
  }, {});
  var reSpecials = charSet("().*{}+?[]^$\\!");
  var addPatternStartSet = charSet("[.(");
  var slashSplit = /\/+/;
  minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
  var ext = (a, b = {}) => {
    const t = {};
    Object.keys(a).forEach((k) => t[k] = a[k]);
    Object.keys(b).forEach((k) => t[k] = b[k]);
    return t;
  };
  minimatch.defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    const orig = minimatch;
    const m2 = (p, pattern, options) => orig(p, pattern, ext(def, options));
    m2.Minimatch = class Minimatch2 extends orig.Minimatch {
      constructor(pattern, options) {
        super(pattern, ext(def, options));
      }
    };
    m2.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
    m2.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
    m2.defaults = (options) => orig.defaults(ext(def, options));
    m2.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
    m2.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
    m2.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
    return m2;
  };
  minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
  var braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  };
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  var SUBPARSE = Symbol("subparse");
  minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
  minimatch.match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f) => mm.match(f));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
  var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");

  class Minimatch {
    constructor(pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    debug() {}
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      let set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = (...args) => console.error(...args);
      this.debug(this.pattern, set);
      set = this.globParts = set.map((s) => s.split(slashSplit));
      this.debug(this.pattern, set);
      set = set.map((s, si, set2) => s.map(this.parse, this));
      this.debug(this.pattern, set);
      set = set.filter((s) => s.indexOf(false) === -1);
      this.debug(this.pattern, set);
      this.set = set;
    }
    parseNegate() {
      if (this.options.nonegate)
        return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0;i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    matchOne(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { this: this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (;fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug(`
globstar while`, file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug(`
>>> no match, partial?`, file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern, isSub) {
      assertValidPattern(pattern);
      const options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      let re = "";
      let hasMagic = false;
      let escaping = false;
      const patternListStack = [];
      const negativeLists = [];
      let stateChar;
      let inClass = false;
      let reClassStart = -1;
      let classStart = -1;
      let cs;
      let pl;
      let sp;
      let dotTravAllowed = pattern.charAt(0) === ".";
      let dotFileAllowed = options.dot || dotTravAllowed;
      const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const clearStateChar = () => {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          this.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      };
      for (let i = 0, c;i < pattern.length && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping) {
          if (c === "/") {
            return false;
          }
          if (reSpecials[c]) {
            re += "\\";
          }
          re += c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            if (inClass && pattern.charAt(i + 1) === "-") {
              re += c;
              continue;
            }
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            this.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(": {
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            const plEntry = {
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            };
            this.debug(this.pattern, "\t", plEntry);
            patternListStack.push(plEntry);
            re += plEntry.open;
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re += subPatternStart(pattern.slice(i + 1));
            }
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          }
          case ")": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\)";
              continue;
            }
            patternListStack.pop();
            clearStateChar();
            hasMagic = true;
            pl = plEntry;
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(Object.assign(pl, { reEnd: re.length }));
            }
            continue;
          }
          case "|": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\|";
              continue;
            }
            clearStateChar();
            re += "|";
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re += subPatternStart(pattern.slice(i + 1));
            }
            continue;
          }
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              continue;
            }
            cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
              re += c;
            } catch (er) {
              re = re.substring(0, reClassStart) + "(?:$.)";
            }
            hasMagic = true;
            inClass = false;
            continue;
          default:
            clearStateChar();
            if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
            break;
        }
      }
      if (inClass) {
        cs = pattern.slice(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substring(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop();pl; pl = patternListStack.pop()) {
        let tail;
        tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug(`tail=%j
   %s`, tail, tail, pl, re);
        const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      const addPatternStart = addPatternStartSet[re.charAt(0)];
      for (let n = negativeLists.length - 1;n > -1; n--) {
        const nl = negativeLists[n];
        const nlBefore = re.slice(0, nl.reStart);
        const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        let nlAfter = re.slice(nl.reEnd);
        const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
        const closeParensBefore = nlBefore.split(")").length;
        const openParensBefore = nlBefore.split("(").length - closeParensBefore;
        let cleanAfter = nlAfter;
        for (let i = 0;i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
        re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart() + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (options.nocase && !hasMagic) {
        hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      const flags = options.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + re + "$", flags), {
          _glob: pattern,
          _src: re
        });
      } catch (er) {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      const flags = options.nocase ? "i" : "";
      let re = set.map((pattern) => {
        pattern = pattern.map((p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set2, p) => {
          if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
            set2.push(p);
          }
          return set2;
        }, []);
        pattern.forEach((p, i) => {
          if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
            return;
          }
          if (i === 0) {
            if (pattern.length > 1) {
              pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
            } else {
              pattern[i] = twoStar;
            }
          } else if (i === pattern.length - 1) {
            pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
          } else {
            pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
            pattern[i + 1] = GLOBSTAR;
          }
        });
        return pattern.filter((p) => p !== GLOBSTAR).join("/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    match(f, partial = this.partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      const options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      const set = this.set;
      this.debug(this.pattern, "set", set);
      let filename;
      for (let i = f.length - 1;i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (let i = 0;i < set.length; i++) {
        const pattern = set[i];
        let file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  }
  minimatch.Minimatch = Minimatch;
});

// node_modules/readdir-glob/index.js
var require_readdir_glob = __commonJS((exports, module) => {
  module.exports = readdirGlob;
  var fs = __require("fs");
  var { EventEmitter } = __require("events");
  var { Minimatch } = require_minimatch2();
  var { resolve } = __require("path");
  function readdir(dir, strict) {
    return new Promise((resolve2, reject) => {
      fs.readdir(dir, { withFileTypes: true }, (err, files) => {
        if (err) {
          switch (err.code) {
            case "ENOTDIR":
              if (strict) {
                reject(err);
              } else {
                resolve2([]);
              }
              break;
            case "ENOTSUP":
            case "ENOENT":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              resolve2([]);
              break;
            case "ELOOP":
            default:
              reject(err);
              break;
          }
        } else {
          resolve2(files);
        }
      });
    });
  }
  function stat(file, followSymlinks) {
    return new Promise((resolve2, reject) => {
      const statFunc = followSymlinks ? fs.stat : fs.lstat;
      statFunc(file, (err, stats) => {
        if (err) {
          switch (err.code) {
            case "ENOENT":
              if (followSymlinks) {
                resolve2(stat(file, false));
              } else {
                resolve2(null);
              }
              break;
            default:
              resolve2(null);
              break;
          }
        } else {
          resolve2(stats);
        }
      });
    });
  }
  async function* exploreWalkAsync(dir, path, followSymlinks, useStat, shouldSkip, strict) {
    let files = await readdir(path + dir, strict);
    for (const file of files) {
      let name = file.name;
      if (name === undefined) {
        name = file;
        useStat = true;
      }
      const filename = dir + "/" + name;
      const relative = filename.slice(1);
      const absolute = path + "/" + relative;
      let stats = null;
      if (useStat || followSymlinks) {
        stats = await stat(absolute, followSymlinks);
      }
      if (!stats && file.name !== undefined) {
        stats = file;
      }
      if (stats === null) {
        stats = { isDirectory: () => false };
      }
      if (stats.isDirectory()) {
        if (!shouldSkip(relative)) {
          yield { relative, absolute, stats };
          yield* exploreWalkAsync(filename, path, followSymlinks, useStat, shouldSkip, false);
        }
      } else {
        yield { relative, absolute, stats };
      }
    }
  }
  async function* explore(path, followSymlinks, useStat, shouldSkip) {
    yield* exploreWalkAsync("", path, followSymlinks, useStat, shouldSkip, true);
  }
  function readOptions(options) {
    return {
      pattern: options.pattern,
      dot: !!options.dot,
      noglobstar: !!options.noglobstar,
      matchBase: !!options.matchBase,
      nocase: !!options.nocase,
      ignore: options.ignore,
      skip: options.skip,
      follow: !!options.follow,
      stat: !!options.stat,
      nodir: !!options.nodir,
      mark: !!options.mark,
      silent: !!options.silent,
      absolute: !!options.absolute
    };
  }

  class ReaddirGlob extends EventEmitter {
    constructor(cwd, options, cb) {
      super();
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      this.options = readOptions(options || {});
      this.matchers = [];
      if (this.options.pattern) {
        const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];
        this.matchers = matchers.map((m2) => new Minimatch(m2, {
          dot: this.options.dot,
          noglobstar: this.options.noglobstar,
          matchBase: this.options.matchBase,
          nocase: this.options.nocase
        }));
      }
      this.ignoreMatchers = [];
      if (this.options.ignore) {
        const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];
        this.ignoreMatchers = ignorePatterns.map((ignore) => new Minimatch(ignore, { dot: true }));
      }
      this.skipMatchers = [];
      if (this.options.skip) {
        const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];
        this.skipMatchers = skipPatterns.map((skip) => new Minimatch(skip, { dot: true }));
      }
      this.iterator = explore(resolve(cwd || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));
      this.paused = false;
      this.inactive = false;
      this.aborted = false;
      if (cb) {
        this._matches = [];
        this.on("match", (match) => this._matches.push(this.options.absolute ? match.absolute : match.relative));
        this.on("error", (err) => cb(err));
        this.on("end", () => cb(null, this._matches));
      }
      setTimeout(() => this._next(), 0);
    }
    _shouldSkipDirectory(relative) {
      return this.skipMatchers.some((m2) => m2.match(relative));
    }
    _fileMatches(relative, isDirectory) {
      const file = relative + (isDirectory ? "/" : "");
      return (this.matchers.length === 0 || this.matchers.some((m2) => m2.match(file))) && !this.ignoreMatchers.some((m2) => m2.match(file)) && (!this.options.nodir || !isDirectory);
    }
    _next() {
      if (!this.paused && !this.aborted) {
        this.iterator.next().then((obj2) => {
          if (!obj2.done) {
            const isDirectory = obj2.value.stats.isDirectory();
            if (this._fileMatches(obj2.value.relative, isDirectory)) {
              let relative = obj2.value.relative;
              let absolute = obj2.value.absolute;
              if (this.options.mark && isDirectory) {
                relative += "/";
                absolute += "/";
              }
              if (this.options.stat) {
                this.emit("match", { relative, absolute, stat: obj2.value.stats });
              } else {
                this.emit("match", { relative, absolute });
              }
            }
            this._next(this.iterator);
          } else {
            this.emit("end");
          }
        }).catch((err) => {
          this.abort();
          this.emit("error", err);
          if (!err.code && !this.options.silent) {
            console.error(err);
          }
        });
      } else {
        this.inactive = true;
      }
    }
    abort() {
      this.aborted = true;
    }
    pause() {
      this.paused = true;
    }
    resume() {
      this.paused = false;
      if (this.inactive) {
        this.inactive = false;
        this._next();
      }
    }
  }
  function readdirGlob(pattern, options, cb) {
    return new ReaddirGlob(pattern, options, cb);
  }
  readdirGlob.ReaddirGlob = ReaddirGlob;
});

// node_modules/async/dist/async.js
var require_async2 = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.async = {}));
  })(exports, function(exports2) {
    function apply(fn, ...args) {
      return (...callArgs) => fn(...args, ...callArgs);
    }
    function initialParams(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    }
    var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer$1;
    if (hasQueueMicrotask) {
      _defer$1 = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer$1 = setImmediate;
    } else if (hasNextTick) {
      _defer$1 = process.nextTick;
    } else {
      _defer$1 = fallback;
    }
    var setImmediate$1 = wrap(_defer$1);
    function asyncify(func) {
      if (isAsync(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return initialParams(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        setImmediate$1((e) => {
          throw e;
        }, err);
      }
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj2) {
      return typeof obj2[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }
    function awaitify(asyncFn, arity) {
      if (!arity)
        arity = asyncFn.length;
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject2) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject2(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    function applyEach$1(eachfn) {
      return function applyEach(fns, ...callArgs) {
        const go = awaitify(function(callback) {
          var that = this;
          return eachfn(fns, (fn, cb) => {
            wrapAsync(fn).apply(that, callArgs.concat(cb));
          }, callback);
        });
        return go;
      };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      arr = arr || [];
      var results2 = [];
      var counter = 0;
      var _iteratee = wrapAsync(iteratee);
      return eachfn(arr, (value, _2, iterCb) => {
        var index2 = counter++;
        _iteratee(value, (err, v) => {
          results2[index2] = v;
          iterCb(err);
        });
      }, (err) => {
        callback(err, results2);
      });
    }
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    const breakLoop = {};
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    function getIterator(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj2) {
      var okeys = obj2 ? Object.keys(obj2) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key2 = okeys[++i];
        if (key2 === "__proto__") {
          return next();
        }
        return i < len ? { value: obj2[key2], key: key2 } : null;
      };
    }
    function createIterator(coll) {
      if (isArrayLike(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = getIterator(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === breakLoop || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    var eachOfLimit$2 = (limit) => {
      return (obj2, iteratee, callback) => {
        callback = once(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj2) {
          return callback(null);
        }
        if (isAsyncGenerator(obj2)) {
          return asyncEachOfLimit(obj2, limit, iteratee, callback);
        }
        if (isAsyncIterable(obj2)) {
          return asyncEachOfLimit(obj2[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = createIterator(obj2);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    function eachOfLimit(coll, limit, iteratee, callback) {
      return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
    }
    var eachOfLimit$1 = awaitify(eachOfLimit, 4);
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = once(callback);
      var index2 = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === breakLoop) {
          callback(null);
        }
      }
      for (;index2 < length; index2++) {
        iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return eachOfLimit$1(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }
    var eachOf$1 = awaitify(eachOf, 3);
    function map(coll, iteratee, callback) {
      return _asyncMap(eachOf$1, coll, iteratee, callback);
    }
    var map$1 = awaitify(map, 3);
    var applyEach = applyEach$1(map$1);
    function eachOfSeries(coll, iteratee, callback) {
      return eachOfLimit$1(coll, 1, iteratee, callback);
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);
    function mapSeries(coll, iteratee, callback) {
      return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
    }
    var mapSeries$1 = awaitify(mapSeries, 3);
    var applyEachSeries = applyEach$1(mapSeries$1);
    const PROMISE_SYMBOL = Symbol("promiseCallback");
    function promiseCallback() {
      let resolve, reject2;
      function callback(err, ...args) {
        if (err)
          return reject2(err);
        resolve(args.length > 1 ? args : args[0]);
      }
      callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res, reject2 = rej;
      });
      return callback;
    }
    function auto(tasks, concurrency, callback) {
      if (typeof concurrency !== "number") {
        callback = concurrency;
        concurrency = null;
      }
      callback = once(callback || promiseCallback());
      var numTasks = Object.keys(tasks).length;
      if (!numTasks) {
        return callback(null);
      }
      if (!concurrency) {
        concurrency = numTasks;
      }
      var results2 = {};
      var runningTasks = 0;
      var canceled = false;
      var hasError = false;
      var listeners = Object.create(null);
      var readyTasks = [];
      var readyToCheck = [];
      var uncheckedDependencies = {};
      Object.keys(tasks).forEach((key2) => {
        var task = tasks[key2];
        if (!Array.isArray(task)) {
          enqueueTask(key2, [task]);
          readyToCheck.push(key2);
          return;
        }
        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
          enqueueTask(key2, task);
          readyToCheck.push(key2);
          return;
        }
        uncheckedDependencies[key2] = remainingDependencies;
        dependencies.forEach((dependencyName) => {
          if (!tasks[dependencyName]) {
            throw new Error("async.auto task `" + key2 + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
          }
          addListener(dependencyName, () => {
            remainingDependencies--;
            if (remainingDependencies === 0) {
              enqueueTask(key2, task);
            }
          });
        });
      });
      checkForDeadlocks();
      processQueue();
      function enqueueTask(key2, task) {
        readyTasks.push(() => runTask(key2, task));
      }
      function processQueue() {
        if (canceled)
          return;
        if (readyTasks.length === 0 && runningTasks === 0) {
          return callback(null, results2);
        }
        while (readyTasks.length && runningTasks < concurrency) {
          var run = readyTasks.shift();
          run();
        }
      }
      function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
          taskListeners = listeners[taskName] = [];
        }
        taskListeners.push(fn);
      }
      function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        taskListeners.forEach((fn) => fn());
        processQueue();
      }
      function runTask(key2, task) {
        if (hasError)
          return;
        var taskCallback = onlyOnce((err, ...result) => {
          runningTasks--;
          if (err === false) {
            canceled = true;
            return;
          }
          if (result.length < 2) {
            [result] = result;
          }
          if (err) {
            var safeResults = {};
            Object.keys(results2).forEach((rkey) => {
              safeResults[rkey] = results2[rkey];
            });
            safeResults[key2] = result;
            hasError = true;
            listeners = Object.create(null);
            if (canceled)
              return;
            callback(err, safeResults);
          } else {
            results2[key2] = result;
            taskComplete(key2);
          }
        });
        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
          taskFn(results2, taskCallback);
        } else {
          taskFn(taskCallback);
        }
      }
      function checkForDeadlocks() {
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
          currentTask = readyToCheck.pop();
          counter++;
          getDependents(currentTask).forEach((dependent) => {
            if (--uncheckedDependencies[dependent] === 0) {
              readyToCheck.push(dependent);
            }
          });
        }
        if (counter !== numTasks) {
          throw new Error("async.auto cannot execute tasks due to a recursive dependency");
        }
      }
      function getDependents(taskName) {
        var result = [];
        Object.keys(tasks).forEach((key2) => {
          const task = tasks[key2];
          if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
            result.push(key2);
          }
        });
        return result;
      }
      return callback[PROMISE_SYMBOL];
    }
    var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
    var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;
    function stripComments(string) {
      let stripped = "";
      let index2 = 0;
      let endBlockComment = string.indexOf("*/");
      while (index2 < string.length) {
        if (string[index2] === "/" && string[index2 + 1] === "/") {
          let endIndex = string.indexOf(`
`, index2);
          index2 = endIndex === -1 ? string.length : endIndex;
        } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
          let endIndex = string.indexOf("*/", index2);
          if (endIndex !== -1) {
            index2 = endIndex + 2;
            endBlockComment = string.indexOf("*/", index2);
          } else {
            stripped += string[index2];
            index2++;
          }
        } else {
          stripped += string[index2];
          index2++;
        }
      }
      return stripped;
    }
    function parseParams(func) {
      const src = stripComments(func.toString());
      let match = src.match(FN_ARGS);
      if (!match) {
        match = src.match(ARROW_FN_ARGS);
      }
      if (!match)
        throw new Error(`could not parse args in autoInject
Source:
` + src);
      let [, args] = match;
      return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
    }
    function autoInject(tasks, callback) {
      var newTasks = {};
      Object.keys(tasks).forEach((key2) => {
        var taskFn = tasks[key2];
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
        if (Array.isArray(taskFn)) {
          params = [...taskFn];
          taskFn = params.pop();
          newTasks[key2] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
          newTasks[key2] = taskFn;
        } else {
          params = parseParams(taskFn);
          if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
            throw new Error("autoInject task functions require explicit parameters.");
          }
          if (!fnIsAsync)
            params.pop();
          newTasks[key2] = params.concat(newTask);
        }
        function newTask(results2, taskCb) {
          var newArgs = params.map((name) => results2[name]);
          newArgs.push(taskCb);
          wrapAsync(taskFn)(...newArgs);
        }
      });
      return auto(newTasks, callback);
    }

    class DLL {
      constructor() {
        this.head = this.tail = null;
        this.length = 0;
      }
      removeLink(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        node.prev = node.next = null;
        this.length -= 1;
        return node;
      }
      empty() {
        while (this.head)
          this.shift();
        return this;
      }
      insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode;
        this.length += 1;
      }
      insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode;
        this.length += 1;
      }
      unshift(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      }
      push(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      }
      shift() {
        return this.head && this.removeLink(this.head);
      }
      pop() {
        return this.tail && this.removeLink(this.tail);
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        var cur = this.head;
        while (cur) {
          yield cur.data;
          cur = cur.next;
        }
      }
      remove(testFn) {
        var curr = this.head;
        while (curr) {
          var { next } = curr;
          if (testFn(curr)) {
            this.removeLink(curr);
          }
          curr = next;
        }
        return this;
      }
    }
    function setInitial(dll, node) {
      dll.length = 1;
      dll.head = dll.tail = node;
    }
    function queue$1(worker, concurrency, payload) {
      if (concurrency == null) {
        concurrency = 1;
      } else if (concurrency === 0) {
        throw new RangeError("Concurrency must not be zero");
      }
      var _worker = wrapAsync(worker);
      var numRunning = 0;
      var workersList = [];
      const events = {
        error: [],
        drain: [],
        saturated: [],
        unsaturated: [],
        empty: []
      };
      function on(event, handler) {
        events[event].push(handler);
      }
      function once2(event, handler) {
        const handleAndRemove = (...args) => {
          off(event, handleAndRemove);
          handler(...args);
        };
        events[event].push(handleAndRemove);
      }
      function off(event, handler) {
        if (!event)
          return Object.keys(events).forEach((ev) => events[ev] = []);
        if (!handler)
          return events[event] = [];
        events[event] = events[event].filter((ev) => ev !== handler);
      }
      function trigger(event, ...args) {
        events[event].forEach((handler) => handler(...args));
      }
      var processingScheduled = false;
      function _insert(data, insertAtFront, rejectOnError, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        var res, rej;
        function promiseCallback2(err, ...args) {
          if (err)
            return rejectOnError ? rej(err) : res();
          if (args.length <= 1)
            return res(args[0]);
          res(args);
        }
        var item = q._createTaskItem(data, rejectOnError ? promiseCallback2 : callback || promiseCallback2);
        if (insertAtFront) {
          q._tasks.unshift(item);
        } else {
          q._tasks.push(item);
        }
        if (!processingScheduled) {
          processingScheduled = true;
          setImmediate$1(() => {
            processingScheduled = false;
            q.process();
          });
        }
        if (rejectOnError || !callback) {
          return new Promise((resolve, reject2) => {
            res = resolve;
            rej = reject2;
          });
        }
      }
      function _createCB(tasks) {
        return function(err, ...args) {
          numRunning -= 1;
          for (var i = 0, l2 = tasks.length;i < l2; i++) {
            var task = tasks[i];
            var index2 = workersList.indexOf(task);
            if (index2 === 0) {
              workersList.shift();
            } else if (index2 > 0) {
              workersList.splice(index2, 1);
            }
            task.callback(err, ...args);
            if (err != null) {
              trigger("error", err, task.data);
            }
          }
          if (numRunning <= q.concurrency - q.buffer) {
            trigger("unsaturated");
          }
          if (q.idle()) {
            trigger("drain");
          }
          q.process();
        };
      }
      function _maybeDrain(data) {
        if (data.length === 0 && q.idle()) {
          setImmediate$1(() => trigger("drain"));
          return true;
        }
        return false;
      }
      const eventMethod = (name) => (handler) => {
        if (!handler) {
          return new Promise((resolve, reject2) => {
            once2(name, (err, data) => {
              if (err)
                return reject2(err);
              resolve(data);
            });
          });
        }
        off(name);
        on(name, handler);
      };
      var isProcessing = false;
      var q = {
        _tasks: new DLL,
        _createTaskItem(data, callback) {
          return {
            data,
            callback
          };
        },
        *[Symbol.iterator]() {
          yield* q._tasks[Symbol.iterator]();
        },
        concurrency,
        payload,
        buffer: concurrency / 4,
        started: false,
        paused: false,
        push(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, false, callback));
          }
          return _insert(data, false, false, callback);
        },
        pushAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, true, callback));
          }
          return _insert(data, false, true, callback);
        },
        kill() {
          off();
          q._tasks.empty();
        },
        unshift(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, false, callback));
          }
          return _insert(data, true, false, callback);
        },
        unshiftAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, true, callback));
          }
          return _insert(data, true, true, callback);
        },
        remove(testFn) {
          q._tasks.remove(testFn);
        },
        process() {
          if (isProcessing) {
            return;
          }
          isProcessing = true;
          while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
            var tasks = [], data = [];
            var l2 = q._tasks.length;
            if (q.payload)
              l2 = Math.min(l2, q.payload);
            for (var i = 0;i < l2; i++) {
              var node = q._tasks.shift();
              tasks.push(node);
              workersList.push(node);
              data.push(node.data);
            }
            numRunning += 1;
            if (q._tasks.length === 0) {
              trigger("empty");
            }
            if (numRunning === q.concurrency) {
              trigger("saturated");
            }
            var cb = onlyOnce(_createCB(tasks));
            _worker(data, cb);
          }
          isProcessing = false;
        },
        length() {
          return q._tasks.length;
        },
        running() {
          return numRunning;
        },
        workersList() {
          return workersList;
        },
        idle() {
          return q._tasks.length + numRunning === 0;
        },
        pause() {
          q.paused = true;
        },
        resume() {
          if (q.paused === false) {
            return;
          }
          q.paused = false;
          setImmediate$1(q.process);
        }
      };
      Object.defineProperties(q, {
        saturated: {
          writable: false,
          value: eventMethod("saturated")
        },
        unsaturated: {
          writable: false,
          value: eventMethod("unsaturated")
        },
        empty: {
          writable: false,
          value: eventMethod("empty")
        },
        drain: {
          writable: false,
          value: eventMethod("drain")
        },
        error: {
          writable: false,
          value: eventMethod("error")
        }
      });
      return q;
    }
    function cargo$1(worker, payload) {
      return queue$1(worker, 1, payload);
    }
    function cargo(worker, concurrency, payload) {
      return queue$1(worker, concurrency, payload);
    }
    function reduce(coll, memo, iteratee, callback) {
      callback = once(callback);
      var _iteratee = wrapAsync(iteratee);
      return eachOfSeries$1(coll, (x, i, iterCb) => {
        _iteratee(memo, x, (err, v) => {
          memo = v;
          iterCb(err);
        });
      }, (err) => callback(err, memo));
    }
    var reduce$1 = awaitify(reduce, 4);
    function seq(...functions) {
      var _functions = functions.map(wrapAsync);
      return function(...args) {
        var that = this;
        var cb = args[args.length - 1];
        if (typeof cb == "function") {
          args.pop();
        } else {
          cb = promiseCallback();
        }
        reduce$1(_functions, args, (newargs, fn, iterCb) => {
          fn.apply(that, newargs.concat((err, ...nextargs) => {
            iterCb(err, nextargs);
          }));
        }, (err, results2) => cb(err, ...results2));
        return cb[PROMISE_SYMBOL];
      };
    }
    function compose(...args) {
      return seq(...args.reverse());
    }
    function mapLimit(coll, limit, iteratee, callback) {
      return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var mapLimit$1 = awaitify(mapLimit, 4);
    function concatLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, ...args) => {
          if (err)
            return iterCb(err);
          return iterCb(err, args);
        });
      }, (err, mapResults) => {
        var result = [];
        for (var i = 0;i < mapResults.length; i++) {
          if (mapResults[i]) {
            result = result.concat(...mapResults[i]);
          }
        }
        return callback(err, result);
      });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);
    function concat(coll, iteratee, callback) {
      return concatLimit$1(coll, Infinity, iteratee, callback);
    }
    var concat$1 = awaitify(concat, 3);
    function concatSeries(coll, iteratee, callback) {
      return concatLimit$1(coll, 1, iteratee, callback);
    }
    var concatSeries$1 = awaitify(concatSeries, 3);
    function constant$1(...args) {
      return function(...ignoredArgs) {
        var callback = ignoredArgs.pop();
        return callback(null, ...args);
      };
    }
    function _createTester(check, getResult) {
      return (eachfn, arr, _iteratee, cb) => {
        var testPassed = false;
        var testResult;
        const iteratee = wrapAsync(_iteratee);
        eachfn(arr, (value, _2, callback) => {
          iteratee(value, (err, result) => {
            if (err || err === false)
              return callback(err);
            if (check(result) && !testResult) {
              testPassed = true;
              testResult = getResult(true, value);
              return callback(null, breakLoop);
            }
            callback();
          });
        }, (err) => {
          if (err)
            return cb(err);
          cb(null, testPassed ? testResult : getResult(false));
        });
      };
    }
    function detect(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
    }
    var detect$1 = awaitify(detect, 3);
    function detectLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var detectLimit$1 = awaitify(detectLimit, 4);
    function detectSeries(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
    }
    var detectSeries$1 = awaitify(detectSeries, 3);
    function consoleFunc(name) {
      return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
        if (typeof console === "object") {
          if (err) {
            if (console.error) {
              console.error(err);
            }
          } else if (console[name]) {
            resultArgs.forEach((x) => console[name](x));
          }
        }
      });
    }
    var dir = consoleFunc("dir");
    function doWhilst(iteratee, test, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results2;
      function next(err, ...args) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        results2 = args;
        _test(...args, check);
      }
      function check(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results2);
        _fn(next);
      }
      return check(null, true);
    }
    var doWhilst$1 = awaitify(doWhilst, 3);
    function doUntil(iteratee, test, callback) {
      const _test = wrapAsync(test);
      return doWhilst$1(iteratee, (...args) => {
        const cb = args.pop();
        _test(...args, (err, truth) => cb(err, !truth));
      }, callback);
    }
    function _withoutIndex(iteratee) {
      return (value, index2, callback) => iteratee(value, callback);
    }
    function eachLimit$2(coll, iteratee, callback) {
      return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var each = awaitify(eachLimit$2, 3);
    function eachLimit(coll, limit, iteratee, callback) {
      return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$1 = awaitify(eachLimit, 4);
    function eachSeries(coll, iteratee, callback) {
      return eachLimit$1(coll, 1, iteratee, callback);
    }
    var eachSeries$1 = awaitify(eachSeries, 3);
    function ensureAsync(fn) {
      if (isAsync(fn))
        return fn;
      return function(...args) {
        var callback = args.pop();
        var sync = true;
        args.push((...innerArgs) => {
          if (sync) {
            setImmediate$1(() => callback(...innerArgs));
          } else {
            callback(...innerArgs);
          }
        });
        fn.apply(this, args);
        sync = false;
      };
    }
    function every(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
    }
    var every$1 = awaitify(every, 3);
    function everyLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var everyLimit$1 = awaitify(everyLimit, 4);
    function everySeries(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var everySeries$1 = awaitify(everySeries, 3);
    function filterArray(eachfn, arr, iteratee, callback) {
      var truthValues = new Array(arr.length);
      eachfn(arr, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          truthValues[index2] = !!v;
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        var results2 = [];
        for (var i = 0;i < arr.length; i++) {
          if (truthValues[i])
            results2.push(arr[i]);
        }
        callback(null, results2);
      });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
      var results2 = [];
      eachfn(coll, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          if (err)
            return iterCb(err);
          if (v) {
            results2.push({ index: index2, value: x });
          }
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        callback(null, results2.sort((a, b) => a.index - b.index).map((v) => v.value));
      });
    }
    function _filter(eachfn, coll, iteratee, callback) {
      var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
      return filter2(eachfn, coll, wrapAsync(iteratee), callback);
    }
    function filter(coll, iteratee, callback) {
      return _filter(eachOf$1, coll, iteratee, callback);
    }
    var filter$1 = awaitify(filter, 3);
    function filterLimit(coll, limit, iteratee, callback) {
      return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var filterLimit$1 = awaitify(filterLimit, 4);
    function filterSeries(coll, iteratee, callback) {
      return _filter(eachOfSeries$1, coll, iteratee, callback);
    }
    var filterSeries$1 = awaitify(filterSeries, 3);
    function forever(fn, errback) {
      var done = onlyOnce(errback);
      var task = wrapAsync(ensureAsync(fn));
      function next(err) {
        if (err)
          return done(err);
        if (err === false)
          return;
        task(next);
      }
      return next();
    }
    var forever$1 = awaitify(forever, 2);
    function groupByLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, key2) => {
          if (err)
            return iterCb(err);
          return iterCb(err, { key: key2, val });
        });
      }, (err, mapResults) => {
        var result = {};
        var { hasOwnProperty } = Object.prototype;
        for (var i = 0;i < mapResults.length; i++) {
          if (mapResults[i]) {
            var { key: key2 } = mapResults[i];
            var { val } = mapResults[i];
            if (hasOwnProperty.call(result, key2)) {
              result[key2].push(val);
            } else {
              result[key2] = [val];
            }
          }
        }
        return callback(err, result);
      });
    }
    var groupByLimit$1 = awaitify(groupByLimit, 4);
    function groupBy(coll, iteratee, callback) {
      return groupByLimit$1(coll, Infinity, iteratee, callback);
    }
    function groupBySeries(coll, iteratee, callback) {
      return groupByLimit$1(coll, 1, iteratee, callback);
    }
    var log2 = consoleFunc("log");
    function mapValuesLimit(obj2, limit, iteratee, callback) {
      callback = once(callback);
      var newObj = {};
      var _iteratee = wrapAsync(iteratee);
      return eachOfLimit$2(limit)(obj2, (val, key2, next) => {
        _iteratee(val, key2, (err, result) => {
          if (err)
            return next(err);
          newObj[key2] = result;
          next(err);
        });
      }, (err) => callback(err, newObj));
    }
    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
    function mapValues(obj2, iteratee, callback) {
      return mapValuesLimit$1(obj2, Infinity, iteratee, callback);
    }
    function mapValuesSeries(obj2, iteratee, callback) {
      return mapValuesLimit$1(obj2, 1, iteratee, callback);
    }
    function memoize(fn, hasher = (v) => v) {
      var memo = Object.create(null);
      var queues = Object.create(null);
      var _fn = wrapAsync(fn);
      var memoized = initialParams((args, callback) => {
        var key2 = hasher(...args);
        if (key2 in memo) {
          setImmediate$1(() => callback(null, ...memo[key2]));
        } else if (key2 in queues) {
          queues[key2].push(callback);
        } else {
          queues[key2] = [callback];
          _fn(...args, (err, ...resultArgs) => {
            if (!err) {
              memo[key2] = resultArgs;
            }
            var q = queues[key2];
            delete queues[key2];
            for (var i = 0, l2 = q.length;i < l2; i++) {
              q[i](err, ...resultArgs);
            }
          });
        }
      });
      memoized.memo = memo;
      memoized.unmemoized = fn;
      return memoized;
    }
    var _defer;
    if (hasNextTick) {
      _defer = process.nextTick;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else {
      _defer = fallback;
    }
    var nextTick = wrap(_defer);
    var _parallel = awaitify((eachfn, tasks, callback) => {
      var results2 = isArrayLike(tasks) ? [] : {};
      eachfn(tasks, (task, key2, taskCb) => {
        wrapAsync(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results2[key2] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results2));
    }, 3);
    function parallel(tasks, callback) {
      return _parallel(eachOf$1, tasks, callback);
    }
    function parallelLimit(tasks, limit, callback) {
      return _parallel(eachOfLimit$2(limit), tasks, callback);
    }
    function queue(worker, concurrency) {
      var _worker = wrapAsync(worker);
      return queue$1((items, cb) => {
        _worker(items[0], cb);
      }, concurrency, 1);
    }

    class Heap {
      constructor() {
        this.heap = [];
        this.pushCount = Number.MIN_SAFE_INTEGER;
      }
      get length() {
        return this.heap.length;
      }
      empty() {
        this.heap = [];
        return this;
      }
      percUp(index2) {
        let p;
        while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
          let t = this.heap[index2];
          this.heap[index2] = this.heap[p];
          this.heap[p] = t;
          index2 = p;
        }
      }
      percDown(index2) {
        let l2;
        while ((l2 = leftChi(index2)) < this.heap.length) {
          if (l2 + 1 < this.heap.length && smaller(this.heap[l2 + 1], this.heap[l2])) {
            l2 = l2 + 1;
          }
          if (smaller(this.heap[index2], this.heap[l2])) {
            break;
          }
          let t = this.heap[index2];
          this.heap[index2] = this.heap[l2];
          this.heap[l2] = t;
          index2 = l2;
        }
      }
      push(node) {
        node.pushCount = ++this.pushCount;
        this.heap.push(node);
        this.percUp(this.heap.length - 1);
      }
      unshift(node) {
        return this.heap.push(node);
      }
      shift() {
        let [top] = this.heap;
        this.heap[0] = this.heap[this.heap.length - 1];
        this.heap.pop();
        this.percDown(0);
        return top;
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        for (let i = 0;i < this.heap.length; i++) {
          yield this.heap[i].data;
        }
      }
      remove(testFn) {
        let j = 0;
        for (let i = 0;i < this.heap.length; i++) {
          if (!testFn(this.heap[i])) {
            this.heap[j] = this.heap[i];
            j++;
          }
        }
        this.heap.splice(j);
        for (let i = parent(this.heap.length - 1);i >= 0; i--) {
          this.percDown(i);
        }
        return this;
      }
    }
    function leftChi(i) {
      return (i << 1) + 1;
    }
    function parent(i) {
      return (i + 1 >> 1) - 1;
    }
    function smaller(x, y) {
      if (x.priority !== y.priority) {
        return x.priority < y.priority;
      } else {
        return x.pushCount < y.pushCount;
      }
    }
    function priorityQueue(worker, concurrency) {
      var q = queue(worker, concurrency);
      var {
        push,
        pushAsync
      } = q;
      q._tasks = new Heap;
      q._createTaskItem = ({ data, priority }, callback) => {
        return {
          data,
          priority,
          callback
        };
      };
      function createDataItems(tasks, priority) {
        if (!Array.isArray(tasks)) {
          return { data: tasks, priority };
        }
        return tasks.map((data) => {
          return { data, priority };
        });
      }
      q.push = function(data, priority = 0, callback) {
        return push(createDataItems(data, priority), callback);
      };
      q.pushAsync = function(data, priority = 0, callback) {
        return pushAsync(createDataItems(data, priority), callback);
      };
      delete q.unshift;
      delete q.unshiftAsync;
      return q;
    }
    function race(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new TypeError("First argument to race must be an array of functions"));
      if (!tasks.length)
        return callback();
      for (var i = 0, l2 = tasks.length;i < l2; i++) {
        wrapAsync(tasks[i])(callback);
      }
    }
    var race$1 = awaitify(race, 2);
    function reduceRight(array, memo, iteratee, callback) {
      var reversed = [...array].reverse();
      return reduce$1(reversed, memo, iteratee, callback);
    }
    function reflect(fn) {
      var _fn = wrapAsync(fn);
      return initialParams(function reflectOn(args, reflectCallback) {
        args.push((error, ...cbArgs) => {
          let retVal = {};
          if (error) {
            retVal.error = error;
          }
          if (cbArgs.length > 0) {
            var value = cbArgs;
            if (cbArgs.length <= 1) {
              [value] = cbArgs;
            }
            retVal.value = value;
          }
          reflectCallback(null, retVal);
        });
        return _fn.apply(this, args);
      });
    }
    function reflectAll(tasks) {
      var results2;
      if (Array.isArray(tasks)) {
        results2 = tasks.map(reflect);
      } else {
        results2 = {};
        Object.keys(tasks).forEach((key2) => {
          results2[key2] = reflect.call(this, tasks[key2]);
        });
      }
      return results2;
    }
    function reject$2(eachfn, arr, _iteratee, callback) {
      const iteratee = wrapAsync(_iteratee);
      return _filter(eachfn, arr, (value, cb) => {
        iteratee(value, (err, v) => {
          cb(err, !v);
        });
      }, callback);
    }
    function reject(coll, iteratee, callback) {
      return reject$2(eachOf$1, coll, iteratee, callback);
    }
    var reject$1 = awaitify(reject, 3);
    function rejectLimit(coll, limit, iteratee, callback) {
      return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);
    function rejectSeries(coll, iteratee, callback) {
      return reject$2(eachOfSeries$1, coll, iteratee, callback);
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);
    function constant(value) {
      return function() {
        return value;
      };
    }
    const DEFAULT_TIMES = 5;
    const DEFAULT_INTERVAL = 0;
    function retry(opts, task, callback) {
      var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant(DEFAULT_INTERVAL)
      };
      if (arguments.length < 3 && typeof opts === "function") {
        callback = task || promiseCallback();
        task = opts;
      } else {
        parseTimes(options, opts);
        callback = callback || promiseCallback();
      }
      if (typeof task !== "function") {
        throw new Error("Invalid arguments for async.retry");
      }
      var _task = wrapAsync(task);
      var attempt = 1;
      function retryAttempt() {
        _task((err, ...args) => {
          if (err === false)
            return;
          if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
            setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
          } else {
            callback(err, ...args);
          }
        });
      }
      retryAttempt();
      return callback[PROMISE_SYMBOL];
    }
    function parseTimes(acc, t) {
      if (typeof t === "object") {
        acc.times = +t.times || DEFAULT_TIMES;
        acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);
        acc.errorFilter = t.errorFilter;
      } else if (typeof t === "number" || typeof t === "string") {
        acc.times = +t || DEFAULT_TIMES;
      } else {
        throw new Error("Invalid arguments for async.retry");
      }
    }
    function retryable(opts, task) {
      if (!task) {
        task = opts;
        opts = null;
      }
      let arity = opts && opts.arity || task.length;
      if (isAsync(task)) {
        arity += 1;
      }
      var _task = wrapAsync(task);
      return initialParams((args, callback) => {
        if (args.length < arity - 1 || callback == null) {
          args.push(callback);
          callback = promiseCallback();
        }
        function taskFn(cb) {
          _task(...args, cb);
        }
        if (opts)
          retry(opts, taskFn, callback);
        else
          retry(taskFn, callback);
        return callback[PROMISE_SYMBOL];
      });
    }
    function series(tasks, callback) {
      return _parallel(eachOfSeries$1, tasks, callback);
    }
    function some(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
    }
    var some$1 = awaitify(some, 3);
    function someLimit(coll, limit, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var someLimit$1 = awaitify(someLimit, 4);
    function someSeries(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var someSeries$1 = awaitify(someSeries, 3);
    function sortBy(coll, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return map$1(coll, (x, iterCb) => {
        _iteratee(x, (err, criteria) => {
          if (err)
            return iterCb(err);
          iterCb(err, { value: x, criteria });
        });
      }, (err, results2) => {
        if (err)
          return callback(err);
        callback(null, results2.sort(comparator).map((v) => v.value));
      });
      function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
      }
    }
    var sortBy$1 = awaitify(sortBy, 3);
    function timeout(asyncFn, milliseconds, info) {
      var fn = wrapAsync(asyncFn);
      return initialParams((args, callback) => {
        var timedOut = false;
        var timer;
        function timeoutCallback() {
          var name = asyncFn.name || "anonymous";
          var error = new Error('Callback function "' + name + '" timed out.');
          error.code = "ETIMEDOUT";
          if (info) {
            error.info = info;
          }
          timedOut = true;
          callback(error);
        }
        args.push((...cbArgs) => {
          if (!timedOut) {
            callback(...cbArgs);
            clearTimeout(timer);
          }
        });
        timer = setTimeout(timeoutCallback, milliseconds);
        fn(...args);
      });
    }
    function range(size) {
      var result = Array(size);
      while (size--) {
        result[size] = size;
      }
      return result;
    }
    function timesLimit(count, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(range(count), limit, _iteratee, callback);
    }
    function times(n, iteratee, callback) {
      return timesLimit(n, Infinity, iteratee, callback);
    }
    function timesSeries(n, iteratee, callback) {
      return timesLimit(n, 1, iteratee, callback);
    }
    function transform(coll, accumulator, iteratee, callback) {
      if (arguments.length <= 3 && typeof accumulator === "function") {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = Array.isArray(coll) ? [] : {};
      }
      callback = once(callback || promiseCallback());
      var _iteratee = wrapAsync(iteratee);
      eachOf$1(coll, (v, k, cb) => {
        _iteratee(accumulator, v, k, cb);
      }, (err) => callback(err, accumulator));
      return callback[PROMISE_SYMBOL];
    }
    function tryEach(tasks, callback) {
      var error = null;
      var result;
      return eachSeries$1(tasks, (task, taskCb) => {
        wrapAsync(task)((err, ...args) => {
          if (err === false)
            return taskCb(err);
          if (args.length < 2) {
            [result] = args;
          } else {
            result = args;
          }
          error = err;
          taskCb(err ? null : {});
        });
      }, () => callback(error, result));
    }
    var tryEach$1 = awaitify(tryEach);
    function unmemoize(fn) {
      return (...args) => {
        return (fn.unmemoized || fn)(...args);
      };
    }
    function whilst(test, iteratee, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results2 = [];
      function next(err, ...rest) {
        if (err)
          return callback(err);
        results2 = rest;
        if (err === false)
          return;
        _test(check);
      }
      function check(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results2);
        _fn(next);
      }
      return _test(check);
    }
    var whilst$1 = awaitify(whilst, 3);
    function until(test, iteratee, callback) {
      const _test = wrapAsync(test);
      return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
    }
    function waterfall(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        task(...args, onlyOnce(next));
      }
      function next(err, ...args) {
        if (err === false)
          return;
        if (err || taskIndex === tasks.length) {
          return callback(err, ...args);
        }
        nextTask(args);
      }
      nextTask([]);
    }
    var waterfall$1 = awaitify(waterfall);
    var index = {
      apply,
      applyEach,
      applyEachSeries,
      asyncify,
      auto,
      autoInject,
      cargo: cargo$1,
      cargoQueue: cargo,
      compose,
      concat: concat$1,
      concatLimit: concatLimit$1,
      concatSeries: concatSeries$1,
      constant: constant$1,
      detect: detect$1,
      detectLimit: detectLimit$1,
      detectSeries: detectSeries$1,
      dir,
      doUntil,
      doWhilst: doWhilst$1,
      each,
      eachLimit: eachLimit$1,
      eachOf: eachOf$1,
      eachOfLimit: eachOfLimit$1,
      eachOfSeries: eachOfSeries$1,
      eachSeries: eachSeries$1,
      ensureAsync,
      every: every$1,
      everyLimit: everyLimit$1,
      everySeries: everySeries$1,
      filter: filter$1,
      filterLimit: filterLimit$1,
      filterSeries: filterSeries$1,
      forever: forever$1,
      groupBy,
      groupByLimit: groupByLimit$1,
      groupBySeries,
      log: log2,
      map: map$1,
      mapLimit: mapLimit$1,
      mapSeries: mapSeries$1,
      mapValues,
      mapValuesLimit: mapValuesLimit$1,
      mapValuesSeries,
      memoize,
      nextTick,
      parallel,
      parallelLimit,
      priorityQueue,
      queue,
      race: race$1,
      reduce: reduce$1,
      reduceRight,
      reflect,
      reflectAll,
      reject: reject$1,
      rejectLimit: rejectLimit$1,
      rejectSeries: rejectSeries$1,
      retry,
      retryable,
      seq,
      series,
      setImmediate: setImmediate$1,
      some: some$1,
      someLimit: someLimit$1,
      someSeries: someSeries$1,
      sortBy: sortBy$1,
      timeout,
      times,
      timesLimit,
      timesSeries,
      transform,
      tryEach: tryEach$1,
      unmemoize,
      until,
      waterfall: waterfall$1,
      whilst: whilst$1,
      all: every$1,
      allLimit: everyLimit$1,
      allSeries: everySeries$1,
      any: some$1,
      anyLimit: someLimit$1,
      anySeries: someSeries$1,
      find: detect$1,
      findLimit: detectLimit$1,
      findSeries: detectSeries$1,
      flatMap: concat$1,
      flatMapLimit: concatLimit$1,
      flatMapSeries: concatSeries$1,
      forEach: each,
      forEachSeries: eachSeries$1,
      forEachLimit: eachLimit$1,
      forEachOf: eachOf$1,
      forEachOfSeries: eachOfSeries$1,
      forEachOfLimit: eachOfLimit$1,
      inject: reduce$1,
      foldl: reduce$1,
      foldr: reduceRight,
      select: filter$1,
      selectLimit: filterLimit$1,
      selectSeries: filterSeries$1,
      wrapSync: asyncify,
      during: whilst$1,
      doDuring: doWhilst$1
    };
    exports2.all = every$1;
    exports2.allLimit = everyLimit$1;
    exports2.allSeries = everySeries$1;
    exports2.any = some$1;
    exports2.anyLimit = someLimit$1;
    exports2.anySeries = someSeries$1;
    exports2.apply = apply;
    exports2.applyEach = applyEach;
    exports2.applyEachSeries = applyEachSeries;
    exports2.asyncify = asyncify;
    exports2.auto = auto;
    exports2.autoInject = autoInject;
    exports2.cargo = cargo$1;
    exports2.cargoQueue = cargo;
    exports2.compose = compose;
    exports2.concat = concat$1;
    exports2.concatLimit = concatLimit$1;
    exports2.concatSeries = concatSeries$1;
    exports2.constant = constant$1;
    exports2.default = index;
    exports2.detect = detect$1;
    exports2.detectLimit = detectLimit$1;
    exports2.detectSeries = detectSeries$1;
    exports2.dir = dir;
    exports2.doDuring = doWhilst$1;
    exports2.doUntil = doUntil;
    exports2.doWhilst = doWhilst$1;
    exports2.during = whilst$1;
    exports2.each = each;
    exports2.eachLimit = eachLimit$1;
    exports2.eachOf = eachOf$1;
    exports2.eachOfLimit = eachOfLimit$1;
    exports2.eachOfSeries = eachOfSeries$1;
    exports2.eachSeries = eachSeries$1;
    exports2.ensureAsync = ensureAsync;
    exports2.every = every$1;
    exports2.everyLimit = everyLimit$1;
    exports2.everySeries = everySeries$1;
    exports2.filter = filter$1;
    exports2.filterLimit = filterLimit$1;
    exports2.filterSeries = filterSeries$1;
    exports2.find = detect$1;
    exports2.findLimit = detectLimit$1;
    exports2.findSeries = detectSeries$1;
    exports2.flatMap = concat$1;
    exports2.flatMapLimit = concatLimit$1;
    exports2.flatMapSeries = concatSeries$1;
    exports2.foldl = reduce$1;
    exports2.foldr = reduceRight;
    exports2.forEach = each;
    exports2.forEachLimit = eachLimit$1;
    exports2.forEachOf = eachOf$1;
    exports2.forEachOfLimit = eachOfLimit$1;
    exports2.forEachOfSeries = eachOfSeries$1;
    exports2.forEachSeries = eachSeries$1;
    exports2.forever = forever$1;
    exports2.groupBy = groupBy;
    exports2.groupByLimit = groupByLimit$1;
    exports2.groupBySeries = groupBySeries;
    exports2.inject = reduce$1;
    exports2.log = log2;
    exports2.map = map$1;
    exports2.mapLimit = mapLimit$1;
    exports2.mapSeries = mapSeries$1;
    exports2.mapValues = mapValues;
    exports2.mapValuesLimit = mapValuesLimit$1;
    exports2.mapValuesSeries = mapValuesSeries;
    exports2.memoize = memoize;
    exports2.nextTick = nextTick;
    exports2.parallel = parallel;
    exports2.parallelLimit = parallelLimit;
    exports2.priorityQueue = priorityQueue;
    exports2.queue = queue;
    exports2.race = race$1;
    exports2.reduce = reduce$1;
    exports2.reduceRight = reduceRight;
    exports2.reflect = reflect;
    exports2.reflectAll = reflectAll;
    exports2.reject = reject$1;
    exports2.rejectLimit = rejectLimit$1;
    exports2.rejectSeries = rejectSeries$1;
    exports2.retry = retry;
    exports2.retryable = retryable;
    exports2.select = filter$1;
    exports2.selectLimit = filterLimit$1;
    exports2.selectSeries = filterSeries$1;
    exports2.seq = seq;
    exports2.series = series;
    exports2.setImmediate = setImmediate$1;
    exports2.some = some$1;
    exports2.someLimit = someLimit$1;
    exports2.someSeries = someSeries$1;
    exports2.sortBy = sortBy$1;
    exports2.timeout = timeout;
    exports2.times = times;
    exports2.timesLimit = timesLimit;
    exports2.timesSeries = timesSeries;
    exports2.transform = transform;
    exports2.tryEach = tryEach$1;
    exports2.unmemoize = unmemoize;
    exports2.until = until;
    exports2.waterfall = waterfall$1;
    exports2.whilst = whilst$1;
    exports2.wrapSync = asyncify;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList4 = __commonJS((exports, module) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util = __require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
      var obj2 = util.inspect({ length: this.length });
      return this.constructor.name + " " + obj2;
    };
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy4 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy
  };
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable4 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node3()
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy4();
  util.inherits(Writable, Stream);
  function nop() {}
  function WritableState(options, stream) {
    Duplex = Duplex || require__stream_duplex4();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_2) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex4();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l2 = state.bufferedRequestCount;
      var buffer = new Array(l2);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex4 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj2) {
    var keys2 = [];
    for (var key2 in obj2) {
      keys2.push(key2);
    }
    return keys2;
  };
  module.exports = Duplex;
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var Readable = require__stream_readable4();
  var Writable = require__stream_writable4();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable4 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var debugUtil = __require("util");
  var debug = undefined;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {};
  }
  var BufferList = require_BufferList4();
  var destroyImpl = require_destroy4();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require__stream_duplex4();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex4();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l2 = xs.length;i < l2; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform4 = __commonJS((exports, module) => {
  module.exports = Transform;
  var Duplex = require__stream_duplex4();
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough4 = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform4();
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/lazystream/node_modules/readable-stream/readable.js
var require_readable4 = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable4();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable4();
    exports.Duplex = require__stream_duplex4();
    exports.Transform = require__stream_transform4();
    exports.PassThrough = require__stream_passthrough4();
  }
});

// node_modules/lazystream/node_modules/readable-stream/passthrough.js
var require_passthrough = __commonJS((exports, module) => {
  module.exports = require_readable4().PassThrough;
});

// node_modules/lazystream/lib/lazystream.js
var require_lazystream = __commonJS((exports, module) => {
  var util = __require("util");
  var PassThrough = require_passthrough();
  module.exports = {
    Readable,
    Writable
  };
  util.inherits(Readable, PassThrough);
  util.inherits(Writable, PassThrough);
  function beforeFirstCall(instance, method, callback) {
    instance[method] = function() {
      delete instance[method];
      callback.apply(this, arguments);
      return this[method].apply(this, arguments);
    };
  }
  function Readable(fn, options) {
    if (!(this instanceof Readable))
      return new Readable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_read", function() {
      var source = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      source.on("error", emit);
      source.pipe(this);
    });
    this.emit("readable");
  }
  function Writable(fn, options) {
    if (!(this instanceof Writable))
      return new Writable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_write", function() {
      var destination = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      destination.on("error", emit);
      this.pipe(destination);
    });
    this.emit("writable");
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS((exports, module) => {
  /*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  module.exports = function(path, stripTrailing) {
    if (typeof path !== "string") {
      throw new TypeError("expected path to be a string");
    }
    if (path === "\\" || path === "/")
      return "/";
    var len = path.length;
    if (len <= 1)
      return path;
    var prefix = "";
    if (len > 4 && path[3] === "\\") {
      var ch = path[2];
      if ((ch === "?" || ch === ".") && path.slice(0, 2) === "\\\\") {
        path = path.slice(2);
        prefix = "//";
      }
    }
    var segs = path.split(/[/\\]+/);
    if (stripTrailing !== false && segs[segs.length - 1] === "") {
      segs.pop();
    }
    return prefix + segs.join("/");
  };
});

// node_modules/lodash.defaults/index.js
var require_lodash = __commonJS((exports, module) => {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeMax = Math.max;
  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key2 in value) {
      if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && (key2 == "length" || isIndex(key2, length)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function assignInDefaults(objValue, srcValue, key2, object) {
    if (objValue === undefined || eq(objValue, objectProto[key2]) && !hasOwnProperty.call(object, key2)) {
      return srcValue;
    }
    return objValue;
  }
  function assignValue(object, key2, value) {
    var objValue = object[key2];
    if (!(hasOwnProperty.call(object, key2) && eq(objValue, value)) || value === undefined && !(key2 in object)) {
      object[key2] = value;
    }
  }
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key2 in object) {
      if (!(key2 == "constructor" && (isProto || !hasOwnProperty.call(object, key2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key2 = props[index];
      var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : undefined;
      assignValue(object, key2, newValue === undefined ? source[key2] : newValue);
    }
    return object;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
      return eq(object[index], value);
    }
    return false;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key2 in Object(object)) {
        result.push(key2);
      }
    }
    return result;
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
  });
  var defaults = baseRest(function(args) {
    args.push(undefined, assignInDefaults);
    return apply(assignInWith, undefined, args);
  });
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  module.exports = defaults;
});

// node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList5 = __commonJS((exports, module) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util = __require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
      var obj2 = util.inspect({ length: this.length });
      return this.constructor.name + " " + obj2;
    };
  }
});

// node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy5 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy
  };
});

// node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable5 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node3()
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy5();
  util.inherits(Writable, Stream);
  function nop() {}
  function WritableState(options, stream) {
    Duplex = Duplex || require__stream_duplex5();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_2) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex5();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l2 = state.bufferedRequestCount;
      var buffer = new Array(l2);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex5 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj2) {
    var keys2 = [];
    for (var key2 in obj2) {
      keys2.push(key2);
    }
    return keys2;
  };
  module.exports = Duplex;
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var Readable = require__stream_readable5();
  var Writable = require__stream_writable5();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable5 = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  var debugUtil = __require("util");
  var debug = undefined;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {};
  }
  var BufferList = require_BufferList5();
  var destroyImpl = require_destroy5();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require__stream_duplex5();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex5();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l2 = xs.length;i < l2; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform5 = __commonJS((exports, module) => {
  module.exports = Transform;
  var Duplex = require__stream_duplex5();
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough5 = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform5();
  var util = Object.create(require_util4());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/archiver-utils/node_modules/readable-stream/readable.js
var require_readable5 = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable5();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable5();
    exports.Duplex = require__stream_duplex5();
    exports.Transform = require__stream_transform5();
    exports.PassThrough = require__stream_passthrough5();
  }
});

// node_modules/lodash.flatten/index.js
var require_lodash2 = __commonJS((exports, module) => {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined;
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function flatten(array) {
    var length = array ? array.length : 0;
    return length ? baseFlatten(array, 1) : [];
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  module.exports = flatten;
});

// node_modules/lodash.difference/index.js
var require_lodash3 = __commonJS((exports, module) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache, key2) {
    return cache.has(key2);
  }
  function getValue(object, key2) {
    return object == null ? undefined : object[key2];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {}
    }
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined;
  var nativeMax = Math.max;
  var Map2 = getNative(root, "Map");
  var nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key2) {
    return this.has(key2) && delete this.__data__[key2];
  }
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key2];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key2) ? data[key2] : undefined;
  }
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== undefined : hasOwnProperty.call(data, key2);
  }
  function hashSet(key2, value) {
    var data = this.__data__;
    data[key2] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    return index < 0 ? undefined : data[index][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) {
      data.push([key2, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  }
  function mapCacheDelete(key2) {
    return getMapData(this, key2)["delete"](key2);
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    getMapData(this, key2).set(key2, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array, key2) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key2)) {
        return length;
      }
    }
    return -1;
  }
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) {
      return result;
    }
    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  function getMapData(map, key2) {
    var data = map.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key2) {
    var value = getValue(object, key2);
    return baseIsNative(value) ? value : undefined;
  }
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  }
  var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
  });
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  module.exports = difference;
});

// node_modules/lodash.union/index.js
var require_lodash4 = __commonJS((exports, module) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function cacheHas(cache, key2) {
    return cache.has(key2);
  }
  function getValue(object, key2) {
    return object == null ? undefined : object[key2];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {}
    }
    return result;
  }
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined;
  var nativeMax = Math.max;
  var Map2 = getNative(root, "Map");
  var Set2 = getNative(root, "Set");
  var nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key2) {
    return this.has(key2) && delete this.__data__[key2];
  }
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key2];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key2) ? data[key2] : undefined;
  }
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== undefined : hasOwnProperty.call(data, key2);
  }
  function hashSet(key2, value) {
    var data = this.__data__;
    data[key2] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    return index < 0 ? undefined : data[index][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) {
      data.push([key2, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  }
  function mapCacheDelete(key2) {
    return getMapData(this, key2)["delete"](key2);
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    getMapData(this, key2).set(key2, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array, key2) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key2)) {
        return length;
      }
    }
    return -1;
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  }
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache;
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  function getMapData(map, key2) {
    var data = map.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key2) {
    var value = getValue(object, key2);
    return baseIsNative(value) ? value : undefined;
  }
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  }
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function noop() {}
  module.exports = union;
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS((exports, module) => {
  var objectTag = "[object Object]";
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {}
    }
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module.exports = isPlainObject;
});

// node_modules/archiver-utils/file.js
var require_file2 = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var flatten = require_lodash2();
  var difference = require_lodash3();
  var union = require_lodash4();
  var isPlainObject = require_lodash5();
  var glob = require_glob();
  var file = module.exports = {};
  var pathSeparatorRe = /[\/\\]/g;
  var processPatterns = function(patterns, fn) {
    var result = [];
    flatten(patterns).forEach(function(pattern) {
      var exclusion = pattern.indexOf("!") === 0;
      if (exclusion) {
        pattern = pattern.slice(1);
      }
      var matches = fn(pattern);
      if (exclusion) {
        result = difference(result, matches);
      } else {
        result = union(result, matches);
      }
    });
    return result;
  };
  file.exists = function() {
    var filepath = path.join.apply(path, arguments);
    return fs.existsSync(filepath);
  };
  file.expand = function(...args) {
    var options = isPlainObject(args[0]) ? args.shift() : {};
    var patterns = Array.isArray(args[0]) ? args[0] : args;
    if (patterns.length === 0) {
      return [];
    }
    var matches = processPatterns(patterns, function(pattern) {
      return glob.sync(pattern, options);
    });
    if (options.filter) {
      matches = matches.filter(function(filepath) {
        filepath = path.join(options.cwd || "", filepath);
        try {
          if (typeof options.filter === "function") {
            return options.filter(filepath);
          } else {
            return fs.statSync(filepath)[options.filter]();
          }
        } catch (e) {
          return false;
        }
      });
    }
    return matches;
  };
  file.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
      rename: function(destBase2, destPath) {
        return path.join(destBase2 || "", destPath);
      }
    }, options);
    var files = [];
    var fileByDest = {};
    file.expand(options, patterns).forEach(function(src) {
      var destPath = src;
      if (options.flatten) {
        destPath = path.basename(destPath);
      }
      if (options.ext) {
        destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
      }
      var dest = options.rename(destBase, destPath, options);
      if (options.cwd) {
        src = path.join(options.cwd, src);
      }
      dest = dest.replace(pathSeparatorRe, "/");
      src = src.replace(pathSeparatorRe, "/");
      if (fileByDest[dest]) {
        fileByDest[dest].src.push(src);
      } else {
        files.push({
          src: [src],
          dest
        });
        fileByDest[dest] = files[files.length - 1];
      }
    });
    return files;
  };
  file.normalizeFilesArray = function(data) {
    var files = [];
    data.forEach(function(obj2) {
      var prop;
      if ("src" in obj2 || "dest" in obj2) {
        files.push(obj2);
      }
    });
    if (files.length === 0) {
      return [];
    }
    files = _(files).chain().forEach(function(obj2) {
      if (!("src" in obj2) || !obj2.src) {
        return;
      }
      if (Array.isArray(obj2.src)) {
        obj2.src = flatten(obj2.src);
      } else {
        obj2.src = [obj2.src];
      }
    }).map(function(obj2) {
      var expandOptions = Object.assign({}, obj2);
      delete expandOptions.src;
      delete expandOptions.dest;
      if (obj2.expand) {
        return file.expandMapping(obj2.src, obj2.dest, expandOptions).map(function(mapObj) {
          var result2 = Object.assign({}, obj2);
          result2.orig = Object.assign({}, obj2);
          result2.src = mapObj.src;
          result2.dest = mapObj.dest;
          ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
            delete result2[prop];
          });
          return result2;
        });
      }
      var result = Object.assign({}, obj2);
      result.orig = Object.assign({}, obj2);
      if ("src" in result) {
        Object.defineProperty(result, "src", {
          enumerable: true,
          get: function fn() {
            var src;
            if (!("result" in fn)) {
              src = obj2.src;
              src = Array.isArray(src) ? flatten(src) : [src];
              fn.result = file.expand(expandOptions, src);
            }
            return fn.result;
          }
        });
      }
      if ("dest" in result) {
        result.dest = obj2.dest;
      }
      return result;
    }).flatten().value();
    return files;
  };
});

// node_modules/archiver-utils/index.js
var require_archiver_utils = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var nutil = __require("util");
  var lazystream = require_lazystream();
  var normalizePath = require_normalize_path();
  var defaults = require_lodash();
  var Stream = __require("stream").Stream;
  var PassThrough = require_readable5().PassThrough;
  var utils = module.exports = {};
  utils.file = require_file2();
  utils.collectStream = function(source, callback) {
    var collection = [];
    var size = 0;
    source.on("error", callback);
    source.on("data", function(chunk) {
      collection.push(chunk);
      size += chunk.length;
    });
    source.on("end", function() {
      var buf = new Buffer(size);
      var offset = 0;
      collection.forEach(function(data) {
        data.copy(buf, offset);
        offset += data.length;
      });
      callback(null, buf);
    });
  };
  utils.dateify = function(dateish) {
    dateish = dateish || new Date;
    if (dateish instanceof Date) {
      dateish = dateish;
    } else if (typeof dateish === "string") {
      dateish = new Date(dateish);
    } else {
      dateish = new Date;
    }
    return dateish;
  };
  utils.defaults = function(object, source, guard) {
    var args = arguments;
    args[0] = args[0] || {};
    return defaults(...args);
  };
  utils.isStream = function(source) {
    return source instanceof Stream;
  };
  utils.lazyReadStream = function(filepath) {
    return new lazystream.Readable(function() {
      return fs.createReadStream(filepath);
    });
  };
  utils.normalizeInputSource = function(source) {
    if (source === null) {
      return new Buffer(0);
    } else if (typeof source === "string") {
      return new Buffer(source);
    } else if (utils.isStream(source) && !source._readableState) {
      var normalized = new PassThrough;
      source.pipe(normalized);
      return normalized;
    }
    return source;
  };
  utils.sanitizePath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  };
  utils.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
  };
  utils.unixifyPath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "");
  };
  utils.walkdir = function(dirpath, base, callback) {
    var results2 = [];
    if (typeof base === "function") {
      callback = base;
      base = dirpath;
    }
    fs.readdir(dirpath, function(err, list) {
      var i = 0;
      var file;
      var filepath;
      if (err) {
        return callback(err);
      }
      (function next() {
        file = list[i++];
        if (!file) {
          return callback(null, results2);
        }
        filepath = path.join(dirpath, file);
        fs.stat(filepath, function(err2, stats) {
          results2.push({
            path: filepath,
            relative: path.relative(base, filepath).replace(/\\/g, "/"),
            stats
          });
          if (stats && stats.isDirectory()) {
            utils.walkdir(filepath, base, function(err3, res) {
              res.forEach(function(dirEntry) {
                results2.push(dirEntry);
              });
              next();
            });
          } else {
            next();
          }
        });
      })();
    });
  };
});

// node_modules/archiver/lib/error.js
var require_error = __commonJS((exports, module) => {
  var util = __require("util");
  var ERROR_CODES = {
    ABORTED: "archive was aborted",
    DIRECTORYDIRPATHREQUIRED: "diretory dirpath argument must be a non-empty string value",
    DIRECTORYFUNCTIONINVALIDDATA: "invalid data returned by directory custom data function",
    ENTRYNAMEREQUIRED: "entry name must be a non-empty string value",
    FILEFILEPATHREQUIRED: "file filepath argument must be a non-empty string value",
    FINALIZING: "archive already finalizing",
    QUEUECLOSED: "queue closed",
    NOENDMETHOD: "no suitable finalize/end method defined by module",
    DIRECTORYNOTSUPPORTED: "support for directory entries not defined by module",
    FORMATSET: "archive format already set",
    INPUTSTEAMBUFFERREQUIRED: "input source must be valid Stream or Buffer instance",
    MODULESET: "module already set",
    SYMLINKNOTSUPPORTED: "support for symlink entries not defined by module",
    SYMLINKFILEPATHREQUIRED: "symlink filepath argument must be a non-empty string value",
    SYMLINKTARGETREQUIRED: "symlink target argument must be a non-empty string value",
    ENTRYNOTSUPPORTED: "entry not supported"
  };
  function ArchiverError(code, data) {
    Error.captureStackTrace(this, this.constructor);
    this.message = ERROR_CODES[code] || code;
    this.code = code;
    this.data = data;
  }
  util.inherits(ArchiverError, Error);
  exports = module.exports = ArchiverError;
});

// node_modules/archiver/lib/core.js
var require_core = __commonJS((exports, module) => {
  var fs = __require("fs");
  var glob = require_readdir_glob();
  var async = require_async2();
  var path = __require("path");
  var util = require_archiver_utils();
  var inherits = __require("util").inherits;
  var ArchiverError = require_error();
  var Transform = require_readable().Transform;
  var win32 = process.platform === "win32";
  var Archiver = function(format, options) {
    if (!(this instanceof Archiver)) {
      return new Archiver(format, options);
    }
    if (typeof format !== "string") {
      options = format;
      format = "zip";
    }
    options = this.options = util.defaults(options, {
      highWaterMark: 1024 * 1024,
      statConcurrency: 4
    });
    Transform.call(this, options);
    this._format = false;
    this._module = false;
    this._pending = 0;
    this._pointer = 0;
    this._entriesCount = 0;
    this._entriesProcessedCount = 0;
    this._fsEntriesTotalBytes = 0;
    this._fsEntriesProcessedBytes = 0;
    this._queue = async.queue(this._onQueueTask.bind(this), 1);
    this._queue.drain(this._onQueueDrain.bind(this));
    this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
    this._statQueue.drain(this._onQueueDrain.bind(this));
    this._state = {
      aborted: false,
      finalize: false,
      finalizing: false,
      finalized: false,
      modulePiped: false
    };
    this._streams = [];
  };
  inherits(Archiver, Transform);
  Archiver.prototype._abort = function() {
    this._state.aborted = true;
    this._queue.kill();
    this._statQueue.kill();
    if (this._queue.idle()) {
      this._shutdown();
    }
  };
  Archiver.prototype._append = function(filepath, data) {
    data = data || {};
    var task = {
      source: null,
      filepath
    };
    if (!data.name) {
      data.name = filepath;
    }
    data.sourcePath = filepath;
    task.data = data;
    this._entriesCount++;
    if (data.stats && data.stats instanceof fs.Stats) {
      task = this._updateQueueTaskWithStats(task, data.stats);
      if (task) {
        if (data.stats.size) {
          this._fsEntriesTotalBytes += data.stats.size;
        }
        this._queue.push(task);
      }
    } else {
      this._statQueue.push(task);
    }
  };
  Archiver.prototype._finalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    this._state.finalizing = true;
    this._moduleFinalize();
    this._state.finalizing = false;
    this._state.finalized = true;
  };
  Archiver.prototype._maybeFinalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return false;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
      return true;
    }
    return false;
  };
  Archiver.prototype._moduleAppend = function(source, data, callback) {
    if (this._state.aborted) {
      callback();
      return;
    }
    this._module.append(source, data, function(err) {
      this._task = null;
      if (this._state.aborted) {
        this._shutdown();
        return;
      }
      if (err) {
        this.emit("error", err);
        setImmediate(callback);
        return;
      }
      this.emit("entry", data);
      this._entriesProcessedCount++;
      if (data.stats && data.stats.size) {
        this._fsEntriesProcessedBytes += data.stats.size;
      }
      this.emit("progress", {
        entries: {
          total: this._entriesCount,
          processed: this._entriesProcessedCount
        },
        fs: {
          totalBytes: this._fsEntriesTotalBytes,
          processedBytes: this._fsEntriesProcessedBytes
        }
      });
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._moduleFinalize = function() {
    if (typeof this._module.finalize === "function") {
      this._module.finalize();
    } else if (typeof this._module.end === "function") {
      this._module.end();
    } else {
      this.emit("error", new ArchiverError("NOENDMETHOD"));
    }
  };
  Archiver.prototype._modulePipe = function() {
    this._module.on("error", this._onModuleError.bind(this));
    this._module.pipe(this);
    this._state.modulePiped = true;
  };
  Archiver.prototype._moduleSupports = function(key2) {
    if (!this._module.supports || !this._module.supports[key2]) {
      return false;
    }
    return this._module.supports[key2];
  };
  Archiver.prototype._moduleUnpipe = function() {
    this._module.unpipe(this);
    this._state.modulePiped = false;
  };
  Archiver.prototype._normalizeEntryData = function(data, stats) {
    data = util.defaults(data, {
      type: "file",
      name: null,
      date: null,
      mode: null,
      prefix: null,
      sourcePath: null,
      stats: false
    });
    if (stats && data.stats === false) {
      data.stats = stats;
    }
    var isDir = data.type === "directory";
    if (data.name) {
      if (typeof data.prefix === "string" && data.prefix !== "") {
        data.name = data.prefix + "/" + data.name;
        data.prefix = null;
      }
      data.name = util.sanitizePath(data.name);
      if (data.type !== "symlink" && data.name.slice(-1) === "/") {
        isDir = true;
        data.type = "directory";
      } else if (isDir) {
        data.name += "/";
      }
    }
    if (typeof data.mode === "number") {
      if (win32) {
        data.mode &= 511;
      } else {
        data.mode &= 4095;
      }
    } else if (data.stats && data.mode === null) {
      if (win32) {
        data.mode = data.stats.mode & 511;
      } else {
        data.mode = data.stats.mode & 4095;
      }
      if (win32 && isDir) {
        data.mode = 493;
      }
    } else if (data.mode === null) {
      data.mode = isDir ? 493 : 420;
    }
    if (data.stats && data.date === null) {
      data.date = data.stats.mtime;
    } else {
      data.date = util.dateify(data.date);
    }
    return data;
  };
  Archiver.prototype._onModuleError = function(err) {
    this.emit("error", err);
  };
  Archiver.prototype._onQueueDrain = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
  };
  Archiver.prototype._onQueueTask = function(task, callback) {
    var fullCallback = () => {
      if (task.data.callback) {
        task.data.callback();
      }
      callback();
    };
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      fullCallback();
      return;
    }
    this._task = task;
    this._moduleAppend(task.source, task.data, fullCallback);
  };
  Archiver.prototype._onStatQueueTask = function(task, callback) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      callback();
      return;
    }
    fs.lstat(task.filepath, function(err, stats) {
      if (this._state.aborted) {
        setImmediate(callback);
        return;
      }
      if (err) {
        this._entriesCount--;
        this.emit("warning", err);
        setImmediate(callback);
        return;
      }
      task = this._updateQueueTaskWithStats(task, stats);
      if (task) {
        if (stats.size) {
          this._fsEntriesTotalBytes += stats.size;
        }
        this._queue.push(task);
      }
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._shutdown = function() {
    this._moduleUnpipe();
    this.end();
  };
  Archiver.prototype._transform = function(chunk, encoding, callback) {
    if (chunk) {
      this._pointer += chunk.length;
    }
    callback(null, chunk);
  };
  Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
    if (stats.isFile()) {
      task.data.type = "file";
      task.data.sourceType = "stream";
      task.source = util.lazyReadStream(task.filepath);
    } else if (stats.isDirectory() && this._moduleSupports("directory")) {
      task.data.name = util.trailingSlashIt(task.data.name);
      task.data.type = "directory";
      task.data.sourcePath = util.trailingSlashIt(task.filepath);
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
      var linkPath = fs.readlinkSync(task.filepath);
      var dirName = path.dirname(task.filepath);
      task.data.type = "symlink";
      task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else {
      if (stats.isDirectory()) {
        this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
      } else if (stats.isSymbolicLink()) {
        this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
      } else {
        this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
      }
      return null;
    }
    task.data = this._normalizeEntryData(task.data, stats);
    return task;
  };
  Archiver.prototype.abort = function() {
    if (this._state.aborted || this._state.finalized) {
      return this;
    }
    this._abort();
    return this;
  };
  Archiver.prototype.append = function(source, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    data = this._normalizeEntryData(data);
    if (typeof data.name !== "string" || data.name.length === 0) {
      this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
      return this;
    }
    if (data.type === "directory" && !this._moduleSupports("directory")) {
      this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", { name: data.name }));
      return this;
    }
    source = util.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      data.sourceType = "buffer";
    } else if (util.isStream(source)) {
      data.sourceType = "stream";
    } else {
      this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", { name: data.name }));
      return this;
    }
    this._entriesCount++;
    this._queue.push({
      data,
      source
    });
    return this;
  };
  Archiver.prototype.directory = function(dirpath, destpath, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof dirpath !== "string" || dirpath.length === 0) {
      this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
      return this;
    }
    this._pending++;
    if (destpath === false) {
      destpath = "";
    } else if (typeof destpath !== "string") {
      destpath = dirpath;
    }
    var dataFunction = false;
    if (typeof data === "function") {
      dataFunction = data;
      data = {};
    } else if (typeof data !== "object") {
      data = {};
    }
    var globOptions = {
      stat: true,
      dot: true
    };
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      globber.pause();
      var ignoreMatch = false;
      var entryData = Object.assign({}, data);
      entryData.name = match.relative;
      entryData.prefix = destpath;
      entryData.stats = match.stat;
      entryData.callback = globber.resume.bind(globber);
      try {
        if (dataFunction) {
          entryData = dataFunction(entryData);
          if (entryData === false) {
            ignoreMatch = true;
          } else if (typeof entryData !== "object") {
            throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", { dirpath });
          }
        }
      } catch (e) {
        this.emit("error", e);
        return;
      }
      if (ignoreMatch) {
        globber.resume();
        return;
      }
      this._append(match.absolute, entryData);
    }
    var globber = glob(dirpath, globOptions);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.file = function(filepath, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
      return this;
    }
    this._append(filepath, data);
    return this;
  };
  Archiver.prototype.glob = function(pattern, options, data) {
    this._pending++;
    options = util.defaults(options, {
      stat: true,
      pattern
    });
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      globber.pause();
      var entryData = Object.assign({}, data);
      entryData.callback = globber.resume.bind(globber);
      entryData.stats = match.stat;
      entryData.name = match.relative;
      this._append(match.absolute, entryData);
    }
    var globber = glob(options.cwd || ".", options);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.finalize = function() {
    if (this._state.aborted) {
      var abortedError = new ArchiverError("ABORTED");
      this.emit("error", abortedError);
      return Promise.reject(abortedError);
    }
    if (this._state.finalize) {
      var finalizingError = new ArchiverError("FINALIZING");
      this.emit("error", finalizingError);
      return Promise.reject(finalizingError);
    }
    this._state.finalize = true;
    if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
    var self2 = this;
    return new Promise(function(resolve, reject) {
      var errored;
      self2._module.on("end", function() {
        if (!errored) {
          resolve();
        }
      });
      self2._module.on("error", function(err) {
        errored = true;
        reject(err);
      });
    });
  };
  Archiver.prototype.setFormat = function(format) {
    if (this._format) {
      this.emit("error", new ArchiverError("FORMATSET"));
      return this;
    }
    this._format = format;
    return this;
  };
  Archiver.prototype.setModule = function(module2) {
    if (this._state.aborted) {
      this.emit("error", new ArchiverError("ABORTED"));
      return this;
    }
    if (this._state.module) {
      this.emit("error", new ArchiverError("MODULESET"));
      return this;
    }
    this._module = module2;
    this._modulePipe();
    return this;
  };
  Archiver.prototype.symlink = function(filepath, target, mode) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
      return this;
    }
    if (typeof target !== "string" || target.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", { filepath }));
      return this;
    }
    if (!this._moduleSupports("symlink")) {
      this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", { filepath }));
      return this;
    }
    var data = {};
    data.type = "symlink";
    data.name = filepath.replace(/\\/g, "/");
    data.linkname = target.replace(/\\/g, "/");
    data.sourceType = "buffer";
    if (typeof mode === "number") {
      data.mode = mode;
    }
    this._entriesCount++;
    this._queue.push({
      data,
      source: Buffer.concat([])
    });
    return this;
  };
  Archiver.prototype.pointer = function() {
    return this._pointer;
  };
  Archiver.prototype.use = function(plugin) {
    this._streams.push(plugin);
    return this;
  };
  module.exports = Archiver;
});

// node_modules/compress-commons/lib/archivers/archive-entry.js
var require_archive_entry = __commonJS((exports, module) => {
  var ArchiveEntry = module.exports = function() {};
  ArchiveEntry.prototype.getName = function() {};
  ArchiveEntry.prototype.getSize = function() {};
  ArchiveEntry.prototype.getLastModifiedDate = function() {};
  ArchiveEntry.prototype.isDirectory = function() {};
});

// node_modules/compress-commons/lib/archivers/zip/util.js
var require_util5 = __commonJS((exports, module) => {
  var util = module.exports = {};
  util.dateToDos = function(d, forceLocalTime) {
    forceLocalTime = forceLocalTime || false;
    var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
    if (year < 1980) {
      return 2162688;
    } else if (year >= 2044) {
      return 2141175677;
    }
    var val = {
      year,
      month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
      date: forceLocalTime ? d.getDate() : d.getUTCDate(),
      hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
      minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
      seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
    };
    return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
  };
  util.dosToDate = function(dos) {
    return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
  };
  util.fromDosTime = function(buf) {
    return util.dosToDate(buf.readUInt32LE(0));
  };
  util.getEightBytes = function(v) {
    var buf = Buffer.alloc(8);
    buf.writeUInt32LE(v % 4294967296, 0);
    buf.writeUInt32LE(v / 4294967296 | 0, 4);
    return buf;
  };
  util.getShortBytes = function(v) {
    var buf = Buffer.alloc(2);
    buf.writeUInt16LE((v & 65535) >>> 0, 0);
    return buf;
  };
  util.getShortBytesValue = function(buf, offset) {
    return buf.readUInt16LE(offset);
  };
  util.getLongBytes = function(v) {
    var buf = Buffer.alloc(4);
    buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
    return buf;
  };
  util.getLongBytesValue = function(buf, offset) {
    return buf.readUInt32LE(offset);
  };
  util.toDosTime = function(d) {
    return util.getLongBytes(util.dateToDos(d));
  };
});

// node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js
var require_general_purpose_bit = __commonJS((exports, module) => {
  var zipUtil = require_util5();
  var DATA_DESCRIPTOR_FLAG = 1 << 3;
  var ENCRYPTION_FLAG = 1 << 0;
  var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
  var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
  var STRONG_ENCRYPTION_FLAG = 1 << 6;
  var UFT8_NAMES_FLAG = 1 << 11;
  var GeneralPurposeBit = module.exports = function() {
    if (!(this instanceof GeneralPurposeBit)) {
      return new GeneralPurposeBit;
    }
    this.descriptor = false;
    this.encryption = false;
    this.utf8 = false;
    this.numberOfShannonFanoTrees = 0;
    this.strongEncryption = false;
    this.slidingDictionarySize = 0;
    return this;
  };
  GeneralPurposeBit.prototype.encode = function() {
    return zipUtil.getShortBytes((this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0));
  };
  GeneralPurposeBit.prototype.parse = function(buf, offset) {
    var flag = zipUtil.getShortBytesValue(buf, offset);
    var gbp = new GeneralPurposeBit;
    gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
    gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
    gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
    gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
    gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
    gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
    return gbp;
  };
  GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
    this.numberOfShannonFanoTrees = n;
  };
  GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
    return this.numberOfShannonFanoTrees;
  };
  GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
    this.slidingDictionarySize = n;
  };
  GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
    return this.slidingDictionarySize;
  };
  GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
    this.descriptor = b;
  };
  GeneralPurposeBit.prototype.usesDataDescriptor = function() {
    return this.descriptor;
  };
  GeneralPurposeBit.prototype.useEncryption = function(b) {
    this.encryption = b;
  };
  GeneralPurposeBit.prototype.usesEncryption = function() {
    return this.encryption;
  };
  GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
    this.strongEncryption = b;
  };
  GeneralPurposeBit.prototype.usesStrongEncryption = function() {
    return this.strongEncryption;
  };
  GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
    this.utf8 = b;
  };
  GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
    return this.utf8;
  };
});

// node_modules/compress-commons/lib/archivers/zip/unix-stat.js
var require_unix_stat = __commonJS((exports, module) => {
  module.exports = {
    PERM_MASK: 4095,
    FILE_TYPE_FLAG: 61440,
    LINK_FLAG: 40960,
    FILE_FLAG: 32768,
    DIR_FLAG: 16384,
    DEFAULT_LINK_PERM: 511,
    DEFAULT_DIR_PERM: 493,
    DEFAULT_FILE_PERM: 420
  };
});

// node_modules/compress-commons/lib/archivers/zip/constants.js
var require_constants3 = __commonJS((exports, module) => {
  module.exports = {
    WORD: 4,
    DWORD: 8,
    EMPTY: Buffer.alloc(0),
    SHORT: 2,
    SHORT_MASK: 65535,
    SHORT_SHIFT: 16,
    SHORT_ZERO: Buffer.from(Array(2)),
    LONG: 4,
    LONG_ZERO: Buffer.from(Array(4)),
    MIN_VERSION_INITIAL: 10,
    MIN_VERSION_DATA_DESCRIPTOR: 20,
    MIN_VERSION_ZIP64: 45,
    VERSION_MADEBY: 45,
    METHOD_STORED: 0,
    METHOD_DEFLATED: 8,
    PLATFORM_UNIX: 3,
    PLATFORM_FAT: 0,
    SIG_LFH: 67324752,
    SIG_DD: 134695760,
    SIG_CFH: 33639248,
    SIG_EOCD: 101010256,
    SIG_ZIP64_EOCD: 101075792,
    SIG_ZIP64_EOCD_LOC: 117853008,
    ZIP64_MAGIC_SHORT: 65535,
    ZIP64_MAGIC: 4294967295,
    ZIP64_EXTRA_ID: 1,
    ZLIB_NO_COMPRESSION: 0,
    ZLIB_BEST_SPEED: 1,
    ZLIB_BEST_COMPRESSION: 9,
    ZLIB_DEFAULT_COMPRESSION: -1,
    MODE_MASK: 4095,
    DEFAULT_FILE_MODE: 33188,
    DEFAULT_DIR_MODE: 16877,
    EXT_FILE_ATTR_DIR: 1106051088,
    EXT_FILE_ATTR_FILE: 2175008800,
    S_IFMT: 61440,
    S_IFIFO: 4096,
    S_IFCHR: 8192,
    S_IFDIR: 16384,
    S_IFBLK: 24576,
    S_IFREG: 32768,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    S_DOS_A: 32,
    S_DOS_D: 16,
    S_DOS_V: 8,
    S_DOS_S: 4,
    S_DOS_H: 2,
    S_DOS_R: 1
  };
});

// node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js
var require_zip_archive_entry = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var normalizePath = require_normalize_path();
  var ArchiveEntry = require_archive_entry();
  var GeneralPurposeBit = require_general_purpose_bit();
  var UnixStat = require_unix_stat();
  var constants = require_constants3();
  var zipUtil = require_util5();
  var ZipArchiveEntry = module.exports = function(name) {
    if (!(this instanceof ZipArchiveEntry)) {
      return new ZipArchiveEntry(name);
    }
    ArchiveEntry.call(this);
    this.platform = constants.PLATFORM_FAT;
    this.method = -1;
    this.name = null;
    this.size = 0;
    this.csize = 0;
    this.gpb = new GeneralPurposeBit;
    this.crc = 0;
    this.time = -1;
    this.minver = constants.MIN_VERSION_INITIAL;
    this.mode = -1;
    this.extra = null;
    this.exattr = 0;
    this.inattr = 0;
    this.comment = null;
    if (name) {
      this.setName(name);
    }
  };
  inherits(ZipArchiveEntry, ArchiveEntry);
  ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getComment = function() {
    return this.comment !== null ? this.comment : "";
  };
  ZipArchiveEntry.prototype.getCompressedSize = function() {
    return this.csize;
  };
  ZipArchiveEntry.prototype.getCrc = function() {
    return this.crc;
  };
  ZipArchiveEntry.prototype.getExternalAttributes = function() {
    return this.exattr;
  };
  ZipArchiveEntry.prototype.getExtra = function() {
    return this.extra !== null ? this.extra : constants.EMPTY;
  };
  ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
    return this.gpb;
  };
  ZipArchiveEntry.prototype.getInternalAttributes = function() {
    return this.inattr;
  };
  ZipArchiveEntry.prototype.getLastModifiedDate = function() {
    return this.getTime();
  };
  ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getMethod = function() {
    return this.method;
  };
  ZipArchiveEntry.prototype.getName = function() {
    return this.name;
  };
  ZipArchiveEntry.prototype.getPlatform = function() {
    return this.platform;
  };
  ZipArchiveEntry.prototype.getSize = function() {
    return this.size;
  };
  ZipArchiveEntry.prototype.getTime = function() {
    return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
  };
  ZipArchiveEntry.prototype.getTimeDos = function() {
    return this.time !== -1 ? this.time : 0;
  };
  ZipArchiveEntry.prototype.getUnixMode = function() {
    return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
  };
  ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
    return this.minver;
  };
  ZipArchiveEntry.prototype.setComment = function(comment) {
    if (Buffer.byteLength(comment) !== comment.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.comment = comment;
  };
  ZipArchiveEntry.prototype.setCompressedSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry compressed size");
    }
    this.csize = size;
  };
  ZipArchiveEntry.prototype.setCrc = function(crc) {
    if (crc < 0) {
      throw new Error("invalid entry crc32");
    }
    this.crc = crc;
  };
  ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
    this.exattr = attr >>> 0;
  };
  ZipArchiveEntry.prototype.setExtra = function(extra) {
    this.extra = extra;
  };
  ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
    if (!(gpb instanceof GeneralPurposeBit)) {
      throw new Error("invalid entry GeneralPurposeBit");
    }
    this.gpb = gpb;
  };
  ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
    this.inattr = attr;
  };
  ZipArchiveEntry.prototype.setMethod = function(method) {
    if (method < 0) {
      throw new Error("invalid entry compression method");
    }
    this.method = method;
  };
  ZipArchiveEntry.prototype.setName = function(name, prependSlash = false) {
    name = normalizePath(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    if (prependSlash) {
      name = `/${name}`;
    }
    if (Buffer.byteLength(name) !== name.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.name = name;
  };
  ZipArchiveEntry.prototype.setPlatform = function(platform) {
    this.platform = platform;
  };
  ZipArchiveEntry.prototype.setSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry size");
    }
    this.size = size;
  };
  ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
    if (!(time instanceof Date)) {
      throw new Error("invalid entry time");
    }
    this.time = zipUtil.dateToDos(time, forceLocalTime);
  };
  ZipArchiveEntry.prototype.setUnixMode = function(mode) {
    mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
    var extattr = 0;
    extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A);
    this.setExternalAttributes(extattr);
    this.mode = mode & constants.MODE_MASK;
    this.platform = constants.PLATFORM_UNIX;
  };
  ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
    this.minver = minver;
  };
  ZipArchiveEntry.prototype.isDirectory = function() {
    return this.getName().slice(-1) === "/";
  };
  ZipArchiveEntry.prototype.isUnixSymlink = function() {
    return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
  };
  ZipArchiveEntry.prototype.isZip64 = function() {
    return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
  };
});

// node_modules/compress-commons/lib/util/index.js
var require_util6 = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  var PassThrough = require_readable().PassThrough;
  var util = module.exports = {};
  util.isStream = function(source) {
    return source instanceof Stream;
  };
  util.normalizeInputSource = function(source) {
    if (source === null) {
      return Buffer.alloc(0);
    } else if (typeof source === "string") {
      return Buffer.from(source);
    } else if (util.isStream(source) && !source._readableState) {
      var normalized = new PassThrough;
      source.pipe(normalized);
      return normalized;
    }
    return source;
  };
});

// node_modules/compress-commons/lib/archivers/archive-output-stream.js
var require_archive_output_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var Transform = require_readable().Transform;
  var ArchiveEntry = require_archive_entry();
  var util = require_util6();
  var ArchiveOutputStream = module.exports = function(options) {
    if (!(this instanceof ArchiveOutputStream)) {
      return new ArchiveOutputStream(options);
    }
    Transform.call(this, options);
    this.offset = 0;
    this._archive = {
      finish: false,
      finished: false,
      processing: false
    };
  };
  inherits(ArchiveOutputStream, Transform);
  ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {};
  ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {};
  ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
    if (err) {
      this.emit("error", err);
    }
  };
  ArchiveOutputStream.prototype._finish = function(ae) {};
  ArchiveOutputStream.prototype._normalizeEntry = function(ae) {};
  ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
    source = source || null;
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    if (!(ae instanceof ArchiveEntry)) {
      callback(new Error("not a valid instance of ArchiveEntry"));
      return;
    }
    if (this._archive.finish || this._archive.finished) {
      callback(new Error("unacceptable entry after finish"));
      return;
    }
    if (this._archive.processing) {
      callback(new Error("already processing an entry"));
      return;
    }
    this._archive.processing = true;
    this._normalizeEntry(ae);
    this._entry = ae;
    source = util.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      this._appendBuffer(ae, source, callback);
    } else if (util.isStream(source)) {
      this._appendStream(ae, source, callback);
    } else {
      this._archive.processing = false;
      callback(new Error("input source must be valid Stream or Buffer instance"));
      return;
    }
    return this;
  };
  ArchiveOutputStream.prototype.finish = function() {
    if (this._archive.processing) {
      this._archive.finish = true;
      return;
    }
    this._finish();
  };
  ArchiveOutputStream.prototype.getBytesWritten = function() {
    return this.offset;
  };
  ArchiveOutputStream.prototype.write = function(chunk, cb) {
    if (chunk) {
      this.offset += chunk.length;
    }
    return Transform.prototype.write.call(this, chunk, cb);
  };
});

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS((exports) => {
  /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
  var CRC32;
  (function(factory) {
    if (typeof DO_NOT_EXPORT_CRC === "undefined") {
      if (typeof exports === "object") {
        factory(exports);
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          var module2 = {};
          factory(module2);
          return module2;
        });
      } else {
        factory(CRC32 = {});
      }
    } else {
      factory(CRC32 = {});
    }
  })(function(CRC322) {
    CRC322.version = "1.2.2";
    function signed_crc_table() {
      var c = 0, table = new Array(256);
      for (var n = 0;n != 256; ++n) {
        c = n;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        table[n] = c;
      }
      return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
      var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
      for (n = 0;n != 256; ++n)
        table[n] = T[n];
      for (n = 0;n != 256; ++n) {
        v = T[n];
        for (c = 256 + n;c < 4096; c += 256)
          v = table[c] = v >>> 8 ^ T[v & 255];
      }
      var out = [];
      for (n = 1;n != 16; ++n)
        out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      return out;
    }
    var TT = slice_by_16_tables(T0);
    var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
    var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
    var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = bstr.length;i < L; )
        C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
      return ~C;
    }
    function crc32_buf(B, seed) {
      var C = seed ^ -1, L = B.length - 15, i = 0;
      for (;i < L; )
        C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      L += 15;
      while (i < L)
        C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
      return ~C;
    }
    function crc32_str(str, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = str.length, c = 0, d = 0;i < L; ) {
        c = str.charCodeAt(i++);
        if (c < 128) {
          C = C >>> 8 ^ T0[(C ^ c) & 255];
        } else if (c < 2048) {
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        } else if (c >= 55296 && c < 57344) {
          c = (c & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        }
      }
      return ~C;
    }
    CRC322.table = T0;
    CRC322.bstr = crc32_bstr;
    CRC322.buf = crc32_buf;
    CRC322.str = crc32_str;
  });
});

// node_modules/crc32-stream/lib/crc32-stream.js
var require_crc32_stream = __commonJS((exports, module) => {
  var { Transform } = require_readable();
  var crc32 = require_crc32();

  class CRC32Stream extends Transform {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
    }
    _transform(chunk, encoding, callback) {
      if (chunk) {
        this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
        this.rawSize += chunk.length;
      }
      callback(null, chunk);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size() {
      return this.rawSize;
    }
  }
  module.exports = CRC32Stream;
});

// node_modules/crc32-stream/lib/deflate-crc32-stream.js
var require_deflate_crc32_stream = __commonJS((exports, module) => {
  var { DeflateRaw } = __require("zlib");
  var crc32 = require_crc32();

  class DeflateCRC32Stream extends DeflateRaw {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
      this.compressedSize = 0;
    }
    push(chunk, encoding) {
      if (chunk) {
        this.compressedSize += chunk.length;
      }
      return super.push(chunk, encoding);
    }
    _transform(chunk, encoding, callback) {
      if (chunk) {
        this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
        this.rawSize += chunk.length;
      }
      super._transform(chunk, encoding, callback);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size(compressed = false) {
      if (compressed) {
        return this.compressedSize;
      } else {
        return this.rawSize;
      }
    }
  }
  module.exports = DeflateCRC32Stream;
});

// node_modules/crc32-stream/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  module.exports = {
    CRC32Stream: require_crc32_stream(),
    DeflateCRC32Stream: require_deflate_crc32_stream()
  };
});

// node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js
var require_zip_archive_output_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var crc32 = require_buffer_crc32();
  var { CRC32Stream } = require_lib5();
  var { DeflateCRC32Stream } = require_lib5();
  var ArchiveOutputStream = require_archive_output_stream();
  var ZipArchiveEntry = require_zip_archive_entry();
  var GeneralPurposeBit = require_general_purpose_bit();
  var constants = require_constants3();
  var util = require_util6();
  var zipUtil = require_util5();
  var ZipArchiveOutputStream = module.exports = function(options) {
    if (!(this instanceof ZipArchiveOutputStream)) {
      return new ZipArchiveOutputStream(options);
    }
    options = this.options = this._defaults(options);
    ArchiveOutputStream.call(this, options);
    this._entry = null;
    this._entries = [];
    this._archive = {
      centralLength: 0,
      centralOffset: 0,
      comment: "",
      finish: false,
      finished: false,
      processing: false,
      forceZip64: options.forceZip64,
      forceLocalTime: options.forceLocalTime
    };
  };
  inherits(ZipArchiveOutputStream, ArchiveOutputStream);
  ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
    this._entries.push(ae);
    if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
      this._writeDataDescriptor(ae);
    }
    this._archive.processing = false;
    this._entry = null;
    if (this._archive.finish && !this._archive.finished) {
      this._finish();
    }
  };
  ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
    if (source.length === 0) {
      ae.setMethod(constants.METHOD_STORED);
    }
    var method = ae.getMethod();
    if (method === constants.METHOD_STORED) {
      ae.setSize(source.length);
      ae.setCompressedSize(source.length);
      ae.setCrc(crc32.unsigned(source));
    }
    this._writeLocalFileHeader(ae);
    if (method === constants.METHOD_STORED) {
      this.write(source);
      this._afterAppend(ae);
      callback(null, ae);
      return;
    } else if (method === constants.METHOD_DEFLATED) {
      this._smartStream(ae, callback).end(source);
      return;
    } else {
      callback(new Error("compression method " + method + " not implemented"));
      return;
    }
  };
  ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
    ae.getGeneralPurposeBit().useDataDescriptor(true);
    ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    this._writeLocalFileHeader(ae);
    var smart = this._smartStream(ae, callback);
    source.once("error", function(err) {
      smart.emit("error", err);
      smart.end();
    });
    source.pipe(smart);
  };
  ZipArchiveOutputStream.prototype._defaults = function(o) {
    if (typeof o !== "object") {
      o = {};
    }
    if (typeof o.zlib !== "object") {
      o.zlib = {};
    }
    if (typeof o.zlib.level !== "number") {
      o.zlib.level = constants.ZLIB_BEST_SPEED;
    }
    o.forceZip64 = !!o.forceZip64;
    o.forceLocalTime = !!o.forceLocalTime;
    return o;
  };
  ZipArchiveOutputStream.prototype._finish = function() {
    this._archive.centralOffset = this.offset;
    this._entries.forEach(function(ae) {
      this._writeCentralFileHeader(ae);
    }.bind(this));
    this._archive.centralLength = this.offset - this._archive.centralOffset;
    if (this.isZip64()) {
      this._writeCentralDirectoryZip64();
    }
    this._writeCentralDirectoryEnd();
    this._archive.processing = false;
    this._archive.finish = true;
    this._archive.finished = true;
    this.end();
  };
  ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    if (ae.getMethod() === -1) {
      ae.setMethod(constants.METHOD_DEFLATED);
    }
    if (ae.getMethod() === constants.METHOD_DEFLATED) {
      ae.getGeneralPurposeBit().useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    }
    if (ae.getTime() === -1) {
      ae.setTime(new Date, this._archive.forceLocalTime);
    }
    ae._offsets = {
      file: 0,
      data: 0,
      contents: 0
    };
  };
  ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
    var deflate = ae.getMethod() === constants.METHOD_DEFLATED;
    var process2 = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream;
    var error = null;
    function handleStuff() {
      var digest = process2.digest().readUInt32BE(0);
      ae.setCrc(digest);
      ae.setSize(process2.size());
      ae.setCompressedSize(process2.size(true));
      this._afterAppend(ae);
      callback(error, ae);
    }
    process2.once("end", handleStuff.bind(this));
    process2.once("error", function(err) {
      error = err;
    });
    process2.pipe(this, { end: false });
    return process2;
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
    var records = this._entries.length;
    var size = this._archive.centralLength;
    var offset = this._archive.centralOffset;
    if (this.isZip64()) {
      records = constants.ZIP64_MAGIC_SHORT;
      size = constants.ZIP64_MAGIC;
      offset = constants.ZIP64_MAGIC;
    }
    this.write(zipUtil.getLongBytes(constants.SIG_EOCD));
    this.write(constants.SHORT_ZERO);
    this.write(constants.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getLongBytes(size));
    this.write(zipUtil.getLongBytes(offset));
    var comment = this.getComment();
    var commentLength = Buffer.byteLength(comment);
    this.write(zipUtil.getShortBytes(commentLength));
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD));
    this.write(zipUtil.getEightBytes(44));
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    this.write(constants.LONG_ZERO);
    this.write(constants.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._archive.centralLength));
    this.write(zipUtil.getEightBytes(this._archive.centralOffset));
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC));
    this.write(constants.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
    this.write(zipUtil.getLongBytes(1));
  };
  ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var offsets = ae._offsets;
    var size = ae.getSize();
    var compressedSize = ae.getCompressedSize();
    if (ae.isZip64() || offsets.file > constants.ZIP64_MAGIC) {
      size = constants.ZIP64_MAGIC;
      compressedSize = constants.ZIP64_MAGIC;
      ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
      var extraBuf = Buffer.concat([
        zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
        zipUtil.getShortBytes(24),
        zipUtil.getEightBytes(ae.getSize()),
        zipUtil.getEightBytes(ae.getCompressedSize()),
        zipUtil.getEightBytes(offsets.file)
      ], 28);
      ae.setExtra(extraBuf);
    }
    this.write(zipUtil.getLongBytes(constants.SIG_CFH));
    this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    this.write(zipUtil.getLongBytes(compressedSize));
    this.write(zipUtil.getLongBytes(size));
    var name = ae.getName();
    var comment = ae.getComment();
    var extra = ae.getCentralDirectoryExtra();
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
      comment = Buffer.from(comment);
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(zipUtil.getShortBytes(comment.length));
    this.write(constants.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
    this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
    if (offsets.file > constants.ZIP64_MAGIC) {
      this.write(zipUtil.getLongBytes(constants.ZIP64_MAGIC));
    } else {
      this.write(zipUtil.getLongBytes(offsets.file));
    }
    this.write(name);
    this.write(extra);
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
    this.write(zipUtil.getLongBytes(constants.SIG_DD));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    if (ae.isZip64()) {
      this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
      this.write(zipUtil.getEightBytes(ae.getSize()));
    } else {
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
  };
  ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var name = ae.getName();
    var extra = ae.getLocalFileDataExtra();
    if (ae.isZip64()) {
      gpb.useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
    }
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
    }
    ae._offsets.file = this.offset;
    this.write(zipUtil.getLongBytes(constants.SIG_LFH));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    ae._offsets.data = this.offset;
    if (gpb.usesDataDescriptor()) {
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
    } else {
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(name);
    this.write(extra);
    ae._offsets.contents = this.offset;
  };
  ZipArchiveOutputStream.prototype.getComment = function(comment) {
    return this._archive.comment !== null ? this._archive.comment : "";
  };
  ZipArchiveOutputStream.prototype.isZip64 = function() {
    return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
  };
  ZipArchiveOutputStream.prototype.setComment = function(comment) {
    this._archive.comment = comment;
  };
});

// node_modules/compress-commons/lib/compress-commons.js
var require_compress_commons = __commonJS((exports, module) => {
  module.exports = {
    ArchiveEntry: require_archive_entry(),
    ZipArchiveEntry: require_zip_archive_entry(),
    ArchiveOutputStream: require_archive_output_stream(),
    ZipArchiveOutputStream: require_zip_archive_output_stream()
  };
});

// node_modules/zip-stream/node_modules/archiver-utils/file.js
var require_file3 = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var flatten = require_lodash2();
  var difference = require_lodash3();
  var union = require_lodash4();
  var isPlainObject = require_lodash5();
  var glob = require_glob();
  var file = module.exports = {};
  var pathSeparatorRe = /[\/\\]/g;
  var processPatterns = function(patterns, fn) {
    var result = [];
    flatten(patterns).forEach(function(pattern) {
      var exclusion = pattern.indexOf("!") === 0;
      if (exclusion) {
        pattern = pattern.slice(1);
      }
      var matches = fn(pattern);
      if (exclusion) {
        result = difference(result, matches);
      } else {
        result = union(result, matches);
      }
    });
    return result;
  };
  file.exists = function() {
    var filepath = path.join.apply(path, arguments);
    return fs.existsSync(filepath);
  };
  file.expand = function(...args) {
    var options = isPlainObject(args[0]) ? args.shift() : {};
    var patterns = Array.isArray(args[0]) ? args[0] : args;
    if (patterns.length === 0) {
      return [];
    }
    var matches = processPatterns(patterns, function(pattern) {
      return glob.sync(pattern, options);
    });
    if (options.filter) {
      matches = matches.filter(function(filepath) {
        filepath = path.join(options.cwd || "", filepath);
        try {
          if (typeof options.filter === "function") {
            return options.filter(filepath);
          } else {
            return fs.statSync(filepath)[options.filter]();
          }
        } catch (e) {
          return false;
        }
      });
    }
    return matches;
  };
  file.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
      rename: function(destBase2, destPath) {
        return path.join(destBase2 || "", destPath);
      }
    }, options);
    var files = [];
    var fileByDest = {};
    file.expand(options, patterns).forEach(function(src) {
      var destPath = src;
      if (options.flatten) {
        destPath = path.basename(destPath);
      }
      if (options.ext) {
        destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
      }
      var dest = options.rename(destBase, destPath, options);
      if (options.cwd) {
        src = path.join(options.cwd, src);
      }
      dest = dest.replace(pathSeparatorRe, "/");
      src = src.replace(pathSeparatorRe, "/");
      if (fileByDest[dest]) {
        fileByDest[dest].src.push(src);
      } else {
        files.push({
          src: [src],
          dest
        });
        fileByDest[dest] = files[files.length - 1];
      }
    });
    return files;
  };
  file.normalizeFilesArray = function(data) {
    var files = [];
    data.forEach(function(obj2) {
      var prop;
      if ("src" in obj2 || "dest" in obj2) {
        files.push(obj2);
      }
    });
    if (files.length === 0) {
      return [];
    }
    files = _(files).chain().forEach(function(obj2) {
      if (!("src" in obj2) || !obj2.src) {
        return;
      }
      if (Array.isArray(obj2.src)) {
        obj2.src = flatten(obj2.src);
      } else {
        obj2.src = [obj2.src];
      }
    }).map(function(obj2) {
      var expandOptions = Object.assign({}, obj2);
      delete expandOptions.src;
      delete expandOptions.dest;
      if (obj2.expand) {
        return file.expandMapping(obj2.src, obj2.dest, expandOptions).map(function(mapObj) {
          var result2 = Object.assign({}, obj2);
          result2.orig = Object.assign({}, obj2);
          result2.src = mapObj.src;
          result2.dest = mapObj.dest;
          ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
            delete result2[prop];
          });
          return result2;
        });
      }
      var result = Object.assign({}, obj2);
      result.orig = Object.assign({}, obj2);
      if ("src" in result) {
        Object.defineProperty(result, "src", {
          enumerable: true,
          get: function fn() {
            var src;
            if (!("result" in fn)) {
              src = obj2.src;
              src = Array.isArray(src) ? flatten(src) : [src];
              fn.result = file.expand(expandOptions, src);
            }
            return fn.result;
          }
        });
      }
      if ("dest" in result) {
        result.dest = obj2.dest;
      }
      return result;
    }).flatten().value();
    return files;
  };
});

// node_modules/zip-stream/node_modules/archiver-utils/index.js
var require_archiver_utils2 = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var lazystream = require_lazystream();
  var normalizePath = require_normalize_path();
  var defaults = require_lodash();
  var Stream = __require("stream").Stream;
  var PassThrough = require_readable().PassThrough;
  var utils = module.exports = {};
  utils.file = require_file3();
  utils.collectStream = function(source, callback) {
    var collection = [];
    var size = 0;
    source.on("error", callback);
    source.on("data", function(chunk) {
      collection.push(chunk);
      size += chunk.length;
    });
    source.on("end", function() {
      var buf = Buffer.alloc(size);
      var offset = 0;
      collection.forEach(function(data) {
        data.copy(buf, offset);
        offset += data.length;
      });
      callback(null, buf);
    });
  };
  utils.dateify = function(dateish) {
    dateish = dateish || new Date;
    if (dateish instanceof Date) {
      dateish = dateish;
    } else if (typeof dateish === "string") {
      dateish = new Date(dateish);
    } else {
      dateish = new Date;
    }
    return dateish;
  };
  utils.defaults = function(object, source, guard) {
    var args = arguments;
    args[0] = args[0] || {};
    return defaults(...args);
  };
  utils.isStream = function(source) {
    return source instanceof Stream;
  };
  utils.lazyReadStream = function(filepath) {
    return new lazystream.Readable(function() {
      return fs.createReadStream(filepath);
    });
  };
  utils.normalizeInputSource = function(source) {
    if (source === null) {
      return Buffer.alloc(0);
    } else if (typeof source === "string") {
      return Buffer.from(source);
    } else if (utils.isStream(source)) {
      return source.pipe(new PassThrough);
    }
    return source;
  };
  utils.sanitizePath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  };
  utils.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
  };
  utils.unixifyPath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "");
  };
  utils.walkdir = function(dirpath, base, callback) {
    var results2 = [];
    if (typeof base === "function") {
      callback = base;
      base = dirpath;
    }
    fs.readdir(dirpath, function(err, list) {
      var i = 0;
      var file;
      var filepath;
      if (err) {
        return callback(err);
      }
      (function next() {
        file = list[i++];
        if (!file) {
          return callback(null, results2);
        }
        filepath = path.join(dirpath, file);
        fs.stat(filepath, function(err2, stats) {
          results2.push({
            path: filepath,
            relative: path.relative(base, filepath).replace(/\\/g, "/"),
            stats
          });
          if (stats && stats.isDirectory()) {
            utils.walkdir(filepath, base, function(err3, res) {
              res.forEach(function(dirEntry) {
                results2.push(dirEntry);
              });
              next();
            });
          } else {
            next();
          }
        });
      })();
    });
  };
});

// node_modules/zip-stream/index.js
var require_zip_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var ZipArchiveOutputStream = require_compress_commons().ZipArchiveOutputStream;
  var ZipArchiveEntry = require_compress_commons().ZipArchiveEntry;
  var util = require_archiver_utils2();
  var ZipStream = module.exports = function(options) {
    if (!(this instanceof ZipStream)) {
      return new ZipStream(options);
    }
    options = this.options = options || {};
    options.zlib = options.zlib || {};
    ZipArchiveOutputStream.call(this, options);
    if (typeof options.level === "number" && options.level >= 0) {
      options.zlib.level = options.level;
      delete options.level;
    }
    if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
      options.store = true;
    }
    options.namePrependSlash = options.namePrependSlash || false;
    if (options.comment && options.comment.length > 0) {
      this.setComment(options.comment);
    }
  };
  inherits(ZipStream, ZipArchiveOutputStream);
  ZipStream.prototype._normalizeFileData = function(data) {
    data = util.defaults(data, {
      type: "file",
      name: null,
      namePrependSlash: this.options.namePrependSlash,
      linkname: null,
      date: null,
      mode: null,
      store: this.options.store,
      comment: ""
    });
    var isDir = data.type === "directory";
    var isSymlink = data.type === "symlink";
    if (data.name) {
      data.name = util.sanitizePath(data.name);
      if (!isSymlink && data.name.slice(-1) === "/") {
        isDir = true;
        data.type = "directory";
      } else if (isDir) {
        data.name += "/";
      }
    }
    if (isDir || isSymlink) {
      data.store = true;
    }
    data.date = util.dateify(data.date);
    return data;
  };
  ZipStream.prototype.entry = function(source, data, callback) {
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    data = this._normalizeFileData(data);
    if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
      callback(new Error(data.type + " entries not currently supported"));
      return;
    }
    if (typeof data.name !== "string" || data.name.length === 0) {
      callback(new Error("entry name must be a non-empty string value"));
      return;
    }
    if (data.type === "symlink" && typeof data.linkname !== "string") {
      callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
      return;
    }
    var entry = new ZipArchiveEntry(data.name);
    entry.setTime(data.date, this.options.forceLocalTime);
    if (data.namePrependSlash) {
      entry.setName(data.name, true);
    }
    if (data.store) {
      entry.setMethod(0);
    }
    if (data.comment.length > 0) {
      entry.setComment(data.comment);
    }
    if (data.type === "symlink" && typeof data.mode !== "number") {
      data.mode = 40960;
    }
    if (typeof data.mode === "number") {
      if (data.type === "symlink") {
        data.mode |= 40960;
      }
      entry.setUnixMode(data.mode);
    }
    if (data.type === "symlink" && typeof data.linkname === "string") {
      source = Buffer.from(data.linkname);
    }
    return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
  };
  ZipStream.prototype.finalize = function() {
    this.finish();
  };
});

// node_modules/archiver/lib/plugins/zip.js
var require_zip = __commonJS((exports, module) => {
  var engine = require_zip_stream();
  var util = require_archiver_utils();
  var Zip = function(options) {
    if (!(this instanceof Zip)) {
      return new Zip(options);
    }
    options = this.options = util.defaults(options, {
      comment: "",
      forceUTC: false,
      namePrependSlash: false,
      store: false
    });
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = new engine(options);
  };
  Zip.prototype.append = function(source, data, callback) {
    this.engine.entry(source, data, callback);
  };
  Zip.prototype.finalize = function() {
    this.engine.finalize();
  };
  Zip.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Zip.prototype.pipe = function() {
    return this.engine.pipe.apply(this.engine, arguments);
  };
  Zip.prototype.unpipe = function() {
    return this.engine.unpipe.apply(this.engine, arguments);
  };
  module.exports = Zip;
});

// node_modules/archiver/lib/plugins/tar.js
var require_tar = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var engine = require_tar_stream();
  var util = require_archiver_utils();
  var Tar = function(options) {
    if (!(this instanceof Tar)) {
      return new Tar(options);
    }
    options = this.options = util.defaults(options, {
      gzip: false
    });
    if (typeof options.gzipOptions !== "object") {
      options.gzipOptions = {};
    }
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = engine.pack(options);
    this.compressor = false;
    if (options.gzip) {
      this.compressor = zlib.createGzip(options.gzipOptions);
      this.compressor.on("error", this._onCompressorError.bind(this));
    }
  };
  Tar.prototype._onCompressorError = function(err) {
    this.engine.emit("error", err);
  };
  Tar.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.mtime = data.date;
    function append(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      self2.engine.entry(data, sourceBuffer, function(err2) {
        callback(err2, data);
      });
    }
    if (data.sourceType === "buffer") {
      append(null, source);
    } else if (data.sourceType === "stream" && data.stats) {
      data.size = data.stats.size;
      var entry = self2.engine.entry(data, function(err) {
        callback(err, data);
      });
      source.pipe(entry);
    } else if (data.sourceType === "stream") {
      util.collectStream(source, append);
    }
  };
  Tar.prototype.finalize = function() {
    this.engine.finalize();
  };
  Tar.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Tar.prototype.pipe = function(destination, options) {
    if (this.compressor) {
      return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
    } else {
      return this.engine.pipe.apply(this.engine, arguments);
    }
  };
  Tar.prototype.unpipe = function() {
    if (this.compressor) {
      return this.compressor.unpipe.apply(this.compressor, arguments);
    } else {
      return this.engine.unpipe.apply(this.engine, arguments);
    }
  };
  module.exports = Tar;
});

// node_modules/archiver/lib/plugins/json.js
var require_json2 = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var Transform = require_readable().Transform;
  var crc32 = require_buffer_crc32();
  var util = require_archiver_utils();
  var Json = function(options) {
    if (!(this instanceof Json)) {
      return new Json(options);
    }
    options = this.options = util.defaults(options, {});
    Transform.call(this, options);
    this.supports = {
      directory: true,
      symlink: true
    };
    this.files = [];
  };
  inherits(Json, Transform);
  Json.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  Json.prototype._writeStringified = function() {
    var fileString = JSON.stringify(this.files);
    this.write(fileString);
  };
  Json.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.crc32 = 0;
    function onend(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      data.size = sourceBuffer.length || 0;
      data.crc32 = crc32.unsigned(sourceBuffer);
      self2.files.push(data);
      callback(null, data);
    }
    if (data.sourceType === "buffer") {
      onend(null, source);
    } else if (data.sourceType === "stream") {
      util.collectStream(source, onend);
    }
  };
  Json.prototype.finalize = function() {
    this._writeStringified();
    this.end();
  };
  module.exports = Json;
});

// node_modules/archiver/index.js
var require_archiver = __commonJS((exports, module) => {
  var Archiver = require_core();
  var formats = {};
  var vending = function(format, options) {
    return vending.create(format, options);
  };
  vending.create = function(format, options) {
    if (formats[format]) {
      var instance = new Archiver(format, options);
      instance.setFormat(format);
      instance.setModule(new formats[format](options));
      return instance;
    } else {
      throw new Error("create(" + format + "): format not registered");
    }
  };
  vending.registerFormat = function(format, module2) {
    if (formats[format]) {
      throw new Error("register(" + format + "): format already registered");
    }
    if (typeof module2 !== "function") {
      throw new Error("register(" + format + "): format module invalid");
    }
    if (typeof module2.prototype.append !== "function" || typeof module2.prototype.finalize !== "function") {
      throw new Error("register(" + format + "): format module missing methods");
    }
    formats[format] = module2;
  };
  vending.isRegisteredFormat = function(format) {
    if (formats[format]) {
      return true;
    }
    return false;
  };
  vending.registerFormat("zip", require_zip());
  vending.registerFormat("tar", require_tar());
  vending.registerFormat("json", require_json2());
  module.exports = vending;
});

// node_modules/whatsapp-web.js/src/authStrategies/RemoteAuth.js
var require_RemoteAuth = __commonJS((exports, module) => {
  try {
    fs = require_lib4();
    unzipper = require_unzip2();
    archiver = require_archiver();
  } catch {
    fs = undefined;
    unzipper = undefined;
    archiver = undefined;
  }
  var fs;
  var unzipper;
  var archiver;
  var path = __require("path");
  var { Events } = require_Constants();
  var BaseAuthStrategy = require_BaseAuthStrategy();

  class RemoteAuth extends BaseAuthStrategy {
    constructor({ clientId, dataPath, store, backupSyncIntervalMs, rmMaxRetries } = {}) {
      if (!fs && !unzipper && !archiver)
        throw new Error("Optional Dependencies [fs-extra, unzipper, archiver] are required to use RemoteAuth. Make sure to run npm install correctly and remove the --no-optional flag");
      super();
      const idRegex = /^[-_\w]+$/i;
      if (clientId && !idRegex.test(clientId)) {
        throw new Error("Invalid clientId. Only alphanumeric characters, underscores and hyphens are allowed.");
      }
      if (!backupSyncIntervalMs || backupSyncIntervalMs < 60000) {
        throw new Error("Invalid backupSyncIntervalMs. Accepts values starting from 60000ms {1 minute}.");
      }
      if (!store)
        throw new Error("Remote database store is required.");
      this.store = store;
      this.clientId = clientId;
      this.backupSyncIntervalMs = backupSyncIntervalMs;
      this.dataPath = path.resolve(dataPath || "./.wwebjs_auth/");
      this.tempDir = `${this.dataPath}/wwebjs_temp_session_${this.clientId}`;
      this.requiredDirs = ["Default", "IndexedDB", "Local Storage"];
      this.rmMaxRetries = rmMaxRetries ?? 4;
    }
    async beforeBrowserInitialized() {
      const puppeteerOpts = this.client.options.puppeteer;
      const sessionDirName = this.clientId ? `RemoteAuth-${this.clientId}` : "RemoteAuth";
      const dirPath = path.join(this.dataPath, sessionDirName);
      if (puppeteerOpts.userDataDir && puppeteerOpts.userDataDir !== dirPath) {
        throw new Error("RemoteAuth is not compatible with a user-supplied userDataDir.");
      }
      this.userDataDir = dirPath;
      this.sessionName = sessionDirName;
      await this.extractRemoteSession();
      this.client.options.puppeteer = {
        ...puppeteerOpts,
        userDataDir: dirPath
      };
    }
    async logout() {
      await this.disconnect();
    }
    async destroy() {
      clearInterval(this.backupSync);
    }
    async disconnect() {
      await this.deleteRemoteSession();
      let pathExists = await this.isValidPath(this.userDataDir);
      if (pathExists) {
        await fs.promises.rm(this.userDataDir, {
          recursive: true,
          force: true,
          maxRetries: this.rmMaxRetries
        }).catch(() => {});
      }
      clearInterval(this.backupSync);
    }
    async afterAuthReady() {
      const sessionExists = await this.store.sessionExists({ session: this.sessionName });
      if (!sessionExists) {
        await this.delay(60000);
        await this.storeRemoteSession({ emit: true });
      }
      var self2 = this;
      this.backupSync = setInterval(async function() {
        await self2.storeRemoteSession();
      }, this.backupSyncIntervalMs);
    }
    async storeRemoteSession(options) {
      const pathExists = await this.isValidPath(this.userDataDir);
      if (pathExists) {
        await this.compressSession();
        await this.store.save({ session: this.sessionName });
        await fs.promises.unlink(`${this.sessionName}.zip`);
        await fs.promises.rm(`${this.tempDir}`, {
          recursive: true,
          force: true,
          maxRetries: this.rmMaxRetries
        }).catch(() => {});
        if (options && options.emit)
          this.client.emit(Events.REMOTE_SESSION_SAVED);
      }
    }
    async extractRemoteSession() {
      const pathExists = await this.isValidPath(this.userDataDir);
      const compressedSessionPath = `${this.sessionName}.zip`;
      const sessionExists = await this.store.sessionExists({ session: this.sessionName });
      if (pathExists) {
        await fs.promises.rm(this.userDataDir, {
          recursive: true,
          force: true,
          maxRetries: this.rmMaxRetries
        }).catch(() => {});
      }
      if (sessionExists) {
        await this.store.extract({ session: this.sessionName, path: compressedSessionPath });
        await this.unCompressSession(compressedSessionPath);
      } else {
        fs.mkdirSync(this.userDataDir, { recursive: true });
      }
    }
    async deleteRemoteSession() {
      const sessionExists = await this.store.sessionExists({ session: this.sessionName });
      if (sessionExists)
        await this.store.delete({ session: this.sessionName });
    }
    async compressSession() {
      const archive = archiver("zip");
      const stream = fs.createWriteStream(`${this.sessionName}.zip`);
      await fs.copy(this.userDataDir, this.tempDir).catch(() => {});
      await this.deleteMetadata();
      return new Promise((resolve, reject) => {
        archive.directory(this.tempDir, false).on("error", (err) => reject(err)).pipe(stream);
        stream.on("close", () => resolve());
        archive.finalize();
      });
    }
    async unCompressSession(compressedSessionPath) {
      var stream = fs.createReadStream(compressedSessionPath);
      await new Promise((resolve, reject) => {
        stream.pipe(unzipper.Extract({
          path: this.userDataDir
        })).on("error", (err) => reject(err)).on("finish", () => resolve());
      });
      await fs.promises.unlink(compressedSessionPath);
    }
    async deleteMetadata() {
      const sessionDirs = [this.tempDir, path.join(this.tempDir, "Default")];
      for (const dir of sessionDirs) {
        const sessionFiles = await fs.promises.readdir(dir);
        for (const element of sessionFiles) {
          if (!this.requiredDirs.includes(element)) {
            const dirElement = path.join(dir, element);
            const stats = await fs.promises.lstat(dirElement);
            if (stats.isDirectory()) {
              await fs.promises.rm(dirElement, {
                recursive: true,
                force: true,
                maxRetries: this.rmMaxRetries
              }).catch(() => {});
            } else {
              await fs.promises.unlink(dirElement).catch(() => {});
            }
          }
        }
      }
    }
    async isValidPath(path2) {
      try {
        await fs.promises.access(path2);
        return true;
      } catch {
        return false;
      }
    }
    async delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  }
  module.exports = RemoteAuth;
});

// node_modules/whatsapp-web.js/index.js
var require_whatsapp_web = __commonJS((exports, module) => {
  var Constants = require_Constants();
  module.exports = {
    Client: require_Client(),
    version: require_package().version,
    Chat: require_Chat(),
    PrivateChat: require_PrivateChat(),
    GroupChat: require_GroupChat(),
    Channel: require_Channel(),
    Message: require_Message(),
    MessageMedia: require_MessageMedia(),
    Contact: require_Contact(),
    PrivateContact: require_PrivateContact(),
    BusinessContact: require_BusinessContact(),
    ClientInfo: require_ClientInfo(),
    Location: require_Location(),
    Poll: require_Poll(),
    ProductMetadata: require_ProductMetadata(),
    List: require_List(),
    Buttons: require_Buttons(),
    Broadcast: require_Broadcast(),
    NoAuth: require_NoAuth(),
    LocalAuth: require_LocalAuth(),
    RemoteAuth: require_RemoteAuth(),
    ...Constants
  };
});

// node_modules/qrcode-terminal/vendor/QRCode/QRMode.js
var require_QRMode = __commonJS((exports, module) => {
  module.exports = {
    MODE_NUMBER: 1 << 0,
    MODE_ALPHA_NUM: 1 << 1,
    MODE_8BIT_BYTE: 1 << 2,
    MODE_KANJI: 1 << 3
  };
});

// node_modules/qrcode-terminal/vendor/QRCode/QR8bitByte.js
var require_QR8bitByte = __commonJS((exports, module) => {
  var QRMode = require_QRMode();
  function QR8bitByte(data) {
    this.mode = QRMode.MODE_8BIT_BYTE;
    this.data = data;
  }
  QR8bitByte.prototype = {
    getLength: function() {
      return this.data.length;
    },
    write: function(buffer) {
      for (var i = 0;i < this.data.length; i++) {
        buffer.put(this.data.charCodeAt(i), 8);
      }
    }
  };
  module.exports = QR8bitByte;
});

// node_modules/qrcode-terminal/vendor/QRCode/QRMath.js
var require_QRMath = __commonJS((exports, module) => {
  var QRMath = {
    glog: function(n) {
      if (n < 1) {
        throw new Error("glog(" + n + ")");
      }
      return QRMath.LOG_TABLE[n];
    },
    gexp: function(n) {
      while (n < 0) {
        n += 255;
      }
      while (n >= 256) {
        n -= 255;
      }
      return QRMath.EXP_TABLE[n];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256)
  };
  for (i = 0;i < 8; i++) {
    QRMath.EXP_TABLE[i] = 1 << i;
  }
  var i;
  for (i = 8;i < 256; i++) {
    QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
  }
  var i;
  for (i = 0;i < 255; i++) {
    QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
  }
  var i;
  module.exports = QRMath;
});

// node_modules/qrcode-terminal/vendor/QRCode/QRPolynomial.js
var require_QRPolynomial = __commonJS((exports, module) => {
  var QRMath = require_QRMath();
  function QRPolynomial(num, shift) {
    if (num.length === undefined) {
      throw new Error(num.length + "/" + shift);
    }
    var offset = 0;
    while (offset < num.length && num[offset] === 0) {
      offset++;
    }
    this.num = new Array(num.length - offset + shift);
    for (var i = 0;i < num.length - offset; i++) {
      this.num[i] = num[i + offset];
    }
  }
  QRPolynomial.prototype = {
    get: function(index) {
      return this.num[index];
    },
    getLength: function() {
      return this.num.length;
    },
    multiply: function(e) {
      var num = new Array(this.getLength() + e.getLength() - 1);
      for (var i = 0;i < this.getLength(); i++) {
        for (var j = 0;j < e.getLength(); j++) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
        }
      }
      return new QRPolynomial(num, 0);
    },
    mod: function(e) {
      if (this.getLength() - e.getLength() < 0) {
        return this;
      }
      var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
      var num = new Array(this.getLength());
      for (var i = 0;i < this.getLength(); i++) {
        num[i] = this.get(i);
      }
      for (var x = 0;x < e.getLength(); x++) {
        num[x] ^= QRMath.gexp(QRMath.glog(e.get(x)) + ratio);
      }
      return new QRPolynomial(num, 0).mod(e);
    }
  };
  module.exports = QRPolynomial;
});

// node_modules/qrcode-terminal/vendor/QRCode/QRMaskPattern.js
var require_QRMaskPattern = __commonJS((exports, module) => {
  module.exports = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
});

// node_modules/qrcode-terminal/vendor/QRCode/QRUtil.js
var require_QRUtil = __commonJS((exports, module) => {
  var QRMode = require_QRMode();
  var QRPolynomial = require_QRPolynomial();
  var QRMath = require_QRMath();
  var QRMaskPattern = require_QRMaskPattern();
  var QRUtil = {
    PATTERN_POSITION_TABLE: [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ],
    G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
    G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
    G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
    getBCHTypeInfo: function(data) {
      var d = data << 10;
      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d ^= QRUtil.G15 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15);
      }
      return (data << 10 | d) ^ QRUtil.G15_MASK;
    },
    getBCHTypeNumber: function(data) {
      var d = data << 12;
      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d ^= QRUtil.G18 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18);
      }
      return data << 12 | d;
    },
    getBCHDigit: function(data) {
      var digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    },
    getPatternPosition: function(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },
    getMask: function(maskPattern, i, j) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i + j) % 2 === 0;
        case QRMaskPattern.PATTERN001:
          return i % 2 === 0;
        case QRMaskPattern.PATTERN010:
          return j % 3 === 0;
        case QRMaskPattern.PATTERN011:
          return (i + j) % 3 === 0;
        case QRMaskPattern.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case QRMaskPattern.PATTERN101:
          return i * j % 2 + i * j % 3 === 0;
        case QRMaskPattern.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 === 0;
        case QRMaskPattern.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    },
    getErrorCorrectPolynomial: function(errorCorrectLength) {
      var a = new QRPolynomial([1], 0);
      for (var i = 0;i < errorCorrectLength; i++) {
        a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
      }
      return a;
    },
    getLengthInBits: function(mode, type) {
      if (1 <= type && type < 10) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 10;
          case QRMode.MODE_ALPHA_NUM:
            return 9;
          case QRMode.MODE_8BIT_BYTE:
            return 8;
          case QRMode.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 27) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 12;
          case QRMode.MODE_ALPHA_NUM:
            return 11;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 41) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 14;
          case QRMode.MODE_ALPHA_NUM:
            return 13;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + mode);
        }
      } else {
        throw new Error("type:" + type);
      }
    },
    getLostPoint: function(qrCode) {
      var moduleCount = qrCode.getModuleCount();
      var lostPoint = 0;
      var row = 0;
      var col = 0;
      for (row = 0;row < moduleCount; row++) {
        for (col = 0;col < moduleCount; col++) {
          var sameCount = 0;
          var dark = qrCode.isDark(row, col);
          for (var r = -1;r <= 1; r++) {
            if (row + r < 0 || moduleCount <= row + r) {
              continue;
            }
            for (var c = -1;c <= 1; c++) {
              if (col + c < 0 || moduleCount <= col + c) {
                continue;
              }
              if (r === 0 && c === 0) {
                continue;
              }
              if (dark === qrCode.isDark(row + r, col + c)) {
                sameCount++;
              }
            }
          }
          if (sameCount > 5) {
            lostPoint += 3 + sameCount - 5;
          }
        }
      }
      for (row = 0;row < moduleCount - 1; row++) {
        for (col = 0;col < moduleCount - 1; col++) {
          var count = 0;
          if (qrCode.isDark(row, col))
            count++;
          if (qrCode.isDark(row + 1, col))
            count++;
          if (qrCode.isDark(row, col + 1))
            count++;
          if (qrCode.isDark(row + 1, col + 1))
            count++;
          if (count === 0 || count === 4) {
            lostPoint += 3;
          }
        }
      }
      for (row = 0;row < moduleCount; row++) {
        for (col = 0;col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
            lostPoint += 40;
          }
        }
      }
      for (col = 0;col < moduleCount; col++) {
        for (row = 0;row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
            lostPoint += 40;
          }
        }
      }
      var darkCount = 0;
      for (col = 0;col < moduleCount; col++) {
        for (row = 0;row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) {
            darkCount++;
          }
        }
      }
      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    }
  };
  module.exports = QRUtil;
});

// node_modules/qrcode-terminal/vendor/QRCode/QRErrorCorrectLevel.js
var require_QRErrorCorrectLevel = __commonJS((exports, module) => {
  module.exports = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
  };
});

// node_modules/qrcode-terminal/vendor/QRCode/QRRSBlock.js
var require_QRRSBlock = __commonJS((exports, module) => {
  var QRErrorCorrectLevel = require_QRErrorCorrectLevel();
  function QRRSBlock(totalCount, dataCount) {
    this.totalCount = totalCount;
    this.dataCount = dataCount;
  }
  QRRSBlock.RS_BLOCK_TABLE = [
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12],
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16]
  ];
  QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
    var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
    if (rsBlock === undefined) {
      throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
    }
    var length = rsBlock.length / 3;
    var list = [];
    for (var i = 0;i < length; i++) {
      var count = rsBlock[i * 3 + 0];
      var totalCount = rsBlock[i * 3 + 1];
      var dataCount = rsBlock[i * 3 + 2];
      for (var j = 0;j < count; j++) {
        list.push(new QRRSBlock(totalCount, dataCount));
      }
    }
    return list;
  };
  QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
    switch (errorCorrectLevel) {
      case QRErrorCorrectLevel.L:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case QRErrorCorrectLevel.M:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case QRErrorCorrectLevel.Q:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case QRErrorCorrectLevel.H:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default:
        return;
    }
  };
  module.exports = QRRSBlock;
});

// node_modules/qrcode-terminal/vendor/QRCode/QRBitBuffer.js
var require_QRBitBuffer = __commonJS((exports, module) => {
  function QRBitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  QRBitBuffer.prototype = {
    get: function(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
    },
    put: function(num, length) {
      for (var i = 0;i < length; i++) {
        this.putBit((num >>> length - i - 1 & 1) == 1);
      }
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    }
  };
  module.exports = QRBitBuffer;
});

// node_modules/qrcode-terminal/vendor/QRCode/index.js
var require_QRCode = __commonJS((exports, module) => {
  var QR8bitByte = require_QR8bitByte();
  var QRUtil = require_QRUtil();
  var QRPolynomial = require_QRPolynomial();
  var QRRSBlock = require_QRRSBlock();
  var QRBitBuffer = require_QRBitBuffer();
  function QRCode(typeNumber, errorCorrectLevel) {
    this.typeNumber = typeNumber;
    this.errorCorrectLevel = errorCorrectLevel;
    this.modules = null;
    this.moduleCount = 0;
    this.dataCache = null;
    this.dataList = [];
  }
  QRCode.prototype = {
    addData: function(data) {
      var newData = new QR8bitByte(data);
      this.dataList.push(newData);
      this.dataCache = null;
    },
    isDark: function(row, col) {
      if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
        throw new Error(row + "," + col);
      }
      return this.modules[row][col];
    },
    getModuleCount: function() {
      return this.moduleCount;
    },
    make: function() {
      if (this.typeNumber < 1) {
        var typeNumber = 1;
        for (typeNumber = 1;typeNumber < 40; typeNumber++) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
          var buffer = new QRBitBuffer;
          var totalDataCount = 0;
          for (var i = 0;i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
          }
          for (var x = 0;x < this.dataList.length; x++) {
            var data = this.dataList[x];
            buffer.put(data.mode, 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
            data.write(buffer);
          }
          if (buffer.getLengthInBits() <= totalDataCount * 8)
            break;
        }
        this.typeNumber = typeNumber;
      }
      this.makeImpl(false, this.getBestMaskPattern());
    },
    makeImpl: function(test, maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (var row = 0;row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
        for (var col = 0;col < this.moduleCount; col++) {
          this.modules[row][col] = null;
        }
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(test, maskPattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(test);
      }
      if (this.dataCache === null) {
        this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      }
      this.mapData(this.dataCache, maskPattern);
    },
    setupPositionProbePattern: function(row, col) {
      for (var r = -1;r <= 7; r++) {
        if (row + r <= -1 || this.moduleCount <= row + r)
          continue;
        for (var c = -1;c <= 7; c++) {
          if (col + c <= -1 || this.moduleCount <= col + c)
            continue;
          if (0 <= r && r <= 6 && (c === 0 || c === 6) || 0 <= c && c <= 6 && (r === 0 || r === 6) || 2 <= r && r <= 4 && 2 <= c && c <= 4) {
            this.modules[row + r][col + c] = true;
          } else {
            this.modules[row + r][col + c] = false;
          }
        }
      }
    },
    getBestMaskPattern: function() {
      var minLostPoint = 0;
      var pattern = 0;
      for (var i = 0;i < 8; i++) {
        this.makeImpl(true, i);
        var lostPoint = QRUtil.getLostPoint(this);
        if (i === 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
        }
      }
      return pattern;
    },
    createMovieClip: function(target_mc, instance_name, depth) {
      var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
      var cs = 1;
      this.make();
      for (var row = 0;row < this.modules.length; row++) {
        var y = row * cs;
        for (var col = 0;col < this.modules[row].length; col++) {
          var x = col * cs;
          var dark = this.modules[row][col];
          if (dark) {
            qr_mc.beginFill(0, 100);
            qr_mc.moveTo(x, y);
            qr_mc.lineTo(x + cs, y);
            qr_mc.lineTo(x + cs, y + cs);
            qr_mc.lineTo(x, y + cs);
            qr_mc.endFill();
          }
        }
      }
      return qr_mc;
    },
    setupTimingPattern: function() {
      for (var r = 8;r < this.moduleCount - 8; r++) {
        if (this.modules[r][6] !== null) {
          continue;
        }
        this.modules[r][6] = r % 2 === 0;
      }
      for (var c = 8;c < this.moduleCount - 8; c++) {
        if (this.modules[6][c] !== null) {
          continue;
        }
        this.modules[6][c] = c % 2 === 0;
      }
    },
    setupPositionAdjustPattern: function() {
      var pos = QRUtil.getPatternPosition(this.typeNumber);
      for (var i = 0;i < pos.length; i++) {
        for (var j = 0;j < pos.length; j++) {
          var row = pos[i];
          var col = pos[j];
          if (this.modules[row][col] !== null) {
            continue;
          }
          for (var r = -2;r <= 2; r++) {
            for (var c = -2;c <= 2; c++) {
              if (Math.abs(r) === 2 || Math.abs(c) === 2 || r === 0 && c === 0) {
                this.modules[row + r][col + c] = true;
              } else {
                this.modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    },
    setupTypeNumber: function(test) {
      var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
      var mod2;
      for (var i = 0;i < 18; i++) {
        mod2 = !test && (bits >> i & 1) === 1;
        this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod2;
      }
      for (var x = 0;x < 18; x++) {
        mod2 = !test && (bits >> x & 1) === 1;
        this.modules[x % 3 + this.moduleCount - 8 - 3][Math.floor(x / 3)] = mod2;
      }
    },
    setupTypeInfo: function(test, maskPattern) {
      var data = this.errorCorrectLevel << 3 | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);
      var mod2;
      for (var v = 0;v < 15; v++) {
        mod2 = !test && (bits >> v & 1) === 1;
        if (v < 6) {
          this.modules[v][8] = mod2;
        } else if (v < 8) {
          this.modules[v + 1][8] = mod2;
        } else {
          this.modules[this.moduleCount - 15 + v][8] = mod2;
        }
      }
      for (var h = 0;h < 15; h++) {
        mod2 = !test && (bits >> h & 1) === 1;
        if (h < 8) {
          this.modules[8][this.moduleCount - h - 1] = mod2;
        } else if (h < 9) {
          this.modules[8][15 - h - 1 + 1] = mod2;
        } else {
          this.modules[8][15 - h - 1] = mod2;
        }
      }
      this.modules[this.moduleCount - 8][8] = !test;
    },
    mapData: function(data, maskPattern) {
      var inc = -1;
      var row = this.moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = this.moduleCount - 1;col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (var c = 0;c < 2; c++) {
            if (this.modules[row][col - c] === null) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              var mask = QRUtil.getMask(maskPattern, row, col - c);
              if (mask) {
                dark = !dark;
              }
              this.modules[row][col - c] = dark;
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
  };
  QRCode.PAD0 = 236;
  QRCode.PAD1 = 17;
  QRCode.createData = function(typeNumber, errorCorrectLevel, dataList) {
    var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
    var buffer = new QRBitBuffer;
    for (var i = 0;i < dataList.length; i++) {
      var data = dataList[i];
      buffer.put(data.mode, 4);
      buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
      data.write(buffer);
    }
    var totalDataCount = 0;
    for (var x = 0;x < rsBlocks.length; x++) {
      totalDataCount += rsBlocks[x].dataCount;
    }
    if (buffer.getLengthInBits() > totalDataCount * 8) {
      throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
    }
    if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
      buffer.put(0, 4);
    }
    while (buffer.getLengthInBits() % 8 !== 0) {
      buffer.putBit(false);
    }
    while (true) {
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }
      buffer.put(QRCode.PAD0, 8);
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }
      buffer.put(QRCode.PAD1, 8);
    }
    return QRCode.createBytes(buffer, rsBlocks);
  };
  QRCode.createBytes = function(buffer, rsBlocks) {
    var offset = 0;
    var maxDcCount = 0;
    var maxEcCount = 0;
    var dcdata = new Array(rsBlocks.length);
    var ecdata = new Array(rsBlocks.length);
    for (var r = 0;r < rsBlocks.length; r++) {
      var dcCount = rsBlocks[r].dataCount;
      var ecCount = rsBlocks[r].totalCount - dcCount;
      maxDcCount = Math.max(maxDcCount, dcCount);
      maxEcCount = Math.max(maxEcCount, ecCount);
      dcdata[r] = new Array(dcCount);
      for (var i = 0;i < dcdata[r].length; i++) {
        dcdata[r][i] = 255 & buffer.buffer[i + offset];
      }
      offset += dcCount;
      var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
      var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
      var modPoly = rawPoly.mod(rsPoly);
      ecdata[r] = new Array(rsPoly.getLength() - 1);
      for (var x = 0;x < ecdata[r].length; x++) {
        var modIndex = x + modPoly.getLength() - ecdata[r].length;
        ecdata[r][x] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
      }
    }
    var totalCodeCount = 0;
    for (var y = 0;y < rsBlocks.length; y++) {
      totalCodeCount += rsBlocks[y].totalCount;
    }
    var data = new Array(totalCodeCount);
    var index = 0;
    for (var z = 0;z < maxDcCount; z++) {
      for (var s = 0;s < rsBlocks.length; s++) {
        if (z < dcdata[s].length) {
          data[index++] = dcdata[s][z];
        }
      }
    }
    for (var xx = 0;xx < maxEcCount; xx++) {
      for (var t = 0;t < rsBlocks.length; t++) {
        if (xx < ecdata[t].length) {
          data[index++] = ecdata[t][xx];
        }
      }
    }
    return data;
  };
  module.exports = QRCode;
});

// node_modules/qrcode-terminal/lib/main.js
var require_main = __commonJS((exports, module) => {
  var QRCode = require_QRCode();
  var QRErrorCorrectLevel = require_QRErrorCorrectLevel();
  var black = "\x1B[40m  \x1B[0m";
  var white = "\x1B[47m  \x1B[0m";
  var toCell = function(isBlack) {
    return isBlack ? black : white;
  };
  var repeat = function(color) {
    return {
      times: function(count) {
        return new Array(count).join(color);
      }
    };
  };
  var fill = function(length, value) {
    var arr = new Array(length);
    for (var i = 0;i < length; i++) {
      arr[i] = value;
    }
    return arr;
  };
  module.exports = {
    error: QRErrorCorrectLevel.L,
    generate: function(input, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      var qrcode = new QRCode(-1, this.error);
      qrcode.addData(input);
      qrcode.make();
      var output = "";
      if (opts && opts.small) {
        var BLACK = true, WHITE = false;
        var moduleCount = qrcode.getModuleCount();
        var moduleData = qrcode.modules.slice();
        var oddRow = moduleCount % 2 === 1;
        if (oddRow) {
          moduleData.push(fill(moduleCount, WHITE));
        }
        var platte = {
          WHITE_ALL: "█",
          WHITE_BLACK: "▀",
          BLACK_WHITE: "▄",
          BLACK_ALL: " "
        };
        var borderTop = repeat(platte.BLACK_WHITE).times(moduleCount + 3);
        var borderBottom = repeat(platte.WHITE_BLACK).times(moduleCount + 3);
        output += borderTop + `
`;
        for (var row = 0;row < moduleCount; row += 2) {
          output += platte.WHITE_ALL;
          for (var col = 0;col < moduleCount; col++) {
            if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === WHITE) {
              output += platte.WHITE_ALL;
            } else if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === BLACK) {
              output += platte.WHITE_BLACK;
            } else if (moduleData[row][col] === BLACK && moduleData[row + 1][col] === WHITE) {
              output += platte.BLACK_WHITE;
            } else {
              output += platte.BLACK_ALL;
            }
          }
          output += platte.WHITE_ALL + `
`;
        }
        if (!oddRow) {
          output += borderBottom;
        }
      } else {
        var border = repeat(white).times(qrcode.getModuleCount() + 3);
        output += border + `
`;
        qrcode.modules.forEach(function(row2) {
          output += white;
          output += row2.map(toCell).join("");
          output += white + `
`;
        });
        output += border;
      }
      if (cb)
        cb(output);
      else
        console.log(output);
    },
    setErrorLevel: function(error) {
      this.error = QRErrorCorrectLevel[error] || this.error;
    }
  };
});

// main.ts
import { existsSync } from "fs";

// base/log.ts
function log(message) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${message}`);
}

// main.ts
var import_whatsapp_web = __toESM(require_whatsapp_web(), 1);
var qrcode = __toESM(require_main(), 1);
import * as fs3 from "fs";

// commandHandler.ts
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
var __filename2 = fileURLToPath(import.meta.url);
var __dirname2 = path.dirname(__filename2);
var prefix = "!";
var commands = new Map;
var commandsPath = path.join(__dirname2, "commands");
var commandVersions = new Map;
function getFileHash(filePath) {
  try {
    const content = fs.readFileSync(filePath, "utf8");
    return Buffer.from(content).toString("base64").slice(0, 20);
  } catch (error) {
    return "error-reading-file";
  }
}
function hasCommandChanged(commandName, filePath) {
  const newHash = getFileHash(filePath);
  const oldHash = commandVersions.get(commandName);
  if (newHash !== oldHash) {
    console.log(`Command ${commandName} content changed: ${oldHash} -> ${newHash}`);
    commandVersions.set(commandName, newHash);
    return true;
  }
  console.log(`Command ${commandName} unchanged (hash: ${newHash})`);
  return false;
}
async function loadCommand(commandName, force = false) {
  const extensions = [".js", ".ts"];
  for (const ext of extensions) {
    const filePath = path.join(commandsPath, `${commandName}${ext}`);
    if (fs.existsSync(filePath)) {
      if (!force && !hasCommandChanged(commandName, filePath)) {
        console.log(`Skipping reload of unchanged command: ${commandName}`);
        return true;
      }
      try {
        console.log(`FORCE RELOADING command: ${commandName}`);
        const tempDir = path.join(__dirname2, "cache");
        if (!fs.existsSync(tempDir)) {
          fs.mkdirSync(tempDir, { recursive: true });
        }
        const tempFile = path.join(tempDir, `${commandName}_${Date.now()}${ext}`);
        fs.copyFileSync(filePath, tempFile);
        const importPath = `file://${tempFile}`;
        const commandModule = await import(importPath);
        if (commandModule.default && commandModule.default.name) {
          commands.set(commandModule.default.name, commandModule.default);
          console.log(`✅ Successfully loaded command: ${commandModule.default.name} (${new Date().toISOString()})`);
          setTimeout(() => {
            try {
              fs.unlinkSync(tempFile);
            } catch (e) {}
          }, 1000);
          return true;
        } else {
          console.error(`Invalid command module structure in ${commandName}`);
        }
      } catch (error) {
        console.error(`Error loading command ${commandName}:`, error);
      }
      break;
    }
  }
  return false;
}
async function loadAllCommands() {
  if (!fs.existsSync(commandsPath)) {
    fs.mkdirSync(commandsPath, { recursive: true });
    console.log(`Created commands directory: ${commandsPath}`);
  }
  const tempDir = path.join(__dirname2, "temp");
  if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true });
  }
  const commandFiles = fs.readdirSync(commandsPath).filter((file) => file.endsWith(".js") || file.endsWith(".ts"));
  commands.clear();
  for (const file of commandFiles) {
    const commandName = path.basename(file).split(".")[0];
    await loadCommand(commandName, true);
  }
  console.log(`Loaded ${commands.size} commands: ${Array.from(commands.keys()).join(", ")}`);
}
async function handleChat(message) {
  const chatId = message.from;
  console.log(`Chat message received from: ${chatId}`);
  console.log(`Message content: ${message.body}`);
}
async function processMessage(message) {
  if (!message.body.startsWith(prefix)) {
    await handleChat(message);
    return;
  }
  const args = message.body.slice(prefix.length).trim().split(/\s+/);
  const commandName = args.shift()?.toLowerCase();
  if (!commandName) {
    await handleChat(message);
    return;
  }
  if (commandName === "reload") {
    const targetCommand = args[0];
    if (!targetCommand) {
      await message.reply("Reloading all commands...");
      await loadAllCommands();
      await message.reply(`Reloaded ${commands.size} commands: ${Array.from(commands.keys()).join(", ")}`);
      return;
    }
    await message.reply(`Reloading command: ${targetCommand}`);
    const success = await loadCommand(targetCommand, true);
    if (success) {
      await message.reply(`Command "${targetCommand}" reloaded successfully`);
    } else {
      await message.reply(`Failed to reload "${targetCommand}" - command file not found`);
    }
    return;
  }
  const command = commands.get(commandName);
  if (!command) {
    console.log(`Command not found: ${commandName}`);
    await handleChat(message);
    return;
  }
  try {
    console.log(`Executing command: ${commandName}`);
    await command.execute(message, args);
  } catch (error) {
    console.error(`Error executing command '${commandName}':`, error);
    await message.reply("There was an error executing that command!");
  }
}
function setupCommandWatcher() {
  fs.watch(commandsPath, async (eventType, filename) => {
    if (!filename)
      return;
    if (filename.endsWith(".js") || filename.endsWith(".ts")) {
      const commandName = path.basename(filename).split(".")[0];
      console.log(`Detected ${eventType} in ${filename}, reloading command ${commandName}...`);
      setTimeout(async () => {
        const success = await loadCommand(commandName, true);
        if (success) {
          console.log(`✅ Auto-reloaded command: ${commandName}`);
        } else {
          console.error(`❌ Failed to auto-reload command: ${commandName}`);
        }
      }, 200);
    }
  });
  console.log(`Watching for changes in ${commandsPath}`);
}

// Jobs/jobManager.ts
import fs2 from "fs/promises";
import path2 from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import EventEmitter from "events";
var __filename3 = fileURLToPath2(import.meta.url);
var __dirname3 = path2.dirname(__filename3);

class JobManager extends EventEmitter {
  jobs = new Map;
  cachePath;
  checkInterval = null;
  constructor() {
    super();
    this.cachePath = path2.join(__dirname3, "..", "cache", "jobs");
    this.initialize();
  }
  async initialize() {
    await this.ensureCacheDirectory();
    await this.loadJobs();
    this.checkInterval = setInterval(() => {
      this.checkDueJobs();
    }, 1000);
  }
  async ensureCacheDirectory() {
    try {
      await fs2.mkdir(this.cachePath, { recursive: true });
    } catch (err) {
      console.error("Failed to create jobs cache directory:", err);
    }
  }
  async createJob(id, userId, time, data) {
    const job = {
      id,
      userId,
      time,
      setAt: Date.now(),
      data,
      completed: false
    };
    this.jobs.set(id, job);
    await this.saveJob(job);
    return job;
  }
  getJob(id) {
    return this.jobs.get(id);
  }
  getAllJobs() {
    return Array.from(this.jobs.values());
  }
  getJobsByUser(userId) {
    return this.getAllJobs().filter((job) => job.userId === userId);
  }
  async deleteJob(id) {
    if (!this.jobs.has(id))
      return false;
    this.jobs.delete(id);
    try {
      const jobPath = path2.join(this.cachePath, `${id}.json`);
      await fs2.unlink(jobPath);
      return true;
    } catch (err) {
      console.error(`Failed to delete job file ${id}:`, err);
      return false;
    }
  }
  async saveJob(job) {
    try {
      const jobPath = path2.join(this.cachePath, `${job.id}.json`);
      await fs2.writeFile(jobPath, JSON.stringify(job, null, 2), "utf8");
    } catch (err) {
      console.error(`Failed to save job ${job.id}:`, err);
    }
  }
  async completeJob(id) {
    const job = this.jobs.get(id);
    if (!job)
      return false;
    job.completed = true;
    await this.saveJob(job);
    return true;
  }
  async loadJobs() {
    try {
      const files = await fs2.readdir(this.cachePath);
      for (const file of files) {
        if (file.endsWith(".json")) {
          try {
            const jobPath = path2.join(this.cachePath, file);
            const jobData = await fs2.readFile(jobPath, "utf8");
            const job = JSON.parse(jobData);
            if (!job.completed) {
              this.jobs.set(job.id, job);
            }
          } catch (err) {
            console.error(`Failed to read job file ${file}:`, err);
          }
        }
      }
      console.log(`Loaded ${this.jobs.size} pending jobs`);
    } catch (err) {
      console.error("Failed to load jobs:", err);
    }
  }
  checkDueJobs() {
    const now = Date.now();
    for (const job of this.jobs.values()) {
      if (job.completed)
        continue;
      if (job.time <= now) {
        this.emit("jobComplete", job);
        this.completeJob(job.id);
      }
    }
  }
  stop() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
  }
}
var jobManager = new JobManager;

// main.ts
async function initialize() {
  await loadAllCommands();
  setupCommandWatcher();
  log("Bot initialized with dynamic command loading");
}
async function main() {
  console.log("Running Preflights for bot.");
  if (!existsSync("./cache")) {
    log("Cache directory does not exist, creating it now.");
    await fs3.promises.mkdir("./cache", { recursive: true });
  } else {
    log("Cache directory exists, skipping creation.");
  }
  log("Initializing Commands ");
  initialize().catch((error) => {
    log(`Error loading commands ${error}`);
  });
  log("Creating WhatsApp Client with LocalAuth.");
  const client = new import_whatsapp_web.Client({
    authStrategy: new import_whatsapp_web.LocalAuth,
    puppeteer: {
      headless: true,
      args: [
        "--no-sandbox",
        "--disable-setuid-sandbox",
        "--log-level=3",
        "--no-default-browser-check",
        "--disable-site-isolation-trials",
        "--no-experiments",
        "--ignore-gpu-blacklist",
        "--ignore-certificate-errors",
        "--ignore-certificate-errors-spki-list",
        "--enable-gpu",
        "--disable-default-apps",
        "--enable-features=NetworkService",
        "--disable-webgl",
        "--disable-threaded-animation",
        "--disable-threaded-scrolling",
        "--disable-in-process-stack-traces",
        "--disable-histogram-customizer",
        "--disable-gl-extensions",
        "--disable-composited-antialiasing",
        "--disable-canvas-aa",
        "--disable-3d-apis",
        "--disable-accelerated-2d-canvas",
        "--disable-accelerated-jpeg-decoding",
        "--disable-accelerated-mjpeg-decode",
        "--disable-app-list-dismiss-on-blur",
        "--disable-accelerated-video-decode"
      ]
    }
  });
  client.on("qr", (qr) => {
    log("QR Code received. Scan with WhatsApp to log in:");
    qrcode.generate(qr, { small: true });
  });
  client.on("authenticated", () => {
    console.log("Authentication successful!");
  });
  client.on("auth_failure", (error) => {
    console.error("Authentication failed:", error);
  });
  jobManager.on("jobComplete", async (job) => {
    log(`Job ${job.id} completed, sending notification...`);
    if (job.data?.chatId && job.data?.reminderText) {
      try {
        const chat = await client.getChatById(job.data.chatId);
        await chat.sendMessage(`⏰ *REMINDER:* ${job.data.reminderText}`);
      } catch (error) {
        console.error(`Failed to send reminder for job ${job.id}:`, error);
      }
    }
  });
  client.on("message", async (message) => {
    console.log(`Message received: ${message.body}`);
    await processMessage(message);
  });
  await client.initialize();
}
main().then(() => {
  log("Preflights completed successfully, starting bot now.");
}).catch((error) => {
  log(`An error occurred during preflights: ${error}`);
  process.exit(1);
});
